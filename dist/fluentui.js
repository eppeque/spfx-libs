
react = __toESM(react);
react_jsx_runtime = __toESM(react_jsx_runtime);
react_dom = __toESM(react_dom);

//#region node_modules/@griffel/core/shorthands/generateStyles.esm.js
	const positionMap = [
		"Top",
		"Right",
		"Bottom",
		"Left"
	];
	function generateStyles(property, suffix, ...values) {
		const [firstValue, secondValue = firstValue, thirdValue = firstValue, fourthValue = secondValue] = values;
		const valuesWithDefaults = [
			firstValue,
			secondValue,
			thirdValue,
			fourthValue
		];
		const styles = {};
		for (let i = 0; i < valuesWithDefaults.length; i += 1) if (valuesWithDefaults[i] || valuesWithDefaults[i] === 0) {
			const newKey = property + positionMap[i] + suffix;
			styles[newKey] = valuesWithDefaults[i];
		}
		return styles;
	}

//#endregion
//#region node_modules/@griffel/core/shorthands/borderWidth.esm.js
/**
	* A function that implements CSS spec conformant expansion for "borderWidth"
	*
	* @example
	*   borderWidth('10px')
	*   borderWidth('10px', '5px')
	*   borderWidth('2px', '4px', '8px')
	*   borderWidth('1px', 0, '3px', '4px')
	*
	* See https://developer.mozilla.org/en-US/docs/Web/CSS/border-width
	*/
	function borderWidth(...values) {
		return generateStyles("border", "Width", ...values);
	}

//#endregion
//#region node_modules/@griffel/core/shorthands/borderStyle.esm.js
/**
	* A function that implements CSS spec conformant expansion for "borderStyle"
	*
	* @example
	*  borderStyle('solid')
	*  borderStyle('solid', 'dashed')
	*  borderStyle('solid', 'dashed', 'dotted')
	*  borderStyle('solid', 'dashed', 'dotted', 'double')
	*
	* See https://developer.mozilla.org/en-US/docs/Web/CSS/border-style
	*/
	function borderStyle(...values) {
		return generateStyles("border", "Style", ...values);
	}

//#endregion
//#region node_modules/@griffel/core/shorthands/borderColor.esm.js
/**
	* A function that implements CSS spec conformant expansion for "borderColor"
	*
	* @example
	*  borderColor('red')
	*  borderColor('red', 'blue')
	*  borderColor('red', 'blue', 'green')
	*  borderColor('red', 'blue', 'green', 'yellow')
	*
	* See https://developer.mozilla.org/en-US/docs/Web/CSS/border-color
	*/
	function borderColor$1(...values) {
		return generateStyles("border", "Color", ...values);
	}

//#endregion
//#region node_modules/@griffel/core/shorthands/utils.esm.js
	const LINE_STYLES = [
		"none",
		"hidden",
		"dotted",
		"dashed",
		"solid",
		"double",
		"groove",
		"ridge",
		"inset",
		"outset"
	];
	function isBorderStyle(value) {
		return LINE_STYLES.includes(value);
	}

//#endregion
//#region node_modules/@griffel/core/shorthands/border.esm.js
/**
	* A function that implements expansion for "border" to all sides of an element, it's simplified - check usage examples.
	*
	* @example
	*  border('2px')
	*  border('solid')
	*  border('2px', 'solid')
	*  border('solid', '2px')
	*  border('2px', 'solid', 'red')
	*  border('solid', '2px', 'red')
	*
	* See https://developer.mozilla.org/en-US/docs/Web/CSS/border
	*
	* @deprecated Just use `{ border: '2px solid red' }` instead as Griffel supports CSS shorthands now
	*/
	function border(...values) {
		if (isBorderStyle(values[0])) return Object.assign({}, borderStyle(values[0]), values[1] && borderWidth(values[1]), values[2] && borderColor$1(values[2]));
		return Object.assign({}, borderWidth(values[0]), values[1] && borderStyle(values[1]), values[2] && borderColor$1(values[2]));
	}

//#endregion
//#region node_modules/@griffel/core/shorthands/borderLeft.esm.js
/**
	* A function that implements expansion for "border-left", it's simplified - check usage examples.
	*
	* @example
	*  borderLeft('2px')
	*  borderLeft('solid')
	*  borderLeft('2px', 'solid')
	*  borderLeft('solid', '2px')
	*  borderLeft('2px', 'solid', 'red')
	*  borderLeft('solid', '2px', 'red')
	*
	* See https://developer.mozilla.org/en-US/docs/Web/CSS/border-left
	*
	* @deprecated Just use `{ borderLeft: '2px solid red' }` instead as Griffel supports CSS shorthands now
	*/
	function borderLeft(...values) {
		if (isBorderStyle(values[0])) return Object.assign({ borderLeftStyle: values[0] }, values[1] && { borderLeftWidth: values[1] }, values[2] && { borderLeftColor: values[2] });
		return Object.assign({ borderLeftWidth: values[0] }, values[1] && { borderLeftStyle: values[1] }, values[2] && { borderLeftColor: values[2] });
	}

//#endregion
//#region node_modules/@griffel/core/shorthands/borderBottom.esm.js
/**
	* A function that implements expansion for "border-Bottom", it's simplified - check usage examples.
	*
	* @example
	*  borderBottom('2px')
	*  borderBottom('solid')
	*  borderBottom('2px', 'solid')
	*  borderBottom('solid', '2px')
	*  borderBottom('2px', 'solid', 'red')
	*  borderBottom('solid', '2px', 'red')
	*
	* See https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom
	*
	* @deprecated Just use `{ borderBottom: '2px solid red' }` instead as Griffel supports CSS shorthands now
	*/
	function borderBottom(...values) {
		if (isBorderStyle(values[0])) return Object.assign({ borderBottomStyle: values[0] }, values[1] && { borderBottomWidth: values[1] }, values[2] && { borderBottomColor: values[2] });
		return Object.assign({ borderBottomWidth: values[0] }, values[1] && { borderBottomStyle: values[1] }, values[2] && { borderBottomColor: values[2] });
	}

//#endregion
//#region node_modules/@griffel/core/shorthands/borderRight.esm.js
/**
	* A function that implements expansion for "border-right", it's simplified - check usage examples.
	*
	* @example
	*  borderRight('2px')
	*  borderRight('solid')
	*  borderRight('2px', 'solid')
	*  borderRight('solid', '2px')
	*  borderRight('2px', 'solid', 'red')
	*  borderRight('solid', '2px', 'red')
	*
	* See https://developer.mozilla.org/en-US/docs/Web/CSS/border-right
	*
	* @deprecated Just use `{ borderRight: '2px solid red' }` instead as Griffel supports CSS shorthands now
	*/
	function borderRight(...values) {
		if (isBorderStyle(values[0])) return Object.assign({ borderRightStyle: values[0] }, values[1] && { borderRightWidth: values[1] }, values[2] && { borderRightColor: values[2] });
		return Object.assign({ borderRightWidth: values[0] }, values[1] && { borderRightStyle: values[1] }, values[2] && { borderRightColor: values[2] });
	}

//#endregion
//#region node_modules/@griffel/core/shorthands/borderTop.esm.js
/**
	* A function that implements expansion for "border-Top", it's simplified - check usage examples.
	*
	* @example
	*  borderTop('2px')
	*  borderTop('solid')
	*  borderTop('2px', 'solid')
	*  borderTop('solid', '2px')
	*  borderTop('2px', 'solid', 'red')
	*  borderTop('solid', '2px', 'red')
	*
	* See https://developer.mozilla.org/en-US/docs/Web/CSS/border-top
	*
	* @deprecated Just use `{ borderTop: '2px solid red' }` instead as Griffel supports CSS shorthands now
	*/
	function borderTop(...values) {
		if (isBorderStyle(values[0])) return Object.assign({ borderTopStyle: values[0] }, values[1] && { borderTopWidth: values[1] }, values[2] && { borderTopColor: values[2] });
		return Object.assign({ borderTopWidth: values[0] }, values[1] && { borderTopStyle: values[1] }, values[2] && { borderTopColor: values[2] });
	}

//#endregion
//#region node_modules/@griffel/core/shorthands/borderRadius.esm.js
/**
	* A function that implements CSS spec conformant expansion for "borderRadius". "/" is not supported, please use CSS
	* longhands directly.
	*
	* @example
	*   borderRadius('10px')
	*   borderRadius('10px', '5%')
	*   borderRadius('2px', '4px', '8px')
	*   borderRadius('1px', 0, '3px', '4px')
	*
	* See https://developer.mozilla.org/en-US/docs/Web/CSS/border-radius
	*
	* @deprecated Just use `{ borderRadius: '10px 5% 8px 4px' }` instead as Griffel supports CSS shorthands now
	*/
	function borderRadius$1(value1, value2 = value1, value3 = value1, value4 = value2) {
		return {
			borderBottomRightRadius: value3,
			borderBottomLeftRadius: value4,
			borderTopRightRadius: value2,
			borderTopLeftRadius: value1
		};
	}

//#endregion
//#region node_modules/@griffel/core/shorthands/flex.esm.js
	const isUnit = (value) => typeof value === "string" && /(\d+(\w+|%))/.test(value);
	const isUnitless = (value) => typeof value === "number" && !Number.isNaN(value);
	const isInitial = (value) => value === "initial";
	const isAuto = (value) => value === "auto";
	const isNone = (value) => value === "none";
	const widthReservedKeys = [
		"content",
		"fit-content",
		"max-content",
		"min-content"
	];
	const isWidth = (value) => widthReservedKeys.some((key) => value === key) || isUnit(value);
	/**
	* A function that implements CSS spec conformant expansion for "flex".
	*
	* @example
	*   flex('auto')
	*   flex(1, '2.5rem')
	*   flex(0, 0, 'auto')
	*
	* @see https://developer.mozilla.org/en-US/docs/Web/CSS/flex
	*
	* @deprecated Just use `{ flex: '1 1 0' }` instead as Griffel supports CSS shorthands now
	*/
	function flex(...values) {
		const isOneValueSyntax = values.length === 1;
		const isTwoValueSyntax = values.length === 2;
		const isThreeValueSyntax = values.length === 3;
		if (isOneValueSyntax) {
			const [firstValue] = values;
			if (isInitial(firstValue)) return {
				flexGrow: 0,
				flexShrink: 1,
				flexBasis: "auto"
			};
			if (isAuto(firstValue)) return {
				flexGrow: 1,
				flexShrink: 1,
				flexBasis: "auto"
			};
			if (isNone(firstValue)) return {
				flexGrow: 0,
				flexShrink: 0,
				flexBasis: "auto"
			};
			if (isUnitless(firstValue)) return {
				flexGrow: firstValue,
				flexShrink: 1,
				flexBasis: 0
			};
			if (isWidth(firstValue)) return {
				flexGrow: 1,
				flexShrink: 1,
				flexBasis: firstValue
			};
		}
		if (isTwoValueSyntax) {
			const [firstValue, secondValue] = values;
			if (isUnitless(secondValue)) return {
				flexGrow: firstValue,
				flexShrink: secondValue,
				flexBasis: 0
			};
			if (isWidth(secondValue)) return {
				flexGrow: firstValue,
				flexShrink: 1,
				flexBasis: secondValue
			};
		}
		if (isThreeValueSyntax) {
			const [firstValue, secondValue, thirdValue] = values;
			if (isUnitless(firstValue) && isUnitless(secondValue) && (isAuto(thirdValue) || isWidth(thirdValue))) return {
				flexGrow: firstValue,
				flexShrink: secondValue,
				flexBasis: thirdValue
			};
		}
		console.error(`The value passed to shorthands.flex did not match any flex property specs. The CSS styles were not generated. Please, check the flex documentation.`);
		return {};
	}

//#endregion
//#region node_modules/@griffel/core/shorthands/gap.esm.js
/**
	* A function that implements CSS spec conformant expansion for "gap"
	*
	* @example
	*   gap('10px')
	*   gap('10px', '5px')
	*
	* See https://developer.mozilla.org/en-US/docs/Web/CSS/gap
	*
	* @deprecated Just use `{ gap: '10px 5px' }` instead as Griffel supports CSS shorthands now
	*/
	function gap(columnGap, rowGap = columnGap) {
		return {
			columnGap,
			rowGap
		};
	}

//#endregion
//#region node_modules/@griffel/core/shorthands/gridArea.esm.js
	const cssVarRegEx = /var\(.*\)/gi;
	function isValidGridAreaInput(value) {
		return value === void 0 || typeof value === "number" || typeof value === "string" && !cssVarRegEx.test(value);
	}
	const customIdentRegEx = /^[a-zA-Z0-9\-_\\#;]+$/;
	const nonCustomIdentRegEx = /^-moz-initial$|^auto$|^initial$|^inherit$|^revert$|^unset$|^span \d+$|^\d.*/;
	function isCustomIdent(value) {
		return value !== void 0 && typeof value === "string" && customIdentRegEx.test(value) && !nonCustomIdentRegEx.test(value);
	}
	/**
	* A function that implements CSS spec conformant expansion for "grid-area"
	*
	* @example
	*   gridArea('auto')
	*   gridArea('first', 'second')
	*   gridArea(2, 4, 4)
	*   gridArea(2, 4, 1, 3)
	*
	* See https://developer.mozilla.org/en-US/docs/Web/CSS/grid-area
	*
	* @deprecated Use `{ gridArea: '2 / 4 / 1 / 3' }` instead as Griffel supports CSS shorthands now
	*/
	function gridArea(...values) {
		if (values.some((value) => !isValidGridAreaInput(value))) {
			console.error(`The value passed to shorthands.gridArea() did not match any gridArea property specs. The CSS styles were not generated. Please, check the gridArea documentation.`, [
				"The value passed to shorthands.gridArea() did not match any gridArea property specs. ",
				"The CSS styles were not generated.\n",
				"Please, check the `grid-area` documentation:\n",
				"- https://developer.mozilla.org/docs/Web/CSS/grid-area",
				"- https://griffel.js.org/react/api/shorthands#shorthandsgridarea"
			].join(""));
			return {};
		}
		const gridRowStart = values[0] !== void 0 ? values[0] : "auto";
		const gridColumnStart = values[1] !== void 0 ? values[1] : isCustomIdent(gridRowStart) ? gridRowStart : "auto";
		return {
			gridRowStart,
			gridColumnStart,
			gridRowEnd: values[2] !== void 0 ? values[2] : isCustomIdent(gridRowStart) ? gridRowStart : "auto",
			gridColumnEnd: values[3] !== void 0 ? values[3] : isCustomIdent(gridColumnStart) ? gridColumnStart : "auto"
		};
	}

//#endregion
//#region node_modules/@griffel/core/shorthands/margin.esm.js
/**
	* A function that implements CSS spec conformant expansion for "margin"
	*
	* @example
	*   margin('10px')
	*   margin('10px', '5px')
	*   margin('2px', '4px', '8px')
	*   margin('1px', 0, '3px', '4px')
	*
	* See https://developer.mozilla.org/en-US/docs/Web/CSS/margin
	*
	* @deprecated Just use `{ margin: '10px 5px 8px 4px' }` instead as Griffel supports CSS shorthands now
	*/
	function margin(...values) {
		return generateStyles("margin", "", ...values);
	}

//#endregion
//#region node_modules/@griffel/core/shorthands/marginBlock.esm.js
/**
	* A function that implements CSS spec conformant expansion for "margin-block"
	*
	* @example
	*   marginBlock('10px')
	*   marginBlock('10px', '5px')
	*
	* See https://developer.mozilla.org/en-US/docs/Web/CSS/margin-block
	*
	* @deprecated Just use `{ marginBlock: '10px' }` instead as Griffel supports CSS shorthands now
	*/
	function marginBlock(start, end = start) {
		return {
			marginBlockStart: start,
			marginBlockEnd: end
		};
	}

//#endregion
//#region node_modules/@griffel/core/shorthands/marginInline.esm.js
/**
	* A function that implements CSS spec conformant expansion for "margin-inline"
	*
	* @example
	*   marginInline('10px')
	*   marginInline('10px', '5px')
	*
	* See https://developer.mozilla.org/en-US/docs/Web/CSS/margin-inline
	*
	* @deprecated Just use `{ marginInline: '10px' }` instead as Griffel supports CSS shorthands now
	*/
	function marginInline(start, end = start) {
		return {
			marginInlineStart: start,
			marginInlineEnd: end
		};
	}

//#endregion
//#region node_modules/@griffel/core/shorthands/padding.esm.js
/**
	* A function that implements CSS spec conformant expansion for "padding"
	*
	* @example
	*   padding('10px')
	*   padding('10px', '5px')
	*   padding('2px', '4px', '8px')
	*   padding('1px', 0, '3px', '4px')
	*
	* See https://developer.mozilla.org/en-US/docs/Web/CSS/padding
	*
	* @deprecated Just use `{ padding: '10px 5px 8px 4px' }` instead as Griffel supports CSS shorthands now
	*/
	function padding(...values) {
		return generateStyles("padding", "", ...values);
	}

//#endregion
//#region node_modules/@griffel/core/shorthands/paddingBlock.esm.js
/**
	* A function that implements CSS spec conformant expansion for "padding-block"
	*
	* @example
	*   paddingBlock('10px')
	*   paddingBlock('10px', '5px')
	*
	* See https://developer.mozilla.org/en-US/docs/Web/CSS/padding-block
	*
	* @deprecated Just use `{ paddingBlock: '10px' }` instead as Griffel supports CSS shorthands now
	*/
	function paddingBlock(start, end = start) {
		return {
			paddingBlockStart: start,
			paddingBlockEnd: end
		};
	}

//#endregion
//#region node_modules/@griffel/core/shorthands/paddingInline.esm.js
/**
	* A function that implements CSS spec conformant expansion for "padding-inline"
	*
	* @example
	*   paddingInline('10px')
	*   paddingInline('10px', '5px')
	*
	* See https://developer.mozilla.org/en-US/docs/Web/CSS/padding-inline
	*
	* @deprecated Just use `{ paddingInline: '10px' }` instead as Griffel supports CSS shorthands now
	*/
	function paddingInline(start, end = start) {
		return {
			paddingInlineStart: start,
			paddingInlineEnd: end
		};
	}

//#endregion
//#region node_modules/@griffel/core/shorthands/overflow.esm.js
/**
	* A function that implements CSS spec conformant expansion for "overflow"
	*
	* @example
	*   overflow('hidden')
	*   overflow('hidden', 'scroll')
	*
	* See https://developer.mozilla.org/en-US/docs/Web/CSS/overflow
	*
	* @deprecated Just use `{ overflow: 'hidden scroll' }` instead as Griffel supports CSS shorthands now
	*/
	function overflow(overflowX, overflowY = overflowX) {
		return {
			overflowX,
			overflowY
		};
	}

//#endregion
//#region node_modules/@griffel/core/shorthands/inset.esm.js
/**
	* A function that implements CSS spec conformant expansion for "inset"
	*
	* @example
	*   inset('10px')
	*   inset('10px', '5px')
	*   inset('2px', '4px', '8px')
	*   inset('1px', 0, '3px', '4px')
	*
	* See https://developer.mozilla.org/en-US/docs/Web/CSS/inset
	*
	* @deprecated Use `{ inset: '10px 5px 8px 4px' }` instead as Griffel supports CSS shorthands now
	*/
	function inset(...values) {
		const [firstValue, secondValue = firstValue, thirdValue = firstValue, fourthValue = secondValue] = values;
		return {
			top: firstValue,
			right: secondValue,
			bottom: thirdValue,
			left: fourthValue
		};
	}

//#endregion
//#region node_modules/@griffel/core/shorthands/outline.esm.js
/**
	* A function that implements expansion for "outline", it's simplified - check usage examples.
	*
	* @example
	*  outline('2px')
	*  outline('2px', 'solid')
	*  outline('2px', 'solid', 'red')
	*
	* See https://developer.mozilla.org/en-US/docs/Web/CSS/outline
	*
	* @deprecated Just use `{ outline: '2px solid red' }` instead as Griffel supports CSS shorthands now
	*/
	function outline(outlineWidth, outlineStyle, outlineColor) {
		return Object.assign({ outlineWidth }, outlineStyle && { outlineStyle }, outlineColor && { outlineColor });
	}

//#endregion
//#region node_modules/@griffel/core/shorthands/transition.esm.js
/**
	* A function that implements expansion for "transition", it's simplified - check usage examples.
	*
	* @example
	*  transition('inherit')
	*  transition('margin-right', '4s')
	*  transition('margin-right', '4s', '1s')
	*  transition('margin-right', '4s', '1s', 'ease-in')
	*  transition([
	*    ['margin-right', '4s', '1s', 'ease-in'],
	*    ['margin-right', '4s', '1s', 'ease-in'],
	* ])
	*
	* See https://developer.mozilla.org/en-US/docs/Web/CSS/transition
	*
	* @deprecated Just use `{ transition: 'margin-right 4s 1s ease-in' }` instead as Griffel supports CSS shorthands now
	*/
	function transition(...values) {
		if (isTransitionGlobalInputs(values)) return {
			transitionDelay: values[0],
			transitionDuration: values[0],
			transitionProperty: values[0],
			transitionTimingFunction: values[0]
		};
		return normalizeTransitionInputs(values).reduce((acc, [property, duration = "0s", delay = "0s", timingFunction = "ease"], index) => {
			if (index === 0) {
				acc.transitionProperty = property;
				acc.transitionDuration = duration;
				acc.transitionDelay = delay;
				acc.transitionTimingFunction = timingFunction;
			} else {
				acc.transitionProperty += `, ${property}`;
				acc.transitionDuration += `, ${duration}`;
				acc.transitionDelay += `, ${delay}`;
				acc.transitionTimingFunction += `, ${timingFunction}`;
			}
			return acc;
		}, {});
	}
	const transitionGlobalInputs = [
		"-moz-initial",
		"inherit",
		"initial",
		"revert",
		"unset"
	];
	function isTransitionGlobalInputs(values) {
		return values.length === 1 && transitionGlobalInputs.includes(values[0]);
	}
	function normalizeTransitionInputs(transitionInputs) {
		if (transitionInputs.length === 1 && Array.isArray(transitionInputs[0])) return transitionInputs[0];
		return [transitionInputs];
	}

//#endregion
//#region node_modules/@griffel/core/shorthands/textDecoration.esm.js
/**
	* A function that implements expansion for "textDecoration" to all sides of an element, it's simplified - check usage examples.
	*
	* @example
	*  textDecoration('none')
	*  textDecoration('dotted')
	*  textDecoration('underline', 'dotted')
	*  textDecoration('underline', 'dotted', 'red')
	*  textDecoration('underline', 'dotted', 'red', '2px')
	*
	* See https://developer.mozilla.org/en-US/docs/Web/CSS/text-decoration
	*
	* @deprecated Just use `{ textDecoration: 'underline dotted red 2px' }` instead as Griffel supports CSS shorthands now
	*/
	function textDecoration(value, ...values) {
		if (values.length === 0) return isTextDecorationStyleInput(value) ? { textDecorationStyle: value } : { textDecorationLine: value };
		const [textDecorationStyle, textDecorationColor, textDecorationThickness] = values;
		return Object.assign({ textDecorationLine: value }, textDecorationStyle && { textDecorationStyle }, textDecorationColor && { textDecorationColor }, textDecorationThickness && { textDecorationThickness });
	}
	const textDecorationStyleInputs = [
		"dashed",
		"dotted",
		"double",
		"solid",
		"wavy"
	];
	function isTextDecorationStyleInput(value) {
		return textDecorationStyleInputs.includes(value);
	}

//#endregion
//#region node_modules/@griffel/core/constants.esm.js
	const __GLOBAL__ = typeof window === "undefined" ? global : window;
	const __NAMESPACE_PREFIX__ = "@griffel/";
	function getGlobalVar(name, defaultValue) {
		if (!__GLOBAL__[Symbol.for(__NAMESPACE_PREFIX__ + name)]) __GLOBAL__[Symbol.for(__NAMESPACE_PREFIX__ + name)] = defaultValue;
		return __GLOBAL__[Symbol.for(__NAMESPACE_PREFIX__ + name)];
	}
	/** @internal */
	const DEBUG_RESET_CLASSES = /* @__PURE__ */ getGlobalVar("DEBUG_RESET_CLASSES", {});
	/** @internal */
	const DEFINITION_LOOKUP_TABLE = /* @__PURE__ */ getGlobalVar("DEFINITION_LOOKUP_TABLE", {});
	/** @internal */
	const DATA_BUCKET_ATTR = "data-make-styles-bucket";
	/** @internal */
	const DATA_PRIORITY_ATTR = "data-priority";
	/** @internal */
	const HASH_PREFIX = "f";
	/** @internal */
	const RESET_HASH_PREFIX = "r";
	/** @internal */
	const SEQUENCE_HASH_LENGTH = 7;
	/** @internal */
	const SEQUENCE_PREFIX = "___";
	/** @internal */
	const DEBUG_SEQUENCE_SEPARATOR = "_";
	/** @internal */
	const SEQUENCE_SIZE = 3 + SEQUENCE_HASH_LENGTH + 1 + SEQUENCE_HASH_LENGTH;
	/** @internal */
	const LOOKUP_DEFINITIONS_INDEX = 0;
	/** @internal */
	const LOOKUP_DIR_INDEX = 1;
	/** @internal */
	const UNSUPPORTED_CSS_PROPERTIES = {
		all: 1,
		borderColor: 1,
		borderStyle: 1,
		borderWidth: 1,
		borderBlock: 1,
		borderBlockEnd: 1,
		borderBlockStart: 1,
		borderInline: 1,
		borderInlineEnd: 1,
		borderInlineStart: 1
	};
	/**
	* Removes a CSS property from the style object.
	*
	* @link https://griffel.js.org/react/api/make-styles
	*
	* Do not use the value directly, use `RESET` constant instead.
	*/
	const RESET = "DO_NOT_USE_DIRECTLY: @griffel/reset-value";

//#endregion
//#region node_modules/@emotion/hash/dist/emotion-hash.esm.js
	function murmur2(str) {
		var h = 0;
		var k, i = 0, len = str.length;
		for (; len >= 4; ++i, len -= 4) {
			k = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
			k = (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16);
			k ^= k >>> 24;
			h = (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16) ^ (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
		}
		switch (len) {
			case 3: h ^= (str.charCodeAt(i + 2) & 255) << 16;
			case 2: h ^= (str.charCodeAt(i + 1) & 255) << 8;
			case 1:
				h ^= str.charCodeAt(i) & 255;
				h = (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
		}
		h ^= h >>> 13;
		h = (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
		return ((h ^ h >>> 15) >>> 0).toString(36);
	}

//#endregion
//#region node_modules/@griffel/core/runtime/utils/hashSequence.esm.js
	function padEndHash(value) {
		const hashLength = value.length;
		if (hashLength === SEQUENCE_HASH_LENGTH) return value;
		for (let i = hashLength; i < SEQUENCE_HASH_LENGTH; i++) value += "0";
		return value;
	}
	function hashSequence(classes, dir, sequenceIds = []) {
		return SEQUENCE_PREFIX + padEndHash(murmur2(classes + dir)) + DEBUG_SEQUENCE_SEPARATOR + padEndHash(murmur2(sequenceIds.join("")));
	}

//#endregion
//#region node_modules/@griffel/core/runtime/reduceToClassNameForSlots.esm.js
/**
	* Reduces a classname map for slot to a classname string. Uses classnames according to text directions.
	*
	* @private
	*/
	function reduceToClassName(classMap, dir) {
		let classString = "";
		let hashString = "";
		for (const propertyHash in classMap) {
			const classNameMapping = classMap[propertyHash];
			if (classNameMapping === 0) {
				hashString += propertyHash + " ";
				continue;
			}
			const hasRTLClassName = Array.isArray(classNameMapping);
			const className = dir === "rtl" ? (hasRTLClassName ? classNameMapping[1] : classNameMapping) + " " : (hasRTLClassName ? classNameMapping[0] : classNameMapping) + " ";
			classString += className;
			hashString += className;
		}
		return [classString.slice(0, -1), hashString.slice(0, -1)];
	}
	/**
	* Reduces classname maps for slots to classname strings. Registers them in a definition cache to be used by
	* `mergeClasses()`.
	*
	* @internal
	*/
	function reduceToClassNameForSlots(classesMapBySlot, dir) {
		const classNamesForSlots = {};
		for (const slotName in classesMapBySlot) {
			const [slotClasses, slotClassesHash] = reduceToClassName(classesMapBySlot[slotName], dir);
			if (slotClassesHash === "") {
				classNamesForSlots[slotName] = "";
				continue;
			}
			const sequenceHash = hashSequence(slotClassesHash, dir);
			const resultSlotClasses = sequenceHash + (slotClasses === "" ? "" : " " + slotClasses);
			DEFINITION_LOOKUP_TABLE[sequenceHash] = [classesMapBySlot[slotName], dir];
			classNamesForSlots[slotName] = resultSlotClasses;
		}
		return classNamesForSlots;
	}

//#endregion
//#region node_modules/@griffel/core/mergeClasses.esm.js
	const mergeClassesCachedResults = {};
	function mergeClasses() {
		let dir = null;
		let resultClassName = "";
		let sequenceMatch = "";
		const sequencesIds = new Array(arguments.length);
		let containsResetClassName = "";
		for (let i = 0; i < arguments.length; i++) {
			const className = arguments[i];
			if (typeof className === "string" && className !== "") {
				const sequenceIndex = className.indexOf(SEQUENCE_PREFIX);
				if (sequenceIndex === -1) {
					className.split(" ").forEach((entry) => {
						if (entry.startsWith(RESET_HASH_PREFIX) && DEBUG_RESET_CLASSES[entry]) if (containsResetClassName) console.error(`mergeClasses(): a passed string contains multiple classes produced by makeResetStyles (${className} & ${resultClassName}, this will lead to non-deterministic behavior. Learn more:https://griffel.js.org/react/api/make-reset-styles#limitations
Source string: ${className}`);
						else containsResetClassName = entry;
					});
					resultClassName += className + " ";
				} else {
					const sequenceId = className.substr(sequenceIndex, SEQUENCE_SIZE);
					if (sequenceIndex > 0) resultClassName += className.slice(0, sequenceIndex);
					sequenceMatch += sequenceId;
					sequencesIds[i] = sequenceId;
				}
				if (className.indexOf(SEQUENCE_PREFIX, sequenceIndex + 1) !== -1) console.error(`mergeClasses(): a passed string contains multiple identifiers of atomic classes (classes that start with "${SEQUENCE_PREFIX}"), it's possible that passed classes were concatenated in a wrong way. Source string: ${className}`);
			}
		}
		if (sequenceMatch === "") return resultClassName.slice(0, -1);
		const mergeClassesResult = mergeClassesCachedResults[sequenceMatch];
		if (mergeClassesResult !== void 0) return resultClassName + mergeClassesResult;
		const sequenceMappings = [];
		for (let i = 0; i < arguments.length; i++) {
			const sequenceId = sequencesIds[i];
			if (sequenceId) {
				const sequenceMapping = DEFINITION_LOOKUP_TABLE[sequenceId];
				if (sequenceMapping) {
					sequenceMappings.push(sequenceMapping[LOOKUP_DEFINITIONS_INDEX]);
					if (dir !== null && dir !== sequenceMapping[LOOKUP_DIR_INDEX]) console.error(`mergeClasses(): a passed string contains an identifier (${sequenceId}) that has different direction (dir="${sequenceMapping[1] ? "rtl" : "ltr"}") setting than other classes. This is not supported. Source string: ${arguments[i]}`);
					dir = sequenceMapping[LOOKUP_DIR_INDEX];
				} else console.error(`mergeClasses(): a passed string contains an identifier (${sequenceId}) that does not match any entry in cache. Source string: ${arguments[i]}`);
			}
		}
		const resultClassesMap = Object.assign.apply(Object, [{}].concat(sequenceMappings));
		const [atomicClasses, classesMapHash] = reduceToClassName(resultClassesMap, dir);
		const newSequenceHash = hashSequence(classesMapHash, dir, sequencesIds);
		const newClassName = newSequenceHash + " " + atomicClasses;
		mergeClassesCachedResults[sequenceMatch] = newClassName;
		DEFINITION_LOOKUP_TABLE[newSequenceHash] = [resultClassesMap, dir];
		return resultClassName + newClassName;
	}

//#endregion
//#region node_modules/@griffel/core/devtools/store.esm.js
	const sequenceDetails = {};
	const cssRules = /* @__PURE__ */ new Set();
	const debugData = {
		getChildrenSequences: (debugSequenceHash) => {
			const key = Object.keys(mergeClassesCachedResults).find((key$1) => mergeClassesCachedResults[key$1].startsWith(debugSequenceHash));
			if (key) return key.split(SEQUENCE_PREFIX).filter((sequence) => sequence.length).map((sequence) => SEQUENCE_PREFIX + sequence);
			return [];
		},
		addCSSRule: (rule) => {
			cssRules.add(rule);
		},
		addSequenceDetails: (classNamesForSlots, sourceURL) => {
			Object.entries(classNamesForSlots).forEach(([slotName, sequenceHash]) => {
				sequenceDetails[sequenceHash.substring(0, SEQUENCE_SIZE)] = {
					slotName,
					sourceURL
				};
			});
		},
		getCSSRules: () => {
			return Array.from(cssRules);
		},
		getSequenceDetails: (sequenceHash) => {
			return sequenceDetails[sequenceHash];
		}
	};

//#endregion
//#region node_modules/@griffel/core/devtools/utils.esm.js
	function getDirectionalClassName(classes, direction) {
		return Array.isArray(classes) ? direction === "rtl" ? classes[1] : classes[0] : classes || "";
	}
	function getDebugClassNames(lookupItem, parentLookupItem, parentDebugClassNames, overridingSiblings) {
		const classesMapping = lookupItem[0];
		const direction = lookupItem[1];
		return Object.entries(classesMapping).map(([propertyHash, classes]) => {
			const className = getDirectionalClassName(classes, direction);
			let overriddenBy;
			if (parentDebugClassNames && parentLookupItem) {
				const matching = parentDebugClassNames.find(({ className: parentClassName }) => parentClassName === className);
				if (!matching && parentLookupItem[0][propertyHash]) overriddenBy = getDirectionalClassName(parentLookupItem[0][propertyHash], parentLookupItem[1]);
				else if (matching && parentLookupItem[0][propertyHash]) overriddenBy = (overridingSiblings ? overridingSiblings.filter(({ debugClassNames }) => debugClassNames.filter(({ className: siblingClassName }) => siblingClassName === className).length > 0).length > 0 : false) ? matching.className : matching.overriddenBy;
				else if (!matching && !parentLookupItem[0][propertyHash]) overriddenBy = void 0;
				else if (matching && !parentLookupItem[0][propertyHash]) overriddenBy = void 0;
			}
			return {
				className,
				overriddenBy
			};
		});
	}

//#endregion
//#region node_modules/@griffel/core/devtools/getAtomicDebugSequenceTree.esm.js
	function getAtomicDebugSequenceTree(debugSequenceHash, parentNode) {
		const lookupItem = DEFINITION_LOOKUP_TABLE[debugSequenceHash];
		if (lookupItem === void 0) return;
		const debugClassNames = getDebugClassNames(lookupItem, parentNode ? DEFINITION_LOOKUP_TABLE[parentNode.sequenceHash] : void 0, parentNode === null || parentNode === void 0 ? void 0 : parentNode.debugClassNames, parentNode === null || parentNode === void 0 ? void 0 : parentNode.children);
		const node$1 = {
			sequenceHash: debugSequenceHash,
			direction: lookupItem[1],
			children: [],
			debugClassNames
		};
		debugData.getChildrenSequences(node$1.sequenceHash).reverse().forEach((sequence) => {
			const child = getAtomicDebugSequenceTree(sequence, node$1);
			if (child) node$1.children.push(child);
		});
		if (!node$1.children.length) {
			node$1.rules = {};
			node$1.debugClassNames.forEach(({ className }) => {
				const mapData = debugData.getSequenceDetails(debugSequenceHash);
				if (mapData) {
					node$1.slot = mapData.slotName;
					node$1.sourceURL = mapData.sourceURL;
				}
				const cssRule = debugData.getCSSRules().find((cssRule$1) => {
					return cssRule$1.includes(className);
				});
				node$1.rules[className] = cssRule;
			});
		}
		return node$1;
	}

//#endregion
//#region node_modules/@griffel/core/devtools/getResetDebugSequence.esm.js
	function getResetDebugSequence(debugSequenceHash) {
		if (DEBUG_RESET_CLASSES[debugSequenceHash] === void 0) return;
		const node$1 = {
			sequenceHash: debugSequenceHash,
			direction: "ltr",
			children: [],
			debugClassNames: [{ className: debugSequenceHash }]
		};
		node$1.rules = {};
		node$1.slot = "makeResetStyles()";
		const [{ className }] = node$1.debugClassNames;
		const cssRules$1 = debugData.getCSSRules().filter((cssRule) => {
			return cssRule.includes(`.${className}`);
		});
		node$1.rules[className] = cssRules$1.join("");
		return node$1;
	}

//#endregion
//#region node_modules/@griffel/core/devtools/mergeDebugSequence.esm.js
	function mergeDebugSequence(atomicClases, resetClassName) {
		const debugResultRootAtomic = atomicClases ? getAtomicDebugSequenceTree(atomicClases) : void 0;
		const debugResultRootReset = resetClassName ? getResetDebugSequence(resetClassName) : void 0;
		if (!debugResultRootAtomic && !debugResultRootReset) return;
		if (!debugResultRootAtomic) return debugResultRootReset;
		if (!debugResultRootReset) return debugResultRootAtomic;
		return {
			sequenceHash: debugResultRootAtomic.sequenceHash + debugResultRootReset.sequenceHash,
			direction: debugResultRootAtomic.direction,
			children: [debugResultRootAtomic, debugResultRootReset],
			debugClassNames: [...debugResultRootAtomic.debugClassNames, ...debugResultRootReset.debugClassNames]
		};
	}

//#endregion
//#region node_modules/@griffel/core/devtools/injectDevTools.esm.js
	function injectDevTools(document$1) {
		const window$1 = document$1.defaultView;
		if (!window$1 || window$1.__GRIFFEL_DEVTOOLS__) return;
		const devtools$1 = { getInfo: (element) => {
			let rootDebugSequenceHash;
			let rootResetDebugClassName;
			for (const className of element.classList) {
				if (className.startsWith(SEQUENCE_PREFIX)) rootDebugSequenceHash = className;
				if (DEBUG_RESET_CLASSES[className]) rootResetDebugClassName = className;
			}
			return mergeDebugSequence(rootDebugSequenceHash, rootResetDebugClassName);
		} };
		Object.defineProperty(window$1, "__GRIFFEL_DEVTOOLS__", {
			configurable: false,
			enumerable: false,
			get() {
				return devtools$1;
			}
		});
	}

//#endregion
//#region node_modules/@griffel/core/devtools/isDevToolsEnabled.esm.js
	const isDevToolsEnabled = /* @__PURE__ */ (() => {
		var _a;
		try {
			return Boolean(typeof window !== "undefined" && ((_a = window.sessionStorage) === null || _a === void 0 ? void 0 : _a.getItem("__GRIFFEL_DEVTOOLS__")));
		} catch (e) {
			return false;
		}
	})();

//#endregion
//#region node_modules/@griffel/core/runtime/utils/normalizeCSSBucketEntry.esm.js
/**
	* @internal
	*
	* @param entry - CSS bucket entry that can be either a string or an array
	* @returns An array where the first element is the CSS rule
	*/
	function normalizeCSSBucketEntry(entry) {
		if (!Array.isArray(entry)) return [entry];
		if (entry.length > 2) throw new Error("CSS Bucket contains an entry with greater than 2 items, please report this to https://github.com/microsoft/griffel/issues");
		return entry;
	}

//#endregion
//#region node_modules/@griffel/core/renderer/createIsomorphicStyleSheet.esm.js
	function createIsomorphicStyleSheet(styleElement, bucketName, priority, elementAttributes) {
		const __cssRulesForSSR = [];
		elementAttributes[DATA_BUCKET_ATTR] = bucketName;
		elementAttributes[DATA_PRIORITY_ATTR] = String(priority);
		if (styleElement) for (const attrName in elementAttributes) styleElement.setAttribute(attrName, elementAttributes[attrName]);
		function insertRule(rule) {
			if (styleElement === null || styleElement === void 0 ? void 0 : styleElement.sheet) return styleElement.sheet.insertRule(rule, styleElement.sheet.cssRules.length);
			return __cssRulesForSSR.push(rule);
		}
		return {
			elementAttributes,
			insertRule,
			element: styleElement,
			bucketName,
			cssRules() {
				if (styleElement === null || styleElement === void 0 ? void 0 : styleElement.sheet) return Array.from(styleElement.sheet.cssRules).map((cssRule) => cssRule.cssText);
				return __cssRulesForSSR;
			}
		};
	}
	function createIsomorphicStyleSheetFromElement(element) {
		const elementAttributes = Array.from(element.attributes).reduce((acc, attr) => {
			acc[attr.name] = attr.value;
			return acc;
		}, {});
		return createIsomorphicStyleSheet(element, elementAttributes[DATA_BUCKET_ATTR], Number(elementAttributes[DATA_PRIORITY_ATTR]), elementAttributes);
	}

//#endregion
//#region node_modules/@griffel/core/renderer/getStyleSheetForBucket.esm.js
/**
	* Ordered style buckets using their short pseudo name.
	*
	* @internal
	*/
	const styleBucketOrdering = [
		"r",
		"d",
		"l",
		"v",
		"w",
		"f",
		"i",
		"h",
		"a",
		"s",
		"k",
		"t",
		"m",
		"c"
	];
	const styleBucketOrderingMap = /* @__PURE__ */ styleBucketOrdering.reduce((acc, cur, j) => {
		acc[cur] = j;
		return acc;
	}, {});
	function getStyleSheetKey(bucketName, media, priority) {
		return (bucketName === "m" ? bucketName + media : bucketName) + priority;
	}
	function getStyleSheetKeyFromElement(styleEl) {
		var _a;
		const bucketName = styleEl.getAttribute(DATA_BUCKET_ATTR);
		const priority = (_a = styleEl.getAttribute(DATA_PRIORITY_ATTR)) !== null && _a !== void 0 ? _a : "0";
		return getStyleSheetKey(bucketName, styleEl.media, priority);
	}
	/**
	* Lazily adds a `<style>` bucket to the `<head>`. This will ensure that the style buckets are ordered.
	*/
	function getStyleSheetForBucket(bucketName, targetDocument, insertionPoint, renderer, metadata = {}) {
		var _a, _b;
		const isMediaBucket = bucketName === "m";
		const media = (_a = metadata["m"]) !== null && _a !== void 0 ? _a : "0";
		const priority = (_b = metadata["p"]) !== null && _b !== void 0 ? _b : 0;
		const stylesheetKey = getStyleSheetKey(bucketName, media, priority);
		if (!renderer.stylesheets[stylesheetKey]) {
			const tag = targetDocument && targetDocument.createElement("style");
			const stylesheet = createIsomorphicStyleSheet(tag, bucketName, priority, Object.assign({}, renderer.styleElementAttributes, isMediaBucket && { media }));
			renderer.stylesheets[stylesheetKey] = stylesheet;
			if ((targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.head) && tag) targetDocument.head.insertBefore(tag, findInsertionPoint(targetDocument, insertionPoint, bucketName, renderer, metadata));
		}
		return renderer.stylesheets[stylesheetKey];
	}
	function isSameInsertionKey(element, bucketName, metadata) {
		var _a, _b;
		return bucketName + ((_a = metadata["m"]) !== null && _a !== void 0 ? _a : "") === element.getAttribute(DATA_BUCKET_ATTR) + ((_b = element.media) !== null && _b !== void 0 ? _b : "");
	}
	/**
	* Finds an element before which the new bucket style element should be inserted following the bucket sort order.
	*
	* @param targetDocument - A document
	* @param insertionPoint - An element that will be used as an initial insertion point
	* @param targetBucket - The bucket that should be inserted to DOM
	* @param renderer - Griffel renderer
	* @param metadata - metadata for CSS rule
	* @returns - Smallest style element with greater sort order than the current bucket
	*/
	function findInsertionPoint(targetDocument, insertionPoint, targetBucket, renderer, metadata = {}) {
		var _a, _b;
		const targetOrder = styleBucketOrderingMap[targetBucket];
		const media = (_a = metadata["m"]) !== null && _a !== void 0 ? _a : "";
		const priority = (_b = metadata["p"]) !== null && _b !== void 0 ? _b : 0;
		let comparer = (el) => targetOrder - styleBucketOrderingMap[el.getAttribute(DATA_BUCKET_ATTR)];
		let styleElements = targetDocument.head.querySelectorAll(`[${DATA_BUCKET_ATTR}]`);
		if (targetBucket === "m") {
			const mediaElements = targetDocument.head.querySelectorAll(`[${DATA_BUCKET_ATTR}="${targetBucket}"]`);
			if (mediaElements.length) {
				styleElements = mediaElements;
				comparer = (el) => renderer.compareMediaQueries(media, el.media);
			}
		}
		const comparerWithPriority = (el) => {
			if (isSameInsertionKey(el, targetBucket, metadata)) return priority - Number(el.getAttribute("data-priority"));
			return comparer(el);
		};
		const length$1 = styleElements.length;
		let index = length$1 - 1;
		while (index >= 0) {
			const styleElement = styleElements.item(index);
			if (comparerWithPriority(styleElement) > 0) return styleElement.nextSibling;
			index--;
		}
		if (length$1 > 0) return styleElements.item(0);
		return insertionPoint ? insertionPoint.nextSibling : null;
	}

//#endregion
//#region node_modules/@griffel/core/renderer/safeInsertRule.esm.js
/**
	* Suffixes to be ignored in case of error
	*/
	const ignoreSuffixes = /* @__PURE__ */ [
		"-moz-placeholder",
		"-moz-focus-inner",
		"-moz-focusring",
		"-ms-input-placeholder",
		"-moz-read-write",
		"-moz-read-only"
	].join("|");
	const ignoreSuffixesRegex = /* @__PURE__ */ new RegExp(`:(${ignoreSuffixes})`);
	/**
	* @internal
	*
	* Calls `sheet.insertRule` and catches errors related to browser prefixes.
	*/
	function safeInsertRule(sheet, ruleCSS) {
		try {
			sheet.insertRule(ruleCSS);
		} catch (e) {
			if (!ignoreSuffixesRegex.test(ruleCSS)) console.error(`There was a problem inserting the following rule: "${ruleCSS}"`, e);
		}
	}

//#endregion
//#region node_modules/@griffel/core/renderer/createDOMRenderer.esm.js
	let lastIndex = 0;
	/** @internal */
	const defaultCompareMediaQueries = (a, b) => a < b ? -1 : a > b ? 1 : 0;
	/**
	* Creates a new instances of a renderer.
	*
	* @public
	*/
	function createDOMRenderer(targetDocument = typeof document === "undefined" ? void 0 : document, options = {}) {
		const { classNameHashSalt, unstable_filterCSSRule, insertionPoint, styleElementAttributes, compareMediaQueries = defaultCompareMediaQueries } = options;
		const renderer = {
			classNameHashSalt,
			insertionCache: {},
			stylesheets: {},
			styleElementAttributes: Object.freeze(styleElementAttributes),
			compareMediaQueries,
			id: `d${lastIndex++}`,
			insertCSSRules(cssRules$1) {
				for (const styleBucketName in cssRules$1) {
					const cssRulesForBucket = cssRules$1[styleBucketName];
					for (let i = 0, l = cssRulesForBucket.length; i < l; i++) {
						const [ruleCSS, metadata] = normalizeCSSBucketEntry(cssRulesForBucket[i]);
						const sheet = getStyleSheetForBucket(styleBucketName, targetDocument, insertionPoint || null, renderer, metadata);
						if (renderer.insertionCache[ruleCSS]) continue;
						renderer.insertionCache[ruleCSS] = styleBucketName;
						if (isDevToolsEnabled) debugData.addCSSRule(ruleCSS);
						if (unstable_filterCSSRule) {
							if (unstable_filterCSSRule(ruleCSS)) safeInsertRule(sheet, ruleCSS);
						} else safeInsertRule(sheet, ruleCSS);
					}
				}
			}
		};
		if (targetDocument && isDevToolsEnabled) injectDevTools(targetDocument);
		return renderer;
	}

//#endregion
//#region node_modules/@griffel/core/renderer/rehydrateRendererCache.esm.js
	const KEYFRAMES_HYDRATOR = /@(-webkit-)?keyframes ([^{]+){((?:(?:from|to|(?:\d+\.?\d*%))\{(?:[^}])*})*)}/g;
	const AT_RULES_HYDRATOR = /@(media|supports|layer)[^{]+\{([\s\S]+?})\s*}/g;
	const STYLES_HYDRATOR = /\.([^{:]+)(:[^{]+)?{(?:[^}]*;)?([^}]*?)}/g;
	const regexps = {
		k: KEYFRAMES_HYDRATOR,
		t: AT_RULES_HYDRATOR,
		m: AT_RULES_HYDRATOR
	};
	/**
	* Should be called in a case of Server-Side rendering. Rehydrates cache from for a renderer to avoid double insertion
	* of classes to DOM.
	*
	* @public
	*/
	function rehydrateRendererCache(renderer, target = typeof document === "undefined" ? void 0 : document) {
		if (target) target.querySelectorAll("[data-make-styles-bucket]").forEach((styleElement) => {
			const bucketName = styleElement.dataset["makeStylesBucket"];
			const stylesheetKey = getStyleSheetKeyFromElement(styleElement);
			if (!renderer.stylesheets[stylesheetKey]) renderer.stylesheets[stylesheetKey] = createIsomorphicStyleSheetFromElement(styleElement);
			const regex$1 = regexps[bucketName] || STYLES_HYDRATOR;
			let match$1;
			while (match$1 = regex$1.exec(styleElement.textContent)) {
				const [cssRule] = match$1;
				renderer.insertionCache[cssRule] = bucketName;
				if (isDevToolsEnabled) debugData.addCSSRule(cssRule);
			}
		});
	}

//#endregion
//#region node_modules/@griffel/core/devtools/react-render-tracker/stackTrace.esm.js
	const UNKNOWN_FUNCTION = "<unknown>";
	function parseStackTraceLine(line$1) {
		return parseChrome(line$1) || parseGecko(line$1) || parseJSC(line$1);
	}
	const chromeRe = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\/|[a-z]:\\|\\\\).*?)?\)?\s*$/i;
	const chromeRe2 = /^\s*at ()((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\/|[a-z]:\\|\\\\).*?)\s*$/i;
	const chromeEvalRe = /\((\S*)\)/;
	function parseChrome(line$1) {
		const parts = chromeRe.exec(line$1) || chromeRe2.exec(line$1);
		if (!parts) return null;
		let loc = parts[2];
		const isNative = loc && loc.indexOf("native") === 0;
		const isEval = loc && loc.indexOf("eval") === 0;
		const submatch = chromeEvalRe.exec(loc);
		if (isEval && submatch != null) loc = submatch[1];
		return {
			loc: !isNative ? parts[2] : null,
			name: parts[1] || UNKNOWN_FUNCTION
		};
	}
	const geckoRe = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\[native).*?|[^@]*bundle)\s*$/i;
	const geckoEvalRe = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
	function parseGecko(line$1) {
		const parts = geckoRe.exec(line$1);
		if (!parts) return null;
		let loc = parts[3];
		const isEval = loc && loc.indexOf(" > eval") > -1;
		const submatch = geckoEvalRe.exec(loc);
		if (isEval && submatch != null) loc = submatch[1];
		return {
			loc: parts[3],
			name: parts[1] || UNKNOWN_FUNCTION
		};
	}
	const javaScriptCoreRe = /^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?)\s*$/i;
	function parseJSC(line$1) {
		const parts = javaScriptCoreRe.exec(line$1);
		if (!parts) return null;
		return {
			loc: parts[3],
			name: parts[1] || UNKNOWN_FUNCTION
		};
	}

//#endregion
//#region node_modules/@griffel/core/devtools/getSourceURLfromError.esm.js
	function getSourceURLfromError() {
		const userMakeStyleCallLine = findUserMakeStyleCallInStacks(String((/* @__PURE__ */ new Error()).stack).split("\n"));
		if (userMakeStyleCallLine === void 0) return;
		const result = parseStackTraceLine(userMakeStyleCallLine);
		return result === null || result === void 0 ? void 0 : result.loc;
	}
	function findUserMakeStyleCallInStacks(stacks) {
		for (let i = stacks.length - 1; i >= 0; --i) if (stacks[i].includes("at getSourceURLfromError")) return stacks[i + 3];
	}

//#endregion
//#region node_modules/@griffel/core/insertionFactory.esm.js
/**
	* Default implementation of insertion factory. Inserts styles only once per renderer and performs
	* insertion immediately after styles computation.
	*
	* @internal
	*/
	const insertionFactory$1 = () => {
		const insertionCache = {};
		return function insertStyles(renderer, cssRules$1) {
			if (insertionCache[renderer.id] === void 0) {
				renderer.insertCSSRules(cssRules$1);
				insertionCache[renderer.id] = true;
			}
		};
	};

//#endregion
//#region node_modules/rtl-css-js/dist/esm/convert-9768a965.js
/**
	* Takes an array of [keyValue1, keyValue2] pairs and creates an object of {keyValue1: keyValue2, keyValue2: keyValue1}
	* @param {Array} array the array of pairs
	* @return {Object} the {key, value} pair object
	*/
	function arrayToObject(array) {
		return array.reduce(function(obj, _ref) {
			var prop1 = _ref[0], prop2 = _ref[1];
			obj[prop1] = prop2;
			obj[prop2] = prop1;
			return obj;
		}, {});
	}
	function isBoolean$1(val) {
		return typeof val === "boolean";
	}
	function isFunction(val) {
		return typeof val === "function";
	}
	function isNumber$2(val) {
		return typeof val === "number";
	}
	function isNullOrUndefined(val) {
		return val === null || typeof val === "undefined";
	}
	function isObject$2(val) {
		return val && typeof val === "object";
	}
	function isString$1(val) {
		return typeof val === "string";
	}
	function includes(inclusive, inclusee) {
		return inclusive.indexOf(inclusee) !== -1;
	}
	/**
	* Flip the sign of a CSS value, possibly with a unit.
	*
	* We can't just negate the value with unary minus due to the units.
	*
	* @private
	* @param {String} value - the original value (for example 77%)
	* @return {String} the result (for example -77%)
	*/
	function flipSign(value) {
		if (parseFloat(value) === 0) return value;
		if (value[0] === "-") return value.slice(1);
		return "-" + value;
	}
	function flipTransformSign(match$1, prefix$1, offset$3, suffix) {
		return prefix$1 + flipSign(offset$3) + suffix;
	}
	/**
	* Takes a percentage for background position and inverts it.
	* This was copied and modified from CSSJanus:
	* https://github.com/cssjanus/cssjanus/blob/4245f834365f6cfb0239191a151432fb85abab23/src/cssjanus.js#L152-L175
	* @param {String} value - the original value (for example 77%)
	* @return {String} the result (for example 23%)
	*/
	function calculateNewBackgroundPosition(value) {
		var idx = value.indexOf(".");
		if (idx === -1) value = 100 - parseFloat(value) + "%";
		else {
			var len = value.length - idx - 2;
			value = 100 - parseFloat(value);
			value = value.toFixed(len) + "%";
		}
		return value;
	}
	/**
	* This takes a list of CSS values and converts it to an array
	* @param {String} value - something like `1px`, `1px 2em`, or `3pt rgb(150, 230, 550) 40px calc(100% - 5px)`
	* @return {Array} the split values (for example: `['3pt', 'rgb(150, 230, 550)', '40px', 'calc(100% - 5px)']`)
	*/
	function getValuesAsList(value) {
		return value.replace(/ +/g, " ").split(" ").map(function(i) {
			return i.trim();
		}).filter(Boolean).reduce(function(_ref2, item) {
			var list = _ref2.list, state = _ref2.state;
			var openParansCount = (item.match(/\(/g) || []).length;
			var closedParansCount = (item.match(/\)/g) || []).length;
			if (state.parensDepth > 0) list[list.length - 1] = list[list.length - 1] + " " + item;
			else list.push(item);
			state.parensDepth += openParansCount - closedParansCount;
			return {
				list,
				state
			};
		}, {
			list: [],
			state: { parensDepth: 0 }
		}).list;
	}
	/**
	* This is intended for properties that are `top right bottom left` and will switch them to `top left bottom right`
	* @param {String} value - `1px 2px 3px 4px` for example, but also handles cases where there are too few/too many and
	* simply returns the value in those cases (which is the correct behavior)
	* @return {String} the result - `1px 4px 3px 2px` for example.
	*/
	function handleQuartetValues(value) {
		var splitValues = getValuesAsList(value);
		if (splitValues.length <= 3 || splitValues.length > 4) return value;
		var top = splitValues[0], right$1 = splitValues[1], bottom = splitValues[2];
		return [
			top,
			splitValues[3],
			bottom,
			right$1
		].join(" ");
	}
	/**
	*
	* @param {String|Number|Object} value css property value to test
	* @returns If the css property value can(should?) have an RTL equivalent
	*/
	function canConvertValue(value) {
		return !isBoolean$1(value) && !isNullOrUndefined(value);
	}
	/**
	* Splits a shadow style into its separate shadows using the comma delimiter, but creating an exception
	* for comma separated values in parentheses often used for rgba colours.
	* @param {String} value
	* @returns {Array} array of all box shadow values in the string
	*/
	function splitShadow(value) {
		var shadows = [];
		var start = 0;
		var end = 0;
		var rgba = false;
		while (end < value.length) if (!rgba && value[end] === ",") {
			shadows.push(value.substring(start, end).trim());
			end++;
			start = end;
		} else if (value[end] === "(") {
			rgba = true;
			end++;
		} else if (value[end] === ")") {
			rgba = false;
			end++;
		} else end++;
		// istanbul ignore next
		if (start != end) shadows.push(value.substring(start, end + 1));
		return shadows;
	}
	var propertyValueConverters = {
		padding: function padding$1(_ref) {
			var value = _ref.value;
			if (isNumber$2(value)) return value;
			return handleQuartetValues(value);
		},
		textShadow: function textShadow(_ref2) {
			var value = _ref2.value;
			return splitShadow(value).map(function(shadow) {
				return shadow.replace(/(^|\s)(-*)([.|\d]+)/, function(match$1, whiteSpace, negative, number) {
					if (number === "0") return match$1;
					var doubleNegative = negative === "" ? "-" : "";
					return "" + whiteSpace + doubleNegative + number;
				});
			}).join(",");
		},
		borderColor: function borderColor$2(_ref3) {
			var value = _ref3.value;
			return handleQuartetValues(value);
		},
		borderRadius: function borderRadius$2(_ref4) {
			var value = _ref4.value;
			if (isNumber$2(value)) return value;
			if (includes(value, "/")) {
				var _value$split = value.split("/"), radius1 = _value$split[0], radius2 = _value$split[1];
				var convertedRadius1 = propertyValueConverters.borderRadius({ value: radius1.trim() });
				var convertedRadius2 = propertyValueConverters.borderRadius({ value: radius2.trim() });
				return convertedRadius1 + " / " + convertedRadius2;
			}
			var splitValues = getValuesAsList(value);
			switch (splitValues.length) {
				case 2: return splitValues.reverse().join(" ");
				case 4:
					var topLeft = splitValues[0], topRight = splitValues[1], bottomRight = splitValues[2];
					return [
						topRight,
						topLeft,
						splitValues[3],
						bottomRight
					].join(" ");
				default: return value;
			}
		},
		background: function background(_ref5) {
			var value = _ref5.value, valuesToConvert$1 = _ref5.valuesToConvert, isRtl = _ref5.isRtl, bgImgDirectionRegex$1 = _ref5.bgImgDirectionRegex, bgPosDirectionRegex$1 = _ref5.bgPosDirectionRegex;
			if (isNumber$2(value)) return value;
			var backgroundPositionValue = value.replace(/(url\(.*?\))|(rgba?\(.*?\))|(hsl\(.*?\))|(#[a-fA-F0-9]+)|((^| )(\D)+( |$))/g, "").trim();
			value = value.replace(backgroundPositionValue, propertyValueConverters.backgroundPosition({
				value: backgroundPositionValue,
				valuesToConvert: valuesToConvert$1,
				isRtl,
				bgPosDirectionRegex: bgPosDirectionRegex$1
			}));
			return propertyValueConverters.backgroundImage({
				value,
				valuesToConvert: valuesToConvert$1,
				bgImgDirectionRegex: bgImgDirectionRegex$1
			});
		},
		backgroundImage: function backgroundImage(_ref6) {
			var value = _ref6.value, valuesToConvert$1 = _ref6.valuesToConvert, bgImgDirectionRegex$1 = _ref6.bgImgDirectionRegex;
			if (!includes(value, "url(") && !includes(value, "linear-gradient(")) return value;
			return value.replace(bgImgDirectionRegex$1, function(match$1, g1, group2) {
				return match$1.replace(group2, valuesToConvert$1[group2]);
			});
		},
		backgroundPosition: function backgroundPosition(_ref7) {
			var value = _ref7.value, valuesToConvert$1 = _ref7.valuesToConvert, isRtl = _ref7.isRtl, bgPosDirectionRegex$1 = _ref7.bgPosDirectionRegex;
			return value.replace(isRtl ? /^((-|\d|\.)+%)/ : null, function(match$1, group) {
				return calculateNewBackgroundPosition(group);
			}).replace(bgPosDirectionRegex$1, function(match$1) {
				return valuesToConvert$1[match$1];
			});
		},
		backgroundPositionX: function backgroundPositionX(_ref8) {
			var value = _ref8.value, valuesToConvert$1 = _ref8.valuesToConvert, isRtl = _ref8.isRtl, bgPosDirectionRegex$1 = _ref8.bgPosDirectionRegex;
			if (isNumber$2(value)) return value;
			return propertyValueConverters.backgroundPosition({
				value,
				valuesToConvert: valuesToConvert$1,
				isRtl,
				bgPosDirectionRegex: bgPosDirectionRegex$1
			});
		},
		transition: function transition$1(_ref9) {
			var value = _ref9.value, propertiesToConvert$1 = _ref9.propertiesToConvert;
			return value.split(/,\s*/g).map(function(transition$2) {
				var values = transition$2.split(" ");
				values[0] = propertiesToConvert$1[values[0]] || values[0];
				return values.join(" ");
			}).join(", ");
		},
		transitionProperty: function transitionProperty(_ref10) {
			var value = _ref10.value, propertiesToConvert$1 = _ref10.propertiesToConvert;
			return value.split(/,\s*/g).map(function(prop) {
				return propertiesToConvert$1[prop] || prop;
			}).join(", ");
		},
		transform: function transform(_ref11) {
			var value = _ref11.value;
			var nonAsciiPattern = "[^\\u0020-\\u007e]";
			var escapePattern = "(?:(?:(?:\\[0-9a-f]{1,6})(?:\\r\\n|\\s)?)|\\\\[^\\r\\n\\f0-9a-f])";
			var signedQuantPattern = "((?:-?" + ("(?:[0-9]*\\.[0-9]+|[0-9]+)(?:\\s*(?:em|ex|px|cm|mm|in|pt|pc|deg|rad|grad|ms|s|hz|khz|%)|" + ("-?" + ("(?:[_a-z]|" + nonAsciiPattern + "|" + escapePattern + ")") + ("(?:[_a-z0-9-]|" + nonAsciiPattern + "|" + escapePattern + ")") + "*") + ")?") + ")|(?:inherit|auto))";
			var translateXRegExp = new RegExp("(translateX\\s*\\(\\s*)" + signedQuantPattern + "(\\s*\\))", "gi");
			var translateRegExp = new RegExp("(translate\\s*\\(\\s*)" + signedQuantPattern + "((?:\\s*,\\s*" + signedQuantPattern + "){0,1}\\s*\\))", "gi");
			var translate3dRegExp = new RegExp("(translate3d\\s*\\(\\s*)" + signedQuantPattern + "((?:\\s*,\\s*" + signedQuantPattern + "){0,2}\\s*\\))", "gi");
			var rotateRegExp = new RegExp("(rotate[ZY]?\\s*\\(\\s*)" + signedQuantPattern + "(\\s*\\))", "gi");
			return value.replace(translateXRegExp, flipTransformSign).replace(translateRegExp, flipTransformSign).replace(translate3dRegExp, flipTransformSign).replace(rotateRegExp, flipTransformSign);
		}
	};
	propertyValueConverters.objectPosition = propertyValueConverters.backgroundPosition;
	propertyValueConverters.margin = propertyValueConverters.padding;
	propertyValueConverters.borderWidth = propertyValueConverters.padding;
	propertyValueConverters.boxShadow = propertyValueConverters.textShadow;
	propertyValueConverters.webkitBoxShadow = propertyValueConverters.boxShadow;
	propertyValueConverters.mozBoxShadow = propertyValueConverters.boxShadow;
	propertyValueConverters.WebkitBoxShadow = propertyValueConverters.boxShadow;
	propertyValueConverters.MozBoxShadow = propertyValueConverters.boxShadow;
	propertyValueConverters.borderStyle = propertyValueConverters.borderColor;
	propertyValueConverters.webkitTransform = propertyValueConverters.transform;
	propertyValueConverters.mozTransform = propertyValueConverters.transform;
	propertyValueConverters.WebkitTransform = propertyValueConverters.transform;
	propertyValueConverters.MozTransform = propertyValueConverters.transform;
	propertyValueConverters.transformOrigin = propertyValueConverters.backgroundPosition;
	propertyValueConverters.webkitTransformOrigin = propertyValueConverters.transformOrigin;
	propertyValueConverters.mozTransformOrigin = propertyValueConverters.transformOrigin;
	propertyValueConverters.WebkitTransformOrigin = propertyValueConverters.transformOrigin;
	propertyValueConverters.MozTransformOrigin = propertyValueConverters.transformOrigin;
	propertyValueConverters.webkitTransition = propertyValueConverters.transition;
	propertyValueConverters.mozTransition = propertyValueConverters.transition;
	propertyValueConverters.WebkitTransition = propertyValueConverters.transition;
	propertyValueConverters.MozTransition = propertyValueConverters.transition;
	propertyValueConverters.webkitTransitionProperty = propertyValueConverters.transitionProperty;
	propertyValueConverters.mozTransitionProperty = propertyValueConverters.transitionProperty;
	propertyValueConverters.WebkitTransitionProperty = propertyValueConverters.transitionProperty;
	propertyValueConverters.MozTransitionProperty = propertyValueConverters.transitionProperty;
	propertyValueConverters["text-shadow"] = propertyValueConverters.textShadow;
	propertyValueConverters["border-color"] = propertyValueConverters.borderColor;
	propertyValueConverters["border-radius"] = propertyValueConverters.borderRadius;
	propertyValueConverters["background-image"] = propertyValueConverters.backgroundImage;
	propertyValueConverters["background-position"] = propertyValueConverters.backgroundPosition;
	propertyValueConverters["background-position-x"] = propertyValueConverters.backgroundPositionX;
	propertyValueConverters["object-position"] = propertyValueConverters.objectPosition;
	propertyValueConverters["border-width"] = propertyValueConverters.padding;
	propertyValueConverters["box-shadow"] = propertyValueConverters.textShadow;
	propertyValueConverters["-webkit-box-shadow"] = propertyValueConverters.textShadow;
	propertyValueConverters["-moz-box-shadow"] = propertyValueConverters.textShadow;
	propertyValueConverters["border-style"] = propertyValueConverters.borderColor;
	propertyValueConverters["-webkit-transform"] = propertyValueConverters.transform;
	propertyValueConverters["-moz-transform"] = propertyValueConverters.transform;
	propertyValueConverters["transform-origin"] = propertyValueConverters.transformOrigin;
	propertyValueConverters["-webkit-transform-origin"] = propertyValueConverters.transformOrigin;
	propertyValueConverters["-moz-transform-origin"] = propertyValueConverters.transformOrigin;
	propertyValueConverters["-webkit-transition"] = propertyValueConverters.transition;
	propertyValueConverters["-moz-transition"] = propertyValueConverters.transition;
	propertyValueConverters["transition-property"] = propertyValueConverters.transitionProperty;
	propertyValueConverters["-webkit-transition-property"] = propertyValueConverters.transitionProperty;
	propertyValueConverters["-moz-transition-property"] = propertyValueConverters.transitionProperty;
	var propertiesToConvert = arrayToObject([
		["paddingLeft", "paddingRight"],
		["marginLeft", "marginRight"],
		["left", "right"],
		["borderLeft", "borderRight"],
		["borderLeftColor", "borderRightColor"],
		["borderLeftStyle", "borderRightStyle"],
		["borderLeftWidth", "borderRightWidth"],
		["borderTopLeftRadius", "borderTopRightRadius"],
		["borderBottomLeftRadius", "borderBottomRightRadius"],
		["padding-left", "padding-right"],
		["margin-left", "margin-right"],
		["border-left", "border-right"],
		["border-left-color", "border-right-color"],
		["border-left-style", "border-right-style"],
		["border-left-width", "border-right-width"],
		["border-top-left-radius", "border-top-right-radius"],
		["border-bottom-left-radius", "border-bottom-right-radius"]
	]);
	var propsToIgnore = ["content"];
	var valuesToConvert = arrayToObject([
		["ltr", "rtl"],
		["left", "right"],
		["w-resize", "e-resize"],
		["sw-resize", "se-resize"],
		["nw-resize", "ne-resize"]
	]);
	var bgImgDirectionRegex = new RegExp("(^|\\W|_)((ltr)|(rtl)|(left)|(right))(\\W|_|$)", "g");
	var bgPosDirectionRegex = /* @__PURE__ */ new RegExp("(left)|(right)");
	/**
	* converts properties and values in the CSS in JS object to their corresponding RTL values
	* @param {Object} object the CSS in JS object
	* @return {Object} the RTL converted object
	*/
	function convert(object) {
		return Object.keys(object).reduce(function(newObj, originalKey) {
			var originalValue = object[originalKey];
			if (isString$1(originalValue)) originalValue = originalValue.trim();
			if (includes(propsToIgnore, originalKey)) {
				newObj[originalKey] = originalValue;
				return newObj;
			}
			var _convertProperty = convertProperty(originalKey, originalValue), key = _convertProperty.key;
			newObj[key] = _convertProperty.value;
			return newObj;
		}, Array.isArray(object) ? [] : {});
	}
	/**
	* Converts a property and its value to the corresponding RTL key and value
	* @param {String} originalKey the original property key
	* @param {Number|String|Object} originalValue the original css property value
	* @return {Object} the new {key, value} pair
	*/
	function convertProperty(originalKey, originalValue) {
		var isNoFlip = /\/\*\s?@noflip\s?\*\//.test(originalValue);
		var key = isNoFlip ? originalKey : getPropertyDoppelganger(originalKey);
		return {
			key,
			value: isNoFlip ? originalValue : getValueDoppelganger(key, originalValue)
		};
	}
	/**
	* This gets the RTL version of the given property if it has a corresponding RTL property
	* @param {String} property the name of the property
	* @return {String} the name of the RTL property
	*/
	function getPropertyDoppelganger(property) {
		return propertiesToConvert[property] || property;
	}
	/**
	* This converts the given value to the RTL version of that value based on the key
	* @param {String} key this is the key (note: this should be the RTL version of the originalKey)
	* @param {String|Number|Object} originalValue the original css property value. If it's an object, then we'll convert that as well
	* @return {String|Number|Object} the converted value
	*/
	function getValueDoppelganger(key, originalValue) {
		if (!canConvertValue(originalValue)) return originalValue;
		if (isObject$2(originalValue)) return convert(originalValue);
		var isNum = isNumber$2(originalValue);
		var isFunc = isFunction(originalValue);
		var importantlessValue = isNum || isFunc ? originalValue : originalValue.replace(/ !important.*?$/, "");
		var isImportant = !isNum && importantlessValue.length !== originalValue.length;
		var valueConverter = propertyValueConverters[key];
		var newValue;
		if (valueConverter) newValue = valueConverter({
			value: importantlessValue,
			valuesToConvert,
			propertiesToConvert,
			isRtl: true,
			bgImgDirectionRegex,
			bgPosDirectionRegex
		});
		else newValue = valuesToConvert[importantlessValue] || importantlessValue;
		if (isImportant) return newValue + " !important";
		return newValue;
	}

//#endregion
//#region node_modules/@griffel/core/runtime/utils/hyphenateProperty.esm.js
	const uppercasePattern = /[A-Z]/g;
	const msPattern = /^ms-/;
	const cache$2 = {};
	function toHyphenLower(match$1) {
		return "-" + match$1.toLowerCase();
	}
	function hyphenateProperty(name) {
		if (Object.prototype.hasOwnProperty.call(cache$2, name)) return cache$2[name];
		if (name.substr(0, 2) === "--") return name;
		const hName = name.replace(uppercasePattern, toHyphenLower);
		return cache$2[name] = msPattern.test(hName) ? "-" + hName : hName;
	}

//#endregion
//#region node_modules/@griffel/core/runtime/utils/normalizeNestedProperty.esm.js
	function normalizeNestedProperty(nestedProperty) {
		if (nestedProperty.charAt(0) === "&") return nestedProperty.slice(1);
		return nestedProperty;
	}

//#endregion
//#region node_modules/stylis/src/Enum.js
	var MOZ = "-moz-";
	var WEBKIT = "-webkit-";
	var COMMENT = "comm";
	var RULESET = "rule";
	var DECLARATION = "decl";
	var MEDIA = "@media";
	var IMPORT = "@import";
	var SUPPORTS = "@supports";
	var NAMESPACE = "@namespace";
	var KEYFRAMES = "@keyframes";
	var LAYER = "@layer";

//#endregion
//#region node_modules/stylis/src/Utility.js
/**
	* @param {number}
	* @return {number}
	*/
	var abs = Math.abs;
	/**
	* @param {number}
	* @return {string}
	*/
	var from = String.fromCharCode;
	/**
	* @param {object}
	* @return {object}
	*/
	var assign = Object.assign;
	/**
	* @param {string} value
	* @param {number} length
	* @return {number}
	*/
	function hash(value, length$1) {
		return charat(value, 0) ^ 45 ? (((length$1 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
	}
	/**
	* @param {string} value
	* @return {string}
	*/
	function trim(value) {
		return value.trim();
	}
	/**
	* @param {string} value
	* @param {RegExp} pattern
	* @return {string?}
	*/
	function match(value, pattern) {
		return (value = pattern.exec(value)) ? value[0] : value;
	}
	/**
	* @param {string} value
	* @param {(string|RegExp)} pattern
	* @param {string} replacement
	* @return {string}
	*/
	function replace(value, pattern, replacement) {
		return value.replace(pattern, replacement);
	}
	/**
	* @param {string} value
	* @param {string} search
	* @param {number} position
	* @return {number}
	*/
	function indexof(value, search, position$1) {
		return value.indexOf(search, position$1);
	}
	/**
	* @param {string} value
	* @param {number} index
	* @return {number}
	*/
	function charat(value, index) {
		return value.charCodeAt(index) | 0;
	}
	/**
	* @param {string} value
	* @param {number} begin
	* @param {number} end
	* @return {string}
	*/
	function substr(value, begin, end) {
		return value.slice(begin, end);
	}
	/**
	* @param {string} value
	* @return {number}
	*/
	function strlen(value) {
		return value.length;
	}
	/**
	* @param {any[]} value
	* @return {number}
	*/
	function sizeof(value) {
		return value.length;
	}
	/**
	* @param {any} value
	* @param {any[]} array
	* @return {any}
	*/
	function append(value, array) {
		return array.push(value), value;
	}
	/**
	* @param {string[]} array
	* @param {function} callback
	* @return {string}
	*/
	function combine(array, callback) {
		return array.map(callback).join("");
	}

//#endregion
//#region node_modules/stylis/src/Tokenizer.js
	var line = 1;
	var column = 1;
	var length = 0;
	var position = 0;
	var character = 0;
	var characters = "";
	/**
	* @param {string} value
	* @param {object | null} root
	* @param {object | null} parent
	* @param {string} type
	* @param {string[] | string} props
	* @param {object[] | string} children
	* @param {object[]} siblings
	* @param {number} length
	*/
	function node(value, root, parent$1, type, props, children, length$1, siblings) {
		return {
			value,
			root,
			parent: parent$1,
			type,
			props,
			children,
			line,
			column,
			length: length$1,
			return: "",
			siblings
		};
	}
	/**
	* @param {object} root
	* @param {object} props
	* @return {object}
	*/
	function copy(root, props) {
		return assign(node("", null, null, "", null, null, 0, root.siblings), root, { length: -root.length }, props);
	}
	/**
	* @return {number}
	*/
	function char() {
		return character;
	}
	/**
	* @return {number}
	*/
	function prev() {
		character = position > 0 ? charat(characters, --position) : 0;
		if (column--, character === 10) column = 1, line--;
		return character;
	}
	/**
	* @return {number}
	*/
	function next() {
		character = position < length ? charat(characters, position++) : 0;
		if (column++, character === 10) column = 1, line++;
		return character;
	}
	/**
	* @return {number}
	*/
	function peek() {
		return charat(characters, position);
	}
	/**
	* @return {number}
	*/
	function caret() {
		return position;
	}
	/**
	* @param {number} begin
	* @param {number} end
	* @return {string}
	*/
	function slice(begin, end) {
		return substr(characters, begin, end);
	}
	/**
	* @param {number} type
	* @return {number}
	*/
	function token(type) {
		switch (type) {
			case 0:
			case 9:
			case 10:
			case 13:
			case 32: return 5;
			case 33:
			case 43:
			case 44:
			case 47:
			case 62:
			case 64:
			case 126:
			case 59:
			case 123:
			case 125: return 4;
			case 58: return 3;
			case 34:
			case 39:
			case 40:
			case 91: return 2;
			case 41:
			case 93: return 1;
		}
		return 0;
	}
	/**
	* @param {string} value
	* @return {any[]}
	*/
	function alloc(value) {
		return line = column = 1, length = strlen(characters = value), position = 0, [];
	}
	/**
	* @param {any} value
	* @return {any}
	*/
	function dealloc(value) {
		return characters = "", value;
	}
	/**
	* @param {number} type
	* @return {string}
	*/
	function delimit(type) {
		return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
	}
	/**
	* @param {string} value
	* @return {string[]}
	*/
	function tokenize(value) {
		return dealloc(tokenizer(alloc(value)));
	}
	/**
	* @param {number} type
	* @return {string}
	*/
	function whitespace(type) {
		while (character = peek()) if (character < 33) next();
		else break;
		return token(type) > 2 || token(character) > 3 ? "" : " ";
	}
	/**
	* @param {string[]} children
	* @return {string[]}
	*/
	function tokenizer(children) {
		while (next()) switch (token(character)) {
			case 0:
				append(identifier(position - 1), children);
				break;
			case 2:
				append(delimit(character), children);
				break;
			default: append(from(character), children);
		}
		return children;
	}
	/**
	* @param {number} index
	* @param {number} count
	* @return {string}
	*/
	function escaping(index, count) {
		while (--count && next()) if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97) break;
		return slice(index, caret() + (count < 6 && peek() == 32 && next() == 32));
	}
	/**
	* @param {number} type
	* @return {number}
	*/
	function delimiter(type) {
		while (next()) switch (character) {
			case type: return position;
			case 34:
			case 39:
				if (type !== 34 && type !== 39) delimiter(character);
				break;
			case 40:
				if (type === 41) delimiter(type);
				break;
			case 92:
				next();
				break;
		}
		return position;
	}
	/**
	* @param {number} type
	* @param {number} index
	* @return {number}
	*/
	function commenter(type, index) {
		while (next()) if (type + character === 57) break;
		else if (type + character === 84 && peek() === 47) break;
		return "/*" + slice(index, position - 1) + "*" + from(type === 47 ? type : next());
	}
	/**
	* @param {number} index
	* @return {string}
	*/
	function identifier(index) {
		while (!token(peek())) next();
		return slice(index, position);
	}

//#endregion
//#region node_modules/stylis/src/Parser.js
/**
	* @param {string} value
	* @return {object[]}
	*/
	function compile(value) {
		return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
	}
	/**
	* @param {string} value
	* @param {object} root
	* @param {object?} parent
	* @param {string[]} rule
	* @param {string[]} rules
	* @param {string[]} rulesets
	* @param {number[]} pseudo
	* @param {number[]} points
	* @param {string[]} declarations
	* @return {object}
	*/
	function parse(value, root, parent$1, rule, rules, rulesets, pseudo, points, declarations) {
		var index = 0;
		var offset$3 = 0;
		var length$1 = pseudo;
		var atrule = 0;
		var property = 0;
		var previous = 0;
		var variable = 1;
		var scanning = 1;
		var ampersand = 1;
		var character$1 = 0;
		var type = "";
		var props = rules;
		var children = rulesets;
		var reference = rule;
		var characters$1 = type;
		while (scanning) switch (previous = character$1, character$1 = next()) {
			case 40: if (previous != 108 && charat(characters$1, length$1 - 1) == 58) {
				if (indexof(characters$1 += replace(delimit(character$1), "&", "&\f"), "&\f", abs(index ? points[index - 1] : 0)) != -1) ampersand = -1;
				break;
			}
			case 34:
			case 39:
			case 91:
				characters$1 += delimit(character$1);
				break;
			case 9:
			case 10:
			case 13:
			case 32:
				characters$1 += whitespace(previous);
				break;
			case 92:
				characters$1 += escaping(caret() - 1, 7);
				continue;
			case 47:
				switch (peek()) {
					case 42:
					case 47:
						append(comment(commenter(next(), caret()), root, parent$1, declarations), declarations);
						if ((token(previous || 1) == 5 || token(peek() || 1) == 5) && strlen(characters$1) && substr(characters$1, -1, void 0) !== " ") characters$1 += " ";
						break;
					default: characters$1 += "/";
				}
				break;
			case 123 * variable: points[index++] = strlen(characters$1) * ampersand;
			case 125 * variable:
			case 59:
			case 0:
				switch (character$1) {
					case 0:
					case 125: scanning = 0;
					case 59 + offset$3:
						if (ampersand == -1) characters$1 = replace(characters$1, /\f/g, "");
						if (property > 0 && (strlen(characters$1) - length$1 || variable === 0 && previous === 47)) append(property > 32 ? declaration(characters$1 + ";", rule, parent$1, length$1 - 1, declarations) : declaration(replace(characters$1, " ", "") + ";", rule, parent$1, length$1 - 2, declarations), declarations);
						break;
					case 59: characters$1 += ";";
					default:
						append(reference = ruleset(characters$1, root, parent$1, index, offset$3, rules, points, type, props = [], children = [], length$1, rulesets), rulesets);
						if (character$1 === 123) if (offset$3 === 0) parse(characters$1, root, reference, reference, props, rulesets, length$1, points, children);
						else {
							switch (atrule) {
								case 99: if (charat(characters$1, 3) === 110) break;
								case 108: if (charat(characters$1, 2) === 97) break;
								default: offset$3 = 0;
								case 100:
								case 109:
								case 115:
							}
							if (offset$3) parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length$1, children), children), rules, children, length$1, points, rule ? props : children);
							else parse(characters$1, reference, reference, reference, [""], children, 0, points, children);
						}
				}
				index = offset$3 = property = 0, variable = ampersand = 1, type = characters$1 = "", length$1 = pseudo;
				break;
			case 58: length$1 = 1 + strlen(characters$1), property = previous;
			default:
				if (variable < 1) {
					if (character$1 == 123) --variable;
					else if (character$1 == 125 && variable++ == 0 && prev() == 125) continue;
				}
				switch (characters$1 += from(character$1), character$1 * variable) {
					case 38:
						ampersand = offset$3 > 0 ? 1 : (characters$1 += "\f", -1);
						break;
					case 44:
						points[index++] = (strlen(characters$1) - 1) * ampersand, ampersand = 1;
						break;
					case 64:
						if (peek() === 45) characters$1 += delimit(next());
						atrule = peek(), offset$3 = length$1 = strlen(type = characters$1 += identifier(caret())), character$1++;
						break;
					case 45: if (previous === 45 && strlen(characters$1) == 2) variable = 0;
				}
		}
		return rulesets;
	}
	/**
	* @param {string} value
	* @param {object} root
	* @param {object?} parent
	* @param {number} index
	* @param {number} offset
	* @param {string[]} rules
	* @param {number[]} points
	* @param {string} type
	* @param {string[]} props
	* @param {string[]} children
	* @param {number} length
	* @param {object[]} siblings
	* @return {object}
	*/
	function ruleset(value, root, parent$1, index, offset$3, rules, points, type, props, children, length$1, siblings) {
		var post = offset$3 - 1;
		var rule = offset$3 === 0 ? rules : [""];
		var size$2 = sizeof(rule);
		for (var i = 0, j = 0, k = 0; i < index; ++i) for (var x = 0, y = substr(value, post + 1, post = abs(j = points[i])), z = value; x < size$2; ++x) if (z = trim(j > 0 ? rule[x] + " " + y : replace(y, /&\f/g, rule[x]))) props[k++] = z;
		return node(value, root, parent$1, offset$3 === 0 ? RULESET : type, props, children, length$1, siblings);
	}
	/**
	* @param {number} value
	* @param {object} root
	* @param {object?} parent
	* @param {object[]} siblings
	* @return {object}
	*/
	function comment(value, root, parent$1, siblings) {
		return node(value, root, parent$1, COMMENT, from(char()), substr(value, 2, -2), 0, siblings);
	}
	/**
	* @param {string} value
	* @param {object} root
	* @param {object?} parent
	* @param {number} length
	* @param {object[]} siblings
	* @return {object}
	*/
	function declaration(value, root, parent$1, length$1, siblings) {
		return node(value, root, parent$1, DECLARATION, substr(value, 0, length$1), substr(value, length$1 + 1, -1), length$1, siblings);
	}

//#endregion
//#region node_modules/stylis/src/Serializer.js
/**
	* @param {object[]} children
	* @param {function} callback
	* @return {string}
	*/
	function serialize$1(children, callback) {
		var output = "";
		for (var i = 0; i < children.length; i++) output += callback(children[i], i, children, callback) || "";
		return output;
	}
	/**
	* @param {object} element
	* @param {number} index
	* @param {object[]} children
	* @param {function} callback
	* @return {string}
	*/
	function stringify(element, index, children, callback) {
		switch (element.type) {
			case LAYER: if (element.children.length) break;
			case IMPORT:
			case NAMESPACE:
			case DECLARATION: return element.return = element.return || element.value;
			case COMMENT: return "";
			case KEYFRAMES: return element.return = element.value + "{" + serialize$1(element.children, callback) + "}";
			case RULESET: if (!strlen(element.value = element.props.join(","))) return "";
		}
		return strlen(children = serialize$1(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
	}

//#endregion
//#region node_modules/stylis/src/Middleware.js
/**
	* @param {function[]} collection
	* @return {function}
	*/
	function middleware(collection) {
		var length$1 = sizeof(collection);
		return function(element, index, children, callback) {
			var output = "";
			for (var i = 0; i < length$1; i++) output += collection[i](element, index, children, callback) || "";
			return output;
		};
	}
	/**
	* @param {function} callback
	* @return {function}
	*/
	function rulesheet(callback) {
		return function(element) {
			if (!element.root) {
				if (element = element.return) callback(element);
			}
		};
	}

//#endregion
//#region node_modules/@griffel/core/runtime/stylis/globalPlugin.esm.js
	const globalPlugin = (element) => {
		switch (element.type) {
			case RULESET:
				if (typeof element.props === "string") throw new Error(`"element.props" has type "string" (${JSON.stringify(element.props, null, 2)}), it's not expected. Please report a bug if it happens.`);
				element.props = element.props.map((value) => {
					if (value.indexOf(":global(") === -1) return value;
					return tokenize(value).reduce((acc, value$1, index, children) => {
						if (value$1 === "") return acc;
						if (value$1 === ":" && children[index + 1] === "global") {
							const selector = children[index + 2].slice(1, -1) + " ";
							acc.unshift(selector);
							children[index + 1] = "";
							children[index + 2] = "";
							return acc;
						}
						acc.push(value$1);
						return acc;
					}, []).join("");
				});
		}
	};

//#endregion
//#region node_modules/@griffel/core/runtime/stylis/prefixerPlugin.esm.js
	function prefix(value, length$1, children) {
		switch (hash(value, length$1)) {
			case 5103: return WEBKIT + "print-" + value + value;
			case 3191:
			case 6645:
			case 3005:
			case 6391:
			case 5879:
			case 5623:
			case 6135:
			case 4599:
			case 4855: return WEBKIT + value + value;
			case 4215:
				if (charat(value, 9) === 102) return WEBKIT + value + value;
				if (charat(value, length$1 + 1) === 116) return WEBKIT + value + value;
				break;
			case 4789: return MOZ + value + value;
			case 5349:
			case 4246:
			case 6968: return WEBKIT + value + MOZ + value + value;
			case 6187: if (!match(value, /grab/)) return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
			case 5495:
			case 3959: return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
			case 4095:
			case 3583:
			case 4068:
			case 2532: return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
			case 8116:
			case 7059:
			case 5753:
			case 5535:
			case 5445:
			case 5701:
			case 4933:
			case 4677:
			case 5533:
			case 5789:
			case 5021:
			case 4765:
				if (strlen(value) - 1 - length$1 > 6) switch (charat(value, length$1 + 1)) {
					case 102: if (charat(value, length$1 + 3) === 108) return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length$1 + 3) == 108 ? "$3" : "$2-$3")) + value;
					case 115: return ~indexof(value, "stretch") ? prefix(replace(value, "stretch", "fill-available"), length$1) + value : value;
				}
				break;
		}
		return value;
	}
	/**
	* @param {object} element
	* @param {number} index
	* @param {object[]} children
	* @param {function} callback
	*/
	function prefixerPlugin(element, index, children, callback) {
		if (element.length > -1) {
			if (!element.return) switch (element.type) {
				case DECLARATION:
					element.return = prefix(element.value, element.length);
					return;
				case RULESET: if (element.length) return combine(element.props, function(value) {
					switch (match(value, /(::plac\w+|:read-\w+)/)) {
						case ":read-only":
						case ":read-write": return serialize$1([copy(element, { props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")] })], callback);
						case "::placeholder": return serialize$1([copy(element, { props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")] }), copy(element, { props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")] })], callback);
					}
					return "";
				});
			}
		}
	}

//#endregion
//#region node_modules/@griffel/core/runtime/stylis/isAtRuleElement.esm.js
	function isAtRuleElement(element) {
		switch (element.type) {
			case "@container":
			case MEDIA:
			case SUPPORTS:
			case LAYER: return true;
		}
		return false;
	}

//#endregion
//#region node_modules/@griffel/core/runtime/stylis/sortClassesInAtRulesPlugin.esm.js
	const sortClassesInAtRulesPlugin = (element) => {
		if (isAtRuleElement(element) && Array.isArray(element.children)) element.children.sort((a, b) => a.props[0] > b.props[0] ? 1 : -1);
	};

//#endregion
//#region node_modules/@griffel/core/runtime/compileCSSRules.esm.js
	function noop$11() {}
	function compileCSSRules(cssRules$1, sortClassesInAtRules) {
		const rules = [];
		serialize$1(compile(cssRules$1), middleware([
			globalPlugin,
			sortClassesInAtRules ? sortClassesInAtRulesPlugin : noop$11,
			prefixerPlugin,
			stringify,
			rulesheet((rule) => rules.push(rule))
		]));
		return rules;
	}

//#endregion
//#region node_modules/@griffel/core/runtime/compileAtomicCSSRule.esm.js
	const PSEUDO_SELECTOR_REGEX = /,( *[^ &])/g;
	/**
	* Normalizes pseudo selectors to always contain &, requires to work properly with comma-separated selectors.
	*
	* @example
	*   ":hover" => "&:hover"
	*   " :hover" => "& :hover"
	*   ":hover,:focus" => "&:hover,&:focus"
	*   " :hover, :focus" => "& :hover,& :focus"
	*/
	function normalizePseudoSelector(pseudoSelector) {
		return "&" + normalizeNestedProperty(pseudoSelector.replace(PSEUDO_SELECTOR_REGEX, ",&$1"));
	}
	function createCSSRule(classNameSelector, cssDeclaration, pseudos) {
		let cssRule = cssDeclaration;
		if (pseudos.length > 0) cssRule = pseudos.reduceRight((acc, selector) => {
			return `${normalizePseudoSelector(selector)} { ${acc} }`;
		}, cssDeclaration);
		return `${classNameSelector}{${cssRule}}`;
	}
	function compileAtomicCSSRule(options, atRules) {
		const { className, selectors, property, rtlClassName, rtlProperty, rtlValue, value } = options;
		const { container, layer, media, supports } = atRules;
		let cssRule = createCSSRule(`.${className}`, Array.isArray(value) ? `${value.map((v) => `${hyphenateProperty(property)}: ${v}`).join(";")};` : `${hyphenateProperty(property)}: ${value};`, selectors);
		if (rtlProperty && rtlClassName) {
			const rtlClassNameSelector = `.${rtlClassName}`;
			const rtlCSSDeclaration = Array.isArray(rtlValue) ? `${rtlValue.map((v) => `${hyphenateProperty(rtlProperty)}: ${v}`).join(";")};` : `${hyphenateProperty(rtlProperty)}: ${rtlValue};`;
			cssRule += createCSSRule(rtlClassNameSelector, rtlCSSDeclaration, selectors);
		}
		if (media) cssRule = `@media ${media} { ${cssRule} }`;
		if (layer) cssRule = `@layer ${layer} { ${cssRule} }`;
		if (supports) cssRule = `@supports ${supports} { ${cssRule} }`;
		if (container) cssRule = `@container ${container} { ${cssRule} }`;
		return compileCSSRules(cssRule, true);
	}

//#endregion
//#region node_modules/@griffel/core/runtime/utils/cssifyObject.esm.js
	function cssifyObject(style) {
		let css = "";
		for (const property in style) {
			const value = style[property];
			if (typeof value === "string" || typeof value === "number") {
				css += hyphenateProperty(property) + ":" + value + ";";
				continue;
			}
			if (Array.isArray(value)) for (const arrValue of value) css += hyphenateProperty(property) + ":" + arrValue + ";";
		}
		return css;
	}

//#endregion
//#region node_modules/@griffel/core/runtime/compileKeyframeCSS.esm.js
	function compileKeyframeRule(keyframeObject) {
		let css = "";
		for (const percentage in keyframeObject) css += `${percentage}{${cssifyObject(keyframeObject[percentage])}}`;
		return css;
	}
	/**
	* Creates CSS rules for insertion from passed CSS.
	*/
	function compileKeyframesCSS(keyframeName, keyframeCSS) {
		const cssRule = `@keyframes ${keyframeName} {${keyframeCSS}}`;
		const rules = [];
		serialize$1(compile(cssRule), middleware([
			stringify,
			prefixerPlugin,
			rulesheet((rule) => rules.push(rule))
		]));
		return rules;
	}

//#endregion
//#region node_modules/@griffel/core/runtime/shorthands.esm.js
	const shorthands$1 = {
		animation: [-1, [
			"animationDelay",
			"animationDirection",
			"animationDuration",
			"animationFillMode",
			"animationIterationCount",
			"animationName",
			"animationPlayState",
			"animationTimeline",
			"animationTimingFunction"
		]],
		animationRange: [-1, ["animationRangeEnd", "animationRangeStart"]],
		background: [-2, [
			"backgroundAttachment",
			"backgroundClip",
			"backgroundColor",
			"backgroundImage",
			"backgroundOrigin",
			"backgroundPosition",
			"backgroundPositionX",
			"backgroundPositionY",
			"backgroundRepeat",
			"backgroundSize"
		]],
		backgroundPosition: [-1, ["backgroundPositionX", "backgroundPositionY"]],
		border: [-2, [
			"borderBottom",
			"borderBottomColor",
			"borderBottomStyle",
			"borderBottomWidth",
			"borderLeft",
			"borderLeftColor",
			"borderLeftStyle",
			"borderLeftWidth",
			"borderRight",
			"borderRightColor",
			"borderRightStyle",
			"borderRightWidth",
			"borderTop",
			"borderTopColor",
			"borderTopStyle",
			"borderTopWidth"
		]],
		borderBottom: [-1, [
			"borderBottomColor",
			"borderBottomStyle",
			"borderBottomWidth"
		]],
		borderImage: [-1, [
			"borderImageOutset",
			"borderImageRepeat",
			"borderImageSlice",
			"borderImageSource",
			"borderImageWidth"
		]],
		borderLeft: [-1, [
			"borderLeftColor",
			"borderLeftStyle",
			"borderLeftWidth"
		]],
		borderRadius: [-1, [
			"borderBottomLeftRadius",
			"borderBottomRightRadius",
			"borderTopLeftRadius",
			"borderTopRightRadius"
		]],
		borderRight: [-1, [
			"borderRightColor",
			"borderRightStyle",
			"borderRightWidth"
		]],
		borderTop: [-1, [
			"borderTopColor",
			"borderTopStyle",
			"borderTopWidth"
		]],
		caret: [-1, ["caretColor", "caretShape"]],
		columnRule: [-1, [
			"columnRuleColor",
			"columnRuleStyle",
			"columnRuleWidth"
		]],
		columns: [-1, ["columnCount", "columnWidth"]],
		containIntrinsicSize: [-1, ["containIntrinsicHeight", "containIntrinsicWidth"]],
		container: [-1, ["containerName", "containerType"]],
		flex: [-1, [
			"flexBasis",
			"flexGrow",
			"flexShrink"
		]],
		flexFlow: [-1, ["flexDirection", "flexWrap"]],
		font: [-1, [
			"fontFamily",
			"fontSize",
			"fontStretch",
			"fontStyle",
			"fontVariant",
			"fontWeight",
			"lineHeight"
		]],
		gap: [-1, ["columnGap", "rowGap"]],
		grid: [-1, [
			"columnGap",
			"gridAutoColumns",
			"gridAutoFlow",
			"gridAutoRows",
			"gridColumnGap",
			"gridRowGap",
			"gridTemplateAreas",
			"gridTemplateColumns",
			"gridTemplateRows",
			"rowGap"
		]],
		gridArea: [-1, [
			"gridColumnEnd",
			"gridColumnStart",
			"gridRowEnd",
			"gridRowStart"
		]],
		gridColumn: [-1, ["gridColumnEnd", "gridColumnStart"]],
		gridRow: [-1, ["gridRowEnd", "gridRowStart"]],
		gridTemplate: [-1, [
			"gridTemplateAreas",
			"gridTemplateColumns",
			"gridTemplateRows"
		]],
		inset: [-1, [
			"bottom",
			"left",
			"right",
			"top"
		]],
		insetBlock: [-1, ["insetBlockEnd", "insetBlockStart"]],
		insetInline: [-1, ["insetInlineEnd", "insetInlineStart"]],
		listStyle: [-1, [
			"listStyleImage",
			"listStylePosition",
			"listStyleType"
		]],
		margin: [-1, [
			"marginBottom",
			"marginLeft",
			"marginRight",
			"marginTop"
		]],
		marginBlock: [-1, ["marginBlockEnd", "marginBlockStart"]],
		marginInline: [-1, ["marginInlineEnd", "marginInlineStart"]],
		mask: [-1, [
			"maskClip",
			"maskComposite",
			"maskImage",
			"maskMode",
			"maskOrigin",
			"maskPosition",
			"maskRepeat",
			"maskSize"
		]],
		maskBorder: [-1, [
			"maskBorderMode",
			"maskBorderOutset",
			"maskBorderRepeat",
			"maskBorderSlice",
			"maskBorderSource",
			"maskBorderWidth"
		]],
		offset: [-1, [
			"offsetAnchor",
			"offsetDistance",
			"offsetPath",
			"offsetPosition",
			"offsetRotate"
		]],
		outline: [-1, [
			"outlineColor",
			"outlineStyle",
			"outlineWidth"
		]],
		overflow: [-1, ["overflowX", "overflowY"]],
		overscrollBehavior: [-1, ["overscrollBehaviorX", "overscrollBehaviorY"]],
		padding: [-1, [
			"paddingBottom",
			"paddingLeft",
			"paddingRight",
			"paddingTop"
		]],
		paddingBlock: [-1, ["paddingBlockEnd", "paddingBlockStart"]],
		paddingInline: [-1, ["paddingInlineEnd", "paddingInlineStart"]],
		placeContent: [-1, ["alignContent", "justifyContent"]],
		placeItems: [-1, ["alignItems", "justifyItems"]],
		placeSelf: [-1, ["alignSelf", "justifySelf"]],
		scrollMargin: [-1, [
			"scrollMarginBottom",
			"scrollMarginLeft",
			"scrollMarginRight",
			"scrollMarginTop"
		]],
		scrollMarginBlock: [-1, ["scrollMarginBlockEnd", "scrollMarginBlockStart"]],
		scrollMarginInline: [-1, ["scrollMarginInlineEnd", "scrollMarginInlineStart"]],
		scrollPadding: [-1, [
			"scrollPaddingBottom",
			"scrollPaddingLeft",
			"scrollPaddingRight",
			"scrollPaddingTop"
		]],
		scrollPaddingBlock: [-1, ["scrollPaddingBlockEnd", "scrollPaddingBlockStart"]],
		scrollPaddingInline: [-1, ["scrollPaddingInlineEnd", "scrollPaddingInlineStart"]],
		scrollTimeline: [-1, ["scrollTimelineAxis", "scrollTimelineName"]],
		textDecoration: [-1, [
			"textDecorationColor",
			"textDecorationLine",
			"textDecorationStyle",
			"textDecorationThickness"
		]],
		textEmphasis: [-1, ["textEmphasisColor", "textEmphasisStyle"]],
		transition: [-1, [
			"transitionBehavior",
			"transitionDelay",
			"transitionDuration",
			"transitionProperty",
			"transitionTimingFunction"
		]],
		viewTimeline: [-1, ["viewTimelineAxis", "viewTimelineName"]]
	};

//#endregion
//#region node_modules/@griffel/core/runtime/utils/generateCombinedMediaQuery.esm.js
	function generateCombinedQuery(currentMediaQuery, nestedMediaQuery) {
		if (currentMediaQuery.length === 0) return nestedMediaQuery;
		return `${currentMediaQuery} and ${nestedMediaQuery}`;
	}

//#endregion
//#region node_modules/@griffel/core/runtime/utils/isMediaQuerySelector.esm.js
	function isMediaQuerySelector(property) {
		return property.substr(0, 6) === "@media";
	}

//#endregion
//#region node_modules/@griffel/core/runtime/utils/isLayerSelector.esm.js
	function isLayerSelector(property) {
		return property.substr(0, 6) === "@layer";
	}

//#endregion
//#region node_modules/@griffel/core/runtime/utils/isNestedSelector.esm.js
	const regex = /^(:|\[|>|&)/;
	function isNestedSelector(property) {
		return regex.test(property);
	}

//#endregion
//#region node_modules/@griffel/core/runtime/utils/isSupportQuerySelector.esm.js
	function isSupportQuerySelector(property) {
		return property.substr(0, 9) === "@supports";
	}

//#endregion
//#region node_modules/@griffel/core/runtime/utils/isContainerQuerySelector.esm.js
	function isContainerQuerySelector(property) {
		return property.substring(0, 10) === "@container";
	}

//#endregion
//#region node_modules/@griffel/core/runtime/utils/isObject.esm.js
	function isObject$1(val) {
		return val != null && typeof val === "object" && Array.isArray(val) === false;
	}

//#endregion
//#region node_modules/@griffel/core/runtime/getStyleBucketName.esm.js
/**
	* Maps the long pseudo name to the short pseudo name. Pseudos that match here will be ordered, everything else will
	* make their way to default style bucket. We reduce the pseudo name to save bundlesize.
	* Thankfully there aren't any overlaps, see: https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes.
	*/
	const pseudosMap = {
		"us-w": "w",
		"us-v": "i",
		nk: "l",
		si: "v",
		cu: "f",
		ve: "h",
		ti: "a"
	};
	/**
	* Gets the bucket depending on the pseudo.
	*
	* Input:
	*
	* ```
	* ":hover"
	* ":focus:hover"
	* ```
	*
	* Output:
	*
	* ```
	* "h"
	* "f"
	* ```
	*
	* @internal
	*/
	function getStyleBucketName(selectors, atRules) {
		if (atRules.media) return "m";
		if (atRules.layer || atRules.supports) return "t";
		if (atRules.container) return "c";
		if (selectors.length > 0) {
			const normalizedPseudo = selectors[0].trim();
			if (normalizedPseudo.charCodeAt(0) === 58) return pseudosMap[normalizedPseudo.slice(4, 8)] || pseudosMap[normalizedPseudo.slice(3, 5)] || "d";
		}
		return "d";
	}

//#endregion
//#region node_modules/@griffel/core/runtime/utils/hashPropertyKey.esm.js
	function addAtRulePrefix(atRule, prefix$1) {
		return atRule ? prefix$1 + atRule : atRule;
	}
	function atRulesToString(atRules) {
		return addAtRulePrefix(atRules.container, "c") + addAtRulePrefix(atRules.media, "m") + addAtRulePrefix(atRules.layer, "l") + addAtRulePrefix(atRules.supports, "s");
	}
	function hashPropertyKey(selector, property, atRules) {
		const hashedKey = murmur2(selector + atRulesToString(atRules) + property);
		const firstCharCode = hashedKey.charCodeAt(0);
		if (firstCharCode >= 48 && firstCharCode <= 57) return String.fromCharCode(firstCharCode + 17) + hashedKey.slice(1);
		return hashedKey;
	}

//#endregion
//#region node_modules/@griffel/core/runtime/utils/hashClassName.esm.js
	function hashClassName({ property, selector, salt, value }, atRules) {
		return HASH_PREFIX + murmur2(salt + selector + atRulesToString(atRules) + property + value.trim());
	}

//#endregion
//#region node_modules/@griffel/core/runtime/utils/isResetValue.esm.js
	function isResetValue(value) {
		return value === RESET;
	}

//#endregion
//#region node_modules/@griffel/core/runtime/utils/trimSelector.esm.js
/**
	* Trims selectors to generate consistent hashes.
	*/
	function trimSelector(selector) {
		return selector.replace(/>\s+/g, ">");
	}

//#endregion
//#region node_modules/@griffel/core/runtime/warnings/logError.esm.js
	function logError(...args) {
		if (typeof document !== "undefined") console.error(...args);
	}

//#endregion
//#region node_modules/@griffel/core/runtime/warnings/warnAboutUnresolvedRule.esm.js
	function warnAboutUnresolvedRule(property, value) {
		logError(/* @__PURE__ */ (() => {
			const ruleText = JSON.stringify(value, null, 2);
			const message = [
				"@griffel/react: A rule was not resolved to CSS properly. Please check your `makeStyles` or `makeResetStyles` calls for following:",
				" ".repeat(2) + "makeStyles({",
				" ".repeat(4) + `[slot]: {`,
				" ".repeat(6) + `"${property}": ${ruleText.split("\n").map((l, n) => " ".repeat(n === 0 ? 0 : 6) + l).join("\n")}`,
				" ".repeat(4) + "}",
				" ".repeat(2) + `})`,
				""
			];
			if (property.indexOf("&") === -1) {
				message.push(`It looks that you're are using a nested selector, but it is missing an ampersand placeholder where the generated class name should be injected.`);
				message.push(`Try to update a property to include it i.e "${property}" => "&${property}".`);
			} else {
				message.push("");
				message.push("If it's not obvious what triggers a problem, please report an issue at https://github.com/microsoft/griffel/issues");
			}
			return message.join("\n");
		})());
	}

//#endregion
//#region node_modules/@griffel/core/runtime/warnings/warnAboutUnsupportedProperties.esm.js
	function warnAboutUnsupportedProperties(property, value) {
		logError(/* @__PURE__ */ (() => [
			`@griffel/react: You are using unsupported shorthand CSS property "${property}". Please check your "makeStyles" calls, there *should not* be following:`,
			" ".repeat(2) + `makeStyles({`,
			" ".repeat(4) + `[slot]: { ${property}: "${value}" }`,
			" ".repeat(2) + `})`,
			"",
			"Learn why CSS shorthands are not supported: https://aka.ms/griffel-css-shorthands"
		].join("\n"))());
	}

//#endregion
//#region node_modules/@griffel/core/runtime/resolveStyleRules.esm.js
	function getShorthandDefinition(property) {
		return shorthands$1[property];
	}
	function computePropertyPriority(shorthand) {
		var _a;
		return (_a = shorthand === null || shorthand === void 0 ? void 0 : shorthand[0]) !== null && _a !== void 0 ? _a : 0;
	}
	function pushToClassesMap(classesMap, propertyKey, ltrClassname, rtlClassname) {
		classesMap[propertyKey] = rtlClassname ? [ltrClassname, rtlClassname] : ltrClassname;
	}
	function createBucketEntry(cssRule, metadata) {
		if (metadata.length > 0) return [cssRule, Object.fromEntries(metadata)];
		return cssRule;
	}
	function pushToCSSRules(cssRulesByBucket, styleBucketName, ltrCSS, rtlCSS, media, priority) {
		var _a;
		const metadata = [];
		if (priority !== 0) metadata.push(["p", priority]);
		if (styleBucketName === "m" && media) metadata.push(["m", media]);
		(_a = cssRulesByBucket[styleBucketName]) !== null && _a !== void 0 || (cssRulesByBucket[styleBucketName] = []);
		if (ltrCSS) cssRulesByBucket[styleBucketName].push(createBucketEntry(ltrCSS, metadata));
		if (rtlCSS) cssRulesByBucket[styleBucketName].push(createBucketEntry(rtlCSS, metadata));
	}
	/**
	* Transforms input styles to classes maps & CSS rules.
	*
	* @internal
	*/
	function resolveStyleRules(styles, classNameHashSalt = "", selectors = [], atRules = {
		container: "",
		layer: "",
		media: "",
		supports: ""
	}, cssClassesMap = {}, cssRulesByBucket = {}, rtlValue) {
		for (const property in styles) {
			if (UNSUPPORTED_CSS_PROPERTIES.hasOwnProperty(property)) {
				warnAboutUnsupportedProperties(property, styles[property]);
				continue;
			}
			const value = styles[property];
			if (value == null) continue;
			if (isResetValue(value)) {
				pushToClassesMap(cssClassesMap, hashPropertyKey(trimSelector(selectors.join("")), property, atRules), 0, void 0);
				continue;
			}
			if (typeof value === "string" || typeof value === "number") {
				const selector = trimSelector(selectors.join(""));
				const shorthand = getShorthandDefinition(property);
				if (shorthand) {
					const shorthandProperties = shorthand[1];
					resolveStyleRules(Object.fromEntries(shorthandProperties.map((property$1) => [property$1, RESET])), classNameHashSalt, selectors, atRules, cssClassesMap, cssRulesByBucket);
				}
				const key = hashPropertyKey(selector, property, atRules);
				const className = hashClassName({
					value: value.toString(),
					salt: classNameHashSalt,
					selector,
					property
				}, atRules);
				const rtlDefinition = rtlValue && {
					key: property,
					value: rtlValue
				} || convertProperty(property, value);
				const flippedInRtl = rtlDefinition.key !== property || rtlDefinition.value !== value;
				const rtlClassName = flippedInRtl ? hashClassName({
					value: rtlDefinition.value.toString(),
					property: rtlDefinition.key,
					salt: classNameHashSalt,
					selector
				}, atRules) : void 0;
				const rtlCompileOptions = flippedInRtl ? {
					rtlClassName,
					rtlProperty: rtlDefinition.key,
					rtlValue: rtlDefinition.value
				} : void 0;
				const styleBucketName = getStyleBucketName(selectors, atRules);
				const [ltrCSS, rtlCSS] = compileAtomicCSSRule(Object.assign({
					className,
					selectors,
					property,
					value
				}, rtlCompileOptions), atRules);
				pushToClassesMap(cssClassesMap, key, className, rtlClassName);
				pushToCSSRules(cssRulesByBucket, styleBucketName, ltrCSS, rtlCSS, atRules.media, computePropertyPriority(shorthand));
			} else if (property === "animationName") {
				const animationNameValue = Array.isArray(value) ? value : [value];
				const animationNames = [];
				const rtlAnimationNames = [];
				for (const keyframeObject of animationNameValue) {
					const keyframeCSS = compileKeyframeRule(keyframeObject);
					const rtlKeyframeCSS = compileKeyframeRule(convert(keyframeObject));
					const animationName = HASH_PREFIX + murmur2(keyframeCSS);
					let rtlAnimationName;
					const keyframeRules = compileKeyframesCSS(animationName, keyframeCSS);
					let rtlKeyframeRules = [];
					if (keyframeCSS === rtlKeyframeCSS) rtlAnimationName = animationName;
					else {
						rtlAnimationName = HASH_PREFIX + murmur2(rtlKeyframeCSS);
						rtlKeyframeRules = compileKeyframesCSS(rtlAnimationName, rtlKeyframeCSS);
					}
					for (let i = 0; i < keyframeRules.length; i++) pushToCSSRules(cssRulesByBucket, "k", keyframeRules[i], rtlKeyframeRules[i], atRules.media, 0);
					animationNames.push(animationName);
					rtlAnimationNames.push(rtlAnimationName);
				}
				resolveStyleRules({ animationName: animationNames.join(", ") }, classNameHashSalt, selectors, atRules, cssClassesMap, cssRulesByBucket, rtlAnimationNames.join(", "));
			} else if (Array.isArray(value)) {
				if (value.length === 0) {
					console.warn(`makeStyles(): An empty array was passed as input to "${property}", the property will be omitted in the styles.`);
					continue;
				}
				const selector = trimSelector(selectors.join(""));
				const shorthand = getShorthandDefinition(property);
				if (shorthand) {
					const shorthandProperties = shorthand[1];
					resolveStyleRules(Object.fromEntries(shorthandProperties.map((property$1) => [property$1, RESET])), classNameHashSalt, selectors, atRules, cssClassesMap, cssRulesByBucket);
				}
				const key = hashPropertyKey(selector, property, atRules);
				const className = hashClassName({
					value: value.map((v) => (v !== null && v !== void 0 ? v : "").toString()).join(";"),
					salt: classNameHashSalt,
					selector,
					property
				}, atRules);
				const rtlDefinitions = value.map((v) => convertProperty(property, v));
				if (!!rtlDefinitions.some((v) => v.key !== rtlDefinitions[0].key)) {
					console.error("makeStyles(): mixing CSS fallback values which result in multiple CSS properties in RTL is not supported.");
					continue;
				}
				const flippedInRtl = rtlDefinitions[0].key !== property || rtlDefinitions.some((v, i) => v.value !== value[i]);
				const rtlClassName = flippedInRtl ? hashClassName({
					value: rtlDefinitions.map((v) => {
						var _a;
						return ((_a = v === null || v === void 0 ? void 0 : v.value) !== null && _a !== void 0 ? _a : "").toString();
					}).join(";"),
					salt: classNameHashSalt,
					property: rtlDefinitions[0].key,
					selector
				}, atRules) : void 0;
				const rtlCompileOptions = flippedInRtl ? {
					rtlClassName,
					rtlProperty: rtlDefinitions[0].key,
					rtlValue: rtlDefinitions.map((d) => d.value)
				} : void 0;
				const styleBucketName = getStyleBucketName(selectors, atRules);
				const [ltrCSS, rtlCSS] = compileAtomicCSSRule(Object.assign({
					className,
					selectors,
					property,
					value
				}, rtlCompileOptions), atRules);
				pushToClassesMap(cssClassesMap, key, className, rtlClassName);
				pushToCSSRules(cssRulesByBucket, styleBucketName, ltrCSS, rtlCSS, atRules.media, computePropertyPriority(shorthand));
			} else if (isObject$1(value)) if (isNestedSelector(property)) resolveStyleRules(value, classNameHashSalt, selectors.concat(normalizeNestedProperty(property)), atRules, cssClassesMap, cssRulesByBucket);
			else if (isMediaQuerySelector(property)) {
				const combinedMediaQuery = generateCombinedQuery(atRules.media, property.slice(6).trim());
				resolveStyleRules(value, classNameHashSalt, selectors, Object.assign({}, atRules, { media: combinedMediaQuery }), cssClassesMap, cssRulesByBucket);
			} else if (isLayerSelector(property)) {
				const combinedLayerQuery = (atRules.layer ? `${atRules.layer}.` : "") + property.slice(6).trim();
				resolveStyleRules(value, classNameHashSalt, selectors, Object.assign({}, atRules, { layer: combinedLayerQuery }), cssClassesMap, cssRulesByBucket);
			} else if (isSupportQuerySelector(property)) {
				const combinedSupportQuery = generateCombinedQuery(atRules.supports, property.slice(9).trim());
				resolveStyleRules(value, classNameHashSalt, selectors, Object.assign({}, atRules, { supports: combinedSupportQuery }), cssClassesMap, cssRulesByBucket);
			} else if (isContainerQuerySelector(property)) {
				const containerQuery = property.slice(10).trim();
				resolveStyleRules(value, classNameHashSalt, selectors, Object.assign({}, atRules, { container: containerQuery }), cssClassesMap, cssRulesByBucket);
			} else warnAboutUnresolvedRule(property, value);
		}
		return [cssClassesMap, cssRulesByBucket];
	}

//#endregion
//#region node_modules/@griffel/core/resolveStyleRulesForSlots.esm.js
/**
	* Calls resolveStyleRules() for each slot, is also used by build time transform.
	*
	* @param stylesBySlots - An object with makeStyles rules where a key is a slot name
	* @param classNameHashSalt - A salt for classes hash
	*
	* @return - A tuple with an object classnames mapping where a key is a slot name and an array with CSS rules
	*/
	function resolveStyleRulesForSlots(stylesBySlots, classNameHashSalt = "") {
		const classesMapBySlot = {};
		const cssRules$1 = {};
		for (const slotName in stylesBySlots) {
			const slotStyles = stylesBySlots[slotName];
			const [cssClassMap, cssRulesByBucket] = resolveStyleRules(slotStyles, classNameHashSalt);
			classesMapBySlot[slotName] = cssClassMap;
			Object.keys(cssRulesByBucket).forEach((styleBucketName) => {
				cssRules$1[styleBucketName] = (cssRules$1[styleBucketName] || []).concat(cssRulesByBucket[styleBucketName]);
			});
		}
		return [classesMapBySlot, cssRules$1];
	}

//#endregion
//#region node_modules/@griffel/core/makeStyles.esm.js
	function makeStyles$1(stylesBySlots, factory = insertionFactory$1) {
		const insertStyles = factory();
		let classesMapBySlot = null;
		let cssRules$1 = null;
		let ltrClassNamesForSlots = null;
		let rtlClassNamesForSlots = null;
		let sourceURL;
		if (isDevToolsEnabled) sourceURL = getSourceURLfromError();
		let classNameHashSalt;
		function computeClasses(options) {
			const { dir, renderer } = options;
			if (classesMapBySlot === null) {
				[classesMapBySlot, cssRules$1] = resolveStyleRulesForSlots(stylesBySlots, renderer.classNameHashSalt);
				if (renderer.classNameHashSalt) {
					if (classNameHashSalt !== renderer.classNameHashSalt) console.error([
						"@griffel/core:",
						"\n\n",
						"A provided renderer has different \"classNameHashSalt\".",
						"This is not supported and WILL cause issues with classnames generation.",
						"Ensure that all renderers created with \"createDOMRenderer()\" have the same \"classNameHashSalt\"."
					].join(" "));
					classNameHashSalt = renderer.classNameHashSalt;
				}
			}
			const isLTR = dir === "ltr";
			if (isLTR) {
				if (ltrClassNamesForSlots === null) ltrClassNamesForSlots = reduceToClassNameForSlots(classesMapBySlot, dir);
			} else if (rtlClassNamesForSlots === null) rtlClassNamesForSlots = reduceToClassNameForSlots(classesMapBySlot, dir);
			insertStyles(renderer, cssRules$1);
			const classNamesForSlots = isLTR ? ltrClassNamesForSlots : rtlClassNamesForSlots;
			if (isDevToolsEnabled) debugData.addSequenceDetails(classNamesForSlots, sourceURL);
			return classNamesForSlots;
		}
		return computeClasses;
	}

//#endregion
//#region node_modules/@griffel/core/runtime/compileStaticCSS.esm.js
	function compileStaticCSS(property, value) {
		return compileCSSRules(`${property} {${cssifyObject(value)}}`, false)[0];
	}

//#endregion
//#region node_modules/@griffel/core/runtime/resolveStaticStyleRules.esm.js
	function resolveStaticStyleRules(stylesSet) {
		return stylesSet.reduce((acc, styles) => {
			if (typeof styles === "string") {
				const cssRules$1 = compileCSSRules(styles, false);
				for (const rule of cssRules$1) acc.push(rule);
				return acc;
			}
			for (const property in styles) {
				const value = styles[property];
				const staticCSS = compileStaticCSS(property, value);
				acc.push(staticCSS);
			}
			return acc;
		}, []);
	}

//#endregion
//#region node_modules/@griffel/core/makeStaticStyles.esm.js
	function makeStaticStyles$1(styles, factory = insertionFactory$1) {
		const insertStyles = factory();
		const stylesSet = Array.isArray(styles) ? styles : [styles];
		function useStaticStyles(options) {
			insertStyles(options.renderer, { d: resolveStaticStyleRules(stylesSet) });
		}
		return useStaticStyles;
	}

//#endregion
//#region node_modules/@griffel/core/runtime/stylis/rulesheetPlugin.esm.js
/**
	* The same plugin as in stylis, but this version also has "element" argument.
	*/
	function rulesheetPlugin(callback) {
		return function(element) {
			if (!element.root) {
				if (element.return) callback(element, element.return);
			}
		};
	}

//#endregion
//#region node_modules/@griffel/core/runtime/compileResetCSSRules.esm.js
	function compileResetCSSRules(cssRules$1) {
		const rules = [];
		const atRules = [];
		serialize$1(compile(cssRules$1), middleware([
			globalPlugin,
			prefixerPlugin,
			stringify,
			rulesheetPlugin((element, rule) => {
				if (isAtRuleElement(element)) {
					atRules.push(rule);
					return;
				}
				rules.push(rule);
			})
		]));
		return [rules, atRules];
	}

//#endregion
//#region node_modules/@griffel/core/runtime/resolveResetStyleRules.esm.js
/**
	* @internal
	*/
	function createStringFromStyles(styles) {
		let ltrCSS = "";
		let rtlCSS = "";
		for (const property in styles) {
			const value = styles[property];
			if (value == null) continue;
			if (typeof value === "string" || typeof value === "number") {
				const { key: rtlProperty, value: rtlValue } = convertProperty(property, value);
				ltrCSS += `${hyphenateProperty(property)}:${value};`;
				rtlCSS += `${hyphenateProperty(rtlProperty)}:${rtlValue};`;
				continue;
			}
			if (property === "animationName" && typeof value === "object") {
				const values = Array.isArray(value) ? value : [value];
				const ltrAnimationNames = [];
				const rtlAnimationNames = [];
				for (const keyframeObject of values) {
					const ltrKeyframeRule = compileKeyframeRule(keyframeObject);
					const rtlKeyframeRule = compileKeyframeRule(convert(keyframeObject));
					const ltrAnimationName = RESET_HASH_PREFIX + murmur2(ltrKeyframeRule);
					const rtlAnimationName = RESET_HASH_PREFIX + murmur2(rtlKeyframeRule);
					ltrAnimationNames.push(ltrAnimationName);
					rtlAnimationNames.push(rtlAnimationName);
					ltrCSS += compileKeyframesCSS(ltrAnimationName, ltrKeyframeRule).join("");
					if (ltrAnimationName !== rtlAnimationName) rtlCSS += compileKeyframesCSS(rtlAnimationName, rtlKeyframeRule).join("");
				}
				ltrCSS += `animation-name:${ltrAnimationNames.join(",")};`;
				rtlCSS += `animation-name:${rtlAnimationNames.join(",")};`;
				continue;
			}
			if (Array.isArray(value)) {
				if (value.length === 0) {
					console.warn(`makeResetStyles(): An empty array was passed as input to "${property}", the property will be omitted in the styles.`);
					continue;
				}
				const rtlDefinitions = value.map((v) => convertProperty(property, v));
				if (!!rtlDefinitions.some((v) => v.key !== rtlDefinitions[0].key)) {
					console.error("makeStyles(): mixing CSS fallback values which result in multiple CSS properties in RTL is not supported.");
					continue;
				}
				const rtlProperty = rtlDefinitions[0].key;
				ltrCSS += value.map((v) => `${hyphenateProperty(property)}:${v};`).join("");
				rtlCSS += rtlDefinitions.map((definition) => `${hyphenateProperty(rtlProperty)}:${definition.value};`).join("");
				continue;
			}
			if (isObject$1(value)) {
				if (isNestedSelector(property)) {
					const nestedSelector = normalizePseudoSelector(property);
					const [ltrNested, rtlNested] = createStringFromStyles(value);
					ltrCSS += `${nestedSelector}{${ltrNested}}`;
					rtlCSS += `${nestedSelector}{${rtlNested}}`;
					continue;
				}
				if (isMediaQuerySelector(property) || isLayerSelector(property) || isSupportQuerySelector(property) || isContainerQuerySelector(property)) {
					const [ltrNested, rtlNested] = createStringFromStyles(value);
					ltrCSS += `${property}{${ltrNested}}`;
					rtlCSS += `${property}{${rtlNested}}`;
					continue;
				}
			}
			warnAboutUnresolvedRule(property, value);
		}
		return [ltrCSS, rtlCSS];
	}
	/**
	* @internal
	*/
	function resolveResetStyleRules(styles, classNameHashSalt = "") {
		const [ltrRule, rtlRule] = createStringFromStyles(styles);
		const ltrClassName = RESET_HASH_PREFIX + murmur2(classNameHashSalt + ltrRule);
		const [ltrCSS, ltrCSSAtRules] = compileResetCSSRules(`.${ltrClassName}{${ltrRule}}`);
		const hasAtRules = ltrCSSAtRules.length > 0;
		if (ltrRule === rtlRule) return [
			ltrClassName,
			null,
			hasAtRules ? {
				r: ltrCSS,
				s: ltrCSSAtRules
			} : ltrCSS
		];
		const rtlClassName = RESET_HASH_PREFIX + murmur2(classNameHashSalt + rtlRule);
		const [rtlCSS, rtlCSSAtRules] = compileResetCSSRules(`.${rtlClassName}{${rtlRule}}`);
		return [
			ltrClassName,
			rtlClassName,
			hasAtRules ? {
				r: ltrCSS.concat(rtlCSS),
				s: ltrCSSAtRules.concat(rtlCSSAtRules)
			} : ltrCSS.concat(rtlCSS)
		];
	}

//#endregion
//#region node_modules/@griffel/core/makeResetStyles.esm.js
	function makeResetStyles$1(styles, factory = insertionFactory$1) {
		const insertStyles = factory();
		let ltrClassName = null;
		let rtlClassName = null;
		let cssRules$1 = null;
		let classNameHashSalt;
		function computeClassName(options) {
			const { dir, renderer } = options;
			if (ltrClassName === null) {
				[ltrClassName, rtlClassName, cssRules$1] = resolveResetStyleRules(styles, renderer.classNameHashSalt);
				if (renderer.classNameHashSalt) {
					if (classNameHashSalt !== renderer.classNameHashSalt) console.error([
						"@griffel/core:",
						"\n\n",
						"A provided renderer has different \"classNameHashSalt\".",
						"This is not supported and WILL cause issues with classnames generation.",
						"Ensure that all renderers created with \"createDOMRenderer()\" have the same \"classNameHashSalt\"."
					].join(" "));
					classNameHashSalt = renderer.classNameHashSalt;
				}
			}
			insertStyles(renderer, Array.isArray(cssRules$1) ? { r: cssRules$1 } : cssRules$1);
			const className = dir === "ltr" ? ltrClassName : rtlClassName || ltrClassName;
			DEBUG_RESET_CLASSES[className] = 1;
			return className;
		}
		return computeClassName;
	}

//#endregion
//#region node_modules/@griffel/core/__css.esm.js
/**
	* A version of makeStyles() that accepts build output as an input and skips all runtime transforms & DOM insertion.
	*
	* @internal
	*/
	function __css$1(classesMapBySlot) {
		let ltrClassNamesForSlots = null;
		let rtlClassNamesForSlots = null;
		function computeClasses(options) {
			const { dir } = options;
			const isLTR = dir === "ltr";
			if (isLTR) {
				if (ltrClassNamesForSlots === null) ltrClassNamesForSlots = reduceToClassNameForSlots(classesMapBySlot, dir);
			} else if (rtlClassNamesForSlots === null) rtlClassNamesForSlots = reduceToClassNameForSlots(classesMapBySlot, dir);
			const classNamesForSlots = isLTR ? ltrClassNamesForSlots : rtlClassNamesForSlots;
			if (isDevToolsEnabled) debugData.addSequenceDetails(classNamesForSlots);
			return classNamesForSlots;
		}
		return computeClasses;
	}

//#endregion
//#region node_modules/@griffel/core/__styles.esm.js
/**
	* A version of makeStyles() that accepts build output as an input and skips all runtime transforms.
	*
	* @internal
	*/
	function __styles$1(classesMapBySlot, cssRules$1, factory = insertionFactory$1) {
		const insertStyles = factory();
		let ltrClassNamesForSlots = null;
		let rtlClassNamesForSlots = null;
		let sourceURL;
		if (isDevToolsEnabled) sourceURL = getSourceURLfromError();
		function computeClasses(options) {
			const { dir, renderer } = options;
			const isLTR = dir === "ltr";
			if (isLTR) {
				if (ltrClassNamesForSlots === null) ltrClassNamesForSlots = reduceToClassNameForSlots(classesMapBySlot, dir);
			} else if (rtlClassNamesForSlots === null) rtlClassNamesForSlots = reduceToClassNameForSlots(classesMapBySlot, dir);
			insertStyles(renderer, cssRules$1);
			const classNamesForSlots = isLTR ? ltrClassNamesForSlots : rtlClassNamesForSlots;
			if (isDevToolsEnabled) debugData.addSequenceDetails(classNamesForSlots, sourceURL);
			return classNamesForSlots;
		}
		return computeClasses;
	}

//#endregion
//#region node_modules/@griffel/core/__resetCSS.esm.js
/**
	* @internal
	*/
	function __resetCSS$1(ltrClassName, rtlClassName) {
		function computeClassName(options) {
			const { dir } = options;
			const className = dir === "ltr" ? ltrClassName : rtlClassName || ltrClassName;
			DEBUG_RESET_CLASSES[className] = 1;
			return className;
		}
		return computeClassName;
	}

//#endregion
//#region node_modules/@griffel/core/__resetStyles.esm.js
/**
	* @internal
	*/
	function __resetStyles$1(ltrClassName, rtlClassName, cssRules$1, factory = insertionFactory$1) {
		const insertStyles = factory();
		function computeClassName(options) {
			const { dir, renderer } = options;
			const className = dir === "ltr" ? ltrClassName : rtlClassName || ltrClassName;
			insertStyles(renderer, Array.isArray(cssRules$1) ? { r: cssRules$1 } : cssRules$1);
			DEBUG_RESET_CLASSES[className] = 1;
			return className;
		}
		return computeClassName;
	}

//#endregion
//#region node_modules/@griffel/core/index.esm.js
	const shorthands = {
		border,
		borderLeft,
		borderBottom,
		borderRight,
		borderTop,
		borderColor: borderColor$1,
		borderStyle,
		borderRadius: borderRadius$1,
		borderWidth,
		flex,
		gap,
		gridArea,
		margin,
		marginBlock,
		marginInline,
		padding,
		paddingBlock,
		paddingInline,
		overflow,
		inset,
		outline,
		transition,
		textDecoration
	};

//#endregion
//#region node_modules/@griffel/react/utils/canUseDOM.esm.js
/**
	* Verifies if an application can use DOM.
	*/
	function canUseDOM$1() {
		return typeof window !== "undefined" && !!(window.document && window.document.createElement);
	}

//#endregion
//#region node_modules/@griffel/react/useInsertionEffect.esm.js
	const useInsertionEffect$2 = react["useInsertionEffect"] ? react["useInsertionEffect"] : void 0;

//#endregion
//#region node_modules/@griffel/react/insertionFactory.esm.js
	const insertionFactory = () => {
		const insertionCache = {};
		return function insert(renderer, cssRules$1) {
			if (useInsertionEffect$2 && canUseDOM$1()) {
				useInsertionEffect$2(() => {
					renderer.insertCSSRules(cssRules$1);
				}, [renderer, cssRules$1]);
				return;
			}
			if (insertionCache[renderer.id] === void 0) {
				renderer.insertCSSRules(cssRules$1);
				insertionCache[renderer.id] = true;
			}
		};
	};

//#endregion
//#region node_modules/@griffel/react/RendererContext.esm.js
/**
	* @private
	*/
	const RendererContext = /* @__PURE__ */ react.createContext(/* @__PURE__ */ createDOMRenderer());
	/**
	* @public
	*/
	const RendererProvider = ({ children, renderer, targetDocument }) => {
		react.useMemo(() => {
			if (canUseDOM$1()) rehydrateRendererCache(renderer, targetDocument);
		}, [renderer, targetDocument]);
		return /* @__PURE__ */ react.createElement(RendererContext.Provider, { value: renderer }, children);
	};
	/**
	* Returns an instance of current makeStyles() renderer.
	*
	* @private Exported as "useRenderer_unstable" use it on own risk. Can be changed or removed without a notice.
	*/
	function useRenderer() {
		return react.useContext(RendererContext);
	}

//#endregion
//#region node_modules/@griffel/react/TextDirectionContext.esm.js
/**
	* @private
	*/
	const TextDirectionContext = /* @__PURE__ */ react.createContext("ltr");
	/**
	* @public
	*/
	const TextDirectionProvider = ({ children, dir }) => {
		return /* @__PURE__ */ react.createElement(TextDirectionContext.Provider, { value: dir }, children);
	};
	/**
	* Returns current directionality of the element's text.
	*
	* @private
	*/
	function useTextDirection() {
		return react.useContext(TextDirectionContext);
	}

//#endregion
//#region node_modules/@griffel/react/utils/isInsideComponent.esm.js
	function getDispatcher() {
		try {
			return react["".concat("__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE")].H;
		} catch (_unused) {}
		try {
			return react["".concat("__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED")].ReactCurrentDispatcher.current;
		} catch (_unused2) {}
	}
	function isInsideComponent() {
		try {
			const dispatcher = getDispatcher();
			if (dispatcher === null || dispatcher === void 0) return false;
			dispatcher.useContext({});
			return true;
		} catch (e) {
			return false;
		}
	}

//#endregion
//#region node_modules/@griffel/react/makeStyles.esm.js
	function makeStyles(stylesBySlots) {
		const getStyles = makeStyles$1(stylesBySlots, insertionFactory);
		if (isInsideComponent()) throw new Error(["makeStyles(): this function cannot be called in component's scope.", "All makeStyles() calls should be top level i.e. in a root scope of a file."].join(" "));
		return function useClasses() {
			return getStyles({
				dir: useTextDirection(),
				renderer: useRenderer()
			});
		};
	}

//#endregion
//#region node_modules/@griffel/react/makeResetStyles.esm.js
	function makeResetStyles(styles) {
		const getStyles = makeResetStyles$1(styles, insertionFactory);
		if (isInsideComponent()) throw new Error(["makeResetStyles(): this function cannot be called in component's scope.", "All makeResetStyles() calls should be top level i.e. in a root scope of a file."].join(" "));
		return function useClassName() {
			return getStyles({
				dir: useTextDirection(),
				renderer: useRenderer()
			});
		};
	}

//#endregion
//#region node_modules/@griffel/react/makeStaticStyles.esm.js
	function makeStaticStyles(styles) {
		const getStyles = makeStaticStyles$1(styles, insertionFactory);
		return function useStaticStyles() {
			return getStyles({ renderer: useRenderer() });
		};
	}

//#endregion
//#region node_modules/@griffel/react/renderToStyleElements.esm.js
/**
	* This method returns a list of <style> React elements with the rendered CSS. This is useful for Server-Side rendering.
	*
	* @public
	*/
	function renderToStyleElements(renderer) {
		return Object.values(renderer.stylesheets).sort((a, b) => {
			return Number(a.elementAttributes["data-priority"]) - Number(b.elementAttributes["data-priority"]);
		}).sort((a, b) => {
			return styleBucketOrdering.indexOf(a.bucketName) - styleBucketOrdering.indexOf(b.bucketName);
		}).sort((a, b) => {
			const mediaA = a.elementAttributes["media"];
			const mediaB = b.elementAttributes["media"];
			if (mediaA && mediaB) return renderer.compareMediaQueries(mediaA, mediaB);
			if (mediaA || mediaB) return mediaA ? 1 : -1;
			return 0;
		}).map((stylesheet) => {
			const cssRules$1 = stylesheet.cssRules();
			if (!cssRules$1.length) return null;
			return /* @__PURE__ */ react.createElement("style", Object.assign({ key: stylesheet.bucketName }, stylesheet.elementAttributes, {
				"data-make-styles-rehydration": "true",
				dangerouslySetInnerHTML: { __html: cssRules$1.join("") }
			}));
		}).filter(Boolean);
	}

//#endregion
//#region node_modules/@griffel/react/__css.esm.js
/**
	* A version of makeStyles() that accepts build output as an input and skips all runtime transforms & DOM insertion.
	*
	* @internal
	*/
	function __css(classesMapBySlot) {
		const getStyles = __css$1(classesMapBySlot);
		return function useClasses() {
			return getStyles({ dir: useTextDirection() });
		};
	}

//#endregion
//#region node_modules/@griffel/react/__styles.esm.js
/**
	* A version of makeStyles() that accepts build output as an input and skips all runtime transforms.
	*
	* @internal
	*/
	function __styles(classesMapBySlot, cssRules$1) {
		const getStyles = __styles$1(classesMapBySlot, cssRules$1, insertionFactory);
		return function useClasses() {
			return getStyles({
				dir: useTextDirection(),
				renderer: useRenderer()
			});
		};
	}

//#endregion
//#region node_modules/@griffel/react/__resetCSS.esm.js
/**
	* A version of makeResetStyles() that accepts build output as an input and skips all runtime transforms & DOM insertion.
	*
	* @internal
	*/
	function __resetCSS(ltrClassName, rtlClassName) {
		const getStyles = __resetCSS$1(ltrClassName, rtlClassName);
		return function useClasses() {
			return getStyles({ dir: useTextDirection() });
		};
	}

//#endregion
//#region node_modules/@griffel/react/__resetStyles.esm.js
/**
	* A version of makeResetStyles() that accepts build output as an input and skips all runtime transforms.
	*
	* @internal
	*/
	function __resetStyles(ltrClassName, rtlClassName, cssRules$1) {
		const getStyles = __resetStyles$1(ltrClassName, rtlClassName, cssRules$1, insertionFactory);
		return function useClasses() {
			return getStyles({
				dir: useTextDirection(),
				renderer: useRenderer()
			});
		};
	}

//#endregion
//#region node_modules/@fluentui/react-provider/lib/components/FluentProvider/createCSSRuleFromTheme.js
/**
	* Creates a CSS rule from a theme object.
	*
	* Useful for scenarios when you want to apply theming statically to a top level elements like `body`.
	*/ function createCSSRuleFromTheme(selector, theme) {
		if (theme) return `${selector} { ${Object.keys(theme).reduce((cssVarRule, cssVar) => {
			return `${cssVarRule}--${cssVar}: ${theme[cssVar]}; `;
		}, "")} }`;
		return `${selector} {}`;
	}

//#endregion
//#region node_modules/@fluentui/react-utilities/lib/compose/constants.js
/**
	* @internal
	* Internal reference for the render function
	*/ const SLOT_RENDER_FUNCTION_SYMBOL = Symbol.for("fui.slotRenderFunction");
	/**
	* @internal
	* Internal reference for the render function
	*/ const SLOT_ELEMENT_TYPE_SYMBOL = Symbol.for("fui.slotElementType");
	/**
	* @internal
	* Internal cache of the original className prop for the slot, before being modified by the useStyles hook.
	*/ const SLOT_CLASS_NAME_PROP_SYMBOL = Symbol.for("fui.slotClassNameProp");

//#endregion
//#region node_modules/@fluentui/react-utilities/lib/compose/slot.js
	var slot_exports = /* @__PURE__ */ __export({
		always: () => always,
		optional: () => optional,
		resolveShorthand: () => resolveShorthand$1
	});
	/**
	* Creates a slot from a slot shorthand or properties (`props.SLOT_NAME` or `props` itself)
	* @param value - the value of the slot, it can be a slot shorthand, a slot component or a slot properties
	* @param options - values you can pass to alter the signature of a slot, those values are:
	*
	* * `elementType` - the base element type of a slot, defaults to `'div'`
	* * `defaultProps` - similar to a React component declaration, you can provide a slot default properties to be merged with the shorthand/properties provided.
	*/ function always(value, options) {
		const { defaultProps, elementType } = options;
		const props = resolveShorthand$1(value);
		/**
		* Casting is required here as SlotComponentType is a function, not an object.
		* Although SlotComponentType has a function signature, it is still just an object.
		* This is required to make a slot callable (JSX compatible), this is the exact same approach
		* that is used on `@types/react` components
		*/ const propsWithMetadata = {
			...defaultProps,
			...props,
			[SLOT_ELEMENT_TYPE_SYMBOL]: elementType,
			[SLOT_CLASS_NAME_PROP_SYMBOL]: (props === null || props === void 0 ? void 0 : props.className) || (defaultProps === null || defaultProps === void 0 ? void 0 : defaultProps.className)
		};
		if (props && typeof props.children === "function") {
			propsWithMetadata[SLOT_RENDER_FUNCTION_SYMBOL] = props.children;
			propsWithMetadata.children = defaultProps === null || defaultProps === void 0 ? void 0 : defaultProps.children;
		}
		return propsWithMetadata;
	}
	/**
	* Creates a slot from a slot shorthand or properties (`props.SLOT_NAME` or `props` itself)
	* @param value - the value of the slot, it can be a slot shorthand, a slot component or a slot properties
	* @param options - values you can pass to alter the signature of a slot, those values are:
	*
	* * `elementType` - the base element type of a slot, defaults to `'div'`
	* * `defaultProps` - similar to a React component declaration, you can provide a slot default properties to be merged with the shorthand/properties provided
	* * `renderByDefault` - a boolean that indicates if a slot will be rendered even if it's base value is `undefined`.
	* By default if `props.SLOT_NAME` is `undefined` then `state.SLOT_NAME` becomes `undefined`
	* and nothing will be rendered, but if `renderByDefault = true` then `state.SLOT_NAME` becomes an object
	* with the values provided by `options.defaultProps` (or `{}`). This is useful for cases such as providing a default content
	* in case no shorthand is provided, like the case of the `expandIcon` slot for the `AccordionHeader`
	*/ function optional(value, options) {
		if (value === null || value === void 0 && !options.renderByDefault) return;
		return always(value, options);
	}
	/**
	* Helper function that converts a slot shorthand or properties to a slot properties object
	* The main difference between this function and `slot` is that this function does not return the metadata required for a slot to be considered a properly renderable slot, it only converts the value to a slot properties object
	* @param value - the value of the slot, it can be a slot shorthand or a slot properties object
	*/ function resolveShorthand$1(value) {
		if (typeof value === "string" || typeof value === "number" || isIterable(value) || react.isValidElement(value)) return { children: value };
		if (value && typeof value !== "object" && true) console.error(`@fluentui/react-utilities [slot.${resolveShorthand$1.name}]:
A slot got an invalid value "${value}" (${typeof value}).
A valid value for a slot is a slot shorthand or slot properties object.
Slot shorthands can be strings, numbers, arrays or JSX elements`);
		return value;
	}
	const isIterable = (value) => typeof value === "object" && value !== null && Symbol.iterator in value;

//#endregion
//#region node_modules/@fluentui/react-utilities/lib/compose/isResolvedShorthand.js
/**
	* Guard method that validates if a shorthand is a slot
	* can be used to extends properties provided by a slot
	*
	* @example
	* ```
	* const backdropSlot = resolveShorthand(backdrop, {
	*  defaultProps: {
	*    onClick: useEventCallback(event => {
	*     if (isResolvedShorthand(backdrop)) {
	*        backdrop.onClick?.(event)
	*      }
	*      // do something after passing click down the line
	*    }),
	*  },
	* })
	* ```
	* @example
	* ```
	* const handleBackDropClick = (event) => {
	*  // do your thing
	* }
	* const backdropSlot = resolveShorthand(backdrop, {
	*  defaultProps: {
	*    onClick: useEventCallback(
	*      mergeCallbacks(isResolvedShorthand(backdrop) ? backdrop.onClick : undefined, handleBackdropClick)
	*    )
	* })
	* ```
	*/ function isResolvedShorthand(shorthand) {
		return shorthand !== null && typeof shorthand === "object" && !Array.isArray(shorthand) && !react.isValidElement(shorthand);
	}

//#endregion
//#region node_modules/@fluentui/react-utilities/lib/compose/isSlot.js
/**
	* Guard method to ensure a given element is a slot.
	* This is mainly used internally to ensure a slot is being used as a component.
	*/ function isSlot(element) {
		return Boolean(element === null || element === void 0 ? void 0 : element.hasOwnProperty(SLOT_ELEMENT_TYPE_SYMBOL));
	}

//#endregion
//#region node_modules/@fluentui/react-utilities/lib/compose/assertSlots.js
/**
	* @internal
	* Assertion method to ensure state slots properties are properly declared.
	* A properly declared slot must be declared by using the `slot` method.
	*
	* @example
	* ```tsx
	* export const renderInput_unstable  = (state: InputState): JSXElement => {
	assertSlots<InputSlots>(state);
	return (
	<state.root>
	{state.contentBefore && <state.contentBefore />}
	<state.input />
	{state.contentAfter && <state.contentAfter />}
	</state.root>
	);
	};
	* ```
	*/ function assertSlots(state) {
		{
			const typedState = state;
			for (const slotName of Object.keys(typedState.components)) {
				const slotElement = typedState[slotName];
				if (slotElement === void 0) continue;
				if (!isSlot(slotElement)) {
					typedState[slotName] = always(slotElement, { elementType: typedState.components[slotName] });
					console.warn(`@fluentui/react-utilities [${assertSlots.name}]:
"state.${slotName}" is not a slot!
Be sure to create slots properly by using "slot.always" or "slot.optional".`);
				} else {
					const { [SLOT_ELEMENT_TYPE_SYMBOL]: elementType } = slotElement;
					if (elementType !== typedState.components[slotName]) {
						slotElement[SLOT_ELEMENT_TYPE_SYMBOL] = typedState.components[slotName];
						console.warn(`@fluentui/react-utilities [${assertSlots.name}]:
"state.${slotName}" element type differs from "state.components.${slotName}",
${elementType} !== ${typedState.components[slotName]}.
Be sure to create slots properly by using "slot.always" or "slot.optional" with the correct elementType.`);
					}
				}
			}
		}
	}

//#endregion
//#region node_modules/@fluentui/react-utilities/lib/utils/properties.js
	const toObjectMap = (...items) => {
		const result = {};
		for (const item of items) {
			const keys = Array.isArray(item) ? item : Object.keys(item);
			for (const key of keys) result[key] = 1;
		}
		return result;
	};
	/**
	* An array of events that are allowed on every html element type.
	*
	* @public
	*/ const baseElementEvents = toObjectMap([
		"onAuxClick",
		"onAnimationEnd",
		"onAnimationStart",
		"onCopy",
		"onCut",
		"onPaste",
		"onCompositionEnd",
		"onCompositionStart",
		"onCompositionUpdate",
		"onFocus",
		"onFocusCapture",
		"onBlur",
		"onBlurCapture",
		"onChange",
		"onInput",
		"onSubmit",
		"onLoad",
		"onError",
		"onKeyDown",
		"onKeyDownCapture",
		"onKeyPress",
		"onKeyUp",
		"onAbort",
		"onCanPlay",
		"onCanPlayThrough",
		"onDurationChange",
		"onEmptied",
		"onEncrypted",
		"onEnded",
		"onLoadedData",
		"onLoadedMetadata",
		"onLoadStart",
		"onPause",
		"onPlay",
		"onPlaying",
		"onProgress",
		"onRateChange",
		"onSeeked",
		"onSeeking",
		"onStalled",
		"onSuspend",
		"onTimeUpdate",
		"onVolumeChange",
		"onWaiting",
		"onClick",
		"onClickCapture",
		"onContextMenu",
		"onDoubleClick",
		"onDrag",
		"onDragEnd",
		"onDragEnter",
		"onDragExit",
		"onDragLeave",
		"onDragOver",
		"onDragStart",
		"onDrop",
		"onMouseDown",
		"onMouseDownCapture",
		"onMouseEnter",
		"onMouseLeave",
		"onMouseMove",
		"onMouseOut",
		"onMouseOver",
		"onMouseUp",
		"onMouseUpCapture",
		"onSelect",
		"onTouchCancel",
		"onTouchEnd",
		"onTouchMove",
		"onTouchStart",
		"onScroll",
		"onWheel",
		"onPointerCancel",
		"onPointerDown",
		"onPointerEnter",
		"onPointerLeave",
		"onPointerMove",
		"onPointerOut",
		"onPointerOver",
		"onPointerUp",
		"onGotPointerCapture",
		"onLostPointerCapture"
	]);
	/**
	* An array of element attributes which are allowed on every html element type.
	*
	* @public
	*/ const baseElementProperties = toObjectMap([
		"accessKey",
		"children",
		"className",
		"contentEditable",
		"dir",
		"draggable",
		"hidden",
		"htmlFor",
		"id",
		"lang",
		"popover",
		"ref",
		"role",
		"style",
		"tabIndex",
		"title",
		"translate",
		"spellCheck",
		"name"
	]);
	/**
	* An array of microdata attributes that are allowed on every html element type.
	*
	* @public
	*/ const microdataProperties = toObjectMap([
		"itemID",
		"itemProp",
		"itemRef",
		"itemScope",
		"itemType"
	]);
	/**
	* An array of HTML element properties and events.
	*
	* @public
	*/ const htmlElementProperties = toObjectMap(baseElementProperties, baseElementEvents, microdataProperties);
	/**
	* An array of LABEL tag properties and events.
	*
	* @public
	*/ const labelProperties = toObjectMap(htmlElementProperties, ["form"]);
	/**
	* An array of AUDIO tag properties and events.
	
	* @public
	*/ const audioProperties = toObjectMap(htmlElementProperties, [
		"height",
		"loop",
		"muted",
		"preload",
		"src",
		"width"
	]);
	/**
	* An array of VIDEO tag properties and events.
	*
	* @public
	*/ const videoProperties = toObjectMap(audioProperties, ["poster"]);
	/**
	* An array of OL tag properties and events.
	*
	* @public
	*/ const olProperties = toObjectMap(htmlElementProperties, ["start"]);
	/**
	* An array of LI tag properties and events.
	*
	* @public
	*/ const liProperties = toObjectMap(htmlElementProperties, ["value"]);
	/**
	* An array of A tag properties and events.
	*
	* @public
	*/ const anchorProperties = toObjectMap(htmlElementProperties, [
		"download",
		"href",
		"hrefLang",
		"media",
		"referrerPolicy",
		"rel",
		"target",
		"type"
	]);
	/**
	* An array of TIME tag properties and events.
	*
	* @public
	*/ const timeProperties = toObjectMap(htmlElementProperties, ["dateTime"]);
	/**
	* An array of BUTTON tag properties and events.
	*
	* @public
	*/ const buttonProperties = toObjectMap(htmlElementProperties, [
		"autoFocus",
		"disabled",
		"form",
		"formAction",
		"formEncType",
		"formMethod",
		"formNoValidate",
		"formTarget",
		"popoverTarget",
		"popoverTargetAction",
		"type",
		"value"
	]);
	/**
	* An array of INPUT tag properties and events.
	*
	* @public
	*/ const inputProperties = toObjectMap(buttonProperties, [
		"accept",
		"alt",
		"autoCorrect",
		"autoCapitalize",
		"autoComplete",
		"checked",
		"dirname",
		"form",
		"height",
		"inputMode",
		"list",
		"max",
		"maxLength",
		"min",
		"minLength",
		"multiple",
		"pattern",
		"placeholder",
		"readOnly",
		"required",
		"src",
		"step",
		"size",
		"type",
		"value",
		"width"
	]);
	/**
	* An array of TEXTAREA tag properties and events.
	*
	* @public
	*/ const textAreaProperties = toObjectMap(buttonProperties, [
		"autoCapitalize",
		"cols",
		"dirname",
		"form",
		"maxLength",
		"placeholder",
		"readOnly",
		"required",
		"rows",
		"wrap"
	]);
	/**
	* An array of SELECT tag properties and events.
	*
	* @public
	*/ const selectProperties = toObjectMap(buttonProperties, [
		"form",
		"multiple",
		"required"
	]);
	const optionProperties = toObjectMap(htmlElementProperties, ["selected", "value"]);
	/**
	* An array of TABLE tag properties and events.
	*
	* @public
	*/ const tableProperties = toObjectMap(htmlElementProperties, ["cellPadding", "cellSpacing"]);
	/**
	* An array of TR tag properties and events.
	*
	* @public
	*/ const trProperties = htmlElementProperties;
	/**
	* An array of TH tag properties and events.
	*
	* @public
	*/ const thProperties = toObjectMap(htmlElementProperties, [
		"colSpan",
		"rowSpan",
		"scope"
	]);
	/**
	* An array of TD tag properties and events.
	*
	* @public
	*/ const tdProperties = toObjectMap(htmlElementProperties, [
		"colSpan",
		"headers",
		"rowSpan",
		"scope"
	]);
	const colGroupProperties = toObjectMap(htmlElementProperties, ["span"]);
	const colProperties = toObjectMap(htmlElementProperties, ["span"]);
	/**
	* An array of FIELDSET tag properties and events.
	*
	* @public
	*/ const fieldsetProperties = toObjectMap(htmlElementProperties, ["disabled", "form"]);
	/**
	* An array of FORM tag properties and events.
	*
	* @public
	*/ const formProperties = toObjectMap(htmlElementProperties, [
		"acceptCharset",
		"action",
		"encType",
		"encType",
		"method",
		"noValidate",
		"target"
	]);
	/**
	* An array of IFRAME tag properties and events.
	*
	* @public
	*/ const iframeProperties = toObjectMap(htmlElementProperties, [
		"allow",
		"allowFullScreen",
		"allowPaymentRequest",
		"allowTransparency",
		"csp",
		"height",
		"importance",
		"referrerPolicy",
		"sandbox",
		"src",
		"srcDoc",
		"width"
	]);
	/**
	* An array of IMAGE tag properties and events.
	*
	* @public
	*/ const imgProperties = toObjectMap(htmlElementProperties, [
		"alt",
		"crossOrigin",
		"height",
		"src",
		"srcSet",
		"useMap",
		"width"
	]);
	/**
	* An array of DIALOG tag properties and events.
	*
	* @public
	*/ const dialogProperties = toObjectMap(htmlElementProperties, [
		"open",
		"onCancel",
		"onClose"
	]);
	/**
	* Gets native supported props for an html element provided the allowance set. Use one of the property
	* sets defined (divProperties, buttonPropertes, etc) to filter out supported properties from a given
	* props set. Note that all data- and aria- prefixed attributes will be allowed.
	* NOTE: getNativeProps should always be applied first when adding props to a react component. The
	* non-native props should be applied second. This will prevent getNativeProps from overriding your custom props.
	* For example, if props passed to getNativeProps has an onClick function and getNativeProps is added to
	* the component after an onClick function is added, then the getNativeProps onClick will override it.
	*
	* @public
	* @param props - The unfiltered input props
	* @param allowedPropNames - The array or record of allowed prop names.
	* @param excludedPropNames
	* @returns The filtered props
	*/ function getNativeProps(props, allowedPropNames, excludedPropNames) {
		const isArray = Array.isArray(allowedPropNames);
		const result = {};
		const keys = Object.keys(props);
		for (const key of keys) if ((!isArray && allowedPropNames[key] || isArray && allowedPropNames.indexOf(key) >= 0 || key.indexOf("data-") === 0 || key.indexOf("aria-") === 0) && (!excludedPropNames || (excludedPropNames === null || excludedPropNames === void 0 ? void 0 : excludedPropNames.indexOf(key)) === -1)) result[key] = props[key];
		return result;
	}

//#endregion
//#region node_modules/@fluentui/react-utilities/lib/utils/getNativeElementProps.js
	const nativeElementMap = {
		label: labelProperties,
		audio: audioProperties,
		video: videoProperties,
		ol: olProperties,
		li: liProperties,
		a: anchorProperties,
		button: buttonProperties,
		input: inputProperties,
		textarea: textAreaProperties,
		select: selectProperties,
		option: optionProperties,
		table: tableProperties,
		tr: trProperties,
		th: thProperties,
		td: tdProperties,
		colGroup: colGroupProperties,
		col: colProperties,
		fieldset: fieldsetProperties,
		form: formProperties,
		iframe: iframeProperties,
		img: imgProperties,
		time: timeProperties,
		dialog: dialogProperties
	};
	/**
	* Given an element tagname and user props, filters the props to only allowed props for the given
	* element type.
	* @param tagName - Tag name (e.g. "div")
	* @param props - Props object
	* @param excludedPropNames - List of props to disallow
	*
	* @deprecated use getIntrinsicElementProps instead, it is a type-safe version of this method
	*/ function getNativeElementProps(tagName, props, excludedPropNames) {
		const allowedPropNames = tagName && nativeElementMap[tagName] || htmlElementProperties;
		allowedPropNames.as = 1;
		return getNativeProps(props, allowedPropNames, excludedPropNames);
	}
	/**
	* Splits the native props into ones that go to the `root` slot, and ones that go to the primary slot.
	*
	* This function is only for use with components that have a primary slot other than `root`.
	* Most components should use {@link getNativeElementProps} for their root slot if it is the primary slot.
	*
	* @returns An object containing the native props for the `root` and primary slots.
	*/ const getPartitionedNativeProps = ({ primarySlotTagName, props, excludedPropNames }) => {
		return {
			root: {
				style: props.style,
				className: props.className
			},
			primary: getNativeElementProps(primarySlotTagName, props, [
				...excludedPropNames || [],
				"style",
				"className"
			])
		};
	};

//#endregion
//#region node_modules/@fluentui/react-utilities/lib/compose/getIntrinsicElementProps.js
/**
	* Given an element tagname and user props, filters the props to only allowed props for the given
	* element type.
	*
	* Equivalent to {@link getNativeElementProps}, but more type-safe.
	*
	* @param tagName - The slot's default element type (e.g. 'div')
	* @param props - The component's props object
	* @param excludedPropNames - List of native props to exclude from the returned value
	*/ const getIntrinsicElementProps = (tagName, props, excludedPropNames) => {
		var _props_as;
		return getNativeElementProps((_props_as = props.as) !== null && _props_as !== void 0 ? _props_as : tagName, props, excludedPropNames);
	};

//#endregion
//#region node_modules/@fluentui/react-utilities/lib/compose/getSlotClassNameProp.js
/**
	* Get the className prop set on the slot by the user, without including the default classes added by the component.
	* Custom style hooks should merge this className _after_ any additional classes added by the hook, to ensure that
	* classes added by the user take precedence over the custom style hook.
	*
	* Example usage in a custom style hook:
	* ```ts
	* state.root.className = mergeClasses(
	*   state.root.className,
	*   customStyles.root,
	*   getSlotClassNameProp_unstable(state.root));
	* ```
	*
	* @returns The className prop set on the slot by the user, or undefined if not set.
	*/ const getSlotClassNameProp = (slot) => {
		if (SLOT_CLASS_NAME_PROP_SYMBOL in slot && typeof slot[SLOT_CLASS_NAME_PROP_SYMBOL] === "string") return slot[SLOT_CLASS_NAME_PROP_SYMBOL];
	};

//#endregion
//#region node_modules/@fluentui/react-utilities/lib/utils/omit.js
/**
	* Tiny helper to do the minimal amount of work in duplicating an object but omitting some
	* props. This ends up faster than using object ...rest or reduce to filter.
	*
	* This behaves very much like filteredAssign, but does not merge many objects together,
	* uses an exclusion object map, and avoids spreads all for optimal performance.
	*
	* See perf test for background:
	* https://jsperf.com/omit-vs-rest-vs-reduce/1
	*
	* @param obj - The object to clone
	* @param exclusions - The array of keys to exclude
	*/ function omit(obj, exclusions) {
		const result = {};
		for (const key in obj) if (exclusions.indexOf(key) === -1 && obj.hasOwnProperty(key)) result[key] = obj[key];
		return result;
	}

//#endregion
//#region node_modules/@fluentui/react-utilities/lib/compose/deprecated/getSlots.js
/**
	* Given the state and an array of slot names, will break out `slots` and `slotProps`
	* collections.
	*
	* The root is derived from a mix of `components` props and `as` prop.
	*
	* Slots will render as null if they are rendered as primitives with undefined children.
	*
	* The slotProps will always omit the `as` prop within them, and for slots that are string
	* primitives, the props will be filtered according to the slot type by the type system.
	* For example, if the slot is rendered `as: 'a'`, the props will be filtered for acceptable
	* anchor props. Note that this is only enforced at build time by Typescript -- there is no
	* runtime code filtering props in this function.
	*
	* @deprecated use slot.always or slot.optional combined with assertSlots instead
	*
	* @param state - State including slot definitions
	* @returns An object containing the `slots` map and `slotProps` map.
	*/ function getSlots(state) {
		const typeState = state;
		const slots = {};
		const slotProps = {};
		const slotNames = Object.keys(typeState.components);
		for (const slotName of slotNames) {
			const [slot, props] = getSlot(typeState, slotName);
			slots[slotName] = slot;
			slotProps[slotName] = props;
		}
		return {
			slots,
			slotProps
		};
	}
	function getSlot(state, slotName) {
		var _state_components, _state_components1;
		const props = state[slotName];
		if (props === void 0) return [null, void 0];
		const { as: asProp, children, ...rest } = props;
		const renderFunction = isSlot(props) ? props[SLOT_RENDER_FUNCTION_SYMBOL] : void 0;
		const slot = ((_state_components = state.components) === null || _state_components === void 0 ? void 0 : _state_components[slotName]) === void 0 || typeof state.components[slotName] === "string" ? asProp || ((_state_components1 = state.components) === null || _state_components1 === void 0 ? void 0 : _state_components1[slotName]) || "div" : state.components[slotName];
		const asserted = slot;
		if (renderFunction || typeof children === "function") {
			const render = renderFunction || children;
			return [react.Fragment, { children: render(asserted, rest) }];
		}
		return [asserted, typeof slot === "string" && asProp ? omit(props, ["as"]) : props];
	}

//#endregion
//#region node_modules/@fluentui/react-utilities/lib/compose/deprecated/resolveShorthand.js
/**
	*
	* Resolves shorthands into slot props, to ensure normalization of the signature
	* being passed down to getSlots method
	* @param value - the base shorthand props
	* @param options - options to resolve shorthand props
	*
	* @deprecated use slot.always, slot.optional, slot.resolveShorthand combined with assertSlots instead
	*/ const resolveShorthand = (value, options) => optional(value, {
		...options,
		renderByDefault: options === null || options === void 0 ? void 0 : options.required,
		elementType: void 0
	});

//#endregion
//#region node_modules/@fluentui/react-utilities/lib/hooks/useBrowserTimer.js
/**
	* @internal
	* Helper to manage a browser timer.
	* Ensures that the timer isn't set multiple times at once,
	* and is cleaned up when the component is unloaded.
	*
	* @param setTimer - The timer setter function
	* @param cancelTimer - The timer cancel function
	* @returns A pair of [setTimer, cancelTimer] that are stable between renders.
	*
	* @example
	* const [setTimer, cancelTimer] = useBrowserTimer(setTimeout, cancelTimeout);
	*
	* setTimer(() => console.log('Hello world!'), 1000);
	* cancelTimer();
	*/ function useBrowserTimer(setTimer, cancelTimer) {
		const id = react.useRef(void 0);
		const set = react.useCallback((fn, delay) => {
			if (id.current !== void 0) cancelTimer(id.current);
			id.current = setTimer(fn, delay);
			return id.current;
		}, [cancelTimer, setTimer]);
		const cancel = react.useCallback(() => {
			if (id.current !== void 0) {
				cancelTimer(id.current);
				id.current = void 0;
			}
		}, [cancelTimer]);
		react.useEffect(() => cancel, [cancel]);
		return [set, cancel];
	}

//#endregion
//#region node_modules/@fluentui/react-shared-contexts/lib/ThemeContext/ThemeContext.js
/**
	* @internal
	*/ const ThemeContext = react.createContext(void 0);
	/**
	* @internal
	*/ const ThemeProvider = ThemeContext.Provider;

//#endregion
//#region node_modules/@fluentui/react-shared-contexts/lib/ThemeClassNameContext/ThemeClassNameContext.js
/**
	* @internal
	* Used to provide a CSS class that applies theme css variables
	*
	* Useful for elements in the React tree (can read context) but not in the DOM Tree. E.g. Portals
	*/ const ThemeClassNameContext = react.createContext(void 0);
	const themeClassNameContextDefaultVaue = "";
	const ThemeClassNameProvider = ThemeClassNameContext.Provider;
	/**
	* @returns CSS class that applies css variables
	*/ function useThemeClassName() {
		var _React_useContext;
		return (_React_useContext = react.useContext(ThemeClassNameContext)) !== null && _React_useContext !== void 0 ? _React_useContext : themeClassNameContextDefaultVaue;
	}

//#endregion
//#region node_modules/@fluentui/react-shared-contexts/lib/TooltipVisibilityContext/TooltipContext.js
/**
	* @internal
	* Context shared by all of the tooltips in the app
	*/ const TooltipVisibilityContext = react.createContext(void 0);
	const tooltipVisibilityContextDefaultValue = {};
	/**
	* @internal
	*/ const TooltipVisibilityProvider = TooltipVisibilityContext.Provider;
	function useTooltipVisibility() {
		var _React_useContext;
		return (_React_useContext = react.useContext(TooltipVisibilityContext)) !== null && _React_useContext !== void 0 ? _React_useContext : tooltipVisibilityContextDefaultValue;
	}

//#endregion
//#region node_modules/@fluentui/react-shared-contexts/lib/ProviderContext/ProviderContext.js
/**
	* @internal
	*/ const ProviderContext = react.createContext(void 0);
	const providerContextDefaultValue = {
		targetDocument: typeof document === "object" ? document : void 0,
		dir: "ltr"
	};
	/**
	* @internal
	*/ const Provider = ProviderContext.Provider;
	function useFluent() {
		var _React_useContext;
		return (_React_useContext = react.useContext(ProviderContext)) !== null && _React_useContext !== void 0 ? _React_useContext : providerContextDefaultValue;
	}

//#endregion
//#region node_modules/@fluentui/react-shared-contexts/lib/OverridesContext/OverridesContext.js
/**
	* @internal
	*/ const OverridesContext = react.createContext(void 0);
	/**
	* @internal
	*/ const OverridesProvider = OverridesContext.Provider;
	function useOverrides() {
		var _React_useContext;
		return (_React_useContext = react.useContext(OverridesContext)) !== null && _React_useContext !== void 0 ? _React_useContext : {};
	}

//#endregion
//#region node_modules/@fluentui/react-shared-contexts/lib/CustomStyleHooksContext/CustomStyleHooksContext.js
/**
	* @internal
	*/ const CustomStyleHooksContext = react.createContext(void 0);
	const noop$10 = () => {};
	/**
	* @internal
	*/ const CustomStyleHooksProvider = CustomStyleHooksContext.Provider;
	/**
	* Gets a custom style hook
	* @param hook - One of the hook properties in CustomStyleHooksContextValue
	* @returns The corresponding hook when defined, otherwise a no-op function.
	*/ const useCustomStyleHook = (hook) => {
		var _React_useContext;
		var _React_useContext_hook;
		return (_React_useContext_hook = (_React_useContext = react.useContext(CustomStyleHooksContext)) === null || _React_useContext === void 0 ? void 0 : _React_useContext[hook]) !== null && _React_useContext_hook !== void 0 ? _React_useContext_hook : noop$10;
	};

//#endregion
//#region node_modules/@fluentui/react-shared-contexts/lib/BackgroundAppearanceContext/BackgroundAppearanceContext.js
/**
	* @internal
	*/ const BackgroundAppearanceContext = react.createContext(void 0);
	/**
	* @internal
	*/ const BackgroundAppearanceProvider = BackgroundAppearanceContext.Provider;
	function useBackgroundAppearance() {
		return react.useContext(BackgroundAppearanceContext);
	}

//#endregion
//#region node_modules/@fluentui/react-shared-contexts/lib/PortalMountNodeContext.js
/**
	* Provides a mount node for portals to render into.
	*
	* @internal
	*/ const PortalMountNodeContext = react.createContext(void 0);
	/**
	* @internal
	*/ const PortalMountNodeProvider = PortalMountNodeContext.Provider;
	function usePortalMountNode() {
		return react.useContext(PortalMountNodeContext);
	}

//#endregion
//#region node_modules/@fluentui/react-shared-contexts/lib/AnnounceContext/AnnounceContext.js
/**
	* @internal
	*/ const AnnounceContext = react.createContext(void 0);
	const AnnounceProvider = AnnounceContext.Provider;
	/**
	* Returns a function that can be used to announce messages to screen readers.
	*/ function useAnnounce() {
		var _React_useContext;
		return (_React_useContext = react.useContext(AnnounceContext)) !== null && _React_useContext !== void 0 ? _React_useContext : { announce: () => void 0 };
	}

//#endregion
//#region node_modules/@fluentui/react-utilities/lib/hooks/useAnimationFrame.js
	const setAnimationFrameNoop = (callback) => {
		callback(0);
		return 0;
	};
	const cancelAnimationFrameNoop = (handle) => handle;
	/**
	* @internal
	* Helper to manage a browser requestAnimationFrame.
	* Ensures that the requestAnimationFrame isn't set multiple times at once and is cleaned up
	* when the component is unloaded.
	*
	* @returns A pair of [requestAnimationFrame, cancelAnimationFrame] that are stable between renders.
	*/ function useAnimationFrame() {
		const { targetDocument } = useFluent();
		const win = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView;
		return useBrowserTimer(win ? win.requestAnimationFrame : setAnimationFrameNoop, win ? win.cancelAnimationFrame : cancelAnimationFrameNoop);
	}

//#endregion
//#region node_modules/@fluentui/react-utilities/lib/utils/measureScrollBarWidth.js
/**
	* Measures the width of the scrollbar for the given document.
	*
	* @param targetDocument - Document to measure the scrollbar width
	* @returns The width of the scrollbar in pixels
	*/ function measureScrollbarWidth(targetDocument) {
		const outer = targetDocument.createElement("div");
		outer.style.visibility = "hidden";
		outer.style.overflow = "scroll";
		const inner = targetDocument.createElement("div");
		outer.appendChild(inner);
		targetDocument.body.appendChild(outer);
		const scrollbarWidth = outer.offsetWidth - inner.offsetWidth;
		outer.remove();
		return scrollbarWidth;
	}

//#endregion
//#region node_modules/@fluentui/react-utilities/lib/hooks/useApplyScrollbarWidth.js
	const cache$1 = /* @__PURE__ */ new WeakMap();
	/**
	* A React hook that provides a ref for applying the browser's scrollbar width as a CSS property.
	*
	* This hook is SSR-safe and caches measurements per document to avoid redundant calculations.
	* When the ref is attached to an element, the hook automatically applies the measured scrollbar
	* width to the specified CSS property (defaults to 'width').
	*
	* @example
	* ```tsx
	* const scrollbarRef = useApplyScrollbarWidth({ targetDocument: document });
	* return <div ref={scrollbarRef} />;
	* ```
	*/ function useApplyScrollbarWidth(options = {}) {
		const { force, property = "width" } = options;
		return react.useCallback((element) => {
			if (!element) return;
			if (!force && cache$1.has(element.ownerDocument)) {
				const cachedWidth = cache$1.get(element.ownerDocument);
				if (cachedWidth !== void 0) {
					element.style.setProperty(property, `${cachedWidth}px`);
					return;
				}
			}
			const scrollbarWidth = measureScrollbarWidth(element.ownerDocument);
			cache$1.set(element.ownerDocument, scrollbarWidth);
			element.style.setProperty(property, `${scrollbarWidth}px`);
		}, [force, property]);
	}

//#endregion
//#region node_modules/@fluentui/react-utilities/lib/hooks/useControllableState.js
	function isFactoryDispatch(newState) {
		return typeof newState === "function";
	}
	/**
	* @internal
	*
	* A [`useState`](https://reactjs.org/docs/hooks-reference.html#usestate)-like hook
	* to manage a value that could be either `controlled` or `uncontrolled`,
	* such as a checked state or text input string.
	*
	* @see https://react.dev/learn/sharing-state-between-components#controlled-and-uncontrolled-components for more details on `controlled`/`uncontrolled`
	*
	* @returns an array of the current value and an updater (dispatcher) function.
	* The updater function is referentially stable (won't change during the component's lifecycle).
	* It can take either a new value, or a function which is passed the previous value and returns the new value.
	*
	*  Calls to the dispatcher will only modify the state if the state is `uncontrolled`.
	* Meaning that if a state is `controlled`, calls to the dispatcher do not modify the state.
	*
	*/ const useControllableState = (options) => {
		"use no memo";
		if (options.state !== void 0 && options.defaultState !== void 0) console.error(`@fluentui/react-utilities [useControllableState]:
A component must be either controlled or uncontrolled (specify either the state or the defaultState, but not both).
Decide between using a controlled or uncontrolled component and remove one of this props.
More info: https://reactjs.org/link/controlled-components
${(/* @__PURE__ */ new Error()).stack}`);
		const [internalState, setInternalState] = react.useState(() => {
			if (options.defaultState === void 0) return options.initialState;
			return isInitializer(options.defaultState) ? options.defaultState() : options.defaultState;
		});
		const stateValueRef = react.useRef(options.state);
		react.useEffect(() => {
			stateValueRef.current = options.state;
		}, [options.state]);
		const setControlledState = react.useCallback((newState) => {
			if (isFactoryDispatch(newState)) newState(stateValueRef.current);
		}, []);
		return useIsControlled(options.state) ? [options.state, setControlledState] : [internalState, setInternalState];
	};
	function isInitializer(value) {
		return typeof value === "function";
	}
	/**
	* Helper hook to handle previous comparison of controlled/uncontrolled
	* Prints an error when isControlled value switches between subsequent renders
	* @returns - whether the value is controlled
	*/ const useIsControlled = (controlledValue) => {
		"use no memo";
		const [isControlled] = react.useState(() => controlledValue !== void 0);
		react.useEffect(() => {
			if (isControlled !== (controlledValue !== void 0)) {
				const error = /* @__PURE__ */ new Error();
				const controlWarning = isControlled ? "a controlled value to be uncontrolled" : "an uncontrolled value to be controlled";
				const undefinedWarning = isControlled ? "defined to an undefined" : "undefined to a defined";
				console.error(`@fluentui/react-utilities [useControllableState]:
A component is changing ${controlWarning}. This is likely caused by the value changing from ${undefinedWarning} value, which should not happen.
Decide between using a controlled or uncontrolled input element for the lifetime of the component.
More info: https://reactjs.org/link/controlled-components
${error.stack}`);
			}
		}, [isControlled, controlledValue]);
		return isControlled;
	};

//#endregion
//#region node_modules/@fluentui/react-utilities/lib/ssr/canUseDOM.js
/**
	* Verifies if an application can use DOM.
	*/ function canUseDOM() {
		return typeof window !== "undefined" && !!(window.document && window.document.createElement);
	}

//#endregion
//#region node_modules/@fluentui/react-utilities/lib/ssr/SSRContext.js
/**
	* Default context value to use in case there is no SSRProvider. This is fine for client-only apps.
	*
	* @internal
	*/ const defaultSSRContextValue = { current: 0 };
	const SSRContext = /* @__PURE__ */ react.createContext(void 0);
	/**
	* @internal
	*/ function useSSRContext() {
		var _React_useContext;
		return (_React_useContext = react.useContext(SSRContext)) !== null && _React_useContext !== void 0 ? _React_useContext : defaultSSRContextValue;
	}
	/**
	* When using SSR with Fluent UI, applications must be wrapped in an SSRProvider. This ensures that auto generated ids
	* are consistent between the client and server.
	*
	* @public
	*/ const SSRProvider = (props) => {
		const [value] = react.useState(() => ({ current: 0 }));
		return /* @__PURE__ */ react.createElement(SSRContext.Provider, { value }, props.children);
	};
	/**
	* Returns whether the component is currently being server side rendered or hydrated on the client. Can be used to delay
	* browser-specific rendering until after hydration. May cause re-renders on a client when is used within SSRProvider.
	*/ function useIsSSR() {
		const isInSSRContext = useSSRContext() !== defaultSSRContextValue;
		const [isSSR, setIsSSR] = react.useState(isInSSRContext);
		if (!isInSSRContext && !canUseDOM()) console.error(`@fluentui/react-components [${useIsSSR.name}]:
When server rendering, you must wrap your application in an <SSRProvider> to ensure consistent ids are generated between the client and server.


Check documentation at https://aka.ms/fluentui-ssr.`);
		if (canUseDOM() && isInSSRContext) react.useLayoutEffect(() => {
			setIsSSR(false);
		}, []);
		return isSSR;
	}

//#endregion
//#region node_modules/@fluentui/react-utilities/lib/hooks/useIsomorphicLayoutEffect.js
/**
	* React currently throws a warning when using useLayoutEffect on the server. To get around it, we can conditionally
	* useEffect on the server (no-op) and useLayoutEffect in the browser. We occasionally need useLayoutEffect to
	* ensure we don't get a render flash for certain operations, but we may also need affected components to render on
	* the server.
	*
	* https://gist.github.com/gaearon/e7d97cdf38a2907924ea12e4ebdf3c85
	* https://github.com/reduxjs/react-redux/blob/master/src/utils/useIsomorphicLayoutEffect.js
	*/ const useIsomorphicLayoutEffect = canUseDOM() ? react.useLayoutEffect : react.useEffect;

//#endregion
//#region node_modules/@fluentui/react-utilities/lib/hooks/useEventCallback.js
/**
	* @internal
	* https://reactjs.org/docs/hooks-faq.html#how-to-read-an-often-changing-value-from-usecallback
	*
	* Modified `useCallback` that can be used when dependencies change too frequently. Can occur when
	* e.g. user props are dependencies which could change on every render
	* e.g. volatile values (i.e. useState/useDispatch) are dependencies which could change frequently
	*
	* This should not be used often, but can be a useful re-render optimization since the callback is a ref and
	* will not be invalidated between re-renders
	*
	* @param fn - The callback function that will be used
	*/ const useEventCallback = (fn) => {
		const callbackRef = react.useRef(() => {
			throw new Error("Cannot call an event handler while rendering");
		});
		useIsomorphicLayoutEffect(() => {
			callbackRef.current = fn;
		}, [fn]);
		return react.useCallback((...args) => {
			const callback = callbackRef.current;
			return callback(...args);
		}, [callbackRef]);
	};

//#endregion
//#region node_modules/@fluentui/react-utilities/lib/hooks/useFirstMount.js
/**
	* @internal
	* Checks if components was mounted the first time.
	* Supports React concurrent/strict mode by using `useEffect`
	* to track the first mount instead of mutating refs during render.
	*
	* @example
	* const isFirstMount = useFirstMount();
	*/ function useFirstMount() {
		const isFirst = react.useRef(true);
		react.useEffect(() => {
			if (isFirst.current) isFirst.current = false;
		}, []);
		return isFirst.current;
	}

//#endregion
//#region node_modules/@fluentui/react-utilities/lib/hooks/useForceUpdate.js
/**
	* @internal
	* Forces a re-render, similar to `forceUpdate` in class components.
	*/ function useForceUpdate() {
		return react.useReducer((x) => x + 1, 0)[1];
	}

//#endregion
//#region node_modules/@fluentui/react-utilities/lib/hooks/useId.js
	const IdPrefixContext = react.createContext(void 0);
	/**
	* Allows to define a prefix that will be used for all IDs generated by useId() hook. It's useful to avoid collisions
	* between different bundles.
	*/ const IdPrefixProvider = IdPrefixContext.Provider;
	function useIdPrefix() {
		return react.useContext(IdPrefixContext) || "";
	}
	/**
	* Resets generated IDs, should be used only in tests.
	*/ function resetIdsForTests() {
		defaultSSRContextValue.current = 0;
	}
	/**
	* Hook to generate a unique ID.
	*
	* @param prefix - Optional prefix for the ID. Defaults to 'fui-'.
	* @param providedId - Optional id provided by a parent component. Defaults to the provided value if present,
	*  without conditioning the hook call
	* @returns The ID
	*/ function useId(prefix$1 = "fui-", providedId) {
		"use no memo";
		const contextValue = useSSRContext();
		const idPrefix = useIdPrefix();
		const _useId = react["useId"];
		if (_useId) {
			const generatedId = _useId();
			const escapedId = react.useMemo(() => generatedId.replace(/:/g, ""), [generatedId]);
			return providedId || `${idPrefix}${prefix$1}${escapedId}`;
		}
		return react.useMemo(() => {
			if (providedId) return providedId;
			return `${idPrefix}${prefix$1}${++contextValue.current}`;
		}, [
			idPrefix,
			prefix$1,
			providedId,
			contextValue
		]);
	}

//#endregion
//#region node_modules/@fluentui/react-utilities/lib/hooks/useMergedRefs.js
/**
	* React hook to merge multiple React refs (either MutableRefObjects or ref callbacks) into a single ref callback that
	* updates all provided refs
	* @param refs - Refs to collectively update with one ref value.
	* @returns A function with an attached "current" prop, so that it can be treated like a RefObject.
	*/ function useMergedRefs(...refs) {
		"use no memo";
		const mergedCallback = react.useCallback((value) => {
			mergedCallback.current = value;
			for (const ref of refs) {
				if (typeof ref === "string" && true) console.error(`@fluentui/react-utilities [useMergedRefs]:
This hook does not support the usage of string refs. Please use React.useRef instead.

For more info on 'React.useRef', see https://react.dev/reference/react/useRef.
For more info on string refs, see https://react.dev/blog/2024/04/25/react-19-upgrade-guide#removed-string-refs.`);
				if (typeof ref === "function") ref(value);
				else if (ref) ref.current = value;
			}
		}, [...refs]);
		return mergedCallback;
	}

//#endregion
//#region node_modules/@fluentui/react-utilities/lib/hooks/useOnClickOutside.js
	const DEFAULT_CONTAINS = (parent$1, child) => !!(parent$1 === null || parent$1 === void 0 ? void 0 : parent$1.contains(child));
	/**
	* @internal
	* Utility to perform checks where a click/touch event was made outside a component
	*/ const useOnClickOutside = (options) => {
		const { targetDocument } = useFluent();
		const win = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView;
		const { refs, callback, element, disabled, disabledFocusOnIframe, contains = DEFAULT_CONTAINS } = options;
		const timeoutId = react.useRef(void 0);
		useIFrameFocus({
			element,
			disabled: disabledFocusOnIframe || disabled,
			callback,
			refs,
			contains
		});
		const isMouseDownInsideRef = react.useRef(false);
		const listener = useEventCallback((ev) => {
			if (isMouseDownInsideRef.current) {
				isMouseDownInsideRef.current = false;
				return;
			}
			const target = ev.composedPath()[0];
			if (refs.every((ref) => !contains(ref.current || null, target)) && !disabled) callback(ev);
		});
		const handleMouseDown = useEventCallback((ev) => {
			isMouseDownInsideRef.current = refs.some((ref) => contains(ref.current || null, ev.target));
		});
		react.useEffect(() => {
			if (disabled) return;
			let currentEvent = getWindowEvent(win);
			const conditionalHandler = (event) => {
				if (event === currentEvent) {
					currentEvent = void 0;
					return;
				}
				listener(event);
			};
			element === null || element === void 0 || element.addEventListener("click", conditionalHandler, true);
			element === null || element === void 0 || element.addEventListener("touchstart", conditionalHandler, true);
			element === null || element === void 0 || element.addEventListener("contextmenu", conditionalHandler, true);
			element === null || element === void 0 || element.addEventListener("mousedown", handleMouseDown, true);
			timeoutId.current = win === null || win === void 0 ? void 0 : win.setTimeout(() => {
				currentEvent = void 0;
			}, 1);
			return () => {
				element === null || element === void 0 || element.removeEventListener("click", conditionalHandler, true);
				element === null || element === void 0 || element.removeEventListener("touchstart", conditionalHandler, true);
				element === null || element === void 0 || element.removeEventListener("contextmenu", conditionalHandler, true);
				element === null || element === void 0 || element.removeEventListener("mousedown", handleMouseDown, true);
				win === null || win === void 0 || win.clearTimeout(timeoutId.current);
				currentEvent = void 0;
			};
		}, [
			listener,
			element,
			disabled,
			handleMouseDown,
			win
		]);
	};
	const getWindowEvent = (target) => {
		if (target) {
			var _target_ownerDocument_defaultView, _target_ownerDocument;
			if (typeof target.window === "object" && target.window === target) return target.event;
			var _target_ownerDocument_defaultView_event;
			return (_target_ownerDocument_defaultView_event = (_target_ownerDocument = target.ownerDocument) === null || _target_ownerDocument === void 0 ? void 0 : (_target_ownerDocument_defaultView = _target_ownerDocument.defaultView) === null || _target_ownerDocument_defaultView === void 0 ? void 0 : _target_ownerDocument_defaultView.event) !== null && _target_ownerDocument_defaultView_event !== void 0 ? _target_ownerDocument_defaultView_event : void 0;
		}
	};
	const FUI_FRAME_EVENT = "fuiframefocus";
	/**
	* Since click events do not propagate past iframes, we use focus to detect if a
	* click has happened inside an iframe, since the only ways of focusing inside an
	* iframe are:
	*   - clicking inside
	*   - tabbing inside
	*
	* Polls the value of `document.activeElement`. If it is an iframe, then dispatch
	* a custom DOM event. When the custom event is received call the provided callback
	*/ const useIFrameFocus = (options) => {
		const { disabled, element: targetDocument, callback, contains = DEFAULT_CONTAINS, pollDuration = 100, refs } = options;
		const timeoutRef = react.useRef(void 0);
		const listener = useEventCallback((e) => {
			if (refs.every((ref) => !contains(ref.current || null, e.target)) && !disabled) callback(e);
		});
		react.useEffect(() => {
			if (disabled) return;
			targetDocument === null || targetDocument === void 0 || targetDocument.addEventListener(FUI_FRAME_EVENT, listener, true);
			return () => {
				targetDocument === null || targetDocument === void 0 || targetDocument.removeEventListener(FUI_FRAME_EVENT, listener, true);
			};
		}, [
			targetDocument,
			disabled,
			listener
		]);
		react.useEffect(() => {
			var _targetDocument_defaultView;
			if (disabled) return;
			timeoutRef.current = targetDocument === null || targetDocument === void 0 ? void 0 : (_targetDocument_defaultView = targetDocument.defaultView) === null || _targetDocument_defaultView === void 0 ? void 0 : _targetDocument_defaultView.setInterval(() => {
				const activeElement = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.activeElement;
				if ((activeElement === null || activeElement === void 0 ? void 0 : activeElement.tagName) === "IFRAME" || (activeElement === null || activeElement === void 0 ? void 0 : activeElement.tagName) === "WEBVIEW") {
					const event = new CustomEvent(FUI_FRAME_EVENT, { bubbles: true });
					activeElement.dispatchEvent(event);
				}
			}, pollDuration);
			return () => {
				var _targetDocument_defaultView$1;
				targetDocument === null || targetDocument === void 0 || (_targetDocument_defaultView$1 = targetDocument.defaultView) == null || _targetDocument_defaultView$1.clearInterval(timeoutRef.current);
			};
		}, [
			targetDocument,
			disabled,
			pollDuration
		]);
	};

//#endregion
//#region node_modules/@fluentui/react-utilities/lib/hooks/useOnScrollOutside.js
/**
	* @internal
	* Utility to perform checks where a click/touch event was made outside a component
	*/ const useOnScrollOutside = (options) => {
		const { refs, callback, element, disabled, contains: containsProp } = options;
		const listener = useEventCallback((ev) => {
			const contains = containsProp || ((parent$1, child) => !!(parent$1 === null || parent$1 === void 0 ? void 0 : parent$1.contains(child)));
			const target = ev.composedPath()[0];
			if (refs.every((ref) => !contains(ref.current || null, target)) && !disabled) callback(ev);
		});
		react.useEffect(() => {
			if (disabled) return;
			element === null || element === void 0 || element.addEventListener("wheel", listener);
			element === null || element === void 0 || element.addEventListener("touchmove", listener);
			return () => {
				element === null || element === void 0 || element.removeEventListener("wheel", listener);
				element === null || element === void 0 || element.removeEventListener("touchmove", listener);
			};
		}, [
			listener,
			element,
			disabled
		]);
	};

//#endregion
//#region node_modules/@fluentui/react-utilities/lib/hooks/usePrevious.js
/**
	* @internal
	*/ const usePrevious = (value) => {
		const ref = react.useRef(null);
		react.useEffect(() => {
			ref.current = value;
		}, [value]);
		return ref.current;
	};

//#endregion
//#region node_modules/@fluentui/react-utilities/lib/hooks/useScrollbarWidth.js
	const cache = /* @__PURE__ */ new WeakMap();
	/**
	* @returns The width in pixels of the scrollbar in the user agent
	* @remarks This hook is not SSR-safe. For SSR-safe scrollbar width application, use the `useApplyScrollbarWidth` from {@link file://./useApplyScrollbarWidth.ts} instead.
	*/ function useScrollbarWidth(options) {
		const { targetDocument, force } = options;
		return react.useMemo(() => {
			if (!targetDocument) return 0;
			if (!force && cache.has(targetDocument)) return cache.get(targetDocument);
			const scrollbarWidth = measureScrollbarWidth(targetDocument);
			cache.set(targetDocument, scrollbarWidth);
			return scrollbarWidth;
		}, [targetDocument, force]);
	}

//#endregion
//#region node_modules/@fluentui/react-utilities/lib/hooks/useTimeout.js
	const setTimeoutNoop$1 = (_callback) => -1;
	const clearTimeoutNoop$1 = (_handle) => void 0;
	/**
	* @internal
	* Helper to manage a browser timeout.
	* Ensures that the timeout isn't set multiple times at once and is cleaned up
	* when the component is unloaded.
	*
	* @returns A pair of [setTimeout, clearTimeout] that are stable between renders.
	*/ function useTimeout() {
		const { targetDocument } = useFluent();
		const win = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView;
		return useBrowserTimer(win ? win.setTimeout : setTimeoutNoop$1, win ? win.clearTimeout : clearTimeoutNoop$1);
	}

//#endregion
//#region node_modules/@fluentui/react-utilities/lib/utils/clamp.js
/**
	* @internal
	* Clamps `value` to a number between the min and max.
	*
	* @param value - the value to be clamped
	* @param min - the lowest valid value
	* @param max - the highest valid value
	*/ const clamp$2 = (value, min$1, max$1) => Math.max(min$1, Math.min(max$1, value || 0));

//#endregion
//#region node_modules/@fluentui/react-utilities/lib/utils/getReactElementRef.js
	const IS_REACT_19_OR_HIGHER = parseInt(react.version, 10) >= 19;
	/**
	* Returns a ref for the React element in a backwards-compatible way.
	*
	* @param element - The element to get the ref for.
	* @returns The ref for the element.
	*/ function getReactElementRef(element) {
		if (!element) return;
		if (IS_REACT_19_OR_HIGHER) return element.props.ref;
		return element.ref;
	}

//#endregion
//#region node_modules/@fluentui/react-utilities/lib/utils/getRTLSafeKey.js
/**
	* @internal
	* Finds and swaps a provided key for it's right to left format.
	*/ const getRTLSafeKey = (key, dir) => {
		if (dir === "rtl") switch (key) {
			case "ArrowLeft": return "ArrowRight";
			case "ArrowRight": return "ArrowLeft";
		}
		return key;
	};

//#endregion
//#region node_modules/@fluentui/react-utilities/lib/utils/mergeCallbacks.js
/**
	* @internal
	* Combine two event callbacks into a single callback function that calls each one in order.
	*
	* Usage example:
	* ```ts
	* state.slot.onChange = mergeCallbacks(state.slot.onChange, ev => {
	*   // Handle onChange
	* });
	* ```
	*
	* The primary use is to avoid the need to capture an existing callback (`state.slot.onChange` in the example) to a
	* local variable before replacing with a new listener that calls the existing one. This helps avoid bugs like:
	* * Infinite recursion by calling the re-assigned state.slot.onChange if it's not captured to a local variable.
	* * Missing a call to the original onChange due to an early return or other conditional.
	*
	* If you need a callback that is stable between renders, wrap the result in {@link useEventCallback}.
	*
	* @param callback1 - The first callback to be called, or undefined
	* @param callback2 - The second callback to be called, or undefined
	*
	* @returns A function that that calls the provided functions in order
	*/ function mergeCallbacks(callback1, callback2) {
		return (...args) => {
			callback1 === null || callback1 === void 0 || callback1(...args);
			callback2 === null || callback2 === void 0 || callback2(...args);
		};
	}

//#endregion
//#region node_modules/@fluentui/react-utilities/lib/utils/isHTMLElement.js
/**
	* Verifies if a given node is an HTMLElement,
	* this method works seamlessly with frames and elements from different documents
	*
	* This is preferred over simply using `instanceof`.
	* Since `instanceof` might be problematic while operating with [multiple realms](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof#instanceof_and_multiple_realms)
	*
	* @example
	* ```ts
	* isHTMLElement(event.target) && event.target.focus()
	* isHTMLElement(event.target, {constructorName: 'HTMLInputElement'}) && event.target.value // some value
	* ```
	*
	*/ function isHTMLElement(element, options) {
		var _typedElement_ownerDocument;
		const typedElement = element;
		var _options_constructorName;
		return Boolean((typedElement === null || typedElement === void 0 ? void 0 : (_typedElement_ownerDocument = typedElement.ownerDocument) === null || _typedElement_ownerDocument === void 0 ? void 0 : _typedElement_ownerDocument.defaultView) && typedElement instanceof typedElement.ownerDocument.defaultView[(_options_constructorName = options === null || options === void 0 ? void 0 : options.constructorName) !== null && _options_constructorName !== void 0 ? _options_constructorName : "HTMLElement"]);
	}

//#endregion
//#region node_modules/@fluentui/react-utilities/lib/utils/isInteractiveHTMLElement.js
/**
	* @internal
	* Checks that the element has default behaviour from user input on click or 'Enter'/'Space' keys
	*/ function isInteractiveHTMLElement(element) {
		if (!isHTMLElement(element)) return false;
		const { tagName } = element;
		switch (tagName) {
			case "BUTTON":
			case "A":
			case "INPUT":
			case "TEXTAREA": return true;
		}
		return element.isContentEditable;
	}

//#endregion
//#region node_modules/@fluentui/react-utilities/lib/utils/priorityQueue.js
/**
	* @internal
	*/
	/**
	* @internal
	* @param compare - comparison function for items
	* @returns Priority queue implemented with a min heap
	*/ function createPriorityQueue$1(compare) {
		const arr = [];
		let size$2 = 0;
		const swap = (a, b) => {
			const tmp = arr[a];
			arr[a] = arr[b];
			arr[b] = tmp;
		};
		const heapify = (i) => {
			let smallest = i;
			const l = left(i);
			const r = right(i);
			if (l < size$2 && compare(arr[l], arr[smallest]) < 0) smallest = l;
			if (r < size$2 && compare(arr[r], arr[smallest]) < 0) smallest = r;
			if (smallest !== i) {
				swap(smallest, i);
				heapify(smallest);
			}
		};
		const dequeue = () => {
			if (size$2 === 0) throw new Error("Priority queue empty");
			const res = arr[0];
			arr[0] = arr[--size$2];
			heapify(0);
			return res;
		};
		const peek$1 = () => {
			if (size$2 === 0) return null;
			return arr[0];
		};
		const enqueue = (item) => {
			arr[size$2++] = item;
			let i = size$2 - 1;
			let p = parent(i);
			while (i > 0 && compare(arr[p], arr[i]) > 0) {
				swap(p, i);
				i = p;
				p = parent(i);
			}
		};
		const contains = (item) => {
			const index = arr.indexOf(item);
			return index >= 0 && index < size$2;
		};
		const remove = (item) => {
			const i = arr.indexOf(item);
			if (i === -1 || i >= size$2) return;
			arr[i] = arr[--size$2];
			heapify(i);
		};
		const clear = () => {
			size$2 = 0;
		};
		const all = () => {
			return arr.slice(0, size$2);
		};
		return {
			all,
			clear,
			contains,
			dequeue,
			enqueue,
			peek: peek$1,
			remove,
			size: () => size$2
		};
	}
	const left = (i) => {
		return 2 * i + 1;
	};
	const right = (i) => {
		return 2 * i + 2;
	};
	const parent = (i) => {
		return Math.floor((i - 1) / 2);
	};

//#endregion
//#region node_modules/@fluentui/react-utilities/lib/trigger/isFluentTrigger.js
/**
	* @internal
	* Checks if a given element is a FluentUI trigger (e.g. `MenuTrigger` or `Tooltip`).
	* See the {@link FluentTriggerComponent} type for more info.
	*/ function isFluentTrigger(element) {
		return Boolean(element.type.isFluentTriggerComponent);
	}

//#endregion
//#region node_modules/@fluentui/react-utilities/lib/trigger/applyTriggerPropsToChildren.js
/**
	* @internal
	* resolve the trigger props to the children, either by calling the render function, or cloning with the new props.
	*/ function applyTriggerPropsToChildren(children, triggerChildProps) {
		if (typeof children === "function") return children(triggerChildProps);
		else if (children) return cloneTriggerTree(children, triggerChildProps);
		return children || null;
	}
	/**
	* Clones a React element tree, and applies the given props to the first grandchild that is not
	* a FluentTriggerComponent or React Fragment (the same element returned by {@link getTriggerChild}).
	*/ function cloneTriggerTree(child, triggerProps) {
		if (!react.isValidElement(child) || child.type === react.Fragment) throw new Error("A trigger element must be a single element for this component. Please ensure that you're not using React Fragments.");
		if (isFluentTrigger(child)) {
			const grandchild = cloneTriggerTree(child.props.children, triggerProps);
			return react.cloneElement(child, void 0, grandchild);
		} else return react.cloneElement(child, triggerProps);
	}

//#endregion
//#region node_modules/@fluentui/react-utilities/lib/trigger/getTriggerChild.js
/**
	* @internal
	* Gets the trigger element of a FluentTriggerComponent (such as Tooltip or MenuTrigger).
	*
	* In the case where the immediate child is itself a FluentTriggerComponent and/or React Fragment,
	* it returns the first descendant that is _not_ a FluentTriggerComponent or Fragment.
	* This allows multiple triggers to be stacked, and still apply their props to the actual trigger element.
	*
	* For example, the following returns `<div id="child" />`:
	* ```jsx
	* getTriggerChild(
	*   <Tooltip>
	*     <MenuTrigger>
	*       <div id="child" />
	*     </MenuTrigger>
	*   </Tooltip>
	* );
	* ```
	*
	* In the case where the immediate child is not a valid element,
	* null is returned
	*/ function getTriggerChild(children) {
		if (!react.isValidElement(children)) return null;
		return isFluentTrigger(children) ? getTriggerChild(children.props.children) : children;
	}

//#endregion
//#region node_modules/@fluentui/react-utilities/lib/events/mouseTouchHelpers.js
/**
	* Returns true if event is a touch event. Useful when sharing logic between touch and mouse interactions.
	*/ function isTouchEvent(event) {
		return event.type.startsWith("touch");
	}
	/**
	* Returns true if event is a mouse event. Useful when sharing logic between touch and mouse interactions.
	*/ function isMouseEvent$1(event) {
		return event.type.startsWith("mouse") || [
			"click",
			"contextmenu",
			"dblclick"
		].indexOf(event.type) > -1;
	}
	/**
	* Returns an object with clientX, clientY for TouchOrMouseEvent.
	* Returns zeros in case the event is not a mouse or a touch event.
	*/ function getEventClientCoords(event) {
		if (isMouseEvent$1(event)) return {
			clientX: event.clientX,
			clientY: event.clientY
		};
		else if (isTouchEvent(event)) return {
			clientX: event.touches[0].clientX,
			clientY: event.touches[0].clientY
		};
		else throw new Error("@fluentui/react-utilities]: Unable to get clientX. Unknown event type.");
	}

//#endregion
//#region node_modules/@fluentui/react-utilities/lib/utils/createSetFromIterable.js
/**
	* Creates a set from a given iterable, in case the iterable is a set itself, returns the given set instead.
	*/ function createSetFromIterable(iterable) {
		return iterable instanceof Set ? iterable : new Set(iterable);
	}

//#endregion
//#region node_modules/@fluentui/react-utilities/lib/selection/useSelection.js
	function useSelectionState(params) {
		const [selected, setSelected] = useControllableState({
			initialState: /* @__PURE__ */ new Set(),
			defaultState: react.useMemo(() => params.defaultSelectedItems && createSetFromIterable(params.defaultSelectedItems), [params.defaultSelectedItems]),
			state: react.useMemo(() => params.selectedItems && createSetFromIterable(params.selectedItems), [params.selectedItems])
		});
		const changeSelection = (event, nextSelectedItems) => {
			var _params_onSelectionChange;
			(_params_onSelectionChange = params.onSelectionChange) === null || _params_onSelectionChange === void 0 || _params_onSelectionChange.call(params, event, { selectedItems: nextSelectedItems });
			setSelected(nextSelectedItems);
		};
		return [selected, changeSelection];
	}
	function useSingleSelection(params) {
		const [selected, changeSelection] = useSelectionState(params);
		return [selected, {
			deselectItem: (event) => changeSelection(event, /* @__PURE__ */ new Set()),
			selectItem: (event, itemId) => changeSelection(event, new Set([itemId])),
			toggleAllItems: () => {
				throw new Error("[react-utilities]: `toggleAllItems` should not be used in single selection mode");
			},
			toggleItem: (event, itemId) => changeSelection(event, new Set([itemId])),
			clearItems: (event) => changeSelection(event, /* @__PURE__ */ new Set()),
			isSelected: (itemId) => {
				var _selected_has;
				return (_selected_has = selected.has(itemId)) !== null && _selected_has !== void 0 ? _selected_has : false;
			}
		}];
	}
	function useMultipleSelection(params) {
		const [selected, changeSelection] = useSelectionState(params);
		return [selected, {
			toggleItem: (event, itemId) => {
				const nextSelectedItems = new Set(selected);
				if (selected.has(itemId)) nextSelectedItems.delete(itemId);
				else nextSelectedItems.add(itemId);
				changeSelection(event, nextSelectedItems);
			},
			selectItem: (event, itemId) => {
				const nextSelectedItems = new Set(selected);
				nextSelectedItems.add(itemId);
				changeSelection(event, nextSelectedItems);
			},
			deselectItem: (event, itemId) => {
				const nextSelectedItems = new Set(selected);
				nextSelectedItems.delete(itemId);
				changeSelection(event, nextSelectedItems);
			},
			clearItems: (event) => {
				changeSelection(event, /* @__PURE__ */ new Set());
			},
			isSelected: (itemId) => selected.has(itemId),
			toggleAllItems: (event, itemIds) => {
				const allItemsSelected = itemIds.every((itemId) => selected.has(itemId));
				const nextSelectedItems = new Set(selected);
				if (allItemsSelected) nextSelectedItems.clear();
				else itemIds.forEach((itemId) => nextSelectedItems.add(itemId));
				changeSelection(event, nextSelectedItems);
			}
		}];
	}
	function useSelection(params) {
		"use no memo";
		if (params.selectionMode === "multiselect") return useMultipleSelection(params);
		return useSingleSelection(params);
	}

//#endregion
//#region node_modules/@fluentui/react-utilities/lib/virtualParent/isVirtualElement.js
/**
	* Determines whether or not an element has the virtual hierarchy extension.
	* @internal
	*/ function isVirtualElement(element) {
		return element && !!element._virtual;
	}

//#endregion
//#region node_modules/@fluentui/react-utilities/lib/virtualParent/getParent.js
/**
	* Gets the virtual parent given the child element, if it exists.
	* @internal
	*/ function getVirtualParent(child) {
		return isVirtualElement(child) ? child._virtual.parent || null : null;
	}
	/**
	* Gets the element which is the parent of a given element.
	* This method prefers the virtual parent over real DOM parent when present.
	* @internal
	*/ function getParent(child, options = {}) {
		if (!child) return null;
		if (!options.skipVirtual) {
			const virtualParent = getVirtualParent(child);
			if (virtualParent) return virtualParent;
		}
		const parent$1 = child.parentNode;
		if (parent$1 && parent$1.nodeType === 11) return parent$1.host;
		return parent$1;
	}

//#endregion
//#region node_modules/@fluentui/react-utilities/lib/virtualParent/elementContains.js
/**
	* Similar functionality to `element.contains` DOM API for use without of order DOM elements that
	* checks the virtual parent hierarchy. If a virtual parents exists, it is chosen over the actual parent
	*
	* @internal
	* @returns true if the child can find the parent in its virtual hierarchy
	*/ function elementContains(parent$1, child) {
		if (!parent$1 || !child) return false;
		if (parent$1 === child) return true;
		else {
			const set = /* @__PURE__ */ new WeakSet();
			while (child) {
				const nextParent = getParent(child, { skipVirtual: set.has(child) });
				set.add(child);
				if (nextParent === parent$1) return true;
				child = nextParent;
			}
		}
		return false;
	}

//#endregion
//#region node_modules/@fluentui/react-utilities/lib/virtualParent/setVirtualParent.js
/**
	* Sets the virtual parent of an element.
	*
	* @internal
	* @param child - Theme element to set the virtual parent
	* @param parent - The virtual parent, use `undefined` to remove a virtual parent relationship
	*/ function setVirtualParent(child, parent$1) {
		if (!child) return;
		Object.assign(child, { _virtual: { parent: parent$1 } });
	}

//#endregion
//#region node_modules/@fluentui/react-jsx-runtime/lib/utils/createCompatSlotComponent.js
	function createCompatSlotComponent(type, props) {
		return {
			...props,
			[SLOT_ELEMENT_TYPE_SYMBOL]: type
		};
	}

//#endregion
//#region node_modules/react-is/cjs/react-is.development.js
/** @license React v17.0.2
	* react-is.development.js
	*
	* Copyright (c) Facebook, Inc. and its affiliates.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	var require_react_is_development = /* @__PURE__ */ __commonJSMin(((exports) => {
		(function() {
			"use strict";
			var REACT_ELEMENT_TYPE = 60103;
			var REACT_PORTAL_TYPE = 60106;
			var REACT_FRAGMENT_TYPE = 60107;
			var REACT_STRICT_MODE_TYPE = 60108;
			var REACT_PROFILER_TYPE = 60114;
			var REACT_PROVIDER_TYPE = 60109;
			var REACT_CONTEXT_TYPE = 60110;
			var REACT_FORWARD_REF_TYPE = 60112;
			var REACT_SUSPENSE_TYPE = 60113;
			var REACT_SUSPENSE_LIST_TYPE = 60120;
			var REACT_MEMO_TYPE = 60115;
			var REACT_LAZY_TYPE = 60116;
			var REACT_BLOCK_TYPE = 60121;
			var REACT_SERVER_BLOCK_TYPE = 60122;
			var REACT_FUNDAMENTAL_TYPE = 60117;
			var REACT_DEBUG_TRACING_MODE_TYPE = 60129;
			var REACT_LEGACY_HIDDEN_TYPE = 60131;
			if (typeof Symbol === "function" && Symbol.for) {
				var symbolFor = Symbol.for;
				REACT_ELEMENT_TYPE = symbolFor("react.element");
				REACT_PORTAL_TYPE = symbolFor("react.portal");
				REACT_FRAGMENT_TYPE = symbolFor("react.fragment");
				REACT_STRICT_MODE_TYPE = symbolFor("react.strict_mode");
				REACT_PROFILER_TYPE = symbolFor("react.profiler");
				REACT_PROVIDER_TYPE = symbolFor("react.provider");
				REACT_CONTEXT_TYPE = symbolFor("react.context");
				REACT_FORWARD_REF_TYPE = symbolFor("react.forward_ref");
				REACT_SUSPENSE_TYPE = symbolFor("react.suspense");
				REACT_SUSPENSE_LIST_TYPE = symbolFor("react.suspense_list");
				REACT_MEMO_TYPE = symbolFor("react.memo");
				REACT_LAZY_TYPE = symbolFor("react.lazy");
				REACT_BLOCK_TYPE = symbolFor("react.block");
				REACT_SERVER_BLOCK_TYPE = symbolFor("react.server.block");
				REACT_FUNDAMENTAL_TYPE = symbolFor("react.fundamental");
				symbolFor("react.scope");
				symbolFor("react.opaque.id");
				REACT_DEBUG_TRACING_MODE_TYPE = symbolFor("react.debug_trace_mode");
				symbolFor("react.offscreen");
				REACT_LEGACY_HIDDEN_TYPE = symbolFor("react.legacy_hidden");
			}
			var enableScopeAPI = false;
			function isValidElementType$1(type) {
				if (typeof type === "string" || typeof type === "function") return true;
				if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI) return true;
				if (typeof type === "object" && type !== null) {
					if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) return true;
				}
				return false;
			}
			function typeOf(object) {
				if (typeof object === "object" && object !== null) {
					var $$typeof = object.$$typeof;
					switch ($$typeof) {
						case REACT_ELEMENT_TYPE:
							var type = object.type;
							switch (type) {
								case REACT_FRAGMENT_TYPE:
								case REACT_PROFILER_TYPE:
								case REACT_STRICT_MODE_TYPE:
								case REACT_SUSPENSE_TYPE:
								case REACT_SUSPENSE_LIST_TYPE: return type;
								default:
									var $$typeofType = type && type.$$typeof;
									switch ($$typeofType) {
										case REACT_CONTEXT_TYPE:
										case REACT_FORWARD_REF_TYPE:
										case REACT_LAZY_TYPE:
										case REACT_MEMO_TYPE:
										case REACT_PROVIDER_TYPE: return $$typeofType;
										default: return $$typeof;
									}
							}
						case REACT_PORTAL_TYPE: return $$typeof;
					}
				}
			}
			var ContextConsumer = REACT_CONTEXT_TYPE;
			var ContextProvider = REACT_PROVIDER_TYPE;
			var Element$1 = REACT_ELEMENT_TYPE;
			var ForwardRef = REACT_FORWARD_REF_TYPE;
			var Fragment$1 = REACT_FRAGMENT_TYPE;
			var Lazy = REACT_LAZY_TYPE;
			var Memo = REACT_MEMO_TYPE;
			var Portal$1 = REACT_PORTAL_TYPE;
			var Profiler = REACT_PROFILER_TYPE;
			var StrictMode = REACT_STRICT_MODE_TYPE;
			var Suspense = REACT_SUSPENSE_TYPE;
			var hasWarnedAboutDeprecatedIsAsyncMode = false;
			var hasWarnedAboutDeprecatedIsConcurrentMode = false;
			function isAsyncMode(object) {
				if (!hasWarnedAboutDeprecatedIsAsyncMode) {
					hasWarnedAboutDeprecatedIsAsyncMode = true;
					console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.");
				}
				return false;
			}
			function isConcurrentMode(object) {
				if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
					hasWarnedAboutDeprecatedIsConcurrentMode = true;
					console["warn"]("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.");
				}
				return false;
			}
			function isContextConsumer(object) {
				return typeOf(object) === REACT_CONTEXT_TYPE;
			}
			function isContextProvider(object) {
				return typeOf(object) === REACT_PROVIDER_TYPE;
			}
			function isElement$1(object) {
				return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
			}
			function isForwardRef(object) {
				return typeOf(object) === REACT_FORWARD_REF_TYPE;
			}
			function isFragment(object) {
				return typeOf(object) === REACT_FRAGMENT_TYPE;
			}
			function isLazy(object) {
				return typeOf(object) === REACT_LAZY_TYPE;
			}
			function isMemo(object) {
				return typeOf(object) === REACT_MEMO_TYPE;
			}
			function isPortal(object) {
				return typeOf(object) === REACT_PORTAL_TYPE;
			}
			function isProfiler(object) {
				return typeOf(object) === REACT_PROFILER_TYPE;
			}
			function isStrictMode(object) {
				return typeOf(object) === REACT_STRICT_MODE_TYPE;
			}
			function isSuspense(object) {
				return typeOf(object) === REACT_SUSPENSE_TYPE;
			}
			exports.ContextConsumer = ContextConsumer;
			exports.ContextProvider = ContextProvider;
			exports.Element = Element$1;
			exports.ForwardRef = ForwardRef;
			exports.Fragment = Fragment$1;
			exports.Lazy = Lazy;
			exports.Memo = Memo;
			exports.Portal = Portal$1;
			exports.Profiler = Profiler;
			exports.StrictMode = StrictMode;
			exports.Suspense = Suspense;
			exports.isAsyncMode = isAsyncMode;
			exports.isConcurrentMode = isConcurrentMode;
			exports.isContextConsumer = isContextConsumer;
			exports.isContextProvider = isContextProvider;
			exports.isElement = isElement$1;
			exports.isForwardRef = isForwardRef;
			exports.isFragment = isFragment;
			exports.isLazy = isLazy;
			exports.isMemo = isMemo;
			exports.isPortal = isPortal;
			exports.isProfiler = isProfiler;
			exports.isStrictMode = isStrictMode;
			exports.isSuspense = isSuspense;
			exports.isValidElementType = isValidElementType$1;
			exports.typeOf = typeOf;
		})();
	}));

//#endregion
//#region node_modules/react-is/index.js
	var require_react_is = /* @__PURE__ */ __commonJSMin(((exports, module) => {
		module.exports = require_react_is_development();
	}));

//#endregion
//#region node_modules/@fluentui/react-jsx-runtime/lib/utils/warnIfElementTypeIsInvalid.js
	var import_react_is = require_react_is();
	function warnIfElementTypeIsInvalid(type) {
		if (typeof type === "object" && !(0, import_react_is.isValidElementType)(type)) console.error(`@fluentui/react-jsx-runtime:
Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: ${type}.

If this happened in a slot of Fluent UI component, you might be facing package resolution issues.
Please make sure you don't have multiple versions of "@fluentui/react-utilities" installed in your dependencies or sub-dependencies.
You can check this by searching up for matching entries in a lockfile produced by your package manager (yarn.lock, pnpm-lock.yaml or package-lock.json).`);
	}

//#endregion
//#region node_modules/@fluentui/react-jsx-runtime/lib/jsx/createJSX.js
	function createJSX(runtime, slotRuntime) {
		return function jsx$1(type, overrideProps, key, source, self) {
			if (isSlot(overrideProps)) return slotRuntime(createCompatSlotComponent(type, overrideProps), null, key, source, self);
			if (isSlot(type)) return slotRuntime(type, overrideProps, key, source, self);
			warnIfElementTypeIsInvalid(type);
			return runtime(type, overrideProps, key, source, self);
		};
	}

//#endregion
//#region node_modules/@fluentui/react-jsx-runtime/lib/utils/getMetadataFromSlotComponent.js
/**
	* @internal
	*/ function getMetadataFromSlotComponent(type) {
		const { as, [SLOT_CLASS_NAME_PROP_SYMBOL]: _classNameProp, [SLOT_ELEMENT_TYPE_SYMBOL]: baseElementType, [SLOT_RENDER_FUNCTION_SYMBOL]: renderFunction, ...propsWithoutMetadata } = type;
		const props = propsWithoutMetadata;
		const elementType = typeof baseElementType === "string" ? as !== null && as !== void 0 ? as : baseElementType : baseElementType;
		if (typeof elementType !== "string" && as) props.as = as;
		return {
			elementType,
			props,
			renderFunction
		};
	}

//#endregion
//#region node_modules/@fluentui/react-jsx-runtime/lib/utils/Runtime.js
	const Runtime = react_jsx_runtime;

//#endregion
//#region node_modules/@fluentui/react-jsx-runtime/lib/jsx/jsxSlot.js
	const jsxSlot = (type, overrideProps, key) => {
		const { elementType, renderFunction, props: slotProps } = getMetadataFromSlotComponent(type);
		const props = {
			...slotProps,
			...overrideProps
		};
		if (renderFunction) return Runtime.jsx(react.Fragment, { children: renderFunction(elementType, props) }, key);
		return Runtime.jsx(elementType, props, key);
	};

//#endregion
//#region node_modules/@fluentui/react-jsx-runtime/lib/jsx/jsxsSlot.js
	const jsxsSlot = (type, overrideProps, key) => {
		const { elementType, renderFunction, props: slotProps } = getMetadataFromSlotComponent(type);
		const props = {
			...slotProps,
			...overrideProps
		};
		if (renderFunction)
 /**
		* In static runtime then children is an array and this array won't be keyed.
		* We should wrap children by a static fragment
		* as there's no way to know if renderFunction will render statically or dynamically
		*/ return Runtime.jsx(react.Fragment, { children: renderFunction(elementType, {
			...props,
			children: Runtime.jsxs(react.Fragment, { children: props.children }, void 0)
		}) }, key);
		return Runtime.jsxs(elementType, props, key);
	};

//#endregion
//#region node_modules/@fluentui/react-jsx-runtime/lib/jsx-runtime.js
	const jsx = createJSX(Runtime.jsx, jsxSlot);
	const jsxs = createJSX(Runtime.jsxs, jsxsSlot);

//#endregion
//#region node_modules/@fluentui/react-icons/lib/contexts/IconDirectionContext.js
	const IconDirectionContext = react.createContext(void 0);
	const IconDirectionContextDefaultValue = {};
	const IconDirectionContextProvider = IconDirectionContext.Provider;
	const useIconContext = () => {
		const context = react.useContext(IconDirectionContext);
		return context !== null && context !== void 0 ? context : IconDirectionContextDefaultValue;
	};

//#endregion
//#region node_modules/@fluentui/react-provider/lib/components/FluentProvider/renderFluentProvider.js
/**
	* Render the final JSX of FluentProvider
	*/ const renderFluentProvider_unstable = (state, contextValues) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(Provider, {
			value: contextValues.provider,
			children: /* @__PURE__ */ jsx(ThemeProvider, {
				value: contextValues.theme,
				children: /* @__PURE__ */ jsx(ThemeClassNameProvider, {
					value: contextValues.themeClassName,
					children: /* @__PURE__ */ jsx(CustomStyleHooksProvider, {
						value: contextValues.customStyleHooks_unstable,
						children: /* @__PURE__ */ jsx(TooltipVisibilityProvider, {
							value: contextValues.tooltip,
							children: /* @__PURE__ */ jsx(TextDirectionProvider, {
								dir: contextValues.textDirection,
								children: /* @__PURE__ */ jsx(IconDirectionContextProvider, {
									value: contextValues.iconDirection,
									children: /* @__PURE__ */ jsx(OverridesProvider, {
										value: contextValues.overrides_unstable,
										children: /* @__PURE__ */ jsxs(state.root, { children: [canUseDOM() ? null : /* @__PURE__ */ jsx("style", {
											dangerouslySetInnerHTML: { __html: state.serverStyleProps.cssRule },
											...state.serverStyleProps.attributes
										}), state.root.children] })
									})
								})
							})
						})
					})
				})
			})
		});
	};

//#endregion
//#region node_modules/keyborg/dist/esm/index.js
	var _canUseWeakRef = typeof WeakRef !== "undefined";
	var WeakRefInstance = class {
		constructor(instance) {
			if (_canUseWeakRef && typeof instance === "object") this._weakRef = new WeakRef(instance);
			else this._instance = instance;
		}
		/**
		* @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef/deref}
		*/
		deref() {
			var _a, _b;
			let instance;
			if (this._weakRef) {
				instance = (_a = this._weakRef) == null ? void 0 : _a.deref();
				if (!instance) delete this._weakRef;
			} else {
				instance = this._instance;
				if ((_b = instance == null ? void 0 : instance.isDisposed) == null ? void 0 : _b.call(instance)) delete this._instance;
			}
			return instance;
		}
	};
	var KEYBORG_FOCUSIN = "keyborg:focusin";
	var KEYBORG_FOCUSOUT = "keyborg:focusout";
	function canOverrideNativeFocus(win) {
		const HTMLElement$1 = win.HTMLElement;
		const origFocus = HTMLElement$1.prototype.focus;
		let isCustomFocusCalled = false;
		HTMLElement$1.prototype.focus = function focus() {
			isCustomFocusCalled = true;
		};
		win.document.createElement("button").focus();
		HTMLElement$1.prototype.focus = origFocus;
		return isCustomFocusCalled;
	}
	var _canOverrideNativeFocus = false;
	function nativeFocus(element) {
		const focus = element.focus;
		if (focus.__keyborgNativeFocus) focus.__keyborgNativeFocus.call(element);
		else element.focus();
	}
	function setupFocusEvent(win) {
		const kwin = win;
		if (!_canOverrideNativeFocus) _canOverrideNativeFocus = canOverrideNativeFocus(kwin);
		const origFocus = kwin.HTMLElement.prototype.focus;
		if (origFocus.__keyborgNativeFocus) return;
		kwin.HTMLElement.prototype.focus = focus;
		const shadowTargets = /* @__PURE__ */ new Set();
		const focusOutHandler = (e) => {
			const target = e.target;
			if (!target) return;
			const event = new CustomEvent(KEYBORG_FOCUSOUT, {
				cancelable: true,
				bubbles: true,
				composed: true,
				detail: { originalEvent: e }
			});
			target.dispatchEvent(event);
		};
		const focusInHandler = (e) => {
			const target = e.target;
			if (!target) return;
			let node$1 = e.composedPath()[0];
			const currentShadows = /* @__PURE__ */ new Set();
			while (node$1) if (node$1.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
				currentShadows.add(node$1);
				node$1 = node$1.host;
			} else node$1 = node$1.parentNode;
			for (const shadowRootWeakRef of shadowTargets) {
				const shadowRoot = shadowRootWeakRef.deref();
				if (!shadowRoot || !currentShadows.has(shadowRoot)) {
					shadowTargets.delete(shadowRootWeakRef);
					if (shadowRoot) {
						shadowRoot.removeEventListener("focusin", focusInHandler, true);
						shadowRoot.removeEventListener("focusout", focusOutHandler, true);
					}
				}
			}
			onFocusIn(target, e.relatedTarget || void 0);
		};
		const onFocusIn = (target, relatedTarget, originalEvent) => {
			var _a;
			const shadowRoot = target.shadowRoot;
			if (shadowRoot) {
				for (const shadowRootWeakRef of shadowTargets) if (shadowRootWeakRef.deref() === shadowRoot) return;
				shadowRoot.addEventListener("focusin", focusInHandler, true);
				shadowRoot.addEventListener("focusout", focusOutHandler, true);
				shadowTargets.add(new WeakRefInstance(shadowRoot));
				return;
			}
			const details = {
				relatedTarget,
				originalEvent
			};
			const event = new CustomEvent(KEYBORG_FOCUSIN, {
				cancelable: true,
				bubbles: true,
				composed: true,
				detail: details
			});
			event.details = details;
			if (_canOverrideNativeFocus || data.lastFocusedProgrammatically) {
				details.isFocusedProgrammatically = target === ((_a = data.lastFocusedProgrammatically) == null ? void 0 : _a.deref());
				data.lastFocusedProgrammatically = void 0;
			}
			target.dispatchEvent(event);
		};
		const data = kwin.__keyborgData = {
			focusInHandler,
			focusOutHandler,
			shadowTargets
		};
		kwin.document.addEventListener("focusin", kwin.__keyborgData.focusInHandler, true);
		kwin.document.addEventListener("focusout", kwin.__keyborgData.focusOutHandler, true);
		function focus() {
			const keyborgNativeFocusEvent = kwin.__keyborgData;
			if (keyborgNativeFocusEvent) keyborgNativeFocusEvent.lastFocusedProgrammatically = new WeakRefInstance(this);
			return origFocus.apply(this, arguments);
		}
		let activeElement = kwin.document.activeElement;
		while (activeElement && activeElement.shadowRoot) {
			onFocusIn(activeElement);
			activeElement = activeElement.shadowRoot.activeElement;
		}
		focus.__keyborgNativeFocus = origFocus;
	}
	function disposeFocusEvent(win) {
		const kwin = win;
		const proto = kwin.HTMLElement.prototype;
		const origFocus = proto.focus.__keyborgNativeFocus;
		const keyborgNativeFocusEvent = kwin.__keyborgData;
		if (keyborgNativeFocusEvent) {
			kwin.document.removeEventListener("focusin", keyborgNativeFocusEvent.focusInHandler, true);
			kwin.document.removeEventListener("focusout", keyborgNativeFocusEvent.focusOutHandler, true);
			for (const shadowRootWeakRef of keyborgNativeFocusEvent.shadowTargets) {
				const shadowRoot = shadowRootWeakRef.deref();
				if (shadowRoot) {
					shadowRoot.removeEventListener("focusin", keyborgNativeFocusEvent.focusInHandler, true);
					shadowRoot.removeEventListener("focusout", keyborgNativeFocusEvent.focusOutHandler, true);
				}
			}
			keyborgNativeFocusEvent.shadowTargets.clear();
			delete kwin.__keyborgData;
		}
		if (origFocus) proto.focus = origFocus;
	}
	var _dismissTimeout = 500;
	var _lastId = 0;
	var KeyborgCore = class {
		constructor(win, props) {
			this._isNavigatingWithKeyboard_DO_NOT_USE = false;
			this._onFocusIn = (e) => {
				if (this._isMouseOrTouchUsedTimer) return;
				if (this.isNavigatingWithKeyboard) return;
				const details = e.detail;
				if (!details.relatedTarget) return;
				if (details.isFocusedProgrammatically || details.isFocusedProgrammatically === void 0) return;
				this.isNavigatingWithKeyboard = true;
			};
			this._onMouseDown = (e) => {
				if (e.buttons === 0 || e.clientX === 0 && e.clientY === 0 && e.screenX === 0 && e.screenY === 0) return;
				this._onMouseOrTouch();
			};
			this._onMouseOrTouch = () => {
				const win$1 = this._win;
				if (win$1) {
					if (this._isMouseOrTouchUsedTimer) win$1.clearTimeout(this._isMouseOrTouchUsedTimer);
					this._isMouseOrTouchUsedTimer = win$1.setTimeout(() => {
						delete this._isMouseOrTouchUsedTimer;
					}, 1e3);
				}
				this.isNavigatingWithKeyboard = false;
			};
			this._onKeyDown = (e) => {
				if (this.isNavigatingWithKeyboard) {
					if (this._shouldDismissKeyboardNavigation(e)) this._scheduleDismiss();
				} else if (this._shouldTriggerKeyboardNavigation(e)) this.isNavigatingWithKeyboard = true;
			};
			this.id = "c" + ++_lastId;
			this._win = win;
			const doc = win.document;
			if (props) {
				const triggerKeys = props.triggerKeys;
				const dismissKeys = props.dismissKeys;
				if (triggerKeys == null ? void 0 : triggerKeys.length) this._triggerKeys = new Set(triggerKeys);
				if (dismissKeys == null ? void 0 : dismissKeys.length) this._dismissKeys = new Set(dismissKeys);
			}
			doc.addEventListener(KEYBORG_FOCUSIN, this._onFocusIn, true);
			doc.addEventListener("mousedown", this._onMouseDown, true);
			win.addEventListener("keydown", this._onKeyDown, true);
			doc.addEventListener("touchstart", this._onMouseOrTouch, true);
			doc.addEventListener("touchend", this._onMouseOrTouch, true);
			doc.addEventListener("touchcancel", this._onMouseOrTouch, true);
			setupFocusEvent(win);
		}
		get isNavigatingWithKeyboard() {
			return this._isNavigatingWithKeyboard_DO_NOT_USE;
		}
		set isNavigatingWithKeyboard(val) {
			if (this._isNavigatingWithKeyboard_DO_NOT_USE !== val) {
				this._isNavigatingWithKeyboard_DO_NOT_USE = val;
				this.update();
			}
		}
		dispose() {
			const win = this._win;
			if (win) {
				if (this._isMouseOrTouchUsedTimer) {
					win.clearTimeout(this._isMouseOrTouchUsedTimer);
					this._isMouseOrTouchUsedTimer = void 0;
				}
				if (this._dismissTimer) {
					win.clearTimeout(this._dismissTimer);
					this._dismissTimer = void 0;
				}
				disposeFocusEvent(win);
				const doc = win.document;
				doc.removeEventListener(KEYBORG_FOCUSIN, this._onFocusIn, true);
				doc.removeEventListener("mousedown", this._onMouseDown, true);
				win.removeEventListener("keydown", this._onKeyDown, true);
				doc.removeEventListener("touchstart", this._onMouseOrTouch, true);
				doc.removeEventListener("touchend", this._onMouseOrTouch, true);
				doc.removeEventListener("touchcancel", this._onMouseOrTouch, true);
				delete this._win;
			}
		}
		isDisposed() {
			return !!this._win;
		}
		/**
		* Updates all keyborg instances with the keyboard navigation state
		*/
		update() {
			var _a, _b;
			const keyborgs = (_b = (_a = this._win) == null ? void 0 : _a.__keyborg) == null ? void 0 : _b.refs;
			if (keyborgs) for (const id of Object.keys(keyborgs)) Keyborg.update(keyborgs[id], this.isNavigatingWithKeyboard);
		}
		/**
		* @returns whether the keyboard event should trigger keyboard navigation mode
		*/
		_shouldTriggerKeyboardNavigation(e) {
			var _a;
			if (e.key === "Tab") return true;
			const activeElement = (_a = this._win) == null ? void 0 : _a.document.activeElement;
			const isTriggerKey = !this._triggerKeys || this._triggerKeys.has(e.keyCode);
			const isEditable = activeElement && (activeElement.tagName === "INPUT" || activeElement.tagName === "TEXTAREA" || activeElement.isContentEditable);
			return isTriggerKey && !isEditable;
		}
		/**
		* @returns whether the keyboard event should dismiss keyboard navigation mode
		*/
		_shouldDismissKeyboardNavigation(e) {
			var _a;
			return (_a = this._dismissKeys) == null ? void 0 : _a.has(e.keyCode);
		}
		_scheduleDismiss() {
			const win = this._win;
			if (win) {
				if (this._dismissTimer) {
					win.clearTimeout(this._dismissTimer);
					this._dismissTimer = void 0;
				}
				const was = win.document.activeElement;
				this._dismissTimer = win.setTimeout(() => {
					this._dismissTimer = void 0;
					const cur = win.document.activeElement;
					if (was && cur && was === cur) this.isNavigatingWithKeyboard = false;
				}, _dismissTimeout);
			}
		}
	};
	var Keyborg = class _Keyborg {
		constructor(win, props) {
			this._cb = [];
			this._id = "k" + ++_lastId;
			this._win = win;
			const current = win.__keyborg;
			if (current) {
				this._core = current.core;
				current.refs[this._id] = this;
			} else {
				this._core = new KeyborgCore(win, props);
				win.__keyborg = {
					core: this._core,
					refs: { [this._id]: this }
				};
			}
		}
		static create(win, props) {
			return new _Keyborg(win, props);
		}
		static dispose(instance) {
			instance.dispose();
		}
		/**
		* Updates all subscribed callbacks with the keyboard navigation state
		*/
		static update(instance, isNavigatingWithKeyboard) {
			instance._cb.forEach((callback) => callback(isNavigatingWithKeyboard));
		}
		dispose() {
			var _a;
			const current = (_a = this._win) == null ? void 0 : _a.__keyborg;
			if (current == null ? void 0 : current.refs[this._id]) {
				delete current.refs[this._id];
				if (Object.keys(current.refs).length === 0) {
					current.core.dispose();
					delete this._win.__keyborg;
				}
			} else console.error(`Keyborg instance ${this._id} is being disposed incorrectly.`);
			this._cb = [];
			delete this._core;
			delete this._win;
		}
		/**
		* @returns Whether the user is navigating with keyboard
		*/
		isNavigatingWithKeyboard() {
			var _a;
			return !!((_a = this._core) == null ? void 0 : _a.isNavigatingWithKeyboard);
		}
		/**
		* @param callback - Called when the keyboard navigation state changes
		*/
		subscribe(callback) {
			this._cb.push(callback);
		}
		/**
		* @param callback - Registered with subscribe
		*/
		unsubscribe(callback) {
			const index = this._cb.indexOf(callback);
			if (index >= 0) this._cb.splice(index, 1);
		}
		/**
		* Manually set the keyboard navigtion state
		*/
		setVal(isNavigatingWithKeyboard) {
			if (this._core) this._core.isNavigatingWithKeyboard = isNavigatingWithKeyboard;
		}
	};
	function createKeyborg(win, props) {
		return Keyborg.create(win, props);
	}
	function disposeKeyborg(instance) {
		Keyborg.dispose(instance);
	}
	/*!
	* Copyright (c) Microsoft Corporation. All rights reserved.
	* Licensed under the MIT License.
	*/

//#endregion
//#region node_modules/tabster/dist/tabster.esm.js
/*!
	* Copyright (c) Microsoft Corporation. All rights reserved.
	* Licensed under the MIT License.
	*/
	const TABSTER_ATTRIBUTE_NAME = "data-tabster";
	const TABSTER_DUMMY_INPUT_ATTRIBUTE_NAME = "data-tabster-dummy";
	const FOCUSABLE_SELECTOR = `:is(${/* @__PURE__ */ [
		"a[href]",
		"button",
		"input",
		"select",
		"textarea",
		"*[tabindex]",
		"*[contenteditable]",
		"details > summary",
		"audio[controls]",
		"video[controls]"
	].join(", ")}):not(:disabled)`;
	const AsyncFocusSources = {
		EscapeGroupper: 1,
		Restorer: 2,
		Deloser: 3
	};
	const ObservedElementAccessibilities = {
		Any: 0,
		Accessible: 1,
		Focusable: 2
	};
	const ObservedElementRequestStatuses = {
		Waiting: 0,
		Succeeded: 1,
		Canceled: 2,
		TimedOut: 3
	};
	const Visibilities = {
		Invisible: 0,
		PartiallyVisible: 1,
		Visible: 2
	};
	const RestorerTypes = {
		Source: 0,
		Target: 1
	};
	const MoverDirections = {
		Both: 0,
		Vertical: 1,
		Horizontal: 2,
		Grid: 3,
		GridLinear: 4
	};
	const MoverKeys = {
		ArrowUp: 1,
		ArrowDown: 2,
		ArrowLeft: 3,
		ArrowRight: 4,
		PageUp: 5,
		PageDown: 6,
		Home: 7,
		End: 8
	};
	const GroupperTabbabilities = {
		Unlimited: 0,
		Limited: 1,
		LimitedTrapFocus: 2
	};
	const GroupperMoveFocusActions = {
		Enter: 1,
		Escape: 2
	};
	const SysDummyInputsPositions = {
		Auto: 0,
		Inside: 1,
		Outside: 2
	};
	/*!
	* Copyright (c) Microsoft Corporation. All rights reserved.
	* Licensed under the MIT License.
	*/
	function getTabsterOnElement(tabster, element) {
		var _a;
		return (_a = tabster.storageEntry(element)) === null || _a === void 0 ? void 0 : _a.tabster;
	}
	function updateTabsterByAttribute(tabster, element, dispose) {
		var _a, _b, _c;
		const newAttrValue = dispose || tabster._noop ? void 0 : element.getAttribute(TABSTER_ATTRIBUTE_NAME);
		let entry = tabster.storageEntry(element);
		let newAttr;
		if (newAttrValue) if (newAttrValue !== ((_a = entry === null || entry === void 0 ? void 0 : entry.attr) === null || _a === void 0 ? void 0 : _a.string)) try {
			const newValue = JSON.parse(newAttrValue);
			if (typeof newValue !== "object") throw new Error(`Value is not a JSON object, got '${newAttrValue}'.`);
			newAttr = {
				string: newAttrValue,
				object: newValue
			};
		} catch (e) {
			console.error(`data-tabster attribute error: ${e}`, element);
		}
		else return;
		else if (!entry) return;
		if (!entry) entry = tabster.storageEntry(element, true);
		if (!entry.tabster) entry.tabster = {};
		const tabsterOnElement = entry.tabster || {};
		const oldTabsterProps = ((_b = entry.attr) === null || _b === void 0 ? void 0 : _b.object) || {};
		const newTabsterProps = (newAttr === null || newAttr === void 0 ? void 0 : newAttr.object) || {};
		for (const key of Object.keys(oldTabsterProps)) if (!newTabsterProps[key]) {
			if (key === "root") {
				const root = tabsterOnElement[key];
				if (root) tabster.root.onRoot(root, true);
			}
			switch (key) {
				case "deloser":
				case "root":
				case "groupper":
				case "modalizer":
				case "restorer":
				case "mover":
					const part = tabsterOnElement[key];
					if (part) {
						part.dispose();
						delete tabsterOnElement[key];
					}
					break;
				case "observed":
					delete tabsterOnElement[key];
					if (tabster.observedElement) tabster.observedElement.onObservedElementUpdate(element);
					break;
				case "focusable":
				case "outline":
				case "uncontrolled":
				case "sys":
					delete tabsterOnElement[key];
					break;
			}
		}
		for (const key of Object.keys(newTabsterProps)) {
			const sys = newTabsterProps.sys;
			switch (key) {
				case "deloser":
					if (tabsterOnElement.deloser) tabsterOnElement.deloser.setProps(newTabsterProps.deloser);
					else if (tabster.deloser) tabsterOnElement.deloser = tabster.deloser.createDeloser(element, newTabsterProps.deloser);
					else console.error("Deloser API used before initialization, please call `getDeloser()`");
					break;
				case "root":
					if (tabsterOnElement.root) tabsterOnElement.root.setProps(newTabsterProps.root);
					else tabsterOnElement.root = tabster.root.createRoot(element, newTabsterProps.root, sys);
					tabster.root.onRoot(tabsterOnElement.root);
					break;
				case "modalizer":
					{
						let newModalizerProps;
						const modalizerAPI = tabster.modalizer;
						if (tabsterOnElement.modalizer) {
							const props = newTabsterProps.modalizer;
							const newModalizerId = props.id;
							if (newModalizerId && ((_c = oldTabsterProps === null || oldTabsterProps === void 0 ? void 0 : oldTabsterProps.modalizer) === null || _c === void 0 ? void 0 : _c.id) !== newModalizerId) {
								tabsterOnElement.modalizer.dispose();
								newModalizerProps = props;
							} else tabsterOnElement.modalizer.setProps(props);
						} else if (modalizerAPI) newModalizerProps = newTabsterProps.modalizer;
						else console.error("Modalizer API used before initialization, please call `getModalizer()`");
						if (modalizerAPI && newModalizerProps) tabsterOnElement.modalizer = modalizerAPI.createModalizer(element, newModalizerProps, sys);
					}
					break;
				case "restorer":
					if (tabsterOnElement.restorer) tabsterOnElement.restorer.setProps(newTabsterProps.restorer);
					else if (tabster.restorer) {
						if (newTabsterProps.restorer) tabsterOnElement.restorer = tabster.restorer.createRestorer(element, newTabsterProps.restorer);
					} else console.error("Restorer API used before initialization, please call `getRestorer()`");
					break;
				case "focusable":
					tabsterOnElement.focusable = newTabsterProps.focusable;
					break;
				case "groupper":
					if (tabsterOnElement.groupper) tabsterOnElement.groupper.setProps(newTabsterProps.groupper);
					else if (tabster.groupper) tabsterOnElement.groupper = tabster.groupper.createGroupper(element, newTabsterProps.groupper, sys);
					else console.error("Groupper API used before initialization, please call `getGroupper()`");
					break;
				case "mover":
					if (tabsterOnElement.mover) tabsterOnElement.mover.setProps(newTabsterProps.mover);
					else if (tabster.mover) tabsterOnElement.mover = tabster.mover.createMover(element, newTabsterProps.mover, sys);
					else console.error("Mover API used before initialization, please call `getMover()`");
					break;
				case "observed":
					if (tabster.observedElement) {
						tabsterOnElement.observed = newTabsterProps.observed;
						tabster.observedElement.onObservedElementUpdate(element);
					} else console.error("ObservedElement API used before initialization, please call `getObservedElement()`");
					break;
				case "uncontrolled":
					tabsterOnElement.uncontrolled = newTabsterProps.uncontrolled;
					break;
				case "outline":
					if (tabster.outline) tabsterOnElement.outline = newTabsterProps.outline;
					else console.error("Outline API used before initialization, please call `getOutline()`");
					break;
				case "sys":
					tabsterOnElement.sys = newTabsterProps.sys;
					break;
				default: console.error(`Unknown key '${key}' in data-tabster attribute value.`);
			}
		}
		if (newAttr) entry.attr = newAttr;
		else {
			if (Object.keys(tabsterOnElement).length === 0) {
				delete entry.tabster;
				delete entry.attr;
			}
			tabster.storageEntry(element, false);
		}
	}
	/*!
	* Copyright (c) Microsoft Corporation. All rights reserved.
	* Licensed under the MIT License.
	*/
	/**
	* Events sent by Tabster.
	*/
	const TabsterFocusInEventName = "tabster:focusin";
	const TabsterFocusOutEventName = "tabster:focusout";
	const TabsterMoveFocusEventName = "tabster:movefocus";
	/**
	* Events sent by Modalizer.
	*/
	const ModalizerActiveEventName = "tabster:modalizer:active";
	const ModalizerInactiveEventName = "tabster:modalizer:inactive";
	/**
	* Events sent by Mover.
	*/
	const MoverStateEventName = "tabster:mover:state";
	/**
	* Events to be sent to Mover by the application.
	*/
	const MoverMoveFocusEventName = "tabster:mover:movefocus";
	const MoverMemorizedElementEventName = "tabster:mover:memorized-element";
	/**
	* Events sent by Groupper.
	*/
	/**
	* Events to be sent to Groupper by the application.
	*/
	const GroupperMoveFocusEventName = "tabster:groupper:movefocus";
	/**
	* Events sent by Restorer.
	*/
	const RestorerRestoreFocusEventName = "tabster:restorer:restore-focus";
	/**
	* Events sent by Root.
	*/
	const RootFocusEventName = "tabster:root:focus";
	const RootBlurEventName = "tabster:root:blur";
	const CustomEvent_ = typeof CustomEvent !== "undefined" ? CustomEvent : function() {};
	var TabsterCustomEvent = class extends CustomEvent_ {
		constructor(type, detail) {
			super(type, {
				bubbles: true,
				cancelable: true,
				composed: true,
				detail
			});
			this.details = detail;
		}
	};
	var TabsterFocusInEvent = class extends TabsterCustomEvent {
		constructor(detail) {
			super(TabsterFocusInEventName, detail);
		}
	};
	var TabsterFocusOutEvent = class extends TabsterCustomEvent {
		constructor(detail) {
			super(TabsterFocusOutEventName, detail);
		}
	};
	var TabsterMoveFocusEvent = class extends TabsterCustomEvent {
		constructor(detail) {
			super(TabsterMoveFocusEventName, detail);
		}
	};
	var MoverStateEvent = class extends TabsterCustomEvent {
		constructor(detail) {
			super(MoverStateEventName, detail);
		}
	};
	var MoverMoveFocusEvent = class extends TabsterCustomEvent {
		constructor(detail) {
			super(MoverMoveFocusEventName, detail);
		}
	};
	var GroupperMoveFocusEvent = class extends TabsterCustomEvent {
		constructor(detail) {
			super(GroupperMoveFocusEventName, detail);
		}
	};
	var ModalizerActiveEvent = class extends TabsterCustomEvent {
		constructor(detail) {
			super(ModalizerActiveEventName, detail);
		}
	};
	var ModalizerInactiveEvent = class extends TabsterCustomEvent {
		constructor(detail) {
			super(ModalizerInactiveEventName, detail);
		}
	};
	var RestorerRestoreFocusEvent = class extends TabsterCustomEvent {
		constructor() {
			super(RestorerRestoreFocusEventName);
		}
	};
	var RootFocusEvent = class extends TabsterCustomEvent {
		constructor(detail) {
			super(RootFocusEventName, detail);
		}
	};
	var RootBlurEvent = class extends TabsterCustomEvent {
		constructor(detail) {
			super(RootBlurEventName, detail);
		}
	};
	/*!
	* Copyright (c) Microsoft Corporation. All rights reserved.
	* Licensed under the MIT License.
	*/
	const _createMutationObserver = (callback) => new MutationObserver(callback);
	const _createTreeWalker = (doc, root, whatToShow, filter) => doc.createTreeWalker(root, whatToShow, filter);
	const _getParentNode = (node$1) => node$1 ? node$1.parentNode : null;
	const _getParentElement = (element) => element ? element.parentElement : null;
	const _nodeContains = (parent$1, child) => !!(child && (parent$1 === null || parent$1 === void 0 ? void 0 : parent$1.contains(child)));
	const _getActiveElement = (doc) => doc.activeElement;
	const _querySelector = (element, selector) => element.querySelector(selector);
	const _querySelectorAll = (element, selector) => Array.prototype.slice.call(element.querySelectorAll(selector), 0);
	const _getElementById = (doc, id) => doc.getElementById(id);
	const _getFirstChild = (node$1) => (node$1 === null || node$1 === void 0 ? void 0 : node$1.firstChild) || null;
	const _getLastChild = (node$1) => (node$1 === null || node$1 === void 0 ? void 0 : node$1.lastChild) || null;
	const _getNextSibling = (node$1) => (node$1 === null || node$1 === void 0 ? void 0 : node$1.nextSibling) || null;
	const _getPreviousSibling = (node$1) => (node$1 === null || node$1 === void 0 ? void 0 : node$1.previousSibling) || null;
	const _getFirstElementChild = (element) => (element === null || element === void 0 ? void 0 : element.firstElementChild) || null;
	const _getLastElementChild = (element) => (element === null || element === void 0 ? void 0 : element.lastElementChild) || null;
	const _getNextElementSibling = (element) => (element === null || element === void 0 ? void 0 : element.nextElementSibling) || null;
	const _getPreviousElementSibling = (element) => (element === null || element === void 0 ? void 0 : element.previousElementSibling) || null;
	const _appendChild = (parent$1, child) => parent$1.appendChild(child);
	const _insertBefore = (parent$1, child, referenceChild) => parent$1.insertBefore(child, referenceChild);
	const _getSelection = (ref) => {
		var _a;
		return ((_a = ref.ownerDocument) === null || _a === void 0 ? void 0 : _a.getSelection()) || null;
	};
	const _getElementsByName = (referenceElement, name) => referenceElement.ownerDocument.getElementsByName(name);
	const dom = {
		createMutationObserver: _createMutationObserver,
		createTreeWalker: _createTreeWalker,
		getParentNode: _getParentNode,
		getParentElement: _getParentElement,
		nodeContains: _nodeContains,
		getActiveElement: _getActiveElement,
		querySelector: _querySelector,
		querySelectorAll: _querySelectorAll,
		getElementById: _getElementById,
		getFirstChild: _getFirstChild,
		getLastChild: _getLastChild,
		getNextSibling: _getNextSibling,
		getPreviousSibling: _getPreviousSibling,
		getFirstElementChild: _getFirstElementChild,
		getLastElementChild: _getLastElementChild,
		getNextElementSibling: _getNextElementSibling,
		getPreviousElementSibling: _getPreviousElementSibling,
		appendChild: _appendChild,
		insertBefore: _insertBefore,
		getSelection: _getSelection,
		getElementsByName: _getElementsByName
	};
	function setDOMAPI(domapi) {
		for (const key of Object.keys(domapi)) dom[key] = domapi[key];
	}
	/*!
	* Copyright (c) Microsoft Corporation. All rights reserved.
	* Licensed under the MIT License.
	*/
	let _isBrokenIE11;
	const _DOMRect = typeof DOMRect !== "undefined" ? DOMRect : class {
		constructor(x, y, width, height) {
			this.left = x || 0;
			this.top = y || 0;
			this.right = (x || 0) + (width || 0);
			this.bottom = (y || 0) + (height || 0);
		}
	};
	let _uidCounter = 0;
	try {
		document.createTreeWalker(document, NodeFilter.SHOW_ELEMENT);
		_isBrokenIE11 = false;
	} catch (e) {
		_isBrokenIE11 = true;
	}
	const _updateDummyInputsTimeout = 100;
	function getInstanceContext(getWindow$1) {
		const win = getWindow$1();
		let ctx = win.__tabsterInstanceContext;
		if (!ctx) {
			ctx = {
				elementByUId: {},
				basics: {
					Promise: win.Promise || void 0,
					WeakRef: win.WeakRef || void 0
				},
				containerBoundingRectCache: {},
				lastContainerBoundingRectCacheId: 0,
				fakeWeakRefs: [],
				fakeWeakRefsStarted: false
			};
			win.__tabsterInstanceContext = ctx;
		}
		return ctx;
	}
	function disposeInstanceContext(win) {
		const ctx = win.__tabsterInstanceContext;
		if (ctx) {
			ctx.elementByUId = {};
			delete ctx.WeakRef;
			ctx.containerBoundingRectCache = {};
			if (ctx.containerBoundingRectCacheTimer) win.clearTimeout(ctx.containerBoundingRectCacheTimer);
			if (ctx.fakeWeakRefsTimer) win.clearTimeout(ctx.fakeWeakRefsTimer);
			ctx.fakeWeakRefs = [];
			delete win.__tabsterInstanceContext;
		}
	}
	function createWeakMap(win) {
		const ctx = win.__tabsterInstanceContext;
		return new ((ctx === null || ctx === void 0 ? void 0 : ctx.basics.WeakMap) || WeakMap)();
	}
	function hasSubFocusable(element) {
		return !!element.querySelector(FOCUSABLE_SELECTOR);
	}
	var FakeWeakRef = class {
		constructor(target) {
			this._target = target;
		}
		deref() {
			return this._target;
		}
		static cleanup(fwr, forceRemove) {
			if (!fwr._target) return true;
			if (forceRemove || !documentContains(fwr._target.ownerDocument, fwr._target)) {
				delete fwr._target;
				return true;
			}
			return false;
		}
	};
	var WeakHTMLElement = class {
		constructor(getWindow$1, element, data) {
			const context = getInstanceContext(getWindow$1);
			let ref;
			if (context.WeakRef) ref = new context.WeakRef(element);
			else {
				ref = new FakeWeakRef(element);
				context.fakeWeakRefs.push(ref);
			}
			this._ref = ref;
			this._data = data;
		}
		get() {
			const ref = this._ref;
			let element;
			if (ref) {
				element = ref.deref();
				if (!element) delete this._ref;
			}
			return element;
		}
		getData() {
			return this._data;
		}
	};
	function cleanupFakeWeakRefs(getWindow$1, forceRemove) {
		const context = getInstanceContext(getWindow$1);
		context.fakeWeakRefs = context.fakeWeakRefs.filter((e) => !FakeWeakRef.cleanup(e, forceRemove));
	}
	function startFakeWeakRefsCleanup(getWindow$1) {
		const context = getInstanceContext(getWindow$1);
		if (!context.fakeWeakRefsStarted) {
			context.fakeWeakRefsStarted = true;
			context.WeakRef = getWeakRef(context);
		}
		if (!context.fakeWeakRefsTimer) context.fakeWeakRefsTimer = getWindow$1().setTimeout(() => {
			context.fakeWeakRefsTimer = void 0;
			cleanupFakeWeakRefs(getWindow$1);
			startFakeWeakRefsCleanup(getWindow$1);
		}, 120 * 1e3);
	}
	function stopFakeWeakRefsCleanupAndClearStorage(getWindow$1) {
		const context = getInstanceContext(getWindow$1);
		context.fakeWeakRefsStarted = false;
		if (context.fakeWeakRefsTimer) {
			getWindow$1().clearTimeout(context.fakeWeakRefsTimer);
			context.fakeWeakRefsTimer = void 0;
			context.fakeWeakRefs = [];
		}
	}
	function createElementTreeWalker(doc, root, acceptNode) {
		if (root.nodeType !== Node.ELEMENT_NODE) return;
		const filter = _isBrokenIE11 ? acceptNode : { acceptNode };
		return dom.createTreeWalker(doc, root, NodeFilter.SHOW_ELEMENT, filter, false);
	}
	function getBoundingRect(getWindow$1, element) {
		let cacheId = element.__tabsterCacheId;
		const context = getInstanceContext(getWindow$1);
		const cached = cacheId ? context.containerBoundingRectCache[cacheId] : void 0;
		if (cached) return cached.rect;
		const scrollingElement = element.ownerDocument && element.ownerDocument.documentElement;
		if (!scrollingElement) return new _DOMRect();
		let left$1 = 0;
		let top = 0;
		let right$1 = scrollingElement.clientWidth;
		let bottom = scrollingElement.clientHeight;
		if (element !== scrollingElement) {
			const r = element.getBoundingClientRect();
			left$1 = Math.max(left$1, r.left);
			top = Math.max(top, r.top);
			right$1 = Math.min(right$1, r.right);
			bottom = Math.min(bottom, r.bottom);
		}
		const rect = new _DOMRect(left$1 < right$1 ? left$1 : -1, top < bottom ? top : -1, left$1 < right$1 ? right$1 - left$1 : 0, top < bottom ? bottom - top : 0);
		if (!cacheId) {
			cacheId = "r-" + ++context.lastContainerBoundingRectCacheId;
			element.__tabsterCacheId = cacheId;
		}
		context.containerBoundingRectCache[cacheId] = {
			rect,
			element
		};
		if (!context.containerBoundingRectCacheTimer) context.containerBoundingRectCacheTimer = window.setTimeout(() => {
			context.containerBoundingRectCacheTimer = void 0;
			for (const cId of Object.keys(context.containerBoundingRectCache)) delete context.containerBoundingRectCache[cId].element.__tabsterCacheId;
			context.containerBoundingRectCache = {};
		}, 50);
		return rect;
	}
	function isElementVerticallyVisibleInContainer(getWindow$1, element, tolerance) {
		const container = getScrollableContainer(element);
		if (!container) return false;
		const containerRect = getBoundingRect(getWindow$1, container);
		const elementRect = element.getBoundingClientRect();
		const intersectionTolerance = elementRect.height * (1 - tolerance);
		const totalIntersection = Math.max(0, containerRect.top - elementRect.top) + Math.max(0, elementRect.bottom - containerRect.bottom);
		return totalIntersection === 0 || totalIntersection <= intersectionTolerance;
	}
	function scrollIntoView$1(getWindow$1, element, alignToTop) {
		const container = getScrollableContainer(element);
		if (container) {
			const containerRect = getBoundingRect(getWindow$1, container);
			const elementRect = element.getBoundingClientRect();
			if (alignToTop) container.scrollTop += elementRect.top - containerRect.top;
			else container.scrollTop += elementRect.bottom - containerRect.bottom;
		}
	}
	function getScrollableContainer(element) {
		const doc = element.ownerDocument;
		if (doc) {
			for (let el = dom.getParentElement(element); el; el = dom.getParentElement(el)) if (el.scrollWidth > el.clientWidth || el.scrollHeight > el.clientHeight) return el;
			return doc.documentElement;
		}
		return null;
	}
	function makeFocusIgnored(element) {
		element.__shouldIgnoreFocus = true;
	}
	function shouldIgnoreFocus(element) {
		return !!element.__shouldIgnoreFocus;
	}
	function getUId(wnd) {
		const rnd = new Uint32Array(4);
		if (wnd.crypto && wnd.crypto.getRandomValues) wnd.crypto.getRandomValues(rnd);
		else if (wnd.msCrypto && wnd.msCrypto.getRandomValues) wnd.msCrypto.getRandomValues(rnd);
		else for (let i = 0; i < rnd.length; i++) rnd[i] = 4294967295 * Math.random();
		const srnd = [];
		for (let i = 0; i < rnd.length; i++) srnd.push(rnd[i].toString(36));
		srnd.push("|");
		srnd.push((++_uidCounter).toString(36));
		srnd.push("|");
		srnd.push(Date.now().toString(36));
		return srnd.join("");
	}
	function getElementUId(getWindow$1, element) {
		const context = getInstanceContext(getWindow$1);
		let uid = element.__tabsterElementUID;
		if (!uid) uid = element.__tabsterElementUID = getUId(getWindow$1());
		if (!context.elementByUId[uid] && documentContains(element.ownerDocument, element)) context.elementByUId[uid] = new WeakHTMLElement(getWindow$1, element);
		return uid;
	}
	function clearElementCache(getWindow$1, parent$1) {
		const context = getInstanceContext(getWindow$1);
		for (const key of Object.keys(context.elementByUId)) {
			const wel = context.elementByUId[key];
			const el = wel && wel.get();
			if (el && parent$1) {
				if (!dom.nodeContains(parent$1, el)) continue;
			}
			delete context.elementByUId[key];
		}
	}
	function documentContains(doc, element) {
		return dom.nodeContains(doc === null || doc === void 0 ? void 0 : doc.body, element);
	}
	function matchesSelector(element, selector) {
		const matches = element.matches || element.matchesSelector || element.msMatchesSelector || element.webkitMatchesSelector;
		return matches && matches.call(element, selector);
	}
	function getPromise(getWindow$1) {
		const context = getInstanceContext(getWindow$1);
		if (context.basics.Promise) return context.basics.Promise;
		throw new Error("No Promise defined.");
	}
	function getWeakRef(context) {
		return context.basics.WeakRef;
	}
	let _lastTabsterPartId = 0;
	var TabsterPart = class {
		constructor(tabster, element, props) {
			const getWindow$1 = tabster.getWindow;
			this._tabster = tabster;
			this._element = new WeakHTMLElement(getWindow$1, element);
			this._props = { ...props };
			this.id = "i" + ++_lastTabsterPartId;
		}
		getElement() {
			return this._element.get();
		}
		getProps() {
			return this._props;
		}
		setProps(props) {
			this._props = { ...props };
		}
	};
	/**
	* Dummy HTML elements that are used as focus sentinels for the DOM enclosed within them
	*/
	var DummyInput = class {
		constructor(getWindow$1, isOutside, props, element, fixedTarget) {
			var _a;
			this._focusIn = (e) => {
				if (this._fixedTarget) {
					const target = this._fixedTarget.get();
					if (target) nativeFocus(target);
					return;
				}
				const input$1 = this.input;
				if (this.onFocusIn && input$1) {
					const relatedTarget = e.relatedTarget;
					this.onFocusIn(this, this._isBackward(true, input$1, relatedTarget), relatedTarget);
				}
			};
			this._focusOut = (e) => {
				if (this._fixedTarget) return;
				this.useDefaultAction = false;
				const input$1 = this.input;
				if (this.onFocusOut && input$1) {
					const relatedTarget = e.relatedTarget;
					this.onFocusOut(this, this._isBackward(false, input$1, relatedTarget), relatedTarget);
				}
			};
			const win = getWindow$1();
			const input = win.document.createElement("i");
			input.tabIndex = 0;
			input.setAttribute("role", "none");
			input.setAttribute(TABSTER_DUMMY_INPUT_ATTRIBUTE_NAME, "");
			input.setAttribute("aria-hidden", "true");
			const style = input.style;
			style.position = "fixed";
			style.width = style.height = "1px";
			style.opacity = "0.001";
			style.zIndex = "-1";
			style.setProperty("content-visibility", "hidden");
			makeFocusIgnored(input);
			this.input = input;
			this.isFirst = props.isFirst;
			this.isOutside = isOutside;
			this._isPhantom = (_a = props.isPhantom) !== null && _a !== void 0 ? _a : false;
			this._fixedTarget = fixedTarget;
			input.addEventListener("focusin", this._focusIn);
			input.addEventListener("focusout", this._focusOut);
			input.__tabsterDummyContainer = element;
			if (this._isPhantom) {
				this._disposeTimer = win.setTimeout(() => {
					delete this._disposeTimer;
					this.dispose();
				}, 0);
				this._clearDisposeTimeout = () => {
					if (this._disposeTimer) {
						win.clearTimeout(this._disposeTimer);
						delete this._disposeTimer;
					}
					delete this._clearDisposeTimeout;
				};
			}
		}
		dispose() {
			var _a;
			if (this._clearDisposeTimeout) this._clearDisposeTimeout();
			const input = this.input;
			if (!input) return;
			delete this._fixedTarget;
			delete this.onFocusIn;
			delete this.onFocusOut;
			delete this.input;
			input.removeEventListener("focusin", this._focusIn);
			input.removeEventListener("focusout", this._focusOut);
			delete input.__tabsterDummyContainer;
			(_a = dom.getParentNode(input)) === null || _a === void 0 || _a.removeChild(input);
		}
		setTopLeft(top, left$1) {
			var _a;
			const style = (_a = this.input) === null || _a === void 0 ? void 0 : _a.style;
			if (style) {
				style.top = `${top}px`;
				style.left = `${left$1}px`;
			}
		}
		_isBackward(isIn, current, previous) {
			return isIn && !previous ? !this.isFirst : !!(previous && current.compareDocumentPosition(previous) & Node.DOCUMENT_POSITION_FOLLOWING);
		}
	};
	const DummyInputManagerPriorities = {
		Root: 1,
		Modalizer: 2,
		Mover: 3,
		Groupper: 4
	};
	var DummyInputManager = class {
		constructor(tabster, element, priority, sys, outsideByDefault, callForDefaultAction) {
			this._element = element;
			this._instance = new DummyInputManagerCore(tabster, element, this, priority, sys, outsideByDefault, callForDefaultAction);
		}
		_setHandlers(onFocusIn, onFocusOut) {
			this._onFocusIn = onFocusIn;
			this._onFocusOut = onFocusOut;
		}
		moveOut(backwards) {
			var _a;
			(_a = this._instance) === null || _a === void 0 || _a.moveOut(backwards);
		}
		moveOutWithDefaultAction(backwards, relatedEvent) {
			var _a;
			(_a = this._instance) === null || _a === void 0 || _a.moveOutWithDefaultAction(backwards, relatedEvent);
		}
		getHandler(isIn) {
			return isIn ? this._onFocusIn : this._onFocusOut;
		}
		setTabbable(tabbable) {
			var _a;
			(_a = this._instance) === null || _a === void 0 || _a.setTabbable(this, tabbable);
		}
		dispose() {
			if (this._instance) {
				this._instance.dispose(this);
				delete this._instance;
			}
			delete this._onFocusIn;
			delete this._onFocusOut;
		}
		static moveWithPhantomDummy(tabster, element, moveOutOfElement, isBackward, relatedEvent) {
			const input = new DummyInput(tabster.getWindow, true, {
				isPhantom: true,
				isFirst: true
			}).input;
			if (input) {
				let parent$1;
				let insertBefore;
				if (element.tagName === "BODY") {
					parent$1 = element;
					insertBefore = moveOutOfElement && isBackward || !moveOutOfElement && !isBackward ? dom.getFirstElementChild(element) : null;
				} else {
					if (moveOutOfElement && (!isBackward || isBackward && !tabster.focusable.isFocusable(element, false, true, true))) {
						parent$1 = element;
						insertBefore = isBackward ? element.firstElementChild : null;
					} else {
						parent$1 = dom.getParentElement(element);
						insertBefore = moveOutOfElement && isBackward || !moveOutOfElement && !isBackward ? element : dom.getNextElementSibling(element);
					}
					let potentialDummy;
					let dummyFor;
					do {
						potentialDummy = moveOutOfElement && isBackward || !moveOutOfElement && !isBackward ? dom.getPreviousElementSibling(insertBefore) : insertBefore;
						dummyFor = getDummyInputContainer(potentialDummy);
						if (dummyFor === element) insertBefore = moveOutOfElement && isBackward || !moveOutOfElement && !isBackward ? potentialDummy : dom.getNextElementSibling(potentialDummy);
						else dummyFor = null;
					} while (dummyFor);
				}
				if (parent$1 === null || parent$1 === void 0 ? void 0 : parent$1.dispatchEvent(new TabsterMoveFocusEvent({
					by: "root",
					owner: parent$1,
					next: null,
					relatedEvent
				}))) {
					dom.insertBefore(parent$1, input, insertBefore);
					nativeFocus(input);
				}
			}
		}
		static addPhantomDummyWithTarget(tabster, sourceElement, isBackward, targetElement) {
			const input = new DummyInput(tabster.getWindow, true, {
				isPhantom: true,
				isFirst: true
			}, void 0, new WeakHTMLElement(tabster.getWindow, targetElement)).input;
			if (input) {
				let dummyParent;
				let insertBefore;
				if (hasSubFocusable(sourceElement) && !isBackward) {
					dummyParent = sourceElement;
					insertBefore = dom.getFirstElementChild(sourceElement);
				} else {
					dummyParent = dom.getParentElement(sourceElement);
					insertBefore = isBackward ? sourceElement : dom.getNextElementSibling(sourceElement);
				}
				if (dummyParent) dom.insertBefore(dummyParent, input, insertBefore);
			}
		}
	};
	function setDummyInputDebugValue(dummy, wrappers) {
		var _a;
		const what = {
			1: "Root",
			2: "Modalizer",
			3: "Mover",
			4: "Groupper"
		};
		(_a = dummy.input) === null || _a === void 0 || _a.setAttribute(TABSTER_DUMMY_INPUT_ATTRIBUTE_NAME, [
			`isFirst=${dummy.isFirst}`,
			`isOutside=${dummy.isOutside}`,
			...wrappers.map((w) => `(${what[w.priority]}, tabbable=${w.tabbable})`)
		].join(", "));
	}
	var DummyInputObserver = class {
		constructor(win) {
			this._updateQueue = /* @__PURE__ */ new Set();
			this._lastUpdateQueueTime = 0;
			this._changedParents = /* @__PURE__ */ new WeakSet();
			this._dummyElements = [];
			this._dummyCallbacks = /* @__PURE__ */ new WeakMap();
			this._domChanged = (parent$1) => {
				var _a;
				if (this._changedParents.has(parent$1)) return;
				this._changedParents.add(parent$1);
				if (this._updateDummyInputsTimer) return;
				this._updateDummyInputsTimer = (_a = this._win) === null || _a === void 0 ? void 0 : _a.call(this).setTimeout(() => {
					delete this._updateDummyInputsTimer;
					for (const ref of this._dummyElements) {
						const dummyElement = ref.get();
						if (dummyElement) {
							const callback = this._dummyCallbacks.get(dummyElement);
							if (callback) {
								const dummyParent = dom.getParentNode(dummyElement);
								if (!dummyParent || this._changedParents.has(dummyParent)) callback();
							}
						}
					}
					this._changedParents = /* @__PURE__ */ new WeakSet();
				}, _updateDummyInputsTimeout);
			};
			this._win = win;
		}
		add(dummy, callback) {
			if (!this._dummyCallbacks.has(dummy) && this._win) {
				this._dummyElements.push(new WeakHTMLElement(this._win, dummy));
				this._dummyCallbacks.set(dummy, callback);
				this.domChanged = this._domChanged;
			}
		}
		remove(dummy) {
			this._dummyElements = this._dummyElements.filter((ref) => {
				const element = ref.get();
				return element && element !== dummy;
			});
			this._dummyCallbacks.delete(dummy);
			if (this._dummyElements.length === 0) delete this.domChanged;
		}
		dispose() {
			var _a;
			const win = (_a = this._win) === null || _a === void 0 ? void 0 : _a.call(this);
			if (this._updateTimer) {
				win === null || win === void 0 || win.clearTimeout(this._updateTimer);
				delete this._updateTimer;
			}
			if (this._updateDummyInputsTimer) {
				win === null || win === void 0 || win.clearTimeout(this._updateDummyInputsTimer);
				delete this._updateDummyInputsTimer;
			}
			this._changedParents = /* @__PURE__ */ new WeakSet();
			this._dummyCallbacks = /* @__PURE__ */ new WeakMap();
			this._dummyElements = [];
			this._updateQueue.clear();
			delete this.domChanged;
			delete this._win;
		}
		updatePositions(compute) {
			if (!this._win) return;
			this._updateQueue.add(compute);
			this._lastUpdateQueueTime = Date.now();
			this._scheduledUpdatePositions();
		}
		_scheduledUpdatePositions() {
			var _a;
			if (this._updateTimer) return;
			this._updateTimer = (_a = this._win) === null || _a === void 0 ? void 0 : _a.call(this).setTimeout(() => {
				delete this._updateTimer;
				if (this._lastUpdateQueueTime + _updateDummyInputsTimeout <= Date.now()) {
					const scrollTopLeftCache = /* @__PURE__ */ new Map();
					const setTopLeftCallbacks = [];
					for (const compute of this._updateQueue) setTopLeftCallbacks.push(compute(scrollTopLeftCache));
					this._updateQueue.clear();
					for (const setTopLeft of setTopLeftCallbacks) setTopLeft();
					scrollTopLeftCache.clear();
				} else this._scheduledUpdatePositions();
			}, _updateDummyInputsTimeout);
		}
	};
	/**
	* Parent class that encapsulates the behaviour of dummy inputs (focus sentinels)
	*/
	var DummyInputManagerCore = class {
		constructor(tabster, element, manager, priority, sys, outsideByDefault, callForDefaultAction) {
			this._wrappers = [];
			this._isOutside = false;
			this._transformElements = /* @__PURE__ */ new Set();
			this._onFocusIn = (dummyInput, isBackward, relatedTarget) => {
				this._onFocus(true, dummyInput, isBackward, relatedTarget);
			};
			this._onFocusOut = (dummyInput, isBackward, relatedTarget) => {
				this._onFocus(false, dummyInput, isBackward, relatedTarget);
			};
			this.moveOut = (backwards) => {
				var _a;
				const first = this._firstDummy;
				const last = this._lastDummy;
				if (first && last) {
					this._ensurePosition();
					const firstInput = first.input;
					const lastInput = last.input;
					const element$1 = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();
					if (firstInput && lastInput && element$1) {
						let toFocus;
						if (backwards) {
							firstInput.tabIndex = 0;
							toFocus = firstInput;
						} else {
							lastInput.tabIndex = 0;
							toFocus = lastInput;
						}
						if (toFocus) nativeFocus(toFocus);
					}
				}
			};
			/**
			* Prepares to move focus out of the given element by focusing
			* one of the dummy inputs and setting the `useDefaultAction` flag
			* @param backwards focus moving to an element behind the given element
			*/
			this.moveOutWithDefaultAction = (backwards, relatedEvent) => {
				var _a;
				const first = this._firstDummy;
				const last = this._lastDummy;
				if (first && last) {
					this._ensurePosition();
					const firstInput = first.input;
					const lastInput = last.input;
					const element$1 = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();
					if (firstInput && lastInput && element$1) {
						let toFocus;
						if (backwards) if (!first.isOutside && this._tabster.focusable.isFocusable(element$1, true, true, true)) toFocus = element$1;
						else {
							first.useDefaultAction = true;
							firstInput.tabIndex = 0;
							toFocus = firstInput;
						}
						else {
							last.useDefaultAction = true;
							lastInput.tabIndex = 0;
							toFocus = lastInput;
						}
						if (toFocus && element$1.dispatchEvent(new TabsterMoveFocusEvent({
							by: "root",
							owner: element$1,
							next: null,
							relatedEvent
						}))) nativeFocus(toFocus);
					}
				}
			};
			this.setTabbable = (manager$1, tabbable) => {
				var _a, _b;
				for (const w of this._wrappers) if (w.manager === manager$1) {
					w.tabbable = tabbable;
					break;
				}
				const wrapper = this._getCurrent();
				if (wrapper) {
					const tabIndex = wrapper.tabbable ? 0 : -1;
					let input = (_a = this._firstDummy) === null || _a === void 0 ? void 0 : _a.input;
					if (input) input.tabIndex = tabIndex;
					input = (_b = this._lastDummy) === null || _b === void 0 ? void 0 : _b.input;
					if (input) input.tabIndex = tabIndex;
				}
				this._firstDummy && setDummyInputDebugValue(this._firstDummy, this._wrappers);
				this._lastDummy && setDummyInputDebugValue(this._lastDummy, this._wrappers);
			};
			/**
			* Adds dummy inputs as the first and last child of the given element
			* Called each time the children under the element is mutated
			*/
			this._addDummyInputs = () => {
				if (this._addTimer) return;
				this._addTimer = this._getWindow().setTimeout(() => {
					delete this._addTimer;
					this._ensurePosition();
					this._firstDummy && setDummyInputDebugValue(this._firstDummy, this._wrappers);
					this._lastDummy && setDummyInputDebugValue(this._lastDummy, this._wrappers);
					this._addTransformOffsets();
				}, 0);
			};
			this._addTransformOffsets = () => {
				this._tabster._dummyObserver.updatePositions(this._computeTransformOffsets);
			};
			this._computeTransformOffsets = (scrollTopLeftCache) => {
				var _a, _b;
				const from$1 = ((_a = this._firstDummy) === null || _a === void 0 ? void 0 : _a.input) || ((_b = this._lastDummy) === null || _b === void 0 ? void 0 : _b.input);
				const transformElements = this._transformElements;
				const newTransformElements = /* @__PURE__ */ new Set();
				let scrollTop = 0;
				let scrollLeft = 0;
				const win = this._getWindow();
				for (let element$1 = from$1; element$1 && element$1.nodeType === Node.ELEMENT_NODE; element$1 = dom.getParentElement(element$1)) {
					let scrollTopLeft = scrollTopLeftCache.get(element$1);
					if (scrollTopLeft === void 0) {
						const transform = win.getComputedStyle(element$1).transform;
						if (transform && transform !== "none") scrollTopLeft = {
							scrollTop: element$1.scrollTop,
							scrollLeft: element$1.scrollLeft
						};
						scrollTopLeftCache.set(element$1, scrollTopLeft || null);
					}
					if (scrollTopLeft) {
						newTransformElements.add(element$1);
						if (!transformElements.has(element$1)) element$1.addEventListener("scroll", this._addTransformOffsets);
						scrollTop += scrollTopLeft.scrollTop;
						scrollLeft += scrollTopLeft.scrollLeft;
					}
				}
				for (const el$1 of transformElements) if (!newTransformElements.has(el$1)) el$1.removeEventListener("scroll", this._addTransformOffsets);
				this._transformElements = newTransformElements;
				return () => {
					var _a$1, _b$1;
					(_a$1 = this._firstDummy) === null || _a$1 === void 0 || _a$1.setTopLeft(scrollTop, scrollLeft);
					(_b$1 = this._lastDummy) === null || _b$1 === void 0 || _b$1.setTopLeft(scrollTop, scrollLeft);
				};
			};
			const el = element.get();
			if (!el) throw new Error("No element");
			this._tabster = tabster;
			this._getWindow = tabster.getWindow;
			this._callForDefaultAction = callForDefaultAction;
			const instance = el.__tabsterDummy;
			(instance || this)._wrappers.push({
				manager,
				priority,
				tabbable: true
			});
			if (instance) {
				this._firstDummy && setDummyInputDebugValue(this._firstDummy, instance._wrappers);
				this._lastDummy && setDummyInputDebugValue(this._lastDummy, instance._wrappers);
				return instance;
			}
			el.__tabsterDummy = this;
			const forcedDummyPosition = sys === null || sys === void 0 ? void 0 : sys.dummyInputsPosition;
			const tagName = el.tagName;
			this._isOutside = !forcedDummyPosition ? (outsideByDefault || tagName === "UL" || tagName === "OL" || tagName === "TABLE") && !(tagName === "LI" || tagName === "TD" || tagName === "TH") : forcedDummyPosition === SysDummyInputsPositions.Outside;
			this._firstDummy = new DummyInput(this._getWindow, this._isOutside, { isFirst: true }, element);
			this._lastDummy = new DummyInput(this._getWindow, this._isOutside, { isFirst: false }, element);
			const dummyElement = this._firstDummy.input;
			dummyElement && tabster._dummyObserver.add(dummyElement, this._addDummyInputs);
			this._firstDummy.onFocusIn = this._onFocusIn;
			this._firstDummy.onFocusOut = this._onFocusOut;
			this._lastDummy.onFocusIn = this._onFocusIn;
			this._lastDummy.onFocusOut = this._onFocusOut;
			this._element = element;
			this._addDummyInputs();
		}
		dispose(manager, force) {
			var _a, _b, _c, _d;
			const wrappers = this._wrappers = this._wrappers.filter((w) => w.manager !== manager && !force);
			this._firstDummy && setDummyInputDebugValue(this._firstDummy, wrappers);
			this._lastDummy && setDummyInputDebugValue(this._lastDummy, wrappers);
			if (wrappers.length === 0) {
				delete ((_a = this._element) === null || _a === void 0 ? void 0 : _a.get()).__tabsterDummy;
				for (const el of this._transformElements) el.removeEventListener("scroll", this._addTransformOffsets);
				this._transformElements.clear();
				const win = this._getWindow();
				if (this._addTimer) {
					win.clearTimeout(this._addTimer);
					delete this._addTimer;
				}
				const dummyElement = (_b = this._firstDummy) === null || _b === void 0 ? void 0 : _b.input;
				dummyElement && this._tabster._dummyObserver.remove(dummyElement);
				(_c = this._firstDummy) === null || _c === void 0 || _c.dispose();
				(_d = this._lastDummy) === null || _d === void 0 || _d.dispose();
			}
		}
		_onFocus(isIn, dummyInput, isBackward, relatedTarget) {
			var _a;
			const wrapper = this._getCurrent();
			if (wrapper && (!dummyInput.useDefaultAction || this._callForDefaultAction)) (_a = wrapper.manager.getHandler(isIn)) === null || _a === void 0 || _a(dummyInput, isBackward, relatedTarget);
		}
		_getCurrent() {
			this._wrappers.sort((a, b) => {
				if (a.tabbable !== b.tabbable) return a.tabbable ? -1 : 1;
				return a.priority - b.priority;
			});
			return this._wrappers[0];
		}
		_ensurePosition() {
			var _a, _b, _c;
			const element = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();
			const firstDummyInput = (_b = this._firstDummy) === null || _b === void 0 ? void 0 : _b.input;
			const lastDummyInput = (_c = this._lastDummy) === null || _c === void 0 ? void 0 : _c.input;
			if (!element || !firstDummyInput || !lastDummyInput) return;
			if (this._isOutside) {
				const elementParent = dom.getParentNode(element);
				if (elementParent) {
					const nextSibling = dom.getNextSibling(element);
					if (nextSibling !== lastDummyInput) dom.insertBefore(elementParent, lastDummyInput, nextSibling);
					if (dom.getPreviousElementSibling(element) !== firstDummyInput) dom.insertBefore(elementParent, firstDummyInput, element);
				}
			} else {
				if (dom.getLastElementChild(element) !== lastDummyInput) dom.appendChild(element, lastDummyInput);
				const firstElementChild = dom.getFirstElementChild(element);
				if (firstElementChild && firstElementChild !== firstDummyInput && firstElementChild.parentNode) dom.insertBefore(firstElementChild.parentNode, firstDummyInput, firstElementChild);
			}
		}
	};
	function getLastChild$2(container) {
		let lastChild = null;
		for (let i = dom.getLastElementChild(container); i; i = dom.getLastElementChild(i)) lastChild = i;
		return lastChild || void 0;
	}
	function getAdjacentElement(from$1, prev$1) {
		let cur = from$1;
		let adjacent = null;
		while (cur && !adjacent) {
			adjacent = prev$1 ? dom.getPreviousElementSibling(cur) : dom.getNextElementSibling(cur);
			cur = dom.getParentElement(cur);
		}
		return adjacent || void 0;
	}
	function augmentAttribute(tabster, element, name, value) {
		const entry = tabster.storageEntry(element, true);
		let ret = false;
		if (!entry.aug) {
			if (value === void 0) return ret;
			entry.aug = {};
		}
		if (value === void 0) {
			if (name in entry.aug) {
				const origVal = entry.aug[name];
				delete entry.aug[name];
				if (origVal === null) element.removeAttribute(name);
				else element.setAttribute(name, origVal);
				ret = true;
			}
		} else {
			let origValue;
			if (!(name in entry.aug)) origValue = element.getAttribute(name);
			if (origValue !== void 0 && origValue !== value) {
				entry.aug[name] = origValue;
				if (value === null) element.removeAttribute(name);
				else element.setAttribute(name, value);
				ret = true;
			}
		}
		if (value === void 0 && Object.keys(entry.aug).length === 0) {
			delete entry.aug;
			tabster.storageEntry(element, false);
		}
		return ret;
	}
	function isDisplayNone(element) {
		var _a, _b;
		const elementDocument = element.ownerDocument;
		const computedStyle = (_a = elementDocument.defaultView) === null || _a === void 0 ? void 0 : _a.getComputedStyle(element);
		if (element.offsetParent === null && elementDocument.body !== element && (computedStyle === null || computedStyle === void 0 ? void 0 : computedStyle.position) !== "fixed") return true;
		if ((computedStyle === null || computedStyle === void 0 ? void 0 : computedStyle.visibility) === "hidden") return true;
		if ((computedStyle === null || computedStyle === void 0 ? void 0 : computedStyle.position) === "fixed") {
			if (computedStyle.display === "none") return true;
			if (((_b = element.parentElement) === null || _b === void 0 ? void 0 : _b.offsetParent) === null && elementDocument.body !== element.parentElement) return true;
		}
		return false;
	}
	function isRadio(element) {
		return element.tagName === "INPUT" && !!element.name && element.type === "radio";
	}
	function getRadioButtonGroup(element) {
		if (!isRadio(element)) return;
		const name = element.name;
		let radioButtons = Array.from(dom.getElementsByName(element, name));
		let checked;
		radioButtons = radioButtons.filter((el) => {
			if (isRadio(el)) {
				if (el.checked) checked = el;
				return true;
			}
			return false;
		});
		return {
			name,
			buttons: new Set(radioButtons),
			checked
		};
	}
	/**
	* If the passed element is Tabster dummy input, returns the container element this dummy input belongs to.
	* @param element Element to check for being dummy input.
	* @returns Dummy input container element (if the passed element is a dummy input) or null.
	*/
	function getDummyInputContainer(element) {
		var _a;
		return ((_a = element === null || element === void 0 ? void 0 : element.__tabsterDummyContainer) === null || _a === void 0 ? void 0 : _a.get()) || null;
	}
	/*!
	* Copyright (c) Microsoft Corporation. All rights reserved.
	* Licensed under the MIT License.
	*/
	function getTabsterAttribute(props, plain) {
		const attr = JSON.stringify(props);
		if (plain === true) return attr;
		return { [TABSTER_ATTRIBUTE_NAME]: attr };
	}
	/**
	* Updates Tabster props object with new props.
	* @param element an element to set data-tabster attribute on.
	* @param props current Tabster props to update.
	* @param newProps new Tabster props to add.
	*  When the value of a property in newProps is undefined, the property
	*  will be removed from the attribute.
	*/
	function mergeTabsterProps(props, newProps) {
		for (const key of Object.keys(newProps)) {
			const value = newProps[key];
			if (value) props[key] = value;
			else delete props[key];
		}
	}
	/**
	* Sets or updates Tabster attribute of the element.
	* @param element an element to set data-tabster attribute on.
	* @param newProps new Tabster props to set.
	* @param update if true, newProps will be merged with the existing props.
	*  When true and the value of a property in newProps is undefined, the property
	*  will be removed from the attribute.
	*/
	function setTabsterAttribute(element, newProps, update) {
		let props;
		if (update) {
			const attr = element.getAttribute(TABSTER_ATTRIBUTE_NAME);
			if (attr) try {
				props = JSON.parse(attr);
			} catch (e) {
				console.error(`data-tabster attribute error: ${e}`, element);
			}
		}
		if (!props) props = {};
		mergeTabsterProps(props, newProps);
		if (Object.keys(props).length > 0) element.setAttribute(TABSTER_ATTRIBUTE_NAME, getTabsterAttribute(props, true));
		else element.removeAttribute(TABSTER_ATTRIBUTE_NAME);
	}
	/*!
	* Copyright (c) Microsoft Corporation. All rights reserved.
	* Licensed under the MIT License.
	*/
	function _setInformativeStyle$3(weakElement, remove, id) {
		{
			const element = weakElement.get();
			if (element) if (remove) element.style.removeProperty("--tabster-root");
			else element.style.setProperty("--tabster-root", id + ",");
		}
	}
	var RootDummyManager = class extends DummyInputManager {
		constructor(tabster, element, setFocused, sys) {
			super(tabster, element, DummyInputManagerPriorities.Root, sys, void 0, true);
			this._onDummyInputFocus = (dummyInput) => {
				var _a;
				if (dummyInput.useDefaultAction) this._setFocused(false);
				else {
					this._tabster.keyboardNavigation.setNavigatingWithKeyboard(true);
					const element$1 = this._element.get();
					if (element$1) {
						this._setFocused(true);
						const toFocus = this._tabster.focusedElement.getFirstOrLastTabbable(dummyInput.isFirst, {
							container: element$1,
							ignoreAccessibility: true
						});
						if (toFocus) {
							nativeFocus(toFocus);
							return;
						}
					}
					(_a = dummyInput.input) === null || _a === void 0 || _a.blur();
				}
			};
			this._setHandlers(this._onDummyInputFocus);
			this._tabster = tabster;
			this._setFocused = setFocused;
		}
	};
	var Root = class extends TabsterPart {
		constructor(tabster, element, onDispose, props, sys) {
			super(tabster, element, props);
			this._isFocused = false;
			this._setFocused = (hasFocused) => {
				var _a;
				if (this._setFocusedTimer) {
					this._tabster.getWindow().clearTimeout(this._setFocusedTimer);
					delete this._setFocusedTimer;
				}
				if (this._isFocused === hasFocused) return;
				const element$1 = this._element.get();
				if (element$1) if (hasFocused) {
					this._isFocused = true;
					(_a = this._dummyManager) === null || _a === void 0 || _a.setTabbable(false);
					element$1.dispatchEvent(new RootFocusEvent({ element: element$1 }));
				} else this._setFocusedTimer = this._tabster.getWindow().setTimeout(() => {
					var _a$1;
					delete this._setFocusedTimer;
					this._isFocused = false;
					(_a$1 = this._dummyManager) === null || _a$1 === void 0 || _a$1.setTabbable(true);
					element$1.dispatchEvent(new RootBlurEvent({ element: element$1 }));
				}, 0);
			};
			this._onFocusIn = (event) => {
				const getParent$1 = this._tabster.getParent;
				const rootElement = this._element.get();
				let curElement = event.composedPath()[0];
				do {
					if (curElement === rootElement) {
						this._setFocused(true);
						return;
					}
					curElement = curElement && getParent$1(curElement);
				} while (curElement);
			};
			this._onFocusOut = () => {
				this._setFocused(false);
			};
			this._onDispose = onDispose;
			const win = tabster.getWindow;
			this.uid = getElementUId(win, element);
			this._sys = sys;
			if (tabster.controlTab || tabster.rootDummyInputs) this.addDummyInputs();
			const doc = win().document;
			doc.addEventListener(KEYBORG_FOCUSIN, this._onFocusIn);
			doc.addEventListener(KEYBORG_FOCUSOUT, this._onFocusOut);
			this._add();
		}
		addDummyInputs() {
			if (!this._dummyManager) this._dummyManager = new RootDummyManager(this._tabster, this._element, this._setFocused, this._sys);
		}
		dispose() {
			var _a;
			this._onDispose(this);
			const win = this._tabster.getWindow();
			const doc = win.document;
			doc.removeEventListener(KEYBORG_FOCUSIN, this._onFocusIn);
			doc.removeEventListener(KEYBORG_FOCUSOUT, this._onFocusOut);
			if (this._setFocusedTimer) {
				win.clearTimeout(this._setFocusedTimer);
				delete this._setFocusedTimer;
			}
			(_a = this._dummyManager) === null || _a === void 0 || _a.dispose();
			this._remove();
		}
		moveOutWithDefaultAction(isBackward, relatedEvent) {
			const dummyManager = this._dummyManager;
			if (dummyManager) dummyManager.moveOutWithDefaultAction(isBackward, relatedEvent);
			else {
				const el = this.getElement();
				if (el) RootDummyManager.moveWithPhantomDummy(this._tabster, el, true, isBackward, relatedEvent);
			}
		}
		_add() {
			_setInformativeStyle$3(this._element, false, this.uid);
		}
		_remove() {
			_setInformativeStyle$3(this._element, true);
		}
	};
	var RootAPI = class {
		constructor(tabster, autoRoot) {
			this._autoRootWaiting = false;
			this._roots = {};
			this._forceDummy = false;
			this.rootById = {};
			this._autoRootCreate = () => {
				var _a;
				const doc = this._win().document;
				const body = doc.body;
				if (body) {
					this._autoRootUnwait(doc);
					const props = this._autoRoot;
					if (props) {
						setTabsterAttribute(body, { root: props }, true);
						updateTabsterByAttribute(this._tabster, body);
						return (_a = getTabsterOnElement(this._tabster, body)) === null || _a === void 0 ? void 0 : _a.root;
					}
				} else if (!this._autoRootWaiting) {
					this._autoRootWaiting = true;
					doc.addEventListener("readystatechange", this._autoRootCreate);
				}
			};
			this._onRootDispose = (root) => {
				delete this._roots[root.id];
			};
			this._tabster = tabster;
			this._win = tabster.getWindow;
			this._autoRoot = autoRoot;
			tabster.queueInit(() => {
				if (this._autoRoot) this._autoRootCreate();
			});
		}
		_autoRootUnwait(doc) {
			doc.removeEventListener("readystatechange", this._autoRootCreate);
			this._autoRootWaiting = false;
		}
		dispose() {
			const win = this._win();
			this._autoRootUnwait(win.document);
			delete this._autoRoot;
			Object.keys(this._roots).forEach((rootId) => {
				if (this._roots[rootId]) {
					this._roots[rootId].dispose();
					delete this._roots[rootId];
				}
			});
			this.rootById = {};
		}
		createRoot(element, props, sys) {
			const newRoot = new Root(this._tabster, element, this._onRootDispose, props, sys);
			this._roots[newRoot.id] = newRoot;
			if (this._forceDummy) newRoot.addDummyInputs();
			return newRoot;
		}
		addDummyInputs() {
			this._forceDummy = true;
			const roots = this._roots;
			for (const id of Object.keys(roots)) roots[id].addDummyInputs();
		}
		static getRootByUId(getWindow$1, id) {
			const tabster = getWindow$1().__tabsterInstance;
			return tabster && tabster.root.rootById[id];
		}
		/**
		* Fetches the tabster context for an element walking up its ancestors
		*
		* @param tabster Tabster instance
		* @param element The element the tabster context should represent
		* @param options Additional options
		* @returns undefined if the element is not a child of a tabster root, otherwise all applicable tabster behaviours and configurations
		*/
		static getTabsterContext(tabster, element, options = {}) {
			var _a, _b, _c, _d;
			if (!element.ownerDocument) return;
			const { checkRtl, referenceElement } = options;
			const getParent$1 = tabster.getParent;
			tabster.drainInitQueue();
			let root;
			let modalizer;
			let groupper;
			let mover;
			let excludedFromMover = false;
			let groupperBeforeMover;
			let modalizerInGroupper;
			let dirRightToLeft;
			let uncontrolled;
			let curElement = referenceElement || element;
			const ignoreKeydown = {};
			while (curElement && (!root || checkRtl)) {
				const tabsterOnElement = getTabsterOnElement(tabster, curElement);
				if (checkRtl && dirRightToLeft === void 0) {
					const dir = curElement.dir;
					if (dir) dirRightToLeft = dir.toLowerCase() === "rtl";
				}
				if (!tabsterOnElement) {
					curElement = getParent$1(curElement);
					continue;
				}
				const tagName = curElement.tagName;
				if ((tabsterOnElement.uncontrolled || tagName === "IFRAME" || tagName === "WEBVIEW") && tabster.focusable.isVisible(curElement)) uncontrolled = curElement;
				if (!mover && ((_a = tabsterOnElement.focusable) === null || _a === void 0 ? void 0 : _a.excludeFromMover) && !groupper) excludedFromMover = true;
				const curModalizer = tabsterOnElement.modalizer;
				const curGroupper = tabsterOnElement.groupper;
				const curMover = tabsterOnElement.mover;
				if (!modalizer && curModalizer) modalizer = curModalizer;
				if (!groupper && curGroupper && (!modalizer || curModalizer)) if (modalizer) {
					if (!curGroupper.isActive() && curGroupper.getProps().tabbability && modalizer.userId !== ((_b = tabster.modalizer) === null || _b === void 0 ? void 0 : _b.activeId)) {
						modalizer = void 0;
						groupper = curGroupper;
					}
					modalizerInGroupper = curGroupper;
				} else groupper = curGroupper;
				if (!mover && curMover && (!modalizer || curModalizer) && (!curGroupper || curElement !== element) && curElement.contains(element)) {
					mover = curMover;
					groupperBeforeMover = !!groupper && groupper !== curGroupper;
				}
				if (tabsterOnElement.root) root = tabsterOnElement.root;
				if ((_c = tabsterOnElement.focusable) === null || _c === void 0 ? void 0 : _c.ignoreKeydown) Object.assign(ignoreKeydown, tabsterOnElement.focusable.ignoreKeydown);
				curElement = getParent$1(curElement);
			}
			if (!root) {
				const rootAPI = tabster.root;
				if (rootAPI._autoRoot) {
					if ((_d = element.ownerDocument) === null || _d === void 0 ? void 0 : _d.body) root = rootAPI._autoRootCreate();
				}
			}
			if (groupper && !mover) groupperBeforeMover = true;
			if (!root) {
				if (modalizer || groupper || mover) console.error("Tabster Root is required for Mover, Groupper and Modalizer to work.");
			}
			const shouldIgnoreKeydown = (event) => !!ignoreKeydown[event.key];
			return root ? {
				root,
				modalizer,
				groupper,
				mover,
				groupperBeforeMover,
				modalizerInGroupper,
				rtl: checkRtl ? !!dirRightToLeft : void 0,
				uncontrolled,
				excludedFromMover,
				ignoreKeydown: shouldIgnoreKeydown
			} : void 0;
		}
		static getRoot(tabster, element) {
			var _a;
			const getParent$1 = tabster.getParent;
			for (let el = element; el; el = getParent$1(el)) {
				const root = (_a = getTabsterOnElement(tabster, el)) === null || _a === void 0 ? void 0 : _a.root;
				if (root) return root;
			}
		}
		onRoot(root, removed) {
			if (removed) delete this.rootById[root.uid];
			else this.rootById[root.uid] = root;
		}
	};
	/*!
	* Copyright (c) Microsoft Corporation. All rights reserved.
	* Licensed under the MIT License.
	*/
	var Subscribable = class {
		constructor() {
			this._callbacks = [];
		}
		dispose() {
			this._callbacks = [];
			delete this._val;
		}
		subscribe(callback) {
			const callbacks = this._callbacks;
			if (callbacks.indexOf(callback) < 0) callbacks.push(callback);
		}
		subscribeFirst(callback) {
			const callbacks = this._callbacks;
			const index = callbacks.indexOf(callback);
			if (index >= 0) callbacks.splice(index, 1);
			callbacks.unshift(callback);
		}
		unsubscribe(callback) {
			const index = this._callbacks.indexOf(callback);
			if (index >= 0) this._callbacks.splice(index, 1);
		}
		setVal(val, detail) {
			if (this._val === val) return;
			this._val = val;
			this._callCallbacks(val, detail);
		}
		getVal() {
			return this._val;
		}
		trigger(val, detail) {
			this._callCallbacks(val, detail);
		}
		_callCallbacks(val, detail) {
			this._callbacks.forEach((callback) => callback(val, detail));
		}
	};
	/*!
	* Copyright (c) Microsoft Corporation. All rights reserved.
	* Licensed under the MIT License.
	*/
	var FocusableAPI = class {
		constructor(tabster) {
			this._tabster = tabster;
		}
		dispose() {}
		getProps(element) {
			const tabsterOnElement = getTabsterOnElement(this._tabster, element);
			return tabsterOnElement && tabsterOnElement.focusable || {};
		}
		isFocusable(el, includeProgrammaticallyFocusable, noVisibleCheck, noAccessibleCheck) {
			if (matchesSelector(el, FOCUSABLE_SELECTOR) && (includeProgrammaticallyFocusable || el.tabIndex !== -1)) return (noVisibleCheck || this.isVisible(el)) && (noAccessibleCheck || this.isAccessible(el));
			return false;
		}
		isVisible(el) {
			if (!el.ownerDocument || el.nodeType !== Node.ELEMENT_NODE) return false;
			if (isDisplayNone(el)) return false;
			const rect = el.ownerDocument.body.getBoundingClientRect();
			if (rect.width === 0 && rect.height === 0) return false;
			return true;
		}
		isAccessible(el) {
			var _a;
			for (let e = el; e; e = dom.getParentElement(e)) {
				const tabsterOnElement = getTabsterOnElement(this._tabster, e);
				if (this._isHidden(e)) return false;
				if (!((_a = tabsterOnElement === null || tabsterOnElement === void 0 ? void 0 : tabsterOnElement.focusable) === null || _a === void 0 ? void 0 : _a.ignoreAriaDisabled) && this._isDisabled(e)) return false;
			}
			return true;
		}
		_isDisabled(el) {
			return el.hasAttribute("disabled");
		}
		_isHidden(el) {
			var _a;
			const attrVal = el.getAttribute("aria-hidden");
			if (attrVal && attrVal.toLowerCase() === "true") {
				if (!((_a = this._tabster.modalizer) === null || _a === void 0 ? void 0 : _a.isAugmented(el))) return true;
			}
			return false;
		}
		findFirst(options, out) {
			return this.findElement({ ...options }, out);
		}
		findLast(options, out) {
			return this.findElement({
				isBackward: true,
				...options
			}, out);
		}
		findNext(options, out) {
			return this.findElement({ ...options }, out);
		}
		findPrev(options, out) {
			return this.findElement({
				...options,
				isBackward: true
			}, out);
		}
		findDefault(options, out) {
			return this.findElement({
				...options,
				acceptCondition: (el) => this.isFocusable(el, options.includeProgrammaticallyFocusable) && !!this.getProps(el).isDefault
			}, out) || null;
		}
		findAll(options) {
			return this._findElements(true, options) || [];
		}
		findElement(options, out) {
			const found = this._findElements(false, options, out);
			return found ? found[0] : found;
		}
		_findElements(isFindAll, options, out) {
			var _a, _b, _c;
			const { container, currentElement = null, includeProgrammaticallyFocusable, useActiveModalizer, ignoreAccessibility, modalizerId, isBackward, onElement } = options;
			if (!out) out = {};
			const elements = [];
			let { acceptCondition } = options;
			const hasCustomCondition = !!acceptCondition;
			if (!container) return null;
			if (!acceptCondition) acceptCondition = (el) => this.isFocusable(el, includeProgrammaticallyFocusable, false, ignoreAccessibility);
			const acceptElementState = {
				container,
				modalizerUserId: modalizerId === void 0 && useActiveModalizer ? (_a = this._tabster.modalizer) === null || _a === void 0 ? void 0 : _a.activeId : modalizerId || ((_c = (_b = RootAPI.getTabsterContext(this._tabster, container)) === null || _b === void 0 ? void 0 : _b.modalizer) === null || _c === void 0 ? void 0 : _c.userId),
				from: currentElement || container,
				isBackward,
				isFindAll,
				acceptCondition,
				hasCustomCondition,
				includeProgrammaticallyFocusable,
				ignoreAccessibility,
				cachedGrouppers: {},
				cachedRadioGroups: {}
			};
			const walker = createElementTreeWalker(container.ownerDocument, container, (node$1) => this._acceptElement(node$1, acceptElementState));
			if (!walker) return null;
			const prepareForNextElement = (shouldContinueIfNotFound) => {
				var _a$1, _b$1;
				const foundElement = (_a$1 = acceptElementState.foundElement) !== null && _a$1 !== void 0 ? _a$1 : acceptElementState.foundBackward;
				if (foundElement) elements.push(foundElement);
				if (isFindAll) {
					if (foundElement) {
						acceptElementState.found = false;
						delete acceptElementState.foundElement;
						delete acceptElementState.foundBackward;
						delete acceptElementState.fromCtx;
						acceptElementState.from = foundElement;
						if (onElement && !onElement(foundElement)) return false;
					}
					return !!(foundElement || shouldContinueIfNotFound);
				} else {
					if (foundElement && out) out.uncontrolled = (_b$1 = RootAPI.getTabsterContext(this._tabster, foundElement)) === null || _b$1 === void 0 ? void 0 : _b$1.uncontrolled;
					return !!(shouldContinueIfNotFound && !foundElement);
				}
			};
			if (!currentElement) out.outOfDOMOrder = true;
			if (currentElement && dom.nodeContains(container, currentElement)) walker.currentNode = currentElement;
			else if (isBackward) {
				const lastChild = getLastChild$2(container);
				if (!lastChild) return null;
				if (this._acceptElement(lastChild, acceptElementState) === NodeFilter.FILTER_ACCEPT && !prepareForNextElement(true)) {
					if (acceptElementState.skippedFocusable) out.outOfDOMOrder = true;
					return elements;
				}
				walker.currentNode = lastChild;
			}
			do
				if (isBackward) walker.previousNode();
				else walker.nextNode();
			while (prepareForNextElement());
			if (acceptElementState.skippedFocusable) out.outOfDOMOrder = true;
			return elements.length ? elements : null;
		}
		_acceptElement(element, state) {
			var _a, _b, _c;
			if (state.found) return NodeFilter.FILTER_ACCEPT;
			const foundBackward = state.foundBackward;
			if (foundBackward && (element === foundBackward || !dom.nodeContains(foundBackward, element))) {
				state.found = true;
				state.foundElement = foundBackward;
				return NodeFilter.FILTER_ACCEPT;
			}
			const container = state.container;
			if (element === container) return NodeFilter.FILTER_SKIP;
			if (!dom.nodeContains(container, element)) return NodeFilter.FILTER_REJECT;
			if (getDummyInputContainer(element)) return NodeFilter.FILTER_REJECT;
			if (dom.nodeContains(state.rejectElementsFrom, element)) return NodeFilter.FILTER_REJECT;
			const ctx = state.currentCtx = RootAPI.getTabsterContext(this._tabster, element);
			if (!ctx) return NodeFilter.FILTER_SKIP;
			if (shouldIgnoreFocus(element)) {
				if (this.isFocusable(element, void 0, true, true)) state.skippedFocusable = true;
				return NodeFilter.FILTER_SKIP;
			}
			if (!state.hasCustomCondition && (element.tagName === "IFRAME" || element.tagName === "WEBVIEW")) if (this.isVisible(element) && ((_a = ctx.modalizer) === null || _a === void 0 ? void 0 : _a.userId) === ((_b = this._tabster.modalizer) === null || _b === void 0 ? void 0 : _b.activeId)) {
				state.found = true;
				state.rejectElementsFrom = state.foundElement = element;
				return NodeFilter.FILTER_ACCEPT;
			} else return NodeFilter.FILTER_REJECT;
			if (!state.ignoreAccessibility && !this.isAccessible(element)) {
				if (this.isFocusable(element, false, true, true)) state.skippedFocusable = true;
				return NodeFilter.FILTER_REJECT;
			}
			let result;
			let fromCtx = state.fromCtx;
			if (!fromCtx) fromCtx = state.fromCtx = RootAPI.getTabsterContext(this._tabster, state.from);
			const fromMover = fromCtx === null || fromCtx === void 0 ? void 0 : fromCtx.mover;
			let groupper = ctx.groupper;
			let mover = ctx.mover;
			result = (_c = this._tabster.modalizer) === null || _c === void 0 ? void 0 : _c.acceptElement(element, state);
			if (result !== void 0) state.skippedFocusable = true;
			if (result === void 0 && (groupper || mover || fromMover)) {
				const groupperElement = groupper === null || groupper === void 0 ? void 0 : groupper.getElement();
				const fromMoverElement = fromMover === null || fromMover === void 0 ? void 0 : fromMover.getElement();
				let moverElement = mover === null || mover === void 0 ? void 0 : mover.getElement();
				if (moverElement && dom.nodeContains(fromMoverElement, moverElement) && dom.nodeContains(container, fromMoverElement) && (!groupperElement || !mover || dom.nodeContains(fromMoverElement, groupperElement))) {
					mover = fromMover;
					moverElement = fromMoverElement;
				}
				if (groupperElement) {
					if (groupperElement === container || !dom.nodeContains(container, groupperElement)) groupper = void 0;
					else if (!dom.nodeContains(groupperElement, element)) return NodeFilter.FILTER_REJECT;
				}
				if (moverElement) {
					if (!dom.nodeContains(container, moverElement)) mover = void 0;
					else if (!dom.nodeContains(moverElement, element)) return NodeFilter.FILTER_REJECT;
				}
				if (groupper && mover) if (moverElement && groupperElement && !dom.nodeContains(groupperElement, moverElement)) mover = void 0;
				else groupper = void 0;
				if (groupper) result = groupper.acceptElement(element, state);
				if (mover) result = mover.acceptElement(element, state);
			}
			if (result === void 0) {
				result = state.acceptCondition(element) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
				if (result === NodeFilter.FILTER_SKIP && this.isFocusable(element, false, true, true)) state.skippedFocusable = true;
			}
			if (result === NodeFilter.FILTER_ACCEPT && !state.found) {
				if (!state.isFindAll && isRadio(element) && !element.checked) {
					const radioGroupName = element.name;
					let radioGroup = state.cachedRadioGroups[radioGroupName];
					if (!radioGroup) {
						radioGroup = getRadioButtonGroup(element);
						if (radioGroup) state.cachedRadioGroups[radioGroupName] = radioGroup;
					}
					if ((radioGroup === null || radioGroup === void 0 ? void 0 : radioGroup.checked) && radioGroup.checked !== element) return NodeFilter.FILTER_SKIP;
				}
				if (state.isBackward) {
					state.foundBackward = element;
					result = NodeFilter.FILTER_SKIP;
				} else {
					state.found = true;
					state.foundElement = element;
				}
			}
			return result;
		}
	};
	/*!
	* Copyright (c) Microsoft Corporation. All rights reserved.
	* Licensed under the MIT License.
	*/
	const Keys = {
		Tab: "Tab",
		Enter: "Enter",
		Escape: "Escape",
		PageUp: "PageUp",
		PageDown: "PageDown",
		End: "End",
		Home: "Home",
		ArrowLeft: "ArrowLeft",
		ArrowUp: "ArrowUp",
		ArrowRight: "ArrowRight",
		ArrowDown: "ArrowDown"
	};
	/*!
	* Copyright (c) Microsoft Corporation. All rights reserved.
	* Licensed under the MIT License.
	*/
	function getUncontrolledCompletelyContainer(tabster, element) {
		var _a;
		const getParent$1 = tabster.getParent;
		let el = element;
		do {
			const uncontrolledOnElement = (_a = getTabsterOnElement(tabster, el)) === null || _a === void 0 ? void 0 : _a.uncontrolled;
			if (uncontrolledOnElement && tabster.uncontrolled.isUncontrolledCompletely(el, !!uncontrolledOnElement.completely)) return el;
			el = getParent$1(el);
		} while (el);
	}
	const AsyncFocusIntentPriorityBySource = {
		[AsyncFocusSources.Restorer]: 0,
		[AsyncFocusSources.Deloser]: 1,
		[AsyncFocusSources.EscapeGroupper]: 2
	};
	var FocusedElementState = class FocusedElementState extends Subscribable {
		constructor(tabster, getWindow$1) {
			super();
			this._init = () => {
				const win = this._win();
				const doc = win.document;
				doc.addEventListener(KEYBORG_FOCUSIN, this._onFocusIn, true);
				doc.addEventListener(KEYBORG_FOCUSOUT, this._onFocusOut, true);
				win.addEventListener("keydown", this._onKeyDown, true);
				const activeElement = dom.getActiveElement(doc);
				if (activeElement && activeElement !== doc.body) this._setFocusedElement(activeElement);
				this.subscribe(this._onChanged);
			};
			this._onFocusIn = (e) => {
				const target = e.composedPath()[0];
				if (target) this._setFocusedElement(target, e.detail.relatedTarget, e.detail.isFocusedProgrammatically);
			};
			this._onFocusOut = (e) => {
				var _a;
				this._setFocusedElement(void 0, (_a = e.detail) === null || _a === void 0 ? void 0 : _a.originalEvent.relatedTarget);
			};
			this._validateFocusedElement = (element) => {};
			this._onKeyDown = (event) => {
				if (event.key !== Keys.Tab || event.ctrlKey) return;
				const currentElement = this.getVal();
				if (!currentElement || !currentElement.ownerDocument || currentElement.contentEditable === "true") return;
				const tabster$1 = this._tabster;
				const controlTab = tabster$1.controlTab;
				const ctx = RootAPI.getTabsterContext(tabster$1, currentElement);
				if (!ctx || ctx.ignoreKeydown(event)) return;
				const isBackward = event.shiftKey;
				const next$1 = FocusedElementState.findNextTabbable(tabster$1, ctx, void 0, currentElement, void 0, isBackward, true);
				const rootElement = ctx.root.getElement();
				if (!rootElement) return;
				const nextElement = next$1 === null || next$1 === void 0 ? void 0 : next$1.element;
				const uncontrolledCompletelyContainer = getUncontrolledCompletelyContainer(tabster$1, currentElement);
				if (nextElement) {
					const nextUncontrolled = next$1.uncontrolled;
					if (ctx.uncontrolled || dom.nodeContains(nextUncontrolled, currentElement)) {
						if (!next$1.outOfDOMOrder && nextUncontrolled === ctx.uncontrolled || uncontrolledCompletelyContainer && !dom.nodeContains(uncontrolledCompletelyContainer, nextElement)) return;
						DummyInputManager.addPhantomDummyWithTarget(tabster$1, currentElement, isBackward, nextElement);
						return;
					}
					if (nextUncontrolled && tabster$1.focusable.isVisible(nextUncontrolled) || nextElement.tagName === "IFRAME" && tabster$1.focusable.isVisible(nextElement)) {
						if (rootElement.dispatchEvent(new TabsterMoveFocusEvent({
							by: "root",
							owner: rootElement,
							next: nextElement,
							relatedEvent: event
						}))) DummyInputManager.moveWithPhantomDummy(tabster$1, nextUncontrolled !== null && nextUncontrolled !== void 0 ? nextUncontrolled : nextElement, false, isBackward, event);
						return;
					}
					if (controlTab || (next$1 === null || next$1 === void 0 ? void 0 : next$1.outOfDOMOrder)) {
						if (rootElement.dispatchEvent(new TabsterMoveFocusEvent({
							by: "root",
							owner: rootElement,
							next: nextElement,
							relatedEvent: event
						}))) {
							event.preventDefault();
							event.stopImmediatePropagation();
							nativeFocus(nextElement);
						}
					}
				} else if (!uncontrolledCompletelyContainer && rootElement.dispatchEvent(new TabsterMoveFocusEvent({
					by: "root",
					owner: rootElement,
					next: null,
					relatedEvent: event
				}))) ctx.root.moveOutWithDefaultAction(isBackward, event);
			};
			this._onChanged = (element, detail) => {
				var _a, _b;
				if (element) element.dispatchEvent(new TabsterFocusInEvent(detail));
				else {
					const last = (_a = this._lastVal) === null || _a === void 0 ? void 0 : _a.get();
					if (last) {
						const d = { ...detail };
						const lastCtx = RootAPI.getTabsterContext(this._tabster, last);
						const modalizerId = (_b = lastCtx === null || lastCtx === void 0 ? void 0 : lastCtx.modalizer) === null || _b === void 0 ? void 0 : _b.userId;
						if (modalizerId) d.modalizerId = modalizerId;
						last.dispatchEvent(new TabsterFocusOutEvent(d));
					}
				}
			};
			this._tabster = tabster;
			this._win = getWindow$1;
			tabster.queueInit(this._init);
		}
		dispose() {
			super.dispose();
			const win = this._win();
			const doc = win.document;
			doc.removeEventListener(KEYBORG_FOCUSIN, this._onFocusIn, true);
			doc.removeEventListener(KEYBORG_FOCUSOUT, this._onFocusOut, true);
			win.removeEventListener("keydown", this._onKeyDown, true);
			this.unsubscribe(this._onChanged);
			const asyncFocus = this._asyncFocus;
			if (asyncFocus) {
				win.clearTimeout(asyncFocus.timeout);
				delete this._asyncFocus;
			}
			delete FocusedElementState._lastResetElement;
			delete this._nextVal;
			delete this._lastVal;
		}
		static forgetMemorized(instance, parent$1) {
			var _a, _b;
			let wel = FocusedElementState._lastResetElement;
			let el = wel && wel.get();
			if (el && dom.nodeContains(parent$1, el)) delete FocusedElementState._lastResetElement;
			el = (_b = (_a = instance._nextVal) === null || _a === void 0 ? void 0 : _a.element) === null || _b === void 0 ? void 0 : _b.get();
			if (el && dom.nodeContains(parent$1, el)) delete instance._nextVal;
			wel = instance._lastVal;
			el = wel && wel.get();
			if (el && dom.nodeContains(parent$1, el)) delete instance._lastVal;
		}
		getFocusedElement() {
			return this.getVal();
		}
		getLastFocusedElement() {
			var _a;
			let el = (_a = this._lastVal) === null || _a === void 0 ? void 0 : _a.get();
			if (!el || el && !documentContains(el.ownerDocument, el)) this._lastVal = el = void 0;
			return el;
		}
		focus(element, noFocusedProgrammaticallyFlag, noAccessibleCheck, preventScroll) {
			if (!this._tabster.focusable.isFocusable(element, noFocusedProgrammaticallyFlag, false, noAccessibleCheck)) return false;
			element.focus({ preventScroll });
			return true;
		}
		focusDefault(container) {
			const el = this._tabster.focusable.findDefault({ container });
			if (el) {
				this._tabster.focusedElement.focus(el);
				return true;
			}
			return false;
		}
		getFirstOrLastTabbable(isFirst, props) {
			var _a;
			const { container, ignoreAccessibility } = props;
			let toFocus;
			if (container) {
				const ctx = RootAPI.getTabsterContext(this._tabster, container);
				if (ctx) toFocus = (_a = FocusedElementState.findNextTabbable(this._tabster, ctx, container, void 0, void 0, !isFirst, ignoreAccessibility)) === null || _a === void 0 ? void 0 : _a.element;
			}
			if (toFocus && !dom.nodeContains(container, toFocus)) toFocus = void 0;
			return toFocus || void 0;
		}
		_focusFirstOrLast(isFirst, props) {
			const toFocus = this.getFirstOrLastTabbable(isFirst, props);
			if (toFocus) {
				this.focus(toFocus, false, true);
				return true;
			}
			return false;
		}
		focusFirst(props) {
			return this._focusFirstOrLast(true, props);
		}
		focusLast(props) {
			return this._focusFirstOrLast(false, props);
		}
		resetFocus(container) {
			if (!this._tabster.focusable.isVisible(container)) return false;
			if (!this._tabster.focusable.isFocusable(container, true, true, true)) {
				const prevTabIndex = container.getAttribute("tabindex");
				const prevAriaHidden = container.getAttribute("aria-hidden");
				container.tabIndex = -1;
				container.setAttribute("aria-hidden", "true");
				FocusedElementState._lastResetElement = new WeakHTMLElement(this._win, container);
				this.focus(container, true, true);
				this._setOrRemoveAttribute(container, "tabindex", prevTabIndex);
				this._setOrRemoveAttribute(container, "aria-hidden", prevAriaHidden);
			} else this.focus(container);
			return true;
		}
		requestAsyncFocus(source, callback, delay) {
			const win = this._tabster.getWindow();
			const currentAsyncFocus = this._asyncFocus;
			if (currentAsyncFocus) {
				if (AsyncFocusIntentPriorityBySource[source] > AsyncFocusIntentPriorityBySource[currentAsyncFocus.source]) return;
				win.clearTimeout(currentAsyncFocus.timeout);
			}
			this._asyncFocus = {
				source,
				callback,
				timeout: win.setTimeout(() => {
					this._asyncFocus = void 0;
					callback();
				}, delay)
			};
		}
		cancelAsyncFocus(source) {
			const asyncFocus = this._asyncFocus;
			if ((asyncFocus === null || asyncFocus === void 0 ? void 0 : asyncFocus.source) === source) {
				this._tabster.getWindow().clearTimeout(asyncFocus.timeout);
				this._asyncFocus = void 0;
			}
		}
		_setOrRemoveAttribute(element, name, value) {
			if (value === null) element.removeAttribute(name);
			else element.setAttribute(name, value);
		}
		_setFocusedElement(element, relatedTarget, isFocusedProgrammatically) {
			var _a, _b;
			if (this._tabster._noop) return;
			const detail = { relatedTarget };
			if (element) {
				const lastResetElement = (_a = FocusedElementState._lastResetElement) === null || _a === void 0 ? void 0 : _a.get();
				FocusedElementState._lastResetElement = void 0;
				if (lastResetElement === element || shouldIgnoreFocus(element)) return;
				detail.isFocusedProgrammatically = isFocusedProgrammatically;
				const ctx = RootAPI.getTabsterContext(this._tabster, element);
				const modalizerId = (_b = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer) === null || _b === void 0 ? void 0 : _b.userId;
				if (modalizerId) detail.modalizerId = modalizerId;
			}
			const nextVal = this._nextVal = {
				element: element ? new WeakHTMLElement(this._win, element) : void 0,
				detail
			};
			if (element && element !== this._val) this._validateFocusedElement(element);
			if (this._nextVal === nextVal) this.setVal(element, detail);
			this._nextVal = void 0;
		}
		setVal(val, detail) {
			super.setVal(val, detail);
			if (val) this._lastVal = new WeakHTMLElement(this._win, val);
		}
		static findNextTabbable(tabster, ctx, container, currentElement, referenceElement, isBackward, ignoreAccessibility) {
			const actualContainer = container || ctx.root.getElement();
			if (!actualContainer) return null;
			let next$1 = null;
			const isTabbingTimer = FocusedElementState._isTabbingTimer;
			const win = tabster.getWindow();
			if (isTabbingTimer) win.clearTimeout(isTabbingTimer);
			FocusedElementState.isTabbing = true;
			FocusedElementState._isTabbingTimer = win.setTimeout(() => {
				delete FocusedElementState._isTabbingTimer;
				FocusedElementState.isTabbing = false;
			}, 0);
			const modalizer = ctx.modalizer;
			const groupper = ctx.groupper;
			const mover = ctx.mover;
			const callFindNext = (what) => {
				next$1 = what.findNextTabbable(currentElement, referenceElement, isBackward, ignoreAccessibility);
				if (currentElement && !(next$1 === null || next$1 === void 0 ? void 0 : next$1.element)) {
					const parentElement$1 = what !== modalizer && dom.getParentElement(what.getElement());
					if (parentElement$1) {
						const parentCtx = RootAPI.getTabsterContext(tabster, currentElement, { referenceElement: parentElement$1 });
						if (parentCtx) {
							const currentScopeElement = what.getElement();
							const newCurrent = isBackward ? currentScopeElement : currentScopeElement && getLastChild$2(currentScopeElement) || currentScopeElement;
							if (newCurrent) {
								next$1 = FocusedElementState.findNextTabbable(tabster, parentCtx, container, newCurrent, parentElement$1, isBackward, ignoreAccessibility);
								if (next$1) next$1.outOfDOMOrder = true;
							}
						}
					}
				}
			};
			if (groupper && mover) callFindNext(ctx.groupperBeforeMover ? groupper : mover);
			else if (groupper) callFindNext(groupper);
			else if (mover) callFindNext(mover);
			else if (modalizer) callFindNext(modalizer);
			else {
				const findProps = {
					container: actualContainer,
					currentElement,
					referenceElement,
					ignoreAccessibility,
					useActiveModalizer: true
				};
				const findPropsOut = {};
				next$1 = {
					element: tabster.focusable[isBackward ? "findPrev" : "findNext"](findProps, findPropsOut),
					outOfDOMOrder: findPropsOut.outOfDOMOrder,
					uncontrolled: findPropsOut.uncontrolled
				};
			}
			return next$1;
		}
	};
	FocusedElementState.isTabbing = false;
	/*!
	* Copyright (c) Microsoft Corporation. All rights reserved.
	* Licensed under the MIT License.
	*/
	var GroupperDummyManager = class extends DummyInputManager {
		constructor(element, groupper, tabster, sys) {
			super(tabster, element, DummyInputManagerPriorities.Groupper, sys, true);
			this._setHandlers((dummyInput, isBackward, relatedTarget) => {
				var _a, _b;
				const container = element.get();
				const input = dummyInput.input;
				if (container && input) {
					const ctx = RootAPI.getTabsterContext(tabster, input);
					if (ctx) {
						let next$1;
						next$1 = (_a = groupper.findNextTabbable(relatedTarget || void 0, void 0, isBackward, true)) === null || _a === void 0 ? void 0 : _a.element;
						if (!next$1) next$1 = (_b = FocusedElementState.findNextTabbable(tabster, ctx, void 0, dummyInput.isOutside ? input : getAdjacentElement(container, !isBackward), void 0, isBackward, true)) === null || _b === void 0 ? void 0 : _b.element;
						if (next$1) nativeFocus(next$1);
					}
				}
			});
		}
	};
	var Groupper = class extends TabsterPart {
		constructor(tabster, element, onDispose, props, sys) {
			super(tabster, element, props);
			this._shouldTabInside = false;
			this.makeTabbable(false);
			this._onDispose = onDispose;
			if (!tabster.controlTab) this.dummyManager = new GroupperDummyManager(this._element, this, tabster, sys);
		}
		dispose() {
			var _a;
			this._onDispose(this);
			const element = this._element.get();
			(_a = this.dummyManager) === null || _a === void 0 || _a.dispose();
			delete this.dummyManager;
			if (element) _setInformativeStyle$1(this._element, true);
			delete this._first;
		}
		findNextTabbable(currentElement, referenceElement, isBackward, ignoreAccessibility) {
			const groupperElement = this.getElement();
			if (!groupperElement) return null;
			const currentIsDummy = getDummyInputContainer(currentElement) === groupperElement;
			if (!this._shouldTabInside && currentElement && dom.nodeContains(groupperElement, currentElement) && !currentIsDummy) return {
				element: void 0,
				outOfDOMOrder: true
			};
			const groupperFirstFocusable = this.getFirst(true);
			if (!currentElement || !dom.nodeContains(groupperElement, currentElement) || currentIsDummy) return {
				element: groupperFirstFocusable,
				outOfDOMOrder: true
			};
			const tabster = this._tabster;
			let next$1 = null;
			let outOfDOMOrder = false;
			let uncontrolled;
			if (this._shouldTabInside && groupperFirstFocusable) {
				const findProps = {
					container: groupperElement,
					currentElement,
					referenceElement,
					ignoreAccessibility,
					useActiveModalizer: true
				};
				const findPropsOut = {};
				next$1 = tabster.focusable[isBackward ? "findPrev" : "findNext"](findProps, findPropsOut);
				outOfDOMOrder = !!findPropsOut.outOfDOMOrder;
				if (!next$1 && this._props.tabbability === GroupperTabbabilities.LimitedTrapFocus) {
					next$1 = tabster.focusable[isBackward ? "findLast" : "findFirst"]({
						container: groupperElement,
						ignoreAccessibility,
						useActiveModalizer: true
					}, findPropsOut);
					outOfDOMOrder = true;
				}
				uncontrolled = findPropsOut.uncontrolled;
			}
			return {
				element: next$1,
				uncontrolled,
				outOfDOMOrder
			};
		}
		makeTabbable(isTabbable) {
			this._shouldTabInside = isTabbable || !this._props.tabbability;
			_setInformativeStyle$1(this._element, !this._shouldTabInside);
		}
		isActive(noIfFirstIsFocused) {
			var _a;
			const element = this.getElement() || null;
			let isParentActive = true;
			for (let e = dom.getParentElement(element); e; e = dom.getParentElement(e)) {
				const g = (_a = getTabsterOnElement(this._tabster, e)) === null || _a === void 0 ? void 0 : _a.groupper;
				if (g) {
					if (!g._shouldTabInside) isParentActive = false;
				}
			}
			let ret = isParentActive ? this._props.tabbability ? this._shouldTabInside : false : void 0;
			if (ret && noIfFirstIsFocused) {
				const focused = this._tabster.focusedElement.getFocusedElement();
				if (focused) ret = focused !== this.getFirst(true);
			}
			return ret;
		}
		getFirst(orContainer) {
			var _a;
			const groupperElement = this.getElement();
			let first;
			if (groupperElement) {
				if (orContainer && this._tabster.focusable.isFocusable(groupperElement)) return groupperElement;
				first = (_a = this._first) === null || _a === void 0 ? void 0 : _a.get();
				if (!first) {
					first = this._tabster.focusable.findFirst({
						container: groupperElement,
						useActiveModalizer: true
					}) || void 0;
					if (first) this.setFirst(first);
				}
			}
			return first;
		}
		setFirst(element) {
			if (element) this._first = new WeakHTMLElement(this._tabster.getWindow, element);
			else delete this._first;
		}
		acceptElement(element, state) {
			const cachedGrouppers = state.cachedGrouppers;
			const parentElement$1 = dom.getParentElement(this.getElement());
			const parentCtx = parentElement$1 && RootAPI.getTabsterContext(this._tabster, parentElement$1);
			const parentCtxGroupper = parentCtx === null || parentCtx === void 0 ? void 0 : parentCtx.groupper;
			const parentGroupper = (parentCtx === null || parentCtx === void 0 ? void 0 : parentCtx.groupperBeforeMover) ? parentCtxGroupper : void 0;
			let parentGroupperElement;
			const getIsActive = (groupper) => {
				let cached = cachedGrouppers[groupper.id];
				let isActive$1;
				if (cached) isActive$1 = cached.isActive;
				else {
					isActive$1 = this.isActive(true);
					cached = cachedGrouppers[groupper.id] = { isActive: isActive$1 };
				}
				return isActive$1;
			};
			if (parentGroupper) {
				parentGroupperElement = parentGroupper.getElement();
				if (!getIsActive(parentGroupper) && parentGroupperElement && state.container !== parentGroupperElement && dom.nodeContains(state.container, parentGroupperElement)) {
					state.skippedFocusable = true;
					return NodeFilter.FILTER_REJECT;
				}
			}
			const isActive = getIsActive(this);
			const groupperElement = this.getElement();
			if (groupperElement) {
				if (isActive !== true) {
					if (groupperElement === element && parentCtxGroupper) {
						if (!parentGroupperElement) parentGroupperElement = parentCtxGroupper.getElement();
						if (parentGroupperElement && !getIsActive(parentCtxGroupper) && dom.nodeContains(state.container, parentGroupperElement) && parentGroupperElement !== state.container) {
							state.skippedFocusable = true;
							return NodeFilter.FILTER_REJECT;
						}
					}
					if (groupperElement !== element && dom.nodeContains(groupperElement, element)) {
						state.skippedFocusable = true;
						return NodeFilter.FILTER_REJECT;
					}
					const cached = cachedGrouppers[this.id];
					let first;
					if ("first" in cached) first = cached.first;
					else first = cached.first = this.getFirst(true);
					if (first && state.acceptCondition(first)) {
						state.rejectElementsFrom = groupperElement;
						state.skippedFocusable = true;
						if (first !== state.from) {
							state.found = true;
							state.foundElement = first;
							return NodeFilter.FILTER_ACCEPT;
						} else return NodeFilter.FILTER_REJECT;
					}
				}
			}
		}
	};
	var GroupperAPI = class {
		constructor(tabster, getWindow$1) {
			this._current = {};
			this._grouppers = {};
			this._init = () => {
				const win = this._win();
				this._tabster.focusedElement.subscribeFirst(this._onFocus);
				const doc = win.document;
				const activeElement = dom.getActiveElement(doc);
				if (activeElement) this._onFocus(activeElement);
				doc.addEventListener("mousedown", this._onMouseDown, true);
				win.addEventListener("keydown", this._onKeyDown, true);
				win.addEventListener(GroupperMoveFocusEventName, this._onMoveFocus);
			};
			this._onGroupperDispose = (groupper) => {
				delete this._grouppers[groupper.id];
			};
			this._onFocus = (element) => {
				if (element) this._updateCurrent(element);
			};
			this._onMouseDown = (e) => {
				let target = e.target;
				while (target && !this._tabster.focusable.isFocusable(target)) target = this._tabster.getParent(target);
				if (target) this._updateCurrent(target);
			};
			this._onKeyDown = (event) => {
				if (event.key !== Keys.Enter && event.key !== Keys.Escape) return;
				if (event.ctrlKey || event.altKey || event.shiftKey || event.metaKey) return;
				const element = this._tabster.focusedElement.getFocusedElement();
				if (element) this.handleKeyPress(element, event);
			};
			this._onMoveFocus = (e) => {
				var _a;
				const element = e.composedPath()[0];
				const action = (_a = e.detail) === null || _a === void 0 ? void 0 : _a.action;
				if (element && action !== void 0 && !e.defaultPrevented) {
					if (action === GroupperMoveFocusActions.Enter) this._enterGroupper(element);
					else this._escapeGroupper(element);
					e.stopImmediatePropagation();
				}
			};
			this._tabster = tabster;
			this._win = getWindow$1;
			tabster.queueInit(this._init);
		}
		dispose() {
			const win = this._win();
			this._tabster.focusedElement.cancelAsyncFocus(AsyncFocusSources.EscapeGroupper);
			this._current = {};
			if (this._updateTimer) {
				win.clearTimeout(this._updateTimer);
				delete this._updateTimer;
			}
			this._tabster.focusedElement.unsubscribe(this._onFocus);
			win.document.removeEventListener("mousedown", this._onMouseDown, true);
			win.removeEventListener("keydown", this._onKeyDown, true);
			win.removeEventListener(GroupperMoveFocusEventName, this._onMoveFocus);
			Object.keys(this._grouppers).forEach((groupperId) => {
				if (this._grouppers[groupperId]) {
					this._grouppers[groupperId].dispose();
					delete this._grouppers[groupperId];
				}
			});
		}
		createGroupper(element, props, sys) {
			const tabster = this._tabster;
			const newGroupper = new Groupper(tabster, element, this._onGroupperDispose, props, sys);
			this._grouppers[newGroupper.id] = newGroupper;
			const focusedElement = tabster.focusedElement.getFocusedElement();
			if (focusedElement && dom.nodeContains(element, focusedElement) && !this._updateTimer) this._updateTimer = this._win().setTimeout(() => {
				delete this._updateTimer;
				if (focusedElement === tabster.focusedElement.getFocusedElement()) this._updateCurrent(focusedElement);
			}, 0);
			return newGroupper;
		}
		forgetCurrentGrouppers() {
			this._current = {};
		}
		_updateCurrent(element) {
			var _a;
			if (this._updateTimer) {
				this._win().clearTimeout(this._updateTimer);
				delete this._updateTimer;
			}
			const tabster = this._tabster;
			const newIds = {};
			for (let el = tabster.getParent(element); el; el = tabster.getParent(el)) {
				const groupper = (_a = getTabsterOnElement(tabster, el)) === null || _a === void 0 ? void 0 : _a.groupper;
				if (groupper) {
					newIds[groupper.id] = true;
					this._current[groupper.id] = groupper;
					const isTabbable = groupper.isActive() || element !== el && (!groupper.getProps().delegated || groupper.getFirst(false) !== element);
					groupper.makeTabbable(isTabbable);
				}
			}
			for (const id of Object.keys(this._current)) {
				const groupper = this._current[id];
				if (!(groupper.id in newIds)) {
					groupper.makeTabbable(false);
					groupper.setFirst(void 0);
					delete this._current[id];
				}
			}
		}
		_enterGroupper(element, relatedEvent) {
			const tabster = this._tabster;
			const ctx = RootAPI.getTabsterContext(tabster, element);
			const groupper = (ctx === null || ctx === void 0 ? void 0 : ctx.groupper) || (ctx === null || ctx === void 0 ? void 0 : ctx.modalizerInGroupper);
			const groupperElement = groupper === null || groupper === void 0 ? void 0 : groupper.getElement();
			if (groupper && groupperElement && (element === groupperElement || groupper.getProps().delegated && element === groupper.getFirst(false))) {
				const next$1 = tabster.focusable.findNext({
					container: groupperElement,
					currentElement: element,
					useActiveModalizer: true
				});
				if (next$1 && (!relatedEvent || relatedEvent && groupperElement.dispatchEvent(new TabsterMoveFocusEvent({
					by: "groupper",
					owner: groupperElement,
					next: next$1,
					relatedEvent
				})))) {
					if (relatedEvent) {
						relatedEvent.preventDefault();
						relatedEvent.stopImmediatePropagation();
					}
					next$1.focus();
					return next$1;
				}
			}
			return null;
		}
		_escapeGroupper(element, relatedEvent, fromModalizer) {
			const tabster = this._tabster;
			const ctx = RootAPI.getTabsterContext(tabster, element);
			let groupper = (ctx === null || ctx === void 0 ? void 0 : ctx.groupper) || (ctx === null || ctx === void 0 ? void 0 : ctx.modalizerInGroupper);
			const groupperElement = groupper === null || groupper === void 0 ? void 0 : groupper.getElement();
			if (groupper && groupperElement && dom.nodeContains(groupperElement, element)) {
				let next$1;
				if (element !== groupperElement || fromModalizer) next$1 = groupper.getFirst(true);
				else {
					const parentElement$1 = dom.getParentElement(groupperElement);
					const parentCtx = parentElement$1 ? RootAPI.getTabsterContext(tabster, parentElement$1) : void 0;
					groupper = parentCtx === null || parentCtx === void 0 ? void 0 : parentCtx.groupper;
					next$1 = groupper === null || groupper === void 0 ? void 0 : groupper.getFirst(true);
				}
				if (next$1 && (!relatedEvent || relatedEvent && groupperElement.dispatchEvent(new TabsterMoveFocusEvent({
					by: "groupper",
					owner: groupperElement,
					next: next$1,
					relatedEvent
				})))) {
					if (groupper) groupper.makeTabbable(false);
					next$1.focus();
					return next$1;
				}
			}
			return null;
		}
		moveFocus(element, action) {
			return action === GroupperMoveFocusActions.Enter ? this._enterGroupper(element) : this._escapeGroupper(element);
		}
		handleKeyPress(element, event, fromModalizer) {
			const tabster = this._tabster;
			const ctx = RootAPI.getTabsterContext(tabster, element);
			if (ctx && ((ctx === null || ctx === void 0 ? void 0 : ctx.groupper) || (ctx === null || ctx === void 0 ? void 0 : ctx.modalizerInGroupper))) {
				tabster.focusedElement.cancelAsyncFocus(AsyncFocusSources.EscapeGroupper);
				if (ctx.ignoreKeydown(event)) return;
				if (event.key === Keys.Enter) this._enterGroupper(element, event);
				else if (event.key === Keys.Escape) {
					const focusedElement = tabster.focusedElement.getFocusedElement();
					tabster.focusedElement.requestAsyncFocus(AsyncFocusSources.EscapeGroupper, () => {
						if (focusedElement !== tabster.focusedElement.getFocusedElement() && (fromModalizer && !focusedElement || !fromModalizer)) return;
						this._escapeGroupper(element, event, fromModalizer);
					}, 0);
				}
			}
		}
	};
	function _setInformativeStyle$1(weakElement, remove) {
		{
			const element = weakElement.get();
			if (element) if (remove) element.style.removeProperty("--tabster-groupper");
			else element.style.setProperty("--tabster-groupper", "unlimited");
		}
	}
	/*!
	* Copyright (c) Microsoft Corporation. All rights reserved.
	* Licensed under the MIT License.
	*/
	var KeyboardNavigationState = class extends Subscribable {
		constructor(getWindow$1) {
			super();
			this._onChange = (isNavigatingWithKeyboard) => {
				this.setVal(isNavigatingWithKeyboard, void 0);
			};
			this._keyborg = createKeyborg(getWindow$1());
			this._keyborg.subscribe(this._onChange);
		}
		dispose() {
			super.dispose();
			if (this._keyborg) {
				this._keyborg.unsubscribe(this._onChange);
				disposeKeyborg(this._keyborg);
				delete this._keyborg;
			}
		}
		setNavigatingWithKeyboard(isNavigatingWithKeyboard) {
			var _a;
			(_a = this._keyborg) === null || _a === void 0 || _a.setVal(isNavigatingWithKeyboard);
		}
		isNavigatingWithKeyboard() {
			var _a;
			return !!((_a = this._keyborg) === null || _a === void 0 ? void 0 : _a.isNavigatingWithKeyboard());
		}
	};
	/*!
	* Copyright (c) Microsoft Corporation. All rights reserved.
	* Licensed under the MIT License.
	*/
	let _wasFocusedCounter = 0;
	const _ariaHidden = "aria-hidden";
	function _setInformativeStyle(weakElement, remove, internalId, userId, isActive, wasFocused) {
		{
			const element = weakElement.get();
			if (element) if (remove) element.style.removeProperty("--tabster-modalizer");
			else element.style.setProperty("--tabster-modalizer", internalId + "," + userId + "," + (isActive ? "active" : "inactive") + ",," + (wasFocused ? `focused(${wasFocused})` : "not-focused"));
		}
	}
	/**
	* Manages the dummy inputs for the Modalizer.
	*/
	var ModalizerDummyManager = class extends DummyInputManager {
		constructor(element, tabster, sys) {
			super(tabster, element, DummyInputManagerPriorities.Modalizer, sys);
			this._setHandlers((dummyInput, isBackward) => {
				var _a, _b;
				const el = element.get();
				const container = el && ((_a = RootAPI.getRoot(tabster, el)) === null || _a === void 0 ? void 0 : _a.getElement());
				const input = dummyInput.input;
				let toFocus;
				if (container && input) {
					const dummyContainer = getDummyInputContainer(input);
					const ctx = RootAPI.getTabsterContext(tabster, dummyContainer || input);
					if (ctx) toFocus = (_b = FocusedElementState.findNextTabbable(tabster, ctx, container, input, void 0, isBackward, true)) === null || _b === void 0 ? void 0 : _b.element;
					if (toFocus) nativeFocus(toFocus);
				}
			});
		}
	};
	var Modalizer = class extends TabsterPart {
		constructor(tabster, element, onDispose, props, sys, activeElements) {
			super(tabster, element, props);
			this._wasFocused = 0;
			this.userId = props.id;
			this._onDispose = onDispose;
			this._activeElements = activeElements;
			if (!tabster.controlTab) this.dummyManager = new ModalizerDummyManager(this._element, tabster, sys);
			_setInformativeStyle(this._element, false, this.id, this.userId, this._isActive, this._wasFocused);
		}
		makeActive(isActive) {
			if (this._isActive !== isActive) {
				this._isActive = isActive;
				const element = this.getElement();
				if (element) {
					const activeElements = this._activeElements;
					const index = activeElements.map((e) => e.get()).indexOf(element);
					if (isActive) {
						if (index < 0) activeElements.push(new WeakHTMLElement(this._tabster.getWindow, element));
					} else if (index >= 0) activeElements.splice(index, 1);
				}
				_setInformativeStyle(this._element, false, this.id, this.userId, this._isActive, this._wasFocused);
				this._dispatchEvent(isActive);
			}
		}
		focused(noIncrement) {
			if (!noIncrement) this._wasFocused = ++_wasFocusedCounter;
			return this._wasFocused;
		}
		setProps(props) {
			if (props.id) this.userId = props.id;
			this._props = { ...props };
		}
		dispose() {
			var _a;
			this.makeActive(false);
			this._onDispose(this);
			(_a = this.dummyManager) === null || _a === void 0 || _a.dispose();
			delete this.dummyManager;
			this._activeElements = [];
			this._remove();
		}
		isActive() {
			return !!this._isActive;
		}
		contains(element) {
			return dom.nodeContains(this.getElement(), element);
		}
		findNextTabbable(currentElement, referenceElement, isBackward, ignoreAccessibility) {
			var _a, _b;
			if (!this.getElement()) return null;
			const tabster = this._tabster;
			let next$1 = null;
			let outOfDOMOrder = false;
			let uncontrolled;
			const container = currentElement && ((_a = RootAPI.getRoot(tabster, currentElement)) === null || _a === void 0 ? void 0 : _a.getElement());
			if (container) {
				const findProps = {
					container,
					currentElement,
					referenceElement,
					ignoreAccessibility,
					useActiveModalizer: true
				};
				const findPropsOut = {};
				next$1 = tabster.focusable[isBackward ? "findPrev" : "findNext"](findProps, findPropsOut);
				if (!next$1 && this._props.isTrapped && ((_b = tabster.modalizer) === null || _b === void 0 ? void 0 : _b.activeId)) {
					next$1 = tabster.focusable[isBackward ? "findLast" : "findFirst"]({
						container,
						ignoreAccessibility,
						useActiveModalizer: true
					}, findPropsOut);
					if (next$1 === null) next$1 = currentElement;
					outOfDOMOrder = true;
				} else outOfDOMOrder = !!findPropsOut.outOfDOMOrder;
				uncontrolled = findPropsOut.uncontrolled;
			}
			return {
				element: next$1,
				uncontrolled,
				outOfDOMOrder
			};
		}
		_dispatchEvent(isActive, allElements) {
			const element = this.getElement();
			let defaultPrevented = false;
			if (element) {
				const elements = allElements ? this._activeElements.map((e) => e.get()) : [element];
				for (const el of elements) if (el) {
					const eventDetail = {
						id: this.userId,
						element
					};
					const event = isActive ? new ModalizerActiveEvent(eventDetail) : new ModalizerInactiveEvent(eventDetail);
					el.dispatchEvent(event);
					if (event.defaultPrevented) defaultPrevented = true;
				}
			}
			return defaultPrevented;
		}
		_remove() {
			_setInformativeStyle(this._element, true);
		}
	};
	var ModalizerAPI = class {
		constructor(tabster, alwaysAccessibleSelector, accessibleCheck) {
			this._onModalizerDispose = (modalizer) => {
				const id = modalizer.id;
				const userId = modalizer.userId;
				const part = this._parts[userId];
				delete this._modalizers[id];
				if (part) {
					delete part[id];
					if (Object.keys(part).length === 0) {
						delete this._parts[userId];
						const activationHistory = this._activationHistory;
						const cleanActivationHistory = [];
						let prevHistoryItem;
						for (let i = activationHistory.length; i--;) {
							const modalizerUserIdFromHistory = activationHistory[i];
							if (modalizerUserIdFromHistory === userId) continue;
							if (modalizerUserIdFromHistory !== prevHistoryItem) {
								prevHistoryItem = modalizerUserIdFromHistory;
								if (modalizerUserIdFromHistory || cleanActivationHistory.length > 0) cleanActivationHistory.unshift(modalizerUserIdFromHistory);
							}
						}
						this._activationHistory = cleanActivationHistory;
						if (this.activeId === userId) {
							const prevActiveId = cleanActivationHistory[0];
							const prevActive = prevActiveId ? Object.values(this._parts[prevActiveId])[0] : void 0;
							this.setActive(prevActive);
						}
					}
				}
			};
			this._onKeyDown = (event) => {
				var _a;
				if (event.key !== Keys.Escape) return;
				const tabster$1 = this._tabster;
				const element = tabster$1.focusedElement.getFocusedElement();
				if (element) {
					const ctx = RootAPI.getTabsterContext(tabster$1, element);
					const modalizer = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer;
					if (ctx && !ctx.groupper && (modalizer === null || modalizer === void 0 ? void 0 : modalizer.isActive()) && !ctx.ignoreKeydown(event)) {
						const activeId = modalizer.userId;
						if (activeId) {
							const part = this._parts[activeId];
							if (part) {
								const focusedSince = Object.keys(part).map((id) => {
									var _a$1;
									const m = part[id];
									const el = m.getElement();
									let groupper;
									if (el) groupper = (_a$1 = getTabsterOnElement(tabster$1, el)) === null || _a$1 === void 0 ? void 0 : _a$1.groupper;
									return m && el && groupper ? {
										el,
										focusedSince: m.focused(true)
									} : { focusedSince: 0 };
								}).filter((f) => f.focusedSince > 0).sort((a, b) => a.focusedSince > b.focusedSince ? -1 : a.focusedSince < b.focusedSince ? 1 : 0);
								if (focusedSince.length) {
									const groupperElement = focusedSince[0].el;
									if (groupperElement) (_a = tabster$1.groupper) === null || _a === void 0 || _a.handleKeyPress(groupperElement, event, true);
								}
							}
						}
					}
				}
			};
			/**
			* Subscribes to the focus state and handles modalizer related focus events
			* @param focusedElement - Element that is focused
			* @param detail - Additional data about the focus event
			*/
			this._onFocus = (focusedElement, detail) => {
				var _a;
				const tabster$1 = this._tabster;
				const ctx = focusedElement && RootAPI.getTabsterContext(tabster$1, focusedElement);
				if (!ctx || !focusedElement) return;
				const augmentedMap = this._augMap;
				for (let e = focusedElement; e; e = dom.getParentElement(e)) if (augmentedMap.has(e)) {
					augmentedMap.delete(e);
					augmentAttribute(tabster$1, e, _ariaHidden);
				}
				let modalizer = ctx.modalizer;
				const tabsterOnFocusedElement = getTabsterOnElement(tabster$1, focusedElement);
				const modalizerOnFocusedElement = tabsterOnFocusedElement === null || tabsterOnFocusedElement === void 0 ? void 0 : tabsterOnFocusedElement.modalizer;
				if (modalizerOnFocusedElement) {
					modalizerOnFocusedElement.focused();
					if (modalizerOnFocusedElement.userId === this.activeId && tabsterOnFocusedElement.groupper) {
						const parentElement$1 = tabster$1.getParent(focusedElement);
						const parentModalizer = parentElement$1 && ((_a = RootAPI.getTabsterContext(tabster$1, parentElement$1)) === null || _a === void 0 ? void 0 : _a.modalizer);
						if (parentModalizer) modalizer = parentModalizer;
						else {
							this.setActive(void 0);
							return;
						}
					}
				}
				modalizer === null || modalizer === void 0 || modalizer.focused();
				if ((modalizer === null || modalizer === void 0 ? void 0 : modalizer.userId) === this.activeId) {
					this.currentIsOthersAccessible = modalizer === null || modalizer === void 0 ? void 0 : modalizer.getProps().isOthersAccessible;
					return;
				}
				if (detail.isFocusedProgrammatically || this.currentIsOthersAccessible || (modalizer === null || modalizer === void 0 ? void 0 : modalizer.getProps().isAlwaysAccessible)) this.setActive(modalizer);
				else {
					const win = this._win();
					win.clearTimeout(this._restoreModalizerFocusTimer);
					this._restoreModalizerFocusTimer = win.setTimeout(() => this._restoreModalizerFocus(focusedElement), 100);
				}
			};
			this._tabster = tabster;
			this._win = tabster.getWindow;
			this._modalizers = {};
			this._parts = {};
			this._augMap = /* @__PURE__ */ new WeakMap();
			this._aug = [];
			this._alwaysAccessibleSelector = alwaysAccessibleSelector;
			this._accessibleCheck = accessibleCheck;
			this._activationHistory = [];
			this.activeElements = [];
			if (!tabster.controlTab) tabster.root.addDummyInputs();
			this._win().addEventListener("keydown", this._onKeyDown, true);
			tabster.queueInit(() => {
				this._tabster.focusedElement.subscribe(this._onFocus);
			});
		}
		dispose() {
			const win = this._win();
			win.removeEventListener("keydown", this._onKeyDown, true);
			Object.keys(this._modalizers).forEach((modalizerId) => {
				if (this._modalizers[modalizerId]) {
					this._modalizers[modalizerId].dispose();
					delete this._modalizers[modalizerId];
				}
			});
			win.clearTimeout(this._restoreModalizerFocusTimer);
			win.clearTimeout(this._hiddenUpdateTimer);
			this._parts = {};
			delete this.activeId;
			this.activeElements = [];
			this._augMap = /* @__PURE__ */ new WeakMap();
			this._aug = [];
			this._tabster.focusedElement.unsubscribe(this._onFocus);
		}
		createModalizer(element, props, sys) {
			var _a;
			const modalizer = new Modalizer(this._tabster, element, this._onModalizerDispose, props, sys, this.activeElements);
			const id = modalizer.id;
			const userId = props.id;
			this._modalizers[id] = modalizer;
			let part = this._parts[userId];
			if (!part) part = this._parts[userId] = {};
			part[id] = modalizer;
			const focusedElement = (_a = this._tabster.focusedElement.getFocusedElement()) !== null && _a !== void 0 ? _a : null;
			if (element !== focusedElement && dom.nodeContains(element, focusedElement)) if (userId !== this.activeId) this.setActive(modalizer);
			else modalizer.makeActive(true);
			return modalizer;
		}
		isAugmented(element) {
			return this._augMap.has(element);
		}
		hiddenUpdate() {
			if (this._hiddenUpdateTimer) return;
			this._hiddenUpdateTimer = this._win().setTimeout(() => {
				delete this._hiddenUpdateTimer;
				this._hiddenUpdate();
			}, 250);
		}
		setActive(modalizer) {
			const userId = modalizer === null || modalizer === void 0 ? void 0 : modalizer.userId;
			const activeId = this.activeId;
			if (activeId === userId) return;
			this.activeId = userId;
			if (activeId) {
				const part = this._parts[activeId];
				if (part) for (const id of Object.keys(part)) part[id].makeActive(false);
			}
			if (userId) {
				const part = this._parts[userId];
				if (part) for (const id of Object.keys(part)) part[id].makeActive(true);
			}
			this.currentIsOthersAccessible = modalizer === null || modalizer === void 0 ? void 0 : modalizer.getProps().isOthersAccessible;
			this.hiddenUpdate();
			const activationHistory = this._activationHistory;
			if (activationHistory[0] !== userId && (userId !== void 0 || activationHistory.length > 0)) activationHistory.unshift(userId);
		}
		focus(elementFromModalizer, noFocusFirst, noFocusDefault) {
			const tabster = this._tabster;
			const ctx = RootAPI.getTabsterContext(tabster, elementFromModalizer);
			const modalizer = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer;
			if (modalizer) {
				this.setActive(modalizer);
				const props = modalizer.getProps();
				const modalizerRoot = modalizer.getElement();
				if (modalizerRoot) {
					if (noFocusFirst === void 0) noFocusFirst = props.isNoFocusFirst;
					if (!noFocusFirst && tabster.keyboardNavigation.isNavigatingWithKeyboard() && tabster.focusedElement.focusFirst({ container: modalizerRoot })) return true;
					if (noFocusDefault === void 0) noFocusDefault = props.isNoFocusDefault;
					if (!noFocusDefault && tabster.focusedElement.focusDefault(modalizerRoot)) return true;
					tabster.focusedElement.resetFocus(modalizerRoot);
				}
			} else console.error("Element is not in Modalizer.", elementFromModalizer);
			return false;
		}
		activate(modalizerElementOrContainer) {
			var _a;
			const modalizerToActivate = modalizerElementOrContainer ? (_a = RootAPI.getTabsterContext(this._tabster, modalizerElementOrContainer)) === null || _a === void 0 ? void 0 : _a.modalizer : void 0;
			if (!modalizerElementOrContainer || modalizerToActivate) {
				this.setActive(modalizerToActivate);
				return true;
			}
			return false;
		}
		acceptElement(element, state) {
			var _a;
			const modalizerUserId = state.modalizerUserId;
			const currentModalizer = (_a = state.currentCtx) === null || _a === void 0 ? void 0 : _a.modalizer;
			if (modalizerUserId) for (const e of this.activeElements) {
				const el = e.get();
				if (el && (dom.nodeContains(element, el) || el === element)) return NodeFilter.FILTER_SKIP;
			}
			const ret = modalizerUserId === (currentModalizer === null || currentModalizer === void 0 ? void 0 : currentModalizer.userId) || !modalizerUserId && (currentModalizer === null || currentModalizer === void 0 ? void 0 : currentModalizer.getProps().isAlwaysAccessible) ? void 0 : NodeFilter.FILTER_SKIP;
			if (ret !== void 0) state.skippedFocusable = true;
			return ret;
		}
		_hiddenUpdate() {
			var _a;
			const tabster = this._tabster;
			const body = tabster.getWindow().document.body;
			const activeId = this.activeId;
			const parts = this._parts;
			const visibleElements = [];
			const hiddenElements = [];
			const alwaysAccessibleSelector = this._alwaysAccessibleSelector;
			const alwaysAccessibleElements = alwaysAccessibleSelector ? Array.from(dom.querySelectorAll(body, alwaysAccessibleSelector)) : [];
			const activeModalizerElements = [];
			for (const userId of Object.keys(parts)) {
				const modalizerParts = parts[userId];
				for (const id of Object.keys(modalizerParts)) {
					const modalizer = modalizerParts[id];
					const el = modalizer.getElement();
					const isAlwaysAccessible = modalizer.getProps().isAlwaysAccessible;
					if (el) if (userId === activeId) {
						activeModalizerElements.push(el);
						if (!this.currentIsOthersAccessible) visibleElements.push(el);
					} else if (isAlwaysAccessible) alwaysAccessibleElements.push(el);
					else hiddenElements.push(el);
				}
			}
			const augmentedMap = this._augMap;
			const allVisibleElements = visibleElements.length > 0 ? [...visibleElements, ...alwaysAccessibleElements] : void 0;
			const newAugmented = [];
			const newAugmentedMap = /* @__PURE__ */ new WeakMap();
			const toggle = (element, hide$2) => {
				var _a$1;
				const tagName = element.tagName;
				if (tagName === "SCRIPT" || tagName === "STYLE") return;
				let isAugmented = false;
				if (augmentedMap.has(element)) if (hide$2) isAugmented = true;
				else {
					augmentedMap.delete(element);
					augmentAttribute(tabster, element, _ariaHidden);
				}
				else if (hide$2 && !((_a$1 = this._accessibleCheck) === null || _a$1 === void 0 ? void 0 : _a$1.call(this, element, activeModalizerElements)) && augmentAttribute(tabster, element, _ariaHidden, "true")) {
					augmentedMap.set(element, true);
					isAugmented = true;
				}
				if (isAugmented) {
					newAugmented.push(new WeakHTMLElement(tabster.getWindow, element));
					newAugmentedMap.set(element, true);
				}
			};
			const walk = (element) => {
				var _a$1;
				for (let el = dom.getFirstElementChild(element); el; el = dom.getNextElementSibling(el)) {
					let skip = false;
					let containsModalizer = false;
					let containedByModalizer = false;
					if (allVisibleElements) {
						const elParent = tabster.getParent(el);
						for (const c of allVisibleElements) {
							if (el === c) {
								skip = true;
								break;
							}
							if (dom.nodeContains(el, c)) {
								containsModalizer = true;
								break;
							} else if (dom.nodeContains(c, elParent)) containedByModalizer = true;
						}
						if (containsModalizer || ((_a$1 = el.__tabsterElementFlags) === null || _a$1 === void 0 ? void 0 : _a$1.noDirectAriaHidden)) walk(el);
						else if (!skip && !containedByModalizer) toggle(el, true);
					} else toggle(el, false);
				}
			};
			if (!allVisibleElements) alwaysAccessibleElements.forEach((e) => toggle(e, false));
			hiddenElements.forEach((e) => toggle(e, true));
			if (body) walk(body);
			(_a = this._aug) === null || _a === void 0 || _a.map((e) => e.get()).forEach((e) => {
				if (e && !newAugmentedMap.get(e)) toggle(e, false);
			});
			this._aug = newAugmented;
			this._augMap = newAugmentedMap;
		}
		/**
		* Called when an element is focused outside of an active modalizer.
		* Attempts to pull focus back into the active modalizer
		* @param outsideElement - An element being focused outside of the modalizer
		*/
		_restoreModalizerFocus(outsideElement) {
			var _a;
			const ownerDocument = outsideElement === null || outsideElement === void 0 ? void 0 : outsideElement.ownerDocument;
			if (!outsideElement || !ownerDocument) return;
			const focusedElement = this._tabster.focusedElement.getFocusedElement();
			const focusedElementModalizer = focusedElement && ((_a = RootAPI.getTabsterContext(this._tabster, focusedElement)) === null || _a === void 0 ? void 0 : _a.modalizer);
			if (!focusedElement || focusedElement && (focusedElementModalizer === null || focusedElementModalizer === void 0 ? void 0 : focusedElementModalizer.userId) === this.activeId) return;
			const tabster = this._tabster;
			const ctx = RootAPI.getTabsterContext(tabster, outsideElement);
			const modalizer = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer;
			const activeId = this.activeId;
			if (!modalizer && !activeId || modalizer && activeId === modalizer.userId) return;
			const container = ctx === null || ctx === void 0 ? void 0 : ctx.root.getElement();
			if (container) {
				let toFocus = tabster.focusable.findFirst({
					container,
					useActiveModalizer: true
				});
				if (toFocus) {
					if (outsideElement.compareDocumentPosition(toFocus) & document.DOCUMENT_POSITION_PRECEDING) {
						toFocus = tabster.focusable.findLast({
							container,
							useActiveModalizer: true
						});
						if (!toFocus) throw new Error("Something went wrong.");
					}
					tabster.focusedElement.focus(toFocus);
					return;
				}
			}
			outsideElement.blur();
		}
	};
	/*!
	* Copyright (c) Microsoft Corporation. All rights reserved.
	* Licensed under the MIT License.
	*/
	const _inputSelector = /* @__PURE__ */ [
		"input",
		"textarea",
		"*[contenteditable]"
	].join(", ");
	var MoverDummyManager = class extends DummyInputManager {
		constructor(element, tabster, getMemorized, sys) {
			super(tabster, element, DummyInputManagerPriorities.Mover, sys);
			this._onFocusDummyInput = (dummyInput) => {
				var _a, _b;
				const container = this._element.get();
				const input = dummyInput.input;
				if (container && input) {
					const ctx = RootAPI.getTabsterContext(this._tabster, container);
					let toFocus;
					if (ctx) toFocus = (_a = FocusedElementState.findNextTabbable(this._tabster, ctx, void 0, input, void 0, !dummyInput.isFirst, true)) === null || _a === void 0 ? void 0 : _a.element;
					const memorized = (_b = this._getMemorized()) === null || _b === void 0 ? void 0 : _b.get();
					if (memorized && this._tabster.focusable.isFocusable(memorized)) toFocus = memorized;
					if (toFocus) nativeFocus(toFocus);
				}
			};
			this._tabster = tabster;
			this._getMemorized = getMemorized;
			this._setHandlers(this._onFocusDummyInput);
		}
	};
	const _moverUpdateAdd = 1;
	const _moverUpdateAttr = 2;
	const _moverUpdateRemove = 3;
	var Mover = class extends TabsterPart {
		constructor(tabster, element, onDispose, props, sys) {
			var _a;
			super(tabster, element, props);
			this._visible = {};
			this._onIntersection = (entries) => {
				for (const entry of entries) {
					const el = entry.target;
					const id = getElementUId(this._win, el);
					let newVisibility;
					let fullyVisible = this._fullyVisible;
					if (entry.intersectionRatio >= .25) {
						newVisibility = entry.intersectionRatio >= .75 ? Visibilities.Visible : Visibilities.PartiallyVisible;
						if (newVisibility === Visibilities.Visible) fullyVisible = id;
					} else newVisibility = Visibilities.Invisible;
					if (this._visible[id] !== newVisibility) {
						if (newVisibility === void 0) {
							delete this._visible[id];
							if (fullyVisible === id) delete this._fullyVisible;
						} else {
							this._visible[id] = newVisibility;
							this._fullyVisible = fullyVisible;
						}
						const state = this.getState(el);
						if (state) el.dispatchEvent(new MoverStateEvent(state));
					}
				}
			};
			this._win = tabster.getWindow;
			this.visibilityTolerance = (_a = props.visibilityTolerance) !== null && _a !== void 0 ? _a : .8;
			if (this._props.trackState || this._props.visibilityAware) {
				this._intersectionObserver = new IntersectionObserver(this._onIntersection, { threshold: [
					0,
					.25,
					.5,
					.75,
					1
				] });
				this._observeState();
			}
			this._onDispose = onDispose;
			const getMemorized = () => props.memorizeCurrent ? this._current : void 0;
			if (!tabster.controlTab) this.dummyManager = new MoverDummyManager(this._element, tabster, getMemorized, sys);
		}
		dispose() {
			var _a;
			this._onDispose(this);
			if (this._intersectionObserver) {
				this._intersectionObserver.disconnect();
				delete this._intersectionObserver;
			}
			delete this._current;
			delete this._fullyVisible;
			delete this._allElements;
			delete this._updateQueue;
			if (this._unobserve) {
				this._unobserve();
				delete this._unobserve;
			}
			const win = this._win();
			if (this._setCurrentTimer) {
				win.clearTimeout(this._setCurrentTimer);
				delete this._setCurrentTimer;
			}
			if (this._updateTimer) {
				win.clearTimeout(this._updateTimer);
				delete this._updateTimer;
			}
			(_a = this.dummyManager) === null || _a === void 0 || _a.dispose();
			delete this.dummyManager;
		}
		setCurrent(element) {
			if (element) this._current = new WeakHTMLElement(this._win, element);
			else this._current = void 0;
			if ((this._props.trackState || this._props.visibilityAware) && !this._setCurrentTimer) this._setCurrentTimer = this._win().setTimeout(() => {
				var _a;
				delete this._setCurrentTimer;
				const changed = [];
				if (this._current !== this._prevCurrent) {
					changed.push(this._current);
					changed.push(this._prevCurrent);
					this._prevCurrent = this._current;
				}
				for (const weak of changed) {
					const el = weak === null || weak === void 0 ? void 0 : weak.get();
					if (el && ((_a = this._allElements) === null || _a === void 0 ? void 0 : _a.get(el)) === this) {
						const props = this._props;
						if (el && (props.visibilityAware !== void 0 || props.trackState)) {
							const state = this.getState(el);
							if (state) el.dispatchEvent(new MoverStateEvent(state));
						}
					}
				}
			});
		}
		getCurrent() {
			var _a;
			return ((_a = this._current) === null || _a === void 0 ? void 0 : _a.get()) || null;
		}
		findNextTabbable(currentElement, referenceElement, isBackward, ignoreAccessibility) {
			const container = this.getElement();
			const currentIsDummy = container && getDummyInputContainer(currentElement) === container;
			if (!container) return null;
			let next$1 = null;
			let outOfDOMOrder = false;
			let uncontrolled;
			if (this._props.tabbable || currentIsDummy || currentElement && !dom.nodeContains(container, currentElement)) {
				const findProps = {
					currentElement,
					referenceElement,
					container,
					ignoreAccessibility,
					useActiveModalizer: true
				};
				const findPropsOut = {};
				next$1 = this._tabster.focusable[isBackward ? "findPrev" : "findNext"](findProps, findPropsOut);
				outOfDOMOrder = !!findPropsOut.outOfDOMOrder;
				uncontrolled = findPropsOut.uncontrolled;
			}
			return {
				element: next$1,
				uncontrolled,
				outOfDOMOrder
			};
		}
		acceptElement(element, state) {
			var _a, _b;
			if (!FocusedElementState.isTabbing) return ((_a = state.currentCtx) === null || _a === void 0 ? void 0 : _a.excludedFromMover) ? NodeFilter.FILTER_REJECT : void 0;
			const { memorizeCurrent, visibilityAware, hasDefault = true } = this._props;
			const moverElement = this.getElement();
			if (moverElement && (memorizeCurrent || visibilityAware || hasDefault) && (!dom.nodeContains(moverElement, state.from) || getDummyInputContainer(state.from) === moverElement)) {
				let found;
				if (memorizeCurrent) {
					const current = (_b = this._current) === null || _b === void 0 ? void 0 : _b.get();
					if (current && state.acceptCondition(current)) found = current;
				}
				if (!found && hasDefault) found = this._tabster.focusable.findDefault({
					container: moverElement,
					useActiveModalizer: true
				});
				if (!found && visibilityAware) found = this._tabster.focusable.findElement({
					container: moverElement,
					useActiveModalizer: true,
					isBackward: state.isBackward,
					acceptCondition: (el) => {
						var _a$1;
						const id = getElementUId(this._win, el);
						const visibility = this._visible[id];
						return moverElement !== el && !!((_a$1 = this._allElements) === null || _a$1 === void 0 ? void 0 : _a$1.get(el)) && state.acceptCondition(el) && (visibility === Visibilities.Visible || visibility === Visibilities.PartiallyVisible && (visibilityAware === Visibilities.PartiallyVisible || !this._fullyVisible));
					}
				});
				if (found) {
					state.found = true;
					state.foundElement = found;
					state.rejectElementsFrom = moverElement;
					state.skippedFocusable = true;
					return NodeFilter.FILTER_ACCEPT;
				}
			}
		}
		_observeState() {
			const element = this.getElement();
			if (this._unobserve || !element || typeof MutationObserver === "undefined") return;
			const win = this._win();
			const allElements = this._allElements = /* @__PURE__ */ new WeakMap();
			const tabsterFocusable = this._tabster.focusable;
			let updateQueue = this._updateQueue = [];
			const observer = dom.createMutationObserver((mutations) => {
				for (const mutation of mutations) {
					const target = mutation.target;
					const removed = mutation.removedNodes;
					const added = mutation.addedNodes;
					if (mutation.type === "attributes") {
						if (mutation.attributeName === "tabindex") updateQueue.push({
							element: target,
							type: _moverUpdateAttr
						});
					} else {
						for (let i = 0; i < removed.length; i++) updateQueue.push({
							element: removed[i],
							type: _moverUpdateRemove
						});
						for (let i = 0; i < added.length; i++) updateQueue.push({
							element: added[i],
							type: _moverUpdateAdd
						});
					}
				}
				requestUpdate();
			});
			const setElement = (element$1, remove) => {
				var _a, _b;
				const current = allElements.get(element$1);
				if (current && remove) {
					(_a = this._intersectionObserver) === null || _a === void 0 || _a.unobserve(element$1);
					allElements.delete(element$1);
				}
				if (!current && !remove) {
					allElements.set(element$1, this);
					(_b = this._intersectionObserver) === null || _b === void 0 || _b.observe(element$1);
				}
			};
			const updateElement = (element$1) => {
				const isFocusable = tabsterFocusable.isFocusable(element$1);
				if (allElements.get(element$1)) {
					if (!isFocusable) setElement(element$1, true);
				} else if (isFocusable) setElement(element$1);
			};
			const addNewElements = (element$1) => {
				const { mover } = getMoverGroupper(element$1);
				if (mover && mover !== this) if (mover.getElement() === element$1 && tabsterFocusable.isFocusable(element$1)) setElement(element$1);
				else return;
				const walker = createElementTreeWalker(win.document, element$1, (node$1) => {
					const { mover: mover$1, groupper } = getMoverGroupper(node$1);
					if (mover$1 && mover$1 !== this) return NodeFilter.FILTER_REJECT;
					const groupperFirstFocusable = groupper === null || groupper === void 0 ? void 0 : groupper.getFirst(true);
					if (groupper && groupper.getElement() !== node$1 && groupperFirstFocusable && groupperFirstFocusable !== node$1) return NodeFilter.FILTER_REJECT;
					if (tabsterFocusable.isFocusable(node$1)) setElement(node$1);
					return NodeFilter.FILTER_SKIP;
				});
				if (walker) {
					walker.currentNode = element$1;
					while (walker.nextNode());
				}
			};
			const removeWalk = (element$1) => {
				if (allElements.get(element$1)) setElement(element$1, true);
				for (let el = dom.getFirstElementChild(element$1); el; el = dom.getNextElementSibling(el)) removeWalk(el);
			};
			const requestUpdate = () => {
				if (!this._updateTimer && updateQueue.length) this._updateTimer = win.setTimeout(() => {
					delete this._updateTimer;
					for (const { element: element$1, type } of updateQueue) switch (type) {
						case _moverUpdateAttr:
							updateElement(element$1);
							break;
						case _moverUpdateAdd:
							addNewElements(element$1);
							break;
						case _moverUpdateRemove:
							removeWalk(element$1);
							break;
					}
					updateQueue = this._updateQueue = [];
				}, 0);
			};
			const getMoverGroupper = (element$1) => {
				const ret = {};
				for (let el = element$1; el; el = dom.getParentElement(el)) {
					const toe = getTabsterOnElement(this._tabster, el);
					if (toe) {
						if (toe.groupper && !ret.groupper) ret.groupper = toe.groupper;
						if (toe.mover) {
							ret.mover = toe.mover;
							break;
						}
					}
				}
				return ret;
			};
			updateQueue.push({
				element,
				type: _moverUpdateAdd
			});
			requestUpdate();
			observer.observe(element, {
				childList: true,
				subtree: true,
				attributes: true,
				attributeFilter: ["tabindex"]
			});
			this._unobserve = () => {
				observer.disconnect();
			};
		}
		getState(element) {
			const id = getElementUId(this._win, element);
			if (id in this._visible) {
				const visibility = this._visible[id] || Visibilities.Invisible;
				return {
					isCurrent: this._current ? this._current.get() === element : void 0,
					visibility
				};
			}
		}
	};
	/**
	* Calculates distance between two rectangles.
	*
	* @param ax1 first rectangle left
	* @param ay1 first rectangle top
	* @param ax2 first rectangle right
	* @param ay2 first rectangle bottom
	* @param bx1 second rectangle left
	* @param by1 second rectangle top
	* @param bx2 second rectangle right
	* @param by2 second rectangle bottom
	* @returns number, shortest distance between the rectangles.
	*/
	function getDistance(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {
		const xDistance = ax2 < bx1 ? bx1 - ax2 : bx2 < ax1 ? ax1 - bx2 : 0;
		const yDistance = ay2 < by1 ? by1 - ay2 : by2 < ay1 ? ay1 - by2 : 0;
		return xDistance === 0 ? yDistance : yDistance === 0 ? xDistance : Math.sqrt(xDistance * xDistance + yDistance * yDistance);
	}
	var MoverAPI = class {
		constructor(tabster, getWindow$1) {
			this._init = () => {
				const win = this._win();
				win.addEventListener("keydown", this._onKeyDown, true);
				win.addEventListener(MoverMoveFocusEventName, this._onMoveFocus);
				win.addEventListener(MoverMemorizedElementEventName, this._onMemorizedElement);
				this._tabster.focusedElement.subscribe(this._onFocus);
			};
			this._onMoverDispose = (mover) => {
				delete this._movers[mover.id];
			};
			this._onFocus = (element) => {
				var _a;
				let currentFocusableElement = element;
				let deepestFocusableElement = element;
				for (let el = dom.getParentElement(element); el; el = dom.getParentElement(el)) {
					const mover = (_a = getTabsterOnElement(this._tabster, el)) === null || _a === void 0 ? void 0 : _a.mover;
					if (mover) {
						mover.setCurrent(deepestFocusableElement);
						currentFocusableElement = void 0;
					}
					if (!currentFocusableElement && this._tabster.focusable.isFocusable(el)) currentFocusableElement = deepestFocusableElement = el;
				}
			};
			this._onKeyDown = async (event) => {
				var _a;
				if (this._ignoredInputTimer) {
					this._win().clearTimeout(this._ignoredInputTimer);
					delete this._ignoredInputTimer;
				}
				(_a = this._ignoredInputResolve) === null || _a === void 0 || _a.call(this, false);
				if (event.ctrlKey || event.altKey || event.shiftKey || event.metaKey) return;
				const key = event.key;
				let moverKey;
				if (key === Keys.ArrowDown) moverKey = MoverKeys.ArrowDown;
				else if (key === Keys.ArrowRight) moverKey = MoverKeys.ArrowRight;
				else if (key === Keys.ArrowUp) moverKey = MoverKeys.ArrowUp;
				else if (key === Keys.ArrowLeft) moverKey = MoverKeys.ArrowLeft;
				else if (key === Keys.PageDown) moverKey = MoverKeys.PageDown;
				else if (key === Keys.PageUp) moverKey = MoverKeys.PageUp;
				else if (key === Keys.Home) moverKey = MoverKeys.Home;
				else if (key === Keys.End) moverKey = MoverKeys.End;
				if (!moverKey) return;
				const focused = this._tabster.focusedElement.getFocusedElement();
				if (!focused || await this._isIgnoredInput(focused, key)) return;
				this._moveFocus(focused, moverKey, event);
			};
			this._onMoveFocus = (e) => {
				var _a;
				const element = e.composedPath()[0];
				const key = (_a = e.detail) === null || _a === void 0 ? void 0 : _a.key;
				if (element && key !== void 0 && !e.defaultPrevented) {
					this._moveFocus(element, key);
					e.stopImmediatePropagation();
				}
			};
			this._onMemorizedElement = (e) => {
				var _a;
				const target = e.composedPath()[0];
				let memorizedElement = (_a = e.detail) === null || _a === void 0 ? void 0 : _a.memorizedElement;
				if (target) {
					const ctx = RootAPI.getTabsterContext(this._tabster, target);
					const mover = ctx === null || ctx === void 0 ? void 0 : ctx.mover;
					if (mover) {
						if (memorizedElement && !dom.nodeContains(mover.getElement(), memorizedElement)) memorizedElement = void 0;
						mover.setCurrent(memorizedElement);
						e.stopImmediatePropagation();
					}
				}
			};
			this._tabster = tabster;
			this._win = getWindow$1;
			this._movers = {};
			tabster.queueInit(this._init);
		}
		dispose() {
			var _a;
			const win = this._win();
			this._tabster.focusedElement.unsubscribe(this._onFocus);
			(_a = this._ignoredInputResolve) === null || _a === void 0 || _a.call(this, false);
			if (this._ignoredInputTimer) {
				win.clearTimeout(this._ignoredInputTimer);
				delete this._ignoredInputTimer;
			}
			win.removeEventListener("keydown", this._onKeyDown, true);
			win.removeEventListener(MoverMoveFocusEventName, this._onMoveFocus);
			win.removeEventListener(MoverMemorizedElementEventName, this._onMemorizedElement);
			Object.keys(this._movers).forEach((moverId) => {
				if (this._movers[moverId]) {
					this._movers[moverId].dispose();
					delete this._movers[moverId];
				}
			});
		}
		createMover(element, props, sys) {
			const newMover = new Mover(this._tabster, element, this._onMoverDispose, props, sys);
			this._movers[newMover.id] = newMover;
			return newMover;
		}
		moveFocus(fromElement, key) {
			return this._moveFocus(fromElement, key);
		}
		_moveFocus(fromElement, key, relatedEvent) {
			var _a, _b;
			const tabster = this._tabster;
			const ctx = RootAPI.getTabsterContext(tabster, fromElement, { checkRtl: true });
			if (!ctx || !ctx.mover || ctx.excludedFromMover || relatedEvent && ctx.ignoreKeydown(relatedEvent)) return null;
			const mover = ctx.mover;
			const container = mover.getElement();
			if (ctx.groupperBeforeMover) {
				const groupper = ctx.groupper;
				if (groupper && !groupper.isActive(true)) {
					for (let el = dom.getParentElement(groupper.getElement()); el && el !== container; el = dom.getParentElement(el)) if ((_b = (_a = getTabsterOnElement(tabster, el)) === null || _a === void 0 ? void 0 : _a.groupper) === null || _b === void 0 ? void 0 : _b.isActive(true)) return null;
				} else return null;
			}
			if (!container) return null;
			const focusable = tabster.focusable;
			const moverProps = mover.getProps();
			const direction = moverProps.direction || MoverDirections.Both;
			const isBoth = direction === MoverDirections.Both;
			const isVertical = isBoth || direction === MoverDirections.Vertical;
			const isHorizontal = isBoth || direction === MoverDirections.Horizontal;
			const isGridLinear = direction === MoverDirections.GridLinear;
			const isGrid = isGridLinear || direction === MoverDirections.Grid;
			const isCyclic = moverProps.cyclic;
			let next$1;
			let scrollIntoViewArg;
			let focusedElementRect;
			let focusedElementX1 = 0;
			let focusedElementX2 = 0;
			if (isGrid) {
				focusedElementRect = fromElement.getBoundingClientRect();
				focusedElementX1 = Math.ceil(focusedElementRect.left);
				focusedElementX2 = Math.floor(focusedElementRect.right);
			}
			if (ctx.rtl) {
				if (key === MoverKeys.ArrowRight) key = MoverKeys.ArrowLeft;
				else if (key === MoverKeys.ArrowLeft) key = MoverKeys.ArrowRight;
			}
			if (key === MoverKeys.ArrowDown && isVertical || key === MoverKeys.ArrowRight && (isHorizontal || isGrid)) {
				next$1 = focusable.findNext({
					currentElement: fromElement,
					container,
					useActiveModalizer: true
				});
				if (next$1 && isGrid) {
					const nextElementX1 = Math.ceil(next$1.getBoundingClientRect().left);
					if (!isGridLinear && focusedElementX2 > nextElementX1) next$1 = void 0;
				} else if (!next$1 && isCyclic) next$1 = focusable.findFirst({
					container,
					useActiveModalizer: true
				});
			} else if (key === MoverKeys.ArrowUp && isVertical || key === MoverKeys.ArrowLeft && (isHorizontal || isGrid)) {
				next$1 = focusable.findPrev({
					currentElement: fromElement,
					container,
					useActiveModalizer: true
				});
				if (next$1 && isGrid) {
					const nextElementX2 = Math.floor(next$1.getBoundingClientRect().right);
					if (!isGridLinear && nextElementX2 > focusedElementX1) next$1 = void 0;
				} else if (!next$1 && isCyclic) next$1 = focusable.findLast({
					container,
					useActiveModalizer: true
				});
			} else if (key === MoverKeys.Home) if (isGrid) focusable.findElement({
				container,
				currentElement: fromElement,
				useActiveModalizer: true,
				isBackward: true,
				acceptCondition: (el) => {
					var _a$1;
					if (!focusable.isFocusable(el)) return false;
					const nextElementX1 = Math.ceil((_a$1 = el.getBoundingClientRect().left) !== null && _a$1 !== void 0 ? _a$1 : 0);
					if (el !== fromElement && focusedElementX1 <= nextElementX1) return true;
					next$1 = el;
					return false;
				}
			});
			else next$1 = focusable.findFirst({
				container,
				useActiveModalizer: true
			});
			else if (key === MoverKeys.End) if (isGrid) focusable.findElement({
				container,
				currentElement: fromElement,
				useActiveModalizer: true,
				acceptCondition: (el) => {
					var _a$1;
					if (!focusable.isFocusable(el)) return false;
					const nextElementX1 = Math.ceil((_a$1 = el.getBoundingClientRect().left) !== null && _a$1 !== void 0 ? _a$1 : 0);
					if (el !== fromElement && focusedElementX1 >= nextElementX1) return true;
					next$1 = el;
					return false;
				}
			});
			else next$1 = focusable.findLast({
				container,
				useActiveModalizer: true
			});
			else if (key === MoverKeys.PageUp) {
				focusable.findElement({
					currentElement: fromElement,
					container,
					useActiveModalizer: true,
					isBackward: true,
					acceptCondition: (el) => {
						if (!focusable.isFocusable(el)) return false;
						if (isElementVerticallyVisibleInContainer(this._win, el, mover.visibilityTolerance)) {
							next$1 = el;
							return false;
						}
						return true;
					}
				});
				if (isGrid && next$1) {
					const firstColumnX1 = Math.ceil(next$1.getBoundingClientRect().left);
					focusable.findElement({
						currentElement: next$1,
						container,
						useActiveModalizer: true,
						acceptCondition: (el) => {
							if (!focusable.isFocusable(el)) return false;
							const nextElementX1 = Math.ceil(el.getBoundingClientRect().left);
							if (focusedElementX1 < nextElementX1 || firstColumnX1 >= nextElementX1) return true;
							next$1 = el;
							return false;
						}
					});
				}
				scrollIntoViewArg = false;
			} else if (key === MoverKeys.PageDown) {
				focusable.findElement({
					currentElement: fromElement,
					container,
					useActiveModalizer: true,
					acceptCondition: (el) => {
						if (!focusable.isFocusable(el)) return false;
						if (isElementVerticallyVisibleInContainer(this._win, el, mover.visibilityTolerance)) {
							next$1 = el;
							return false;
						}
						return true;
					}
				});
				if (isGrid && next$1) {
					const lastColumnX1 = Math.ceil(next$1.getBoundingClientRect().left);
					focusable.findElement({
						currentElement: next$1,
						container,
						useActiveModalizer: true,
						isBackward: true,
						acceptCondition: (el) => {
							if (!focusable.isFocusable(el)) return false;
							const nextElementX1 = Math.ceil(el.getBoundingClientRect().left);
							if (focusedElementX1 > nextElementX1 || lastColumnX1 <= nextElementX1) return true;
							next$1 = el;
							return false;
						}
					});
				}
				scrollIntoViewArg = true;
			} else if (isGrid) {
				const isBackward = key === MoverKeys.ArrowUp;
				const ax1 = focusedElementX1;
				const ay1 = Math.ceil(focusedElementRect.top);
				const ax2 = focusedElementX2;
				const ay2 = Math.floor(focusedElementRect.bottom);
				let targetElement;
				let lastDistance;
				let lastIntersection = 0;
				focusable.findAll({
					container,
					currentElement: fromElement,
					isBackward,
					onElement: (el) => {
						const rect = el.getBoundingClientRect();
						const bx1 = Math.ceil(rect.left);
						const by1 = Math.ceil(rect.top);
						const bx2 = Math.floor(rect.right);
						const by2 = Math.floor(rect.bottom);
						if (isBackward && ay1 < by2 || !isBackward && ay2 > by1) return true;
						const xIntersectionWidth = Math.ceil(Math.min(ax2, bx2)) - Math.floor(Math.max(ax1, bx1));
						const minWidth = Math.ceil(Math.min(ax2 - ax1, bx2 - bx1));
						if (xIntersectionWidth > 0 && minWidth >= xIntersectionWidth) {
							const intersection = xIntersectionWidth / minWidth;
							if (intersection > lastIntersection) {
								targetElement = el;
								lastIntersection = intersection;
							}
						} else if (lastIntersection === 0) {
							const distance = getDistance(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2);
							if (lastDistance === void 0 || distance < lastDistance) {
								lastDistance = distance;
								targetElement = el;
							}
						} else if (lastIntersection > 0) return false;
						return true;
					}
				});
				next$1 = targetElement;
			}
			if (next$1 && (!relatedEvent || relatedEvent && container.dispatchEvent(new TabsterMoveFocusEvent({
				by: "mover",
				owner: container,
				next: next$1,
				relatedEvent
			})))) {
				if (scrollIntoViewArg !== void 0) scrollIntoView$1(this._win, next$1, scrollIntoViewArg);
				if (relatedEvent) {
					relatedEvent.preventDefault();
					relatedEvent.stopImmediatePropagation();
				}
				nativeFocus(next$1);
				return next$1;
			}
			return null;
		}
		async _isIgnoredInput(element, key) {
			if (element.getAttribute("aria-expanded") === "true" && (element.hasAttribute("aria-activedescendant") || element.getAttribute("role") === "combobox")) return true;
			if (matchesSelector(element, _inputSelector)) {
				let selectionStart = 0;
				let selectionEnd = 0;
				let textLength = 0;
				let asyncRet;
				if (element.tagName === "INPUT" || element.tagName === "TEXTAREA") {
					const type = element.type;
					textLength = (element.value || "").length;
					if (type === "email" || type === "number") {
						if (textLength) {
							const selection = dom.getSelection(element);
							if (selection) {
								const initialLength = selection.toString().length;
								const isBackward = key === Keys.ArrowLeft || key === Keys.ArrowUp;
								selection.modify("extend", isBackward ? "backward" : "forward", "character");
								if (initialLength !== selection.toString().length) {
									selection.modify("extend", isBackward ? "forward" : "backward", "character");
									return true;
								} else textLength = 0;
							}
						}
					} else {
						const selStart = element.selectionStart;
						if (selStart === null) return type === "hidden";
						selectionStart = selStart || 0;
						selectionEnd = element.selectionEnd || 0;
					}
				} else if (element.contentEditable === "true") asyncRet = new (getPromise(this._win))((resolve) => {
					this._ignoredInputResolve = (value) => {
						delete this._ignoredInputResolve;
						resolve(value);
					};
					const win = this._win();
					if (this._ignoredInputTimer) win.clearTimeout(this._ignoredInputTimer);
					const { anchorNode: prevAnchorNode, focusNode: prevFocusNode, anchorOffset: prevAnchorOffset, focusOffset: prevFocusOffset } = dom.getSelection(element) || {};
					this._ignoredInputTimer = win.setTimeout(() => {
						var _a, _b, _c;
						delete this._ignoredInputTimer;
						const { anchorNode, focusNode, anchorOffset, focusOffset } = dom.getSelection(element) || {};
						if (anchorNode !== prevAnchorNode || focusNode !== prevFocusNode || anchorOffset !== prevAnchorOffset || focusOffset !== prevFocusOffset) {
							(_a = this._ignoredInputResolve) === null || _a === void 0 || _a.call(this, false);
							return;
						}
						selectionStart = anchorOffset || 0;
						selectionEnd = focusOffset || 0;
						textLength = ((_b = element.textContent) === null || _b === void 0 ? void 0 : _b.length) || 0;
						if (anchorNode && focusNode) {
							if (dom.nodeContains(element, anchorNode) && dom.nodeContains(element, focusNode)) {
								if (anchorNode !== element) {
									let anchorFound = false;
									const addOffsets = (node$1) => {
										if (node$1 === anchorNode) anchorFound = true;
										else if (node$1 === focusNode) return true;
										const nodeText = node$1.textContent;
										if (nodeText && !dom.getFirstChild(node$1)) {
											const len = nodeText.length;
											if (anchorFound) {
												if (focusNode !== anchorNode) selectionEnd += len;
											} else {
												selectionStart += len;
												selectionEnd += len;
											}
										}
										let stop = false;
										for (let e = dom.getFirstChild(node$1); e && !stop; e = e.nextSibling) stop = addOffsets(e);
										return stop;
									};
									addOffsets(element);
								}
							}
						}
						(_c = this._ignoredInputResolve) === null || _c === void 0 || _c.call(this, true);
					}, 0);
				});
				if (asyncRet && !await asyncRet) return true;
				if (selectionStart !== selectionEnd) return true;
				if (selectionStart > 0 && (key === Keys.ArrowLeft || key === Keys.ArrowUp || key === Keys.Home)) return true;
				if (selectionStart < textLength && (key === Keys.ArrowRight || key === Keys.ArrowDown || key === Keys.End)) return true;
			}
			return false;
		}
	};
	/*!
	* Copyright (c) Microsoft Corporation. All rights reserved.
	* Licensed under the MIT License.
	*/
	function observeMutations(doc, tabster, updateTabsterByAttribute$1, syncState) {
		if (typeof MutationObserver === "undefined") return () => {};
		const getWindow$1 = tabster.getWindow;
		let elementByUId;
		const onMutation = (mutations) => {
			var _a, _b, _c, _d, _e;
			const removedNodes = /* @__PURE__ */ new Set();
			for (const mutation of mutations) {
				const target = mutation.target;
				const removed = mutation.removedNodes;
				const added = mutation.addedNodes;
				if (mutation.type === "attributes") {
					if (mutation.attributeName === TABSTER_ATTRIBUTE_NAME) {
						if (!removedNodes.has(target)) updateTabsterByAttribute$1(tabster, target);
					}
				} else {
					for (let i = 0; i < removed.length; i++) {
						const removedNode = removed[i];
						removedNodes.add(removedNode);
						updateTabsterElements(removedNode, true);
						(_b = (_a = tabster._dummyObserver).domChanged) === null || _b === void 0 || _b.call(_a, target);
					}
					for (let i = 0; i < added.length; i++) {
						updateTabsterElements(added[i]);
						(_d = (_c = tabster._dummyObserver).domChanged) === null || _d === void 0 || _d.call(_c, target);
					}
				}
			}
			removedNodes.clear();
			(_e = tabster.modalizer) === null || _e === void 0 || _e.hiddenUpdate();
		};
		function updateTabsterElements(node$1, removed) {
			if (!elementByUId) elementByUId = getInstanceContext(getWindow$1).elementByUId;
			processNode(node$1, removed);
			const walker = createElementTreeWalker(doc, node$1, (element) => {
				return processNode(element, removed);
			});
			if (walker) while (walker.nextNode());
		}
		function processNode(element, removed) {
			var _a;
			if (!element.getAttribute) return NodeFilter.FILTER_SKIP;
			const uid = element.__tabsterElementUID;
			if (uid && elementByUId) if (removed) delete elementByUId[uid];
			else (_a = elementByUId[uid]) !== null && _a !== void 0 || (elementByUId[uid] = new WeakHTMLElement(getWindow$1, element));
			if (getTabsterOnElement(tabster, element) || element.hasAttribute(TABSTER_ATTRIBUTE_NAME)) updateTabsterByAttribute$1(tabster, element, removed);
			return NodeFilter.FILTER_SKIP;
		}
		const observer = dom.createMutationObserver(onMutation);
		if (syncState) updateTabsterElements(getWindow$1().document.body);
		observer.observe(doc, {
			childList: true,
			subtree: true,
			attributes: true,
			attributeFilter: [TABSTER_ATTRIBUTE_NAME]
		});
		return () => {
			observer.disconnect();
		};
	}
	/*!
	* Copyright (c) Microsoft Corporation. All rights reserved.
	* Licensed under the MIT License.
	*/
	const _conditionCheckTimeout = 100;
	var ObservedElementAPI = class extends Subscribable {
		constructor(tabster) {
			super();
			this._waiting = {};
			this._lastRequestFocusId = 0;
			this._observedById = {};
			this._observedByName = {};
			this._currentRequestTimestamp = 0;
			this._onFocus = (e) => {
				if (e) {
					const current = this._currentRequest;
					if (current) {
						if (Date.now() - this._currentRequestTimestamp >= 300) {
							delete this._currentRequest;
							current.cancel();
						}
					}
				}
			};
			this.onObservedElementUpdate = (element) => {
				var _a, _b;
				const observed = (_a = getTabsterOnElement(this._tabster, element)) === null || _a === void 0 ? void 0 : _a.observed;
				const uid = getElementUId(this._win, element);
				let info = this._observedById[uid];
				if (observed && documentContains(element.ownerDocument, element)) {
					const isNewElement = !info;
					if (!info) info = this._observedById[uid] = { element: new WeakHTMLElement(this._win, element) };
					observed.names.sort();
					const observedNames = observed.names;
					const prevNames = info.prevNames;
					if (this._isObservedNamesUpdated(observedNames, prevNames)) {
						if (prevNames) prevNames.forEach((prevName) => {
							const obn = this._observedByName[prevName];
							if (obn && obn[uid]) if (Object.keys(obn).length > 1) delete obn[uid];
							else delete this._observedByName[prevName];
						});
						info.prevNames = observedNames;
						this._notifyObservedElementChange(element, observedNames, prevNames, isNewElement);
					}
					observedNames.forEach((observedName) => {
						let obn = this._observedByName[observedName];
						if (!obn) obn = this._observedByName[observedName] = {};
						obn[uid] = info;
						this._waitConditional(observedName);
					});
				} else if (info) {
					const prevNames = info.prevNames;
					if (prevNames) {
						prevNames.forEach((prevName) => {
							const obn = this._observedByName[prevName];
							if (obn && obn[uid]) if (Object.keys(obn).length > 1) delete obn[uid];
							else delete this._observedByName[prevName];
						});
						(_b = this.onObservedElementChange) === null || _b === void 0 || _b.call(this, {
							element,
							type: "removed",
							names: [],
							removedNames: prevNames
						});
					}
					delete this._observedById[uid];
				}
			};
			this._tabster = tabster;
			this._win = tabster.getWindow;
			tabster.queueInit(() => {
				this._tabster.focusedElement.subscribe(this._onFocus);
			});
		}
		dispose() {
			this._tabster.focusedElement.unsubscribe(this._onFocus);
			for (const key of Object.keys(this._waiting)) this._rejectWaiting(key);
			this._observedById = {};
			this._observedByName = {};
			this.onObservedElementChange = void 0;
		}
		_rejectWaiting(key, shouldResolve) {
			const w = this._waiting[key];
			if (w) {
				const win = this._win();
				if (w.timer) win.clearTimeout(w.timer);
				if (w.conditionTimer) win.clearTimeout(w.conditionTimer);
				if (!shouldResolve && w.reject) w.reject();
				else if (shouldResolve && w.resolve) w.resolve(null);
				delete this._waiting[key];
			}
		}
		_isObservedNamesUpdated(cur, prev$1) {
			if (!prev$1 || cur.length !== prev$1.length) return true;
			for (let i = 0; i < cur.length; ++i) if (cur[i] !== prev$1[i]) return true;
			return false;
		}
		_notifyObservedElementChange(element, observedNames, prevNames, isNewElement) {
			if (!this.onObservedElementChange) return;
			const addedNames = observedNames.filter((name) => !prevNames || !prevNames.includes(name));
			const removedNames = prevNames ? prevNames.filter((name) => !observedNames.includes(name)) : [];
			if (isNewElement) this.onObservedElementChange({
				element,
				type: "added",
				names: observedNames,
				addedNames: observedNames
			});
			else if (addedNames.length > 0 || removedNames.length > 0) this.onObservedElementChange({
				element,
				type: "updated",
				names: observedNames,
				addedNames: addedNames.length > 0 ? addedNames : void 0,
				removedNames: removedNames.length > 0 ? removedNames : void 0
			});
		}
		/**
		* Returns all registered observed names with their respective elements and full names arrays
		*
		* @returns Map<string, Array<{ element: HTMLElement; names: string[] }>> A map where keys are observed names
		* and values are arrays of objects containing the element and its complete names array (in the order they were defined)
		*/
		getAllObservedElements() {
			const result = /* @__PURE__ */ new Map();
			for (const name of Object.keys(this._observedByName)) {
				const elementsWithNames = [];
				const observed = this._observedByName[name];
				for (const uid of Object.keys(observed)) {
					const el = observed[uid].element.get();
					if (el) {
						const info = this._observedById[uid];
						elementsWithNames.push({
							element: el,
							names: (info === null || info === void 0 ? void 0 : info.prevNames) || []
						});
					}
				}
				if (elementsWithNames.length > 0) result.set(name, elementsWithNames);
			}
			return result;
		}
		/**
		* Returns existing element by observed name
		*
		* @param observedName An observed name
		* @param accessibility Optionally, return only if the element is accessible or focusable
		* @returns HTMLElement | null
		*/
		getElement(observedName, accessibility) {
			const o = this._observedByName[observedName];
			if (o) for (const uid of Object.keys(o)) {
				let el = o[uid].element.get() || null;
				if (el) {
					if (accessibility === ObservedElementAccessibilities.Accessible && !this._tabster.focusable.isAccessible(el) || accessibility === ObservedElementAccessibilities.Focusable && !this._tabster.focusable.isFocusable(el, true)) el = null;
				} else {
					delete o[uid];
					delete this._observedById[uid];
				}
				return el;
			}
			return null;
		}
		/**
		* Waits for the element to appear in the DOM and returns it.
		*
		* @param observedName An observed name
		* @param timeout Wait no longer than this timeout
		* @param accessibility Optionally, wait for the element to also become accessible or focusable before returning it
		* @returns Promise<HTMLElement | null>
		*/
		waitElement(observedName, timeout, accessibility) {
			const el = this.getElement(observedName, accessibility);
			if (el) return {
				result: getPromise(this._win).resolve(el),
				cancel: () => {},
				status: ObservedElementRequestStatuses.Succeeded
			};
			let prefix$1;
			if (accessibility === ObservedElementAccessibilities.Accessible) prefix$1 = "a";
			else if (accessibility === ObservedElementAccessibilities.Focusable) prefix$1 = "f";
			else prefix$1 = "_";
			const key = prefix$1 + observedName;
			let w = this._waiting[key];
			if (w && w.request) return w.request;
			w = this._waiting[key] = { timer: this._win().setTimeout(() => {
				if (w.conditionTimer) this._win().clearTimeout(w.conditionTimer);
				delete this._waiting[key];
				if (w.request) w.request.status = ObservedElementRequestStatuses.TimedOut;
				if (w.resolve) w.resolve(null);
			}, timeout) };
			const request = {
				result: new (getPromise(this._win))((resolve, reject) => {
					w.resolve = resolve;
					w.reject = reject;
				}).catch(() => {
					return null;
				}),
				cancel: () => {
					if (request.status === ObservedElementRequestStatuses.Waiting) request.status = ObservedElementRequestStatuses.Canceled;
					this._rejectWaiting(key, true);
				},
				status: ObservedElementRequestStatuses.Waiting
			};
			w.request = request;
			if (accessibility && this.getElement(observedName)) this._waitConditional(observedName);
			return request;
		}
		requestFocus(observedName, timeout, options = {}) {
			const requestId = ++this._lastRequestFocusId;
			const currentRequestFocus = this._currentRequest;
			if (currentRequestFocus) currentRequestFocus.cancel();
			const request = this.waitElement(observedName, timeout, ObservedElementAccessibilities.Focusable);
			this._currentRequest = request;
			this._currentRequestTimestamp = Date.now();
			const ret = {
				result: request.result.then((element) => this._lastRequestFocusId === requestId && element ? this._tabster.focusedElement.focus(element, true, void 0, options.preventScroll) : false),
				cancel: () => {
					request.cancel();
				},
				status: request.status
			};
			request.result.finally(() => {
				if (this._currentRequest === request) delete this._currentRequest;
				ret.status = request.status;
			});
			return ret;
		}
		_waitConditional(observedName) {
			const waitingElementKey = "_" + observedName;
			const waitingAccessibleElementKey = "a" + observedName;
			const waitingFocusableElementKey = "f" + observedName;
			const waitingElement = this._waiting[waitingElementKey];
			const waitingAccessibleElement = this._waiting[waitingAccessibleElementKey];
			const waitingFocusableElement = this._waiting[waitingFocusableElementKey];
			const win = this._win();
			const resolve = (element, key, waiting, accessibility) => {
				var _a;
				const observed = (_a = getTabsterOnElement(this._tabster, element)) === null || _a === void 0 ? void 0 : _a.observed;
				if (!observed || !observed.names.includes(observedName)) return;
				if (waiting.timer) win.clearTimeout(waiting.timer);
				delete this._waiting[key];
				if (waiting.request) waiting.request.status = ObservedElementRequestStatuses.Succeeded;
				if (waiting.resolve) waiting.resolve(element);
				this.trigger(element, {
					names: [observedName],
					details: observed.details,
					accessibility
				});
			};
			if (waitingElement) {
				const element = this.getElement(observedName);
				if (element && documentContains(element.ownerDocument, element)) resolve(element, waitingElementKey, waitingElement, ObservedElementAccessibilities.Any);
			}
			if (waitingAccessibleElement && !waitingAccessibleElement.conditionTimer) {
				const resolveAccessible = () => {
					const element = this.getElement(observedName);
					if (element && documentContains(element.ownerDocument, element) && this._tabster.focusable.isAccessible(element)) resolve(element, waitingAccessibleElementKey, waitingAccessibleElement, ObservedElementAccessibilities.Accessible);
					else waitingAccessibleElement.conditionTimer = win.setTimeout(resolveAccessible, _conditionCheckTimeout);
				};
				resolveAccessible();
			}
			if (waitingFocusableElement && !waitingFocusableElement.conditionTimer) {
				const resolveFocusable = () => {
					const element = this.getElement(observedName);
					if (element && documentContains(element.ownerDocument, element) && this._tabster.focusable.isFocusable(element, true)) resolve(element, waitingFocusableElementKey, waitingFocusableElement, ObservedElementAccessibilities.Focusable);
					else waitingFocusableElement.conditionTimer = win.setTimeout(resolveFocusable, _conditionCheckTimeout);
				};
				resolveFocusable();
			}
		}
	};
	/*!
	* Copyright (c) Microsoft Corporation. All rights reserved.
	* Licensed under the MIT License.
	*/
	/**
	* Allows default or user focus behaviour on the DOM subtree
	* i.e. Tabster will not control focus events within an uncontrolled area
	*/
	var UncontrolledAPI = class {
		constructor(isUncontrolledCompletely) {
			this._isUncontrolledCompletely = isUncontrolledCompletely;
		}
		isUncontrolledCompletely(element, completely) {
			var _a;
			const isUncontrolledCompletely = (_a = this._isUncontrolledCompletely) === null || _a === void 0 ? void 0 : _a.call(this, element, completely);
			return isUncontrolledCompletely === void 0 ? completely : isUncontrolledCompletely;
		}
	};
	/*!
	* Copyright (c) Microsoft Corporation. All rights reserved.
	* Licensed under the MIT License.
	*/
	var Restorer = class extends TabsterPart {
		constructor(tabster, element, props) {
			var _a;
			super(tabster, element, props);
			this._hasFocus = false;
			this._onFocusOut = (e) => {
				var _a$1;
				const element$1 = (_a$1 = this._element) === null || _a$1 === void 0 ? void 0 : _a$1.get();
				if (element$1 && e.relatedTarget === null) element$1.dispatchEvent(new RestorerRestoreFocusEvent());
				if (element$1 && !dom.nodeContains(element$1, e.relatedTarget)) this._hasFocus = false;
			};
			this._onFocusIn = () => {
				this._hasFocus = true;
			};
			if (this._props.type === RestorerTypes.Source) {
				const element$1 = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();
				element$1 === null || element$1 === void 0 || element$1.addEventListener("focusout", this._onFocusOut);
				element$1 === null || element$1 === void 0 || element$1.addEventListener("focusin", this._onFocusIn);
				this._hasFocus = dom.nodeContains(element$1, element$1 && dom.getActiveElement(element$1.ownerDocument));
			}
		}
		dispose() {
			var _a;
			if (this._props.type === RestorerTypes.Source) {
				const element = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();
				element === null || element === void 0 || element.removeEventListener("focusout", this._onFocusOut);
				element === null || element === void 0 || element.removeEventListener("focusin", this._onFocusIn);
				if (this._hasFocus) this._tabster.getWindow().document.body.dispatchEvent(new RestorerRestoreFocusEvent());
			}
		}
	};
	var History = class History {
		constructor(getWindow$1) {
			this._stack = [];
			this._getWindow = getWindow$1;
		}
		/**
		* Push a weak element to the top of the history stack.
		* If the stack is full, the bottom weak element is removed.
		* If the element is already at the top of the stack, it is not duplicated.
		*/
		push(element) {
			var _a;
			if (((_a = this._stack[this._stack.length - 1]) === null || _a === void 0 ? void 0 : _a.get()) === element) return;
			if (this._stack.length > History.DEPTH) this._stack.shift();
			this._stack.push(new WeakHTMLElement(this._getWindow, element));
		}
		/**
		* Pop the first element from the history that satisfies the callback.
		* The history is searched from the top to the bottom (from the most recent to the least recent).
		*
		* If a weak reference to the element is broken,
		* or the element is no longer in the DOM,
		* the element is removed from the top of the stack while popping.
		*
		* If no matching element is found, undefined is returned.
		* If the stack is empty, undefined is returned.
		*/
		pop(filter = () => true) {
			var _a;
			const doc = this._getWindow().document;
			for (let index = this._stack.length - 1; index >= 0; index--) {
				const maybeElement = (_a = this._stack.pop()) === null || _a === void 0 ? void 0 : _a.get();
				if (maybeElement && dom.nodeContains(doc.body, dom.getParentElement(maybeElement)) && filter(maybeElement)) return maybeElement;
			}
		}
	};
	History.DEPTH = 10;
	var RestorerAPI = class {
		constructor(tabster) {
			this._onRestoreFocus = (e) => {
				var _a, _b;
				this._focusedElementState.cancelAsyncFocus(AsyncFocusSources.Restorer);
				const source = e.composedPath()[0];
				if (source) {
					const sourceId = (_b = (_a = getTabsterOnElement(this._tabster, source)) === null || _a === void 0 ? void 0 : _a.restorer) === null || _b === void 0 ? void 0 : _b.getProps().id;
					this._focusedElementState.requestAsyncFocus(AsyncFocusSources.Restorer, () => this._restoreFocus(source, sourceId), 0);
				}
			};
			this._onFocusIn = (element) => {
				var _a;
				if (!element) return;
				const tabsterAttribute = getTabsterOnElement(this._tabster, element);
				if (((_a = tabsterAttribute === null || tabsterAttribute === void 0 ? void 0 : tabsterAttribute.restorer) === null || _a === void 0 ? void 0 : _a.getProps().type) !== RestorerTypes.Target) return;
				this._history.push(element);
			};
			this._restoreFocus = (source, sourceId) => {
				var _a;
				const doc = this._getWindow().document;
				if (dom.getActiveElement(doc) !== doc.body) return;
				if (!this._keyboardNavState.isNavigatingWithKeyboard() && dom.nodeContains(doc.body, source)) return;
				const getId = (element) => {
					var _a$1, _b;
					const restorerProps = (_b = (_a$1 = getTabsterOnElement(this._tabster, element)) === null || _a$1 === void 0 ? void 0 : _a$1.restorer) === null || _b === void 0 ? void 0 : _b.getProps();
					return restorerProps ? restorerProps.id : null;
				};
				(_a = this._history.pop((target) => sourceId === getId(target))) === null || _a === void 0 || _a.focus();
			};
			this._tabster = tabster;
			this._getWindow = tabster.getWindow;
			this._getWindow().addEventListener(RestorerRestoreFocusEventName, this._onRestoreFocus);
			this._history = new History(this._getWindow);
			this._keyboardNavState = tabster.keyboardNavigation;
			this._focusedElementState = tabster.focusedElement;
			this._focusedElementState.subscribe(this._onFocusIn);
		}
		dispose() {
			const win = this._getWindow();
			this._focusedElementState.unsubscribe(this._onFocusIn);
			this._focusedElementState.cancelAsyncFocus(AsyncFocusSources.Restorer);
			win.removeEventListener(RestorerRestoreFocusEventName, this._onRestoreFocus);
		}
		createRestorer(element, props) {
			const restorer = new Restorer(this._tabster, element, props);
			if (props.type === RestorerTypes.Target && dom.getActiveElement(element.ownerDocument) === element) this._history.push(element);
			return restorer;
		}
	};
	function nodeContains(node$1, otherNode) {
		var _a, _b;
		if (!node$1 || !otherNode) return false;
		let currentNode = otherNode;
		while (currentNode) {
			if (currentNode === node$1) return true;
			if (typeof currentNode.assignedElements !== "function" && ((_a = currentNode.assignedSlot) === null || _a === void 0 ? void 0 : _a.parentNode)) currentNode = (_b = currentNode.assignedSlot) === null || _b === void 0 ? void 0 : _b.parentNode;
			else if (currentNode.nodeType === document.DOCUMENT_FRAGMENT_NODE) currentNode = currentNode.host;
			else currentNode = currentNode.parentNode;
		}
		return false;
	}
	/*!
	* Copyright (c) Microsoft Corporation. All rights reserved.
	* Licensed under the MIT License.
	*/
	var ShadowMutationObserver = class ShadowMutationObserver {
		static _overrideAttachShadow(win) {
			const origAttachShadow = win.Element.prototype.attachShadow;
			if (origAttachShadow.__origAttachShadow) return;
			Element.prototype.attachShadow = function(options) {
				const shadowRoot = origAttachShadow.call(this, options);
				for (const shadowObserver of ShadowMutationObserver._shadowObservers) shadowObserver._addSubObserver(shadowRoot);
				return shadowRoot;
			};
			Element.prototype.attachShadow.__origAttachShadow = origAttachShadow;
		}
		constructor(callback) {
			this._isObserving = false;
			this._callbackWrapper = (mutations, observer) => {
				for (const mutation of mutations) if (mutation.type === "childList") {
					const removed = mutation.removedNodes;
					const added = mutation.addedNodes;
					for (let i = 0; i < removed.length; i++) this._walkShadows(removed[i], true);
					for (let i = 0; i < added.length; i++) this._walkShadows(added[i]);
				}
				this._callback(mutations, observer);
			};
			this._callback = callback;
			this._observer = new MutationObserver(this._callbackWrapper);
			this._subObservers = /* @__PURE__ */ new Map();
		}
		_addSubObserver(shadowRoot) {
			if (!this._options || !this._callback || this._subObservers.has(shadowRoot)) return;
			if (this._options.subtree && nodeContains(this._root, shadowRoot)) {
				const subObserver = new MutationObserver(this._callbackWrapper);
				this._subObservers.set(shadowRoot, subObserver);
				if (this._isObserving) subObserver.observe(shadowRoot, this._options);
				this._walkShadows(shadowRoot);
			}
		}
		disconnect() {
			this._isObserving = false;
			delete this._options;
			ShadowMutationObserver._shadowObservers.delete(this);
			for (const subObserver of this._subObservers.values()) subObserver.disconnect();
			this._subObservers.clear();
			this._observer.disconnect();
		}
		observe(target, options) {
			const doc = target.nodeType === Node.DOCUMENT_NODE ? target : target.ownerDocument;
			const win = doc === null || doc === void 0 ? void 0 : doc.defaultView;
			if (!doc || !win) return;
			ShadowMutationObserver._overrideAttachShadow(win);
			ShadowMutationObserver._shadowObservers.add(this);
			this._root = target;
			this._options = options;
			this._isObserving = true;
			this._observer.observe(target, options);
			this._walkShadows(target);
		}
		_walkShadows(target, remove) {
			const doc = target.nodeType === Node.DOCUMENT_NODE ? target : target.ownerDocument;
			if (!doc) return;
			if (target === doc) target = doc.body;
			else {
				const shadowRoot = target.shadowRoot;
				if (shadowRoot) {
					this._addSubObserver(shadowRoot);
					return;
				}
			}
			doc.createTreeWalker(target, NodeFilter.SHOW_ELEMENT, { acceptNode: (node$1) => {
				if (node$1.nodeType === Node.ELEMENT_NODE) if (remove) {
					const subObserver = this._subObservers.get(node$1);
					if (subObserver) {
						subObserver.disconnect();
						this._subObservers.delete(node$1);
					}
				} else {
					const shadowRoot = node$1.shadowRoot;
					if (shadowRoot) this._addSubObserver(shadowRoot);
				}
				return NodeFilter.FILTER_SKIP;
			} }).nextNode();
		}
		takeRecords() {
			const records = this._observer.takeRecords();
			for (const subObserver of this._subObservers.values()) records.push(...subObserver.takeRecords());
			return records;
		}
	};
	ShadowMutationObserver._shadowObservers = /* @__PURE__ */ new Set();
	/*!
	* Copyright (c) Microsoft Corporation. All rights reserved.
	* Licensed under the MIT License.
	*/
	var Tabster = class {
		constructor(tabster) {
			this.keyboardNavigation = tabster.keyboardNavigation;
			this.focusedElement = tabster.focusedElement;
			this.focusable = tabster.focusable;
			this.root = tabster.root;
			this.uncontrolled = tabster.uncontrolled;
			this.core = tabster;
		}
	};
	/**
	* Extends Window to include an internal Tabster instance.
	*/
	var TabsterCore = class {
		constructor(win, props) {
			var _a, _b;
			this._forgetMemorizedElements = [];
			this._wrappers = /* @__PURE__ */ new Set();
			this._initQueue = [];
			this._version = "8.6.2";
			this._noop = false;
			this.getWindow = () => {
				if (!this._win) throw new Error("Using disposed Tabster.");
				return this._win;
			};
			this._storage = createWeakMap(win);
			this._win = win;
			const getWindow$1 = this.getWindow;
			if (props === null || props === void 0 ? void 0 : props.DOMAPI) setDOMAPI({ ...props.DOMAPI });
			this.keyboardNavigation = new KeyboardNavigationState(getWindow$1);
			this.focusedElement = new FocusedElementState(this, getWindow$1);
			this.focusable = new FocusableAPI(this);
			this.root = new RootAPI(this, props === null || props === void 0 ? void 0 : props.autoRoot);
			this.uncontrolled = new UncontrolledAPI((props === null || props === void 0 ? void 0 : props.checkUncontrolledCompletely) || (props === null || props === void 0 ? void 0 : props.checkUncontrolledTrappingFocus));
			this.controlTab = (_a = props === null || props === void 0 ? void 0 : props.controlTab) !== null && _a !== void 0 ? _a : true;
			this.rootDummyInputs = !!(props === null || props === void 0 ? void 0 : props.rootDummyInputs);
			this._dummyObserver = new DummyInputObserver(getWindow$1);
			this.getParent = (_b = props === null || props === void 0 ? void 0 : props.getParent) !== null && _b !== void 0 ? _b : dom.getParentNode;
			this.internal = {
				stopObserver: () => {
					if (this._unobserve) {
						this._unobserve();
						delete this._unobserve;
					}
				},
				resumeObserver: (syncState) => {
					if (!this._unobserve) {
						const doc = getWindow$1().document;
						this._unobserve = observeMutations(doc, this, updateTabsterByAttribute, syncState);
					}
				}
			};
			startFakeWeakRefsCleanup(getWindow$1);
			this.queueInit(() => {
				this.internal.resumeObserver(true);
			});
		}
		/**
		* Merges external props with the current props. Not all
		* props can/should be mergeable, so let's add more as we move on.
		* @param props Tabster props
		*/
		_mergeProps(props) {
			var _a;
			if (!props) return;
			this.getParent = (_a = props.getParent) !== null && _a !== void 0 ? _a : this.getParent;
		}
		createTabster(noRefCount, props) {
			const wrapper = new Tabster(this);
			if (!noRefCount) this._wrappers.add(wrapper);
			this._mergeProps(props);
			return wrapper;
		}
		disposeTabster(wrapper, allInstances) {
			if (allInstances) this._wrappers.clear();
			else this._wrappers.delete(wrapper);
			if (this._wrappers.size === 0) this.dispose();
		}
		dispose() {
			var _a, _b, _c, _d, _e, _f, _g, _h;
			this.internal.stopObserver();
			const win = this._win;
			win === null || win === void 0 || win.clearTimeout(this._initTimer);
			delete this._initTimer;
			this._initQueue = [];
			this._forgetMemorizedElements = [];
			if (win && this._forgetMemorizedTimer) {
				win.clearTimeout(this._forgetMemorizedTimer);
				delete this._forgetMemorizedTimer;
			}
			(_a = this.outline) === null || _a === void 0 || _a.dispose();
			(_b = this.crossOrigin) === null || _b === void 0 || _b.dispose();
			(_c = this.deloser) === null || _c === void 0 || _c.dispose();
			(_d = this.groupper) === null || _d === void 0 || _d.dispose();
			(_e = this.mover) === null || _e === void 0 || _e.dispose();
			(_f = this.modalizer) === null || _f === void 0 || _f.dispose();
			(_g = this.observedElement) === null || _g === void 0 || _g.dispose();
			(_h = this.restorer) === null || _h === void 0 || _h.dispose();
			this.keyboardNavigation.dispose();
			this.focusable.dispose();
			this.focusedElement.dispose();
			this.root.dispose();
			this._dummyObserver.dispose();
			stopFakeWeakRefsCleanupAndClearStorage(this.getWindow);
			clearElementCache(this.getWindow);
			this._storage = /* @__PURE__ */ new WeakMap();
			this._wrappers.clear();
			if (win) {
				disposeInstanceContext(win);
				delete win.__tabsterInstance;
				delete this._win;
			}
		}
		storageEntry(element, addremove) {
			const storage = this._storage;
			let entry = storage.get(element);
			if (entry) {
				if (addremove === false && Object.keys(entry).length === 0) storage.delete(element);
			} else if (addremove === true) {
				entry = {};
				storage.set(element, entry);
			}
			return entry;
		}
		forceCleanup() {
			if (!this._win) return;
			this._forgetMemorizedElements.push(this._win.document.body);
			if (this._forgetMemorizedTimer) return;
			this._forgetMemorizedTimer = this._win.setTimeout(() => {
				delete this._forgetMemorizedTimer;
				for (let el = this._forgetMemorizedElements.shift(); el; el = this._forgetMemorizedElements.shift()) {
					clearElementCache(this.getWindow, el);
					FocusedElementState.forgetMemorized(this.focusedElement, el);
				}
			}, 0);
			cleanupFakeWeakRefs(this.getWindow, true);
		}
		queueInit(callback) {
			var _a;
			if (!this._win) return;
			this._initQueue.push(callback);
			if (!this._initTimer) this._initTimer = (_a = this._win) === null || _a === void 0 ? void 0 : _a.setTimeout(() => {
				delete this._initTimer;
				this.drainInitQueue();
			}, 0);
		}
		drainInitQueue() {
			if (!this._win) return;
			const queue = this._initQueue;
			this._initQueue = [];
			queue.forEach((callback) => callback());
		}
	};
	/**
	* Creates an instance of Tabster, returns the current window instance if it already exists.
	*/
	function createTabster(win, props) {
		let tabster = getCurrentTabster(win);
		if (tabster) return tabster.createTabster(false, props);
		tabster = new TabsterCore(win, props);
		win.__tabsterInstance = tabster;
		return tabster.createTabster();
	}
	/**
	* Creates a new groupper instance or returns an existing one
	* @param tabster Tabster instance
	*/
	function getGroupper(tabster) {
		const tabsterCore = tabster.core;
		if (!tabsterCore.groupper) tabsterCore.groupper = new GroupperAPI(tabsterCore, tabsterCore.getWindow);
		return tabsterCore.groupper;
	}
	/**
	* Creates a new mover instance or returns an existing one
	* @param tabster Tabster instance
	*/
	function getMover(tabster) {
		const tabsterCore = tabster.core;
		if (!tabsterCore.mover) tabsterCore.mover = new MoverAPI(tabsterCore, tabsterCore.getWindow);
		return tabsterCore.mover;
	}
	/**
	* Creates a new modalizer instance or returns an existing one
	* @param tabster Tabster instance
	* @param alwaysAccessibleSelector When Modalizer is active, we put
	* aria-hidden to everything else to hide it from screen readers. This CSS
	* selector allows to exclude some elements from this behaviour. For example,
	* this could be used to exclude aria-live region with the application-wide
	* status announcements.
	* @param accessibleCheck An optional callback that will be called when
	* active Modalizer wants to hide an element that doesn't belong to it from
	* the screen readers by setting aria-hidden. Similar to alwaysAccessibleSelector
	* but allows to address the elements programmatically rather than with a selector.
	* If the callback returns true, the element will not receive aria-hidden.
	*/
	function getModalizer(tabster, alwaysAccessibleSelector, accessibleCheck) {
		const tabsterCore = tabster.core;
		if (!tabsterCore.modalizer) tabsterCore.modalizer = new ModalizerAPI(tabsterCore, alwaysAccessibleSelector, accessibleCheck);
		return tabsterCore.modalizer;
	}
	function getObservedElement(tabster) {
		const tabsterCore = tabster.core;
		if (!tabsterCore.observedElement) tabsterCore.observedElement = new ObservedElementAPI(tabsterCore);
		return tabsterCore.observedElement;
	}
	function getRestorer(tabster) {
		const tabsterCore = tabster.core;
		if (!tabsterCore.restorer) tabsterCore.restorer = new RestorerAPI(tabsterCore);
		return tabsterCore.restorer;
	}
	function disposeTabster(tabster, allInstances) {
		tabster.core.disposeTabster(tabster, allInstances);
	}
	/**
	* Returns an instance of Tabster if it already exists on the window .
	* @param win window instance that could contain an Tabster instance.
	*/
	function getCurrentTabster(win) {
		return win.__tabsterInstance;
	}

//#endregion
//#region node_modules/@fluentui/react-tabster/lib/hooks/useTabster.js
	const DEFAULT_FACTORY = (tabster) => {
		return tabster;
	};
	/**
	* Creates a tabster instance with the provided configuration
	*
	* @internal
	* @param targetDocument
	*/ function createTabsterWithConfig(targetDocument) {
		const defaultView = (targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView) || void 0;
		const shadowDOMAPI = defaultView === null || defaultView === void 0 ? void 0 : defaultView.__tabsterShadowDOMAPI;
		if (defaultView) return createTabster(defaultView, {
			autoRoot: {},
			controlTab: false,
			getParent,
			checkUncontrolledCompletely: (element) => {
				var _element_firstElementChild;
				return ((_element_firstElementChild = element.firstElementChild) === null || _element_firstElementChild === void 0 ? void 0 : _element_firstElementChild.hasAttribute("data-is-focus-trap-zone-bumper")) === true || void 0;
			},
			DOMAPI: shadowDOMAPI
		});
	}
	function useTabster(factory = DEFAULT_FACTORY) {
		const { targetDocument } = useFluent();
		const factoryResultRef = react.useRef(null);
		useIsomorphicLayoutEffect(() => {
			const tabster = createTabsterWithConfig(targetDocument);
			if (tabster) {
				factoryResultRef.current = factory(tabster);
				return () => {
					disposeTabster(tabster);
					factoryResultRef.current = null;
				};
			}
		}, [targetDocument, factory]);
		{
			const previousFactory = usePrevious(factory);
			if (previousFactory !== null && previousFactory !== factory) throw new Error(["@fluentui/react-tabster: ", "The factory function passed to useTabster has changed. This should not ever happen."].join("\n"));
		}
		return factoryResultRef;
	}

//#endregion
//#region node_modules/@fluentui/react-tabster/lib/hooks/useTabsterAttributes.js
/**
	* @internal
	* Hook that returns tabster attributes while ensuring tabster exists
	*/ const useTabsterAttributes = (props) => {
		useTabster();
		const strAttr = getTabsterAttribute(props, true);
		return react.useMemo(() => ({ [TABSTER_ATTRIBUTE_NAME]: strAttr }), [strAttr]);
	};

//#endregion
//#region node_modules/@fluentui/react-tabster/lib/hooks/useArrowNavigationGroup.js
/**
	* A hook that returns the necessary tabster attributes to support arrow key navigation
	* @param options - Options to configure keyboard navigation
	*/ const useArrowNavigationGroup = (options = {}) => {
		const { circular, axis, memorizeCurrent = true, tabbable, ignoreDefaultKeydown, unstable_hasDefault } = options;
		useTabster(getMover);
		return useTabsterAttributes({
			mover: {
				cyclic: !!circular,
				direction: axisToMoverDirection(axis !== null && axis !== void 0 ? axis : "vertical"),
				memorizeCurrent,
				tabbable,
				hasDefault: unstable_hasDefault
			},
			...ignoreDefaultKeydown && { focusable: { ignoreKeydown: ignoreDefaultKeydown } }
		});
	};
	function axisToMoverDirection(axis) {
		switch (axis) {
			case "horizontal": return MoverDirections.Horizontal;
			case "grid": return MoverDirections.Grid;
			case "grid-linear": return MoverDirections.GridLinear;
			case "both": return MoverDirections.Both;
			case "vertical":
			default: return MoverDirections.Vertical;
		}
	}

//#endregion
//#region node_modules/@fluentui/react-tabster/lib/hooks/useFocusableGroup.js
/**
	* A hook that returns the necessary tabster attributes to support groupping.
	* @param options - Options to configure keyboard navigation
	*/ const useFocusableGroup = (options) => {
		useTabster(getGroupper);
		return useTabsterAttributes({
			groupper: { tabbability: getTabbability(options === null || options === void 0 ? void 0 : options.tabBehavior) },
			focusable: { ignoreKeydown: options === null || options === void 0 ? void 0 : options.ignoreDefaultKeydown }
		});
	};
	const getTabbability = (tabBehavior) => {
		switch (tabBehavior) {
			case "unlimited": return GroupperTabbabilities.Unlimited;
			case "limited": return GroupperTabbabilities.Limited;
			case "limited-trap-focus": return GroupperTabbabilities.LimitedTrapFocus;
			default: return;
		}
	};

//#endregion
//#region node_modules/@fluentui/react-tabster/lib/hooks/useFocusFinders.js
/**
	* Returns a set of helper functions that will traverse focusable elements in the context of a root DOM element
	*/ const useFocusFinders = () => {
		const tabsterRef = useTabster();
		const { targetDocument } = useFluent();
		return {
			findAllFocusable: react.useCallback((container, acceptCondition) => {
				var _tabsterRef_current;
				return container && ((_tabsterRef_current = tabsterRef.current) === null || _tabsterRef_current === void 0 ? void 0 : _tabsterRef_current.focusable.findAll({
					container,
					acceptCondition
				})) || [];
			}, [tabsterRef]),
			findFirstFocusable: react.useCallback((container) => {
				var _tabsterRef_current;
				return container && ((_tabsterRef_current = tabsterRef.current) === null || _tabsterRef_current === void 0 ? void 0 : _tabsterRef_current.focusable.findFirst({ container }));
			}, [tabsterRef]),
			findLastFocusable: react.useCallback((container) => {
				var _tabsterRef_current;
				return container && ((_tabsterRef_current = tabsterRef.current) === null || _tabsterRef_current === void 0 ? void 0 : _tabsterRef_current.focusable.findLast({ container }));
			}, [tabsterRef]),
			findNextFocusable: react.useCallback((currentElement, options = {}) => {
				if (!tabsterRef.current || !targetDocument || !currentElement) return null;
				const { container = targetDocument.body } = options;
				return tabsterRef.current.focusable.findNext({
					currentElement,
					container
				});
			}, [tabsterRef, targetDocument]),
			findPrevFocusable: react.useCallback((currentElement, options = {}) => {
				if (!tabsterRef.current || !targetDocument || !currentElement) return null;
				const { container = targetDocument.body } = options;
				return tabsterRef.current.focusable.findPrev({
					currentElement,
					container
				});
			}, [tabsterRef, targetDocument])
		};
	};

//#endregion
//#region node_modules/@fluentui/react-tabster/lib/focus/constants.js
	const KEYBOARD_NAV_ATTRIBUTE = "data-keyboard-nav";
	const KEYBOARD_NAV_SELECTOR = `:global([${KEYBOARD_NAV_ATTRIBUTE}])`;
	/**
	* @internal
	*/ const FOCUS_VISIBLE_ATTR = "data-fui-focus-visible";
	/**
	* @internal
	*/ const FOCUS_WITHIN_ATTR = "data-fui-focus-within";
	const defaultOptions$2 = {
		style: {},
		selector: "focus",
		customizeSelector: (selector) => selector
	};

//#endregion
//#region node_modules/@fluentui/react-tabster/lib/focus/focusVisiblePolyfill.js
/**
	* @internal
	* @param scope - Applies the ponyfill to all DOM children
	* @param targetWindow - window
	*/ function applyFocusVisiblePolyfill(scope, targetWindow) {
		if (alreadyInScope(scope)) return () => void 0;
		const state = { current: void 0 };
		const keyborg = createKeyborg(targetWindow);
		function registerElementIfNavigating(el) {
			if (keyborg.isNavigatingWithKeyboard() && isHTMLElement(el)) {
				state.current = el;
				el.setAttribute(FOCUS_VISIBLE_ATTR, "");
			}
		}
		function disposeCurrentElement() {
			if (state.current) {
				state.current.removeAttribute(FOCUS_VISIBLE_ATTR);
				state.current = void 0;
			}
		}
		keyborg.subscribe((isNavigatingWithKeyboard) => {
			if (!isNavigatingWithKeyboard) disposeCurrentElement();
			else registerElementIfNavigating(targetWindow.document.activeElement);
		});
		const keyborgListener = (e) => {
			disposeCurrentElement();
			const target = e.composedPath()[0];
			registerElementIfNavigating(target);
		};
		const blurListener = (e) => {
			if (!e.relatedTarget || isHTMLElement(e.relatedTarget) && !scope.contains(e.relatedTarget)) disposeCurrentElement();
		};
		scope.addEventListener(KEYBORG_FOCUSIN, keyborgListener);
		scope.addEventListener("focusout", blurListener);
		scope.focusVisible = true;
		if (scope.contains(targetWindow.document.activeElement)) registerElementIfNavigating(targetWindow.document.activeElement);
		return () => {
			disposeCurrentElement();
			scope.removeEventListener(KEYBORG_FOCUSIN, keyborgListener);
			scope.removeEventListener("focusout", blurListener);
			scope.focusVisible = void 0;
			disposeKeyborg(keyborg);
		};
	}
	function alreadyInScope(el) {
		if (!el) return false;
		if (el.focusVisible) return true;
		return alreadyInScope(el === null || el === void 0 ? void 0 : el.parentElement);
	}

//#endregion
//#region node_modules/@fluentui/react-tabster/lib/hooks/useFocusVisible.js
	function useFocusVisible(options = {}) {
		const contextValue = useFluent();
		const scopeRef = react.useRef(null);
		var _options_targetDocument;
		const targetDocument = (_options_targetDocument = options.targetDocument) !== null && _options_targetDocument !== void 0 ? _options_targetDocument : contextValue.targetDocument;
		react.useEffect(() => {
			if ((targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView) && scopeRef.current) return applyFocusVisiblePolyfill(scopeRef.current, targetDocument.defaultView);
		}, [scopeRef, targetDocument]);
		return scopeRef;
	}

//#endregion
//#region node_modules/@fluentui/react-tabster/lib/focus/focusWithinPolyfill.js
/**
	* A ponyfill that allows `:focus-within` to support visibility based on keyboard/mouse navigation
	* like `:focus-visible` https://github.com/WICG/focus-visible/issues/151
	* @returns ref to the element that uses `:focus-within` styles
	*/ function applyFocusWithinPolyfill(element, win) {
		const keyborg = createKeyborg(win);
		keyborg.subscribe((isNavigatingWithKeyboard) => {
			if (!isNavigatingWithKeyboard) removeFocusWithinClass(element);
		});
		const keyborgListener = (e) => {
			if (keyborg.isNavigatingWithKeyboard() && isHTMLElement$3(e.target)) applyFocusWithinClass(element);
		};
		const blurListener = (e) => {
			if (!e.relatedTarget || isHTMLElement$3(e.relatedTarget) && !element.contains(e.relatedTarget)) removeFocusWithinClass(element);
		};
		element.addEventListener(KEYBORG_FOCUSIN, keyborgListener);
		element.addEventListener("focusout", blurListener);
		return () => {
			element.removeEventListener(KEYBORG_FOCUSIN, keyborgListener);
			element.removeEventListener("focusout", blurListener);
			disposeKeyborg(keyborg);
		};
	}
	function applyFocusWithinClass(el) {
		el.setAttribute(FOCUS_WITHIN_ATTR, "");
	}
	function removeFocusWithinClass(el) {
		el.removeAttribute(FOCUS_WITHIN_ATTR);
	}
	function isHTMLElement$3(target) {
		if (!target) return false;
		return Boolean(target && typeof target === "object" && "classList" in target && "contains" in target);
	}

//#endregion
//#region node_modules/@fluentui/react-tabster/lib/hooks/useFocusWithin.js
/**
	* A ponyfill that allows `:focus-within` to support visibility based on keyboard/mouse navigation
	* like `:focus-visible` https://github.com/WICG/focus-visible/issues/151
	* @returns ref to the element that uses `:focus-within` styles
	*/ function useFocusWithin() {
		const { targetDocument } = useFluent();
		const elementRef = react.useRef(null);
		react.useEffect(() => {
			if ((targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView) && elementRef.current) return applyFocusWithinPolyfill(elementRef.current, targetDocument.defaultView);
		}, [elementRef, targetDocument]);
		return elementRef;
	}

//#endregion
//#region node_modules/@fluentui/react-tabster/lib/hooks/useKeyboardNavAttribute.js
/**
	* Instantiates [keyborg](https://github.com/microsoft/keyborg) and adds `data-keyboard-nav`
	* attribute to a referenced element to ensure keyboard navigation awareness
	* synced to keyborg logic without having to cause a re-render on react tree.
	*/ function useKeyboardNavAttribute() {
		const { targetDocument } = useFluent();
		const keyborg = react.useMemo(() => targetDocument && createKeyborg(targetDocument.defaultView), [targetDocument]);
		const ref = react.useRef(null);
		react.useEffect(() => {
			if (keyborg) {
				setBooleanAttribute(ref, KEYBOARD_NAV_ATTRIBUTE, keyborg.isNavigatingWithKeyboard());
				const cb = (next$1) => {
					setBooleanAttribute(ref, KEYBOARD_NAV_ATTRIBUTE, next$1);
				};
				keyborg.subscribe(cb);
				return () => keyborg.unsubscribe(cb);
			}
		}, [keyborg]);
		return ref;
	}
	function setBooleanAttribute(elementRef, attribute, value) {
		if (!elementRef.current) return;
		if (value) elementRef.current.setAttribute(attribute, "");
		else elementRef.current.removeAttribute(attribute);
	}

//#endregion
//#region node_modules/@fluentui/react-tabster/lib/hooks/useKeyborgRef.js
/**
	* @internal
	* Instantiates [keyborg](https://github.com/microsoft/keyborg)
	* @returns - keyborg instance
	*/ function useKeyborgRef() {
		const { targetDocument } = useFluent();
		const keyborgRef = react.useRef(null);
		react.useEffect(() => {
			const targetWindow = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView;
			if (targetWindow) {
				const keyborg = createKeyborg(targetWindow);
				keyborgRef.current = keyborg;
				return () => {
					disposeKeyborg(keyborg);
					keyborgRef.current = null;
				};
			}
		}, [targetDocument]);
		return keyborgRef;
	}

//#endregion
//#region node_modules/@fluentui/react-tabster/lib/hooks/useOnKeyboardNavigationChange.js
/**
	* Instantiates [keyborg](https://github.com/microsoft/keyborg) and subscribes to changes
	* in the keyboard navigation mode.
	*
	* @param callback - called every time the keyboard navigation state changes
	*/ function useOnKeyboardNavigationChange(callback) {
		const keyborgRef = useKeyborgRef();
		const eventCallback = useEventCallback(callback);
		react.useEffect(() => {
			const keyborg = keyborgRef.current;
			if (keyborg) {
				const cb = (next$1) => {
					eventCallback(next$1);
				};
				keyborg.subscribe(cb);
				cb(keyborg.isNavigatingWithKeyboard());
				return () => {
					keyborg.unsubscribe(cb);
				};
			}
		}, [keyborgRef, eventCallback]);
	}

//#endregion
//#region node_modules/@fluentui/react-tabster/lib/hooks/useModalAttributes.js
	const DangerousNeverHiddenAttribute = "data-tabster-never-hide";
	const DangerousNeverHiddenPropObject = { [DangerousNeverHiddenAttribute]: "" };
	/**
	* !!DANGEROUS!! Designates an element that will not be hidden even when outside an open modal.
	* Only works for top-level elements; should be used with extreme care.
	* @returns Attribute to apply to the target element that should never receive aria-hidden
	*/ function useDangerousNeverHidden_unstable() {
		return DangerousNeverHiddenPropObject;
	}
	const tabsterAccessibleCheck = (element) => {
		return element.hasAttribute(DangerousNeverHiddenAttribute);
	};
	function initTabsterModules(tabster) {
		getModalizer(tabster, void 0, tabsterAccessibleCheck);
		getRestorer(tabster);
	}
	/**
	* Applies modal dialog behaviour through DOM attributes
	* Modal element will focus trap and hide other content on the page
	* The trigger element will be focused if focus is lost after the modal element is removed
	*
	* @returns DOM attributes to apply to the modal element and its trigger
	*/ const useModalAttributes = (options = {}) => {
		const { trapFocus, alwaysFocusable, legacyTrapFocus } = options;
		useTabster(initTabsterModules);
		const id = useId("modal-", options.id);
		return {
			modalAttributes: useTabsterAttributes({
				restorer: { type: RestorerTypes.Source },
				...trapFocus && { modalizer: {
					id,
					isOthersAccessible: !trapFocus,
					isAlwaysAccessible: alwaysFocusable,
					isTrapped: legacyTrapFocus && trapFocus
				} }
			}),
			triggerAttributes: useTabsterAttributes({ restorer: { type: RestorerTypes.Target } })
		};
	};

//#endregion
//#region node_modules/@fluentui/react-tabster/lib/hooks/useObservedElement.js
	function useObservedElement(name) {
		useTabster(getObservedElement);
		return useTabsterAttributes({ observed: { names: Array.isArray(name) ? name : [name] } });
	}

//#endregion
//#region node_modules/@fluentui/react-tabster/lib/hooks/useMergeTabsterAttributes.js
/**
	* Merges a collection of tabster attributes.
	*
	* The attributes passed as arguments to this  hook cannot change at runtime.
	* @internal
	* @param attributes - collection of tabster attributes from other react-tabster hooks
	* @returns single merged tabster attribute
	*/ const useMergedTabsterAttributes_unstable = (...attributes) => {
		"use no memo";
		const stringAttributes = attributes.reduce((acc, curr) => {
			if (curr === null || curr === void 0 ? void 0 : curr[TABSTER_ATTRIBUTE_NAME]) acc.push(curr[TABSTER_ATTRIBUTE_NAME]);
			return acc;
		}, []);
		useWarnIfUnstableAttributes(stringAttributes);
		return react.useMemo(() => ({ [TABSTER_ATTRIBUTE_NAME]: stringAttributes.length > 0 ? stringAttributes.reduce(mergeJSONStrings) : void 0 }), stringAttributes);
	};
	/**
	* Merges two JSON strings into one.
	*/ const mergeJSONStrings = (a, b) => JSON.stringify(Object.assign(safelyParseJSON(a), safelyParseJSON(b)));
	/**
	* Tries to parse a JSON string and returns an object.
	* If the JSON string is invalid, an empty object is returned.
	*/ const safelyParseJSON = (json) => {
		try {
			return JSON.parse(json);
		} catch {
			return {};
		}
	};
	/**
	* Helper hook that ensures that the attributes passed to the hook are stable.
	* This is necessary because the attributes are expected to not change at runtime.
	*
	* This hook will console.warn if the attributes change at runtime.
	*/ const useWarnIfUnstableAttributes = (attributes) => {
		"use no memo";
		const initialAttributesRef = react.useRef(attributes);
		let isStable = initialAttributesRef.current.length === attributes.length;
		if (initialAttributesRef.current !== attributes && isStable) {
			for (let i = 0; i < attributes.length; i++) if (initialAttributesRef.current[i] !== attributes[i]) {
				isStable = false;
				break;
			}
		}
		react.useEffect(() => {
			if (!isStable) {
				const error = /* @__PURE__ */ new Error();
				console.warn(
					/** #__DE-INDENT__ */
					`
        @fluentui/react-tabster [useMergedTabsterAttributes]:
        The attributes passed to the hook changed at runtime.
        This might lead to unexpected behavior, please ensure that the attributes are stable.
        ${error.stack}
      `
				);
			}
		}, [isStable]);
	};

//#endregion
//#region node_modules/@fluentui/react-tabster/lib/hooks/useFocusObserved.js
/**
	* @param name - The observed element to focus
	* @param options - Options for the focus observed
	*
	* @returns Function that will focus an element
	*/ function useFocusObserved(name, options = {}) {
		const { timeout = 1e3 } = options;
		const observedAPIRef = useTabster(getObservedElement);
		return react.useCallback(() => {
			const observerAPI = observedAPIRef.current;
			if (observerAPI) return observerAPI.requestFocus(name, timeout);
			return {
				result: Promise.resolve(false),
				cancel: () => null
			};
		}, [
			observedAPIRef,
			name,
			timeout
		]);
	}

//#endregion
//#region node_modules/@fluentui/react-tabster/lib/hooks/useRestoreFocus.js
/**
	* Focus will be restored to the most recent target element when it is lost from a source
	* @returns Attribute to apply to the target element where focus is restored
	*/ function useRestoreFocusTarget() {
		useTabster(getRestorer);
		return getTabsterAttribute({ restorer: { type: RestorerTypes.Target } });
	}
	/**
	* Focus will be restored to the most recent target element when it is lost from a source
	* @returns Attribute to apply to the element that might lose focus
	*/ function useRestoreFocusSource() {
		useTabster(getRestorer);
		return getTabsterAttribute({ restorer: { type: RestorerTypes.Source } });
	}

//#endregion
//#region node_modules/@fluentui/react-tabster/lib/hooks/useUncontrolledFocus.js
/**
	* Designates an area where tabster does not control focus
	* @returns Attribute to apply to the target element that should be uncontrolled by tabster
	*/ function useUncontrolledFocus() {
		useTabster();
		return getTabsterAttribute({ uncontrolled: {} });
	}

//#endregion
//#region node_modules/@fluentui/react-tabster/lib/hooks/useIsNavigatingWithKeyboard.js
/**
	* Instantiates [keyborg](https://github.com/microsoft/keyborg) and checks if the user is navigating with the keyboard.
	* @returns
	*/ function useIsNavigatingWithKeyboard() {
		const keyborgRef = useKeyborgRef();
		return react.useCallback(() => {
			var _keyborgRef_current;
			var _keyborgRef_current_isNavigatingWithKeyboard;
			return (_keyborgRef_current_isNavigatingWithKeyboard = (_keyborgRef_current = keyborgRef.current) === null || _keyborgRef_current === void 0 ? void 0 : _keyborgRef_current.isNavigatingWithKeyboard()) !== null && _keyborgRef_current_isNavigatingWithKeyboard !== void 0 ? _keyborgRef_current_isNavigatingWithKeyboard : false;
		}, [keyborgRef]);
	}

//#endregion
//#region node_modules/@fluentui/react-tabster/lib/hooks/useSetKeyboardNavigation.js
/**
	*/ function useSetKeyboardNavigation() {
		const keyborgRef = useKeyborgRef();
		return react.useCallback((isNavigatingWithKeyboard) => {
			var _keyborgRef_current;
			(_keyborgRef_current = keyborgRef.current) === null || _keyborgRef_current === void 0 || _keyborgRef_current.setVal(isNavigatingWithKeyboard);
		}, [keyborgRef]);
	}

//#endregion
//#region node_modules/@fluentui/react-tabster/lib/hooks/useFocusedElementChange.js
/**
	* Subscribes to the tabster focused element. Calls the callback when the focused element changes.
	* @param callback - Callback to subscribe to the focused element.
	*/ function useFocusedElementChange(callback) {
		const { targetDocument } = useFluent();
		const listener = useEventCallback(callback);
		react.useEffect(() => {
			const tabster = createTabsterWithConfig(targetDocument);
			if (tabster) {
				tabster.focusedElement.subscribe(listener);
				return () => {
					tabster.focusedElement.unsubscribe(listener);
					disposeTabster(tabster);
				};
			}
		}, [listener, targetDocument]);
	}

//#endregion
//#region node_modules/@fluentui/react-tabster/lib/hooks/useActivateModal.js
/**
	* Returns a function that activates a modal by element from the modal or modal container.
	*/ function useActivateModal() {
		const modalizerRefAPI = useTabster(getModalizer);
		const [setActivateModalTimeout] = useTimeout();
		return react.useCallback((elementFromModal) => {
			setActivateModalTimeout(() => {
				var _modalizerRefAPI_current;
				(_modalizerRefAPI_current = modalizerRefAPI.current) === null || _modalizerRefAPI_current === void 0 || _modalizerRefAPI_current.activate(elementFromModal);
			}, 0);
		}, [modalizerRefAPI, setActivateModalTimeout]);
	}

//#endregion
//#region node_modules/@fluentui/react-tabster/lib/focus/createCustomFocusIndicatorStyle.js
/**
	* Creates a style for @see makeStyles that includes the necessary selectors for focus.
	* Should be used only when @see createFocusOutlineStyle does not fit requirements
	*
	* If you're using `createCustomFocusIndicatorStyle` instead of `createFocusOutlineStyle`
	* keep in mind that the default outline style is not going to be removed
	* (as it is in `createFocusOutlineStyle`),
	* and is your responsibility to manually remove it from your styles.
	*
	* @example
	* ```ts
	* // Link styles
	* const useStyles = makeStyles({
	focusIndicator: createCustomFocusIndicatorStyle({
	textDecorationColor: tokens.colorStrokeFocus2,
	textDecorationLine: 'underline',
	textDecorationStyle: 'double',
	outlineStyle: 'none',
	}),
	// Common styles.
	root: {
	//  DO NOT FORGET TO REMOVE THE DEFAULT OUTLINE STYLE
	':focus-visible': {
	outlineStyle: 'none',
	},
	* ```
	*
	* @param style - styling applied on focus, defaults to @see getDefaultFocusOutlineStyles
	* @param options - Configure the style of the focus outline
	*/ function createCustomFocusIndicatorStyle(style, { selector: selectorType = defaultOptions$2.selector, customizeSelector = defaultOptions$2.customizeSelector } = defaultOptions$2) {
		return { [customizeSelector(createBaseSelector(selectorType))]: style };
	}
	function createBaseSelector(selectorType) {
		switch (selectorType) {
			case "focus": return `&[${FOCUS_VISIBLE_ATTR}]`;
			case "focus-within": return `&[${FOCUS_WITHIN_ATTR}]:focus-within`;
		}
	}

//#endregion
//#region node_modules/@fluentui/tokens/lib/global/colors.js
	const grey = {
		"2": "#050505",
		"4": "#0a0a0a",
		"6": "#0f0f0f",
		"8": "#141414",
		"10": "#1a1a1a",
		"12": "#1f1f1f",
		"14": "#242424",
		"16": "#292929",
		"18": "#2e2e2e",
		"20": "#333333",
		"22": "#383838",
		"24": "#3d3d3d",
		"26": "#424242",
		"28": "#474747",
		"30": "#4d4d4d",
		"32": "#525252",
		"34": "#575757",
		"36": "#5c5c5c",
		"38": "#616161",
		"40": "#666666",
		"42": "#6b6b6b",
		"44": "#707070",
		"46": "#757575",
		"48": "#7a7a7a",
		"50": "#808080",
		"52": "#858585",
		"54": "#8a8a8a",
		"56": "#8f8f8f",
		"58": "#949494",
		"60": "#999999",
		"62": "#9e9e9e",
		"64": "#a3a3a3",
		"66": "#a8a8a8",
		"68": "#adadad",
		"70": "#b3b3b3",
		"72": "#b8b8b8",
		"74": "#bdbdbd",
		"76": "#c2c2c2",
		"78": "#c7c7c7",
		"80": "#cccccc",
		"82": "#d1d1d1",
		"84": "#d6d6d6",
		"86": "#dbdbdb",
		"88": "#e0e0e0",
		"90": "#e6e6e6",
		"92": "#ebebeb",
		"94": "#f0f0f0",
		"96": "#f5f5f5",
		"98": "#fafafa"
	};
	const whiteAlpha = {
		"5": "rgba(255, 255, 255, 0.05)",
		"10": "rgba(255, 255, 255, 0.1)",
		"20": "rgba(255, 255, 255, 0.2)",
		"30": "rgba(255, 255, 255, 0.3)",
		"40": "rgba(255, 255, 255, 0.4)",
		"50": "rgba(255, 255, 255, 0.5)",
		"60": "rgba(255, 255, 255, 0.6)",
		"70": "rgba(255, 255, 255, 0.7)",
		"80": "rgba(255, 255, 255, 0.8)",
		"90": "rgba(255, 255, 255, 0.9)"
	};
	const blackAlpha = {
		"5": "rgba(0, 0, 0, 0.05)",
		"10": "rgba(0, 0, 0, 0.1)",
		"20": "rgba(0, 0, 0, 0.2)",
		"30": "rgba(0, 0, 0, 0.3)",
		"40": "rgba(0, 0, 0, 0.4)",
		"50": "rgba(0, 0, 0, 0.5)",
		"60": "rgba(0, 0, 0, 0.6)",
		"70": "rgba(0, 0, 0, 0.7)",
		"80": "rgba(0, 0, 0, 0.8)",
		"90": "rgba(0, 0, 0, 0.9)"
	};
	const grey10Alpha = {
		"5": "rgba(26, 26, 26, 0.05)",
		"10": "rgba(26, 26, 26, 0.1)",
		"20": "rgba(26, 26, 26, 0.2)",
		"30": "rgba(26, 26, 26, 0.3)",
		"40": "rgba(26, 26, 26, 0.4)",
		"50": "rgba(26, 26, 26, 0.5)",
		"60": "rgba(26, 26, 26, 0.6)",
		"70": "rgba(26, 26, 26, 0.7)",
		"80": "rgba(26, 26, 26, 0.8)",
		"90": "rgba(26, 26, 26, 0.9)"
	};
	const grey12Alpha = {
		"5": "rgba(31, 31, 31, 0.05)",
		"10": "rgba(31, 31, 31, 0.1)",
		"20": "rgba(31, 31, 31, 0.2)",
		"30": "rgba(31, 31, 31, 0.3)",
		"40": "rgba(31, 31, 31, 0.4)",
		"50": "rgba(31, 31, 31, 0.5)",
		"60": "rgba(31, 31, 31, 0.6)",
		"70": "rgba(31, 31, 31, 0.7)",
		"80": "rgba(31, 31, 31, 0.8)",
		"90": "rgba(31, 31, 31, 0.9)"
	};
	const grey14Alpha = {
		"5": "rgba(36, 36, 36, 0.05)",
		"10": "rgba(36, 36, 36, 0.1)",
		"20": "rgba(36, 36, 36, 0.2)",
		"30": "rgba(36, 36, 36, 0.3)",
		"40": "rgba(36, 36, 36, 0.4)",
		"50": "rgba(36, 36, 36, 0.5)",
		"60": "rgba(36, 36, 36, 0.6)",
		"70": "rgba(36, 36, 36, 0.7)",
		"80": "rgba(36, 36, 36, 0.8)",
		"90": "rgba(36, 36, 36, 0.9)"
	};
	const white = "#ffffff";
	const black = "#000000";
	const hcHyperlink = "#ffff00";
	const hcHighlight = "#1aebff";
	const hcDisabled = "#3ff23f";
	const hcCanvas = "#000000";
	const hcCanvasText = "#ffffff";
	const hcHighlightText = "#000000";
	const hcButtonText = "#000000";
	const hcButtonFace = "#ffffff";
	const darkRed = {
		shade50: "#130204",
		shade40: "#230308",
		shade30: "#420610",
		shade20: "#590815",
		shade10: "#690a19",
		primary: "#750b1c",
		tint10: "#861b2c",
		tint20: "#962f3f",
		tint30: "#ac4f5e",
		tint40: "#d69ca5",
		tint50: "#e9c7cd",
		tint60: "#f9f0f2"
	};
	const cranberry = {
		shade50: "#200205",
		shade40: "#3b0509",
		shade30: "#6e0811",
		shade20: "#960b18",
		shade10: "#b10e1c",
		primary: "#c50f1f",
		tint10: "#cc2635",
		tint20: "#d33f4c",
		tint30: "#dc626d",
		tint40: "#eeacb2",
		tint50: "#f6d1d5",
		tint60: "#fdf3f4"
	};
	const red = {
		shade50: "#210809",
		shade40: "#3f1011",
		shade30: "#751d1f",
		shade20: "#9f282b",
		shade10: "#bc2f32",
		primary: "#d13438",
		tint10: "#d7494c",
		tint20: "#dc5e62",
		tint30: "#e37d80",
		tint40: "#f1bbbc",
		tint50: "#f8dadb",
		tint60: "#fdf6f6"
	};
	const darkOrange = {
		shade50: "#230900",
		shade40: "#411200",
		shade30: "#7a2101",
		shade20: "#a62d01",
		shade10: "#c43501",
		primary: "#da3b01",
		tint10: "#de501c",
		tint20: "#e36537",
		tint30: "#e9835e",
		tint40: "#f4bfab",
		tint50: "#f9dcd1",
		tint60: "#fdf6f3"
	};
	const pumpkin = {
		shade50: "#200d03",
		shade40: "#3d1805",
		shade30: "#712d09",
		shade20: "#9a3d0c",
		shade10: "#b6480e",
		primary: "#ca5010",
		tint10: "#d06228",
		tint20: "#d77440",
		tint30: "#df8e64",
		tint40: "#efc4ad",
		tint50: "#f7dfd2",
		tint60: "#fdf7f4"
	};
	const orange = {
		shade50: "#271002",
		shade40: "#4a1e04",
		shade30: "#8a3707",
		shade20: "#bc4b09",
		shade10: "#de590b",
		primary: "#f7630c",
		tint10: "#f87528",
		tint20: "#f98845",
		tint30: "#faa06b",
		tint40: "#fdcfb4",
		tint50: "#fee5d7",
		tint60: "#fff9f5"
	};
	const peach = {
		shade50: "#291600",
		shade40: "#4d2a00",
		shade30: "#8f4e00",
		shade20: "#c26a00",
		shade10: "#e67e00",
		primary: "#ff8c00",
		tint10: "#ff9a1f",
		tint20: "#ffa83d",
		tint30: "#ffba66",
		tint40: "#ffddb3",
		tint50: "#ffedd6",
		tint60: "#fffaf5"
	};
	const marigold = {
		shade50: "#251a00",
		shade40: "#463100",
		shade30: "#835b00",
		shade20: "#b27c00",
		shade10: "#d39300",
		primary: "#eaa300",
		tint10: "#edad1c",
		tint20: "#efb839",
		tint30: "#f2c661",
		tint40: "#f9e2ae",
		tint50: "#fcefd3",
		tint60: "#fefbf4"
	};
	const yellow = {
		shade50: "#282400",
		shade40: "#4c4400",
		shade30: "#817400",
		shade20: "#c0ad00",
		shade10: "#e4cc00",
		primary: "#fde300",
		tint10: "#fde61e",
		tint20: "#fdea3d",
		tint30: "#feee66",
		tint40: "#fef7b2",
		tint50: "#fffad6",
		tint60: "#fffef5"
	};
	const gold = {
		shade50: "#1f1900",
		shade40: "#3a2f00",
		shade30: "#6c5700",
		shade20: "#937700",
		shade10: "#ae8c00",
		primary: "#c19c00",
		tint10: "#c8a718",
		tint20: "#d0b232",
		tint30: "#dac157",
		tint40: "#ecdfa5",
		tint50: "#f5eece",
		tint60: "#fdfbf2"
	};
	const brass = {
		shade50: "#181202",
		shade40: "#2e2103",
		shade30: "#553e06",
		shade20: "#745408",
		shade10: "#89640a",
		primary: "#986f0b",
		tint10: "#a47d1e",
		tint20: "#b18c34",
		tint30: "#c1a256",
		tint40: "#e0cea2",
		tint50: "#efe4cb",
		tint60: "#fbf8f2"
	};
	const brown = {
		shade50: "#170e07",
		shade40: "#2b1a0e",
		shade30: "#50301a",
		shade20: "#6c4123",
		shade10: "#804d29",
		primary: "#8e562e",
		tint10: "#9c663f",
		tint20: "#a97652",
		tint30: "#bb8f6f",
		tint40: "#ddc3b0",
		tint50: "#edded3",
		tint60: "#faf7f4"
	};
	const forest = {
		shade50: "#0c1501",
		shade40: "#162702",
		shade30: "#294903",
		shade20: "#376304",
		shade10: "#427505",
		primary: "#498205",
		tint10: "#599116",
		tint20: "#6ba02b",
		tint30: "#85b44c",
		tint40: "#bdd99b",
		tint50: "#dbebc7",
		tint60: "#f6faf0"
	};
	const seafoam = {
		shade50: "#002111",
		shade40: "#003d20",
		shade30: "#00723b",
		shade20: "#009b51",
		shade10: "#00b85f",
		primary: "#00cc6a",
		tint10: "#19d279",
		tint20: "#34d889",
		tint30: "#5ae0a0",
		tint40: "#a8f0cd",
		tint50: "#cff7e4",
		tint60: "#f3fdf8"
	};
	const lightGreen = {
		shade50: "#031a02",
		shade40: "#063004",
		shade30: "#0b5a08",
		shade20: "#0e7a0b",
		shade10: "#11910d",
		primary: "#13a10e",
		tint10: "#27ac22",
		tint20: "#3db838",
		tint30: "#5ec75a",
		tint40: "#a7e3a5",
		tint50: "#cef0cd",
		tint60: "#f2fbf2"
	};
	const green = {
		shade50: "#031403",
		shade40: "#052505",
		shade30: "#094509",
		shade20: "#0c5e0c",
		shade10: "#0e700e",
		primary: "#107c10",
		tint10: "#218c21",
		tint20: "#359b35",
		tint30: "#54b054",
		tint40: "#9fd89f",
		tint50: "#c9eac9",
		tint60: "#f1faf1"
	};
	const darkGreen = {
		shade50: "#021102",
		shade40: "#032003",
		shade30: "#063b06",
		shade20: "#085108",
		shade10: "#0a5f0a",
		primary: "#0b6a0b",
		tint10: "#1a7c1a",
		tint20: "#2d8e2d",
		tint30: "#4da64d",
		tint40: "#9ad29a",
		tint50: "#c6e7c6",
		tint60: "#f0f9f0"
	};
	const lightTeal = {
		shade50: "#001d1f",
		shade40: "#00373a",
		shade30: "#00666d",
		shade20: "#008b94",
		shade10: "#00a5af",
		primary: "#00b7c3",
		tint10: "#18bfca",
		tint20: "#32c8d1",
		tint30: "#58d3db",
		tint40: "#a6e9ed",
		tint50: "#cef3f5",
		tint60: "#f2fcfd"
	};
	const teal = {
		shade50: "#001516",
		shade40: "#012728",
		shade30: "#02494c",
		shade20: "#026467",
		shade10: "#037679",
		primary: "#038387",
		tint10: "#159195",
		tint20: "#2aa0a4",
		tint30: "#4cb4b7",
		tint40: "#9bd9db",
		tint50: "#c7ebec",
		tint60: "#f0fafa"
	};
	const steel = {
		shade50: "#000f12",
		shade40: "#001b22",
		shade30: "#00333f",
		shade20: "#004555",
		shade10: "#005265",
		primary: "#005b70",
		tint10: "#0f6c81",
		tint20: "#237d92",
		tint30: "#4496a9",
		tint40: "#94c8d4",
		tint50: "#c3e1e8",
		tint60: "#eff7f9"
	};
	const blue = {
		shade50: "#001322",
		shade40: "#002440",
		shade30: "#004377",
		shade20: "#005ba1",
		shade10: "#006cbf",
		primary: "#0078d4",
		tint10: "#1a86d9",
		tint20: "#3595de",
		tint30: "#5caae5",
		tint40: "#a9d3f2",
		tint50: "#d0e7f8",
		tint60: "#f3f9fd"
	};
	const royalBlue = {
		shade50: "#000c16",
		shade40: "#00172a",
		shade30: "#002c4e",
		shade20: "#003b6a",
		shade10: "#00467e",
		primary: "#004e8c",
		tint10: "#125e9a",
		tint20: "#286fa8",
		tint30: "#4a89ba",
		tint40: "#9abfdc",
		tint50: "#c7dced",
		tint60: "#f0f6fa"
	};
	const cornflower = {
		shade50: "#0d1126",
		shade40: "#182047",
		shade30: "#2c3c85",
		shade20: "#3c51b4",
		shade10: "#4760d5",
		primary: "#4f6bed",
		tint10: "#637cef",
		tint20: "#778df1",
		tint30: "#93a4f4",
		tint40: "#c8d1fa",
		tint50: "#e1e6fc",
		tint60: "#f7f9fe"
	};
	const navy = {
		shade50: "#00061d",
		shade40: "#000c36",
		shade30: "#001665",
		shade20: "#001e89",
		shade10: "#0023a2",
		primary: "#0027b4",
		tint10: "#173bbd",
		tint20: "#3050c6",
		tint30: "#546fd2",
		tint40: "#a3b2e8",
		tint50: "#ccd5f3",
		tint60: "#f2f4fc"
	};
	const lavender = {
		shade50: "#120f25",
		shade40: "#221d46",
		shade30: "#3f3682",
		shade20: "#5649b0",
		shade10: "#6656d1",
		primary: "#7160e8",
		tint10: "#8172eb",
		tint20: "#9184ee",
		tint30: "#a79cf1",
		tint40: "#d2ccf8",
		tint50: "#e7e4fb",
		tint60: "#f9f8fe"
	};
	const purple = {
		shade50: "#0f0717",
		shade40: "#1c0e2b",
		shade30: "#341a51",
		shade20: "#46236e",
		shade10: "#532982",
		primary: "#5c2e91",
		tint10: "#6b3f9e",
		tint20: "#7c52ab",
		tint30: "#9470bd",
		tint40: "#c6b1de",
		tint50: "#e0d3ed",
		tint60: "#f7f4fb"
	};
	const grape = {
		shade50: "#160418",
		shade40: "#29072e",
		shade30: "#4c0d55",
		shade20: "#671174",
		shade10: "#7a1589",
		primary: "#881798",
		tint10: "#952aa4",
		tint20: "#a33fb1",
		tint30: "#b55fc1",
		tint40: "#d9a7e0",
		tint50: "#eaceef",
		tint60: "#faf2fb"
	};
	const berry = {
		shade50: "#1f091d",
		shade40: "#3a1136",
		shade30: "#6d2064",
		shade20: "#932b88",
		shade10: "#af33a1",
		primary: "#c239b3",
		tint10: "#c94cbc",
		tint20: "#d161c4",
		tint30: "#da7ed0",
		tint40: "#edbbe7",
		tint50: "#f5daf2",
		tint60: "#fdf5fc"
	};
	const lilac = {
		shade50: "#1c0b1f",
		shade40: "#35153a",
		shade30: "#63276d",
		shade20: "#863593",
		shade10: "#9f3faf",
		primary: "#b146c2",
		tint10: "#ba58c9",
		tint20: "#c36bd1",
		tint30: "#cf87da",
		tint40: "#e6bfed",
		tint50: "#f2dcf5",
		tint60: "#fcf6fd"
	};
	const pink = {
		shade50: "#24091b",
		shade40: "#441232",
		shade30: "#80215d",
		shade20: "#ad2d7e",
		shade10: "#cd3595",
		primary: "#e43ba6",
		tint10: "#e750b0",
		tint20: "#ea66ba",
		tint30: "#ef85c8",
		tint40: "#f7c0e3",
		tint50: "#fbddf0",
		tint60: "#fef6fb"
	};
	const magenta = {
		shade50: "#1f0013",
		shade40: "#390024",
		shade30: "#6b0043",
		shade20: "#91005a",
		shade10: "#ac006b",
		primary: "#bf0077",
		tint10: "#c71885",
		tint20: "#ce3293",
		tint30: "#d957a8",
		tint40: "#eca5d1",
		tint50: "#f5cee6",
		tint60: "#fcf2f9"
	};
	const plum = {
		shade50: "#13000c",
		shade40: "#240017",
		shade30: "#43002b",
		shade20: "#5a003b",
		shade10: "#6b0045",
		primary: "#77004d",
		tint10: "#87105d",
		tint20: "#98246f",
		tint30: "#ad4589",
		tint40: "#d696c0",
		tint50: "#e9c4dc",
		tint60: "#faf0f6"
	};
	const beige = {
		shade50: "#141313",
		shade40: "#252323",
		shade30: "#444241",
		shade20: "#5d5958",
		shade10: "#6e6968",
		primary: "#7a7574",
		tint10: "#8a8584",
		tint20: "#9a9594",
		tint30: "#afabaa",
		tint40: "#d7d4d4",
		tint50: "#eae8e8",
		tint60: "#faf9f9"
	};
	const mink = {
		shade50: "#0f0e0e",
		shade40: "#1c1b1a",
		shade30: "#343231",
		shade20: "#474443",
		shade10: "#54514f",
		primary: "#5d5a58",
		tint10: "#706d6b",
		tint20: "#84817e",
		tint30: "#9e9b99",
		tint40: "#cecccb",
		tint50: "#e5e4e3",
		tint60: "#f8f8f8"
	};
	const platinum = {
		shade50: "#111314",
		shade40: "#1f2426",
		shade30: "#3b4447",
		shade20: "#505c60",
		shade10: "#5f6d71",
		primary: "#69797e",
		tint10: "#79898d",
		tint20: "#89989d",
		tint30: "#a0adb2",
		tint40: "#cdd6d8",
		tint50: "#e4e9ea",
		tint60: "#f8f9fa"
	};
	const anchor = {
		shade50: "#090a0b",
		shade40: "#111315",
		shade30: "#202427",
		shade20: "#2b3135",
		shade10: "#333a3f",
		primary: "#394146",
		tint10: "#4d565c",
		tint20: "#626c72",
		tint30: "#808a90",
		tint40: "#bcc3c7",
		tint50: "#dbdfe1",
		tint60: "#f6f7f8"
	};

//#endregion
//#region node_modules/@fluentui/tokens/lib/global/colorPalette.js
	const statusSharedColors = {
		red,
		green,
		darkOrange,
		yellow,
		berry,
		lightGreen,
		marigold
	};
	const personaSharedColors = {
		darkRed,
		cranberry,
		pumpkin,
		peach,
		gold,
		brass,
		brown,
		forest,
		seafoam,
		darkGreen,
		lightTeal,
		teal,
		steel,
		blue,
		royalBlue,
		cornflower,
		navy,
		lavender,
		purple,
		grape,
		lilac,
		pink,
		magenta,
		plum,
		beige,
		mink,
		platinum,
		anchor
	};
	const mappedStatusColors = {
		cranberry,
		green,
		orange
	};

//#endregion
//#region node_modules/@fluentui/tokens/lib/sharedColorNames.js
	const statusSharedColorNames = [
		"red",
		"green",
		"darkOrange",
		"yellow",
		"berry",
		"lightGreen",
		"marigold"
	];
	const personaSharedColorNames = [
		"darkRed",
		"cranberry",
		"pumpkin",
		"peach",
		"gold",
		"brass",
		"brown",
		"forest",
		"seafoam",
		"darkGreen",
		"lightTeal",
		"teal",
		"steel",
		"blue",
		"royalBlue",
		"cornflower",
		"navy",
		"lavender",
		"purple",
		"grape",
		"lilac",
		"pink",
		"magenta",
		"plum",
		"beige",
		"mink",
		"platinum",
		"anchor"
	];

//#endregion
//#region node_modules/@fluentui/tokens/lib/statusColorMapping.js
	const statusColorMapping = {
		success: "green",
		warning: "orange",
		danger: "cranberry"
	};

//#endregion
//#region node_modules/@fluentui/tokens/lib/alias/lightColorPalette.js
	const statusColorPaletteTokens$2 = statusSharedColorNames.reduce((acc, sharedColor) => {
		const color$1 = sharedColor.slice(0, 1).toUpperCase() + sharedColor.slice(1);
		const sharedColorTokens = {
			[`colorPalette${color$1}Background1`]: statusSharedColors[sharedColor].tint60,
			[`colorPalette${color$1}Background2`]: statusSharedColors[sharedColor].tint40,
			[`colorPalette${color$1}Background3`]: statusSharedColors[sharedColor].primary,
			[`colorPalette${color$1}Foreground1`]: statusSharedColors[sharedColor].shade10,
			[`colorPalette${color$1}Foreground2`]: statusSharedColors[sharedColor].shade30,
			[`colorPalette${color$1}Foreground3`]: statusSharedColors[sharedColor].primary,
			[`colorPalette${color$1}BorderActive`]: statusSharedColors[sharedColor].primary,
			[`colorPalette${color$1}Border1`]: statusSharedColors[sharedColor].tint40,
			[`colorPalette${color$1}Border2`]: statusSharedColors[sharedColor].primary
		};
		return Object.assign(acc, sharedColorTokens);
	}, {});
	statusColorPaletteTokens$2.colorPaletteYellowForeground1 = statusSharedColors.yellow.shade30;
	statusColorPaletteTokens$2.colorPaletteRedForegroundInverted = statusSharedColors.red.tint20;
	statusColorPaletteTokens$2.colorPaletteGreenForegroundInverted = statusSharedColors.green.tint20;
	statusColorPaletteTokens$2.colorPaletteYellowForegroundInverted = statusSharedColors.yellow.tint40;
	const personaColorPaletteTokens$2 = personaSharedColorNames.reduce((acc, sharedColor) => {
		const color$1 = sharedColor.slice(0, 1).toUpperCase() + sharedColor.slice(1);
		const sharedColorTokens = {
			[`colorPalette${color$1}Background2`]: personaSharedColors[sharedColor].tint40,
			[`colorPalette${color$1}Foreground2`]: personaSharedColors[sharedColor].shade30,
			[`colorPalette${color$1}BorderActive`]: personaSharedColors[sharedColor].primary
		};
		return Object.assign(acc, sharedColorTokens);
	}, {});
	const colorPaletteTokens$2 = {
		...statusColorPaletteTokens$2,
		...personaColorPaletteTokens$2
	};
	const colorStatusTokens$2 = Object.entries(statusColorMapping).reduce((acc, [statusColor, sharedColor]) => {
		const color$1 = statusColor.slice(0, 1).toUpperCase() + statusColor.slice(1);
		const statusColorTokens = {
			[`colorStatus${color$1}Background1`]: mappedStatusColors[sharedColor].tint60,
			[`colorStatus${color$1}Background2`]: mappedStatusColors[sharedColor].tint40,
			[`colorStatus${color$1}Background3`]: mappedStatusColors[sharedColor].primary,
			[`colorStatus${color$1}Foreground1`]: mappedStatusColors[sharedColor].shade10,
			[`colorStatus${color$1}Foreground2`]: mappedStatusColors[sharedColor].shade30,
			[`colorStatus${color$1}Foreground3`]: mappedStatusColors[sharedColor].primary,
			[`colorStatus${color$1}ForegroundInverted`]: mappedStatusColors[sharedColor].tint30,
			[`colorStatus${color$1}BorderActive`]: mappedStatusColors[sharedColor].primary,
			[`colorStatus${color$1}Border1`]: mappedStatusColors[sharedColor].tint40,
			[`colorStatus${color$1}Border2`]: mappedStatusColors[sharedColor].primary
		};
		return Object.assign(acc, statusColorTokens);
	}, {});
	colorStatusTokens$2.colorStatusDangerBackground3Hover = mappedStatusColors[statusColorMapping.danger].shade10;
	colorStatusTokens$2.colorStatusDangerBackground3Pressed = mappedStatusColors[statusColorMapping.danger].shade20;
	colorStatusTokens$2.colorStatusWarningForeground1 = mappedStatusColors[statusColorMapping.warning].shade20;
	colorStatusTokens$2.colorStatusWarningForeground3 = mappedStatusColors[statusColorMapping.warning].shade20;
	colorStatusTokens$2.colorStatusWarningBorder2 = mappedStatusColors[statusColorMapping.warning].shade20;

//#endregion
//#region node_modules/@fluentui/tokens/lib/alias/lightColor.js
	const generateColorTokens$3 = (brand) => ({
		colorNeutralForeground1: grey[14],
		colorNeutralForeground1Hover: grey[14],
		colorNeutralForeground1Pressed: grey[14],
		colorNeutralForeground1Selected: grey[14],
		colorNeutralForeground2: grey[26],
		colorNeutralForeground2Hover: grey[14],
		colorNeutralForeground2Pressed: grey[14],
		colorNeutralForeground2Selected: grey[14],
		colorNeutralForeground2BrandHover: brand[80],
		colorNeutralForeground2BrandPressed: brand[70],
		colorNeutralForeground2BrandSelected: brand[80],
		colorNeutralForeground3: grey[38],
		colorNeutralForeground3Hover: grey[26],
		colorNeutralForeground3Pressed: grey[26],
		colorNeutralForeground3Selected: grey[26],
		colorNeutralForeground3BrandHover: brand[80],
		colorNeutralForeground3BrandPressed: brand[70],
		colorNeutralForeground3BrandSelected: brand[80],
		colorNeutralForeground4: grey[44],
		colorNeutralForegroundDisabled: grey[74],
		colorNeutralForegroundInvertedDisabled: whiteAlpha[40],
		colorBrandForegroundLink: brand[70],
		colorBrandForegroundLinkHover: brand[60],
		colorBrandForegroundLinkPressed: brand[40],
		colorBrandForegroundLinkSelected: brand[70],
		colorNeutralForeground2Link: grey[26],
		colorNeutralForeground2LinkHover: grey[14],
		colorNeutralForeground2LinkPressed: grey[14],
		colorNeutralForeground2LinkSelected: grey[14],
		colorCompoundBrandForeground1: brand[80],
		colorCompoundBrandForeground1Hover: brand[70],
		colorCompoundBrandForeground1Pressed: brand[60],
		colorBrandForeground1: brand[80],
		colorBrandForeground2: brand[70],
		colorBrandForeground2Hover: brand[60],
		colorBrandForeground2Pressed: brand[30],
		colorNeutralForeground1Static: grey[14],
		colorNeutralForegroundStaticInverted: white,
		colorNeutralForegroundInverted: white,
		colorNeutralForegroundInvertedHover: white,
		colorNeutralForegroundInvertedPressed: white,
		colorNeutralForegroundInvertedSelected: white,
		colorNeutralForegroundInverted2: white,
		colorNeutralForegroundOnBrand: white,
		colorNeutralForegroundInvertedLink: white,
		colorNeutralForegroundInvertedLinkHover: white,
		colorNeutralForegroundInvertedLinkPressed: white,
		colorNeutralForegroundInvertedLinkSelected: white,
		colorBrandForegroundInverted: brand[100],
		colorBrandForegroundInvertedHover: brand[110],
		colorBrandForegroundInvertedPressed: brand[100],
		colorBrandForegroundOnLight: brand[80],
		colorBrandForegroundOnLightHover: brand[70],
		colorBrandForegroundOnLightPressed: brand[50],
		colorBrandForegroundOnLightSelected: brand[60],
		colorNeutralBackground1: white,
		colorNeutralBackground1Hover: grey[96],
		colorNeutralBackground1Pressed: grey[88],
		colorNeutralBackground1Selected: grey[92],
		colorNeutralBackground2: grey[98],
		colorNeutralBackground2Hover: grey[94],
		colorNeutralBackground2Pressed: grey[86],
		colorNeutralBackground2Selected: grey[90],
		colorNeutralBackground3: grey[96],
		colorNeutralBackground3Hover: grey[92],
		colorNeutralBackground3Pressed: grey[84],
		colorNeutralBackground3Selected: grey[88],
		colorNeutralBackground4: grey[94],
		colorNeutralBackground4Hover: grey[98],
		colorNeutralBackground4Pressed: grey[96],
		colorNeutralBackground4Selected: white,
		colorNeutralBackground5: grey[92],
		colorNeutralBackground5Hover: grey[96],
		colorNeutralBackground5Pressed: grey[94],
		colorNeutralBackground5Selected: grey[98],
		colorNeutralBackground6: grey[90],
		colorNeutralBackgroundInverted: grey[16],
		colorNeutralBackgroundStatic: grey[20],
		colorNeutralBackgroundAlpha: whiteAlpha[50],
		colorNeutralBackgroundAlpha2: whiteAlpha[80],
		colorSubtleBackground: "transparent",
		colorSubtleBackgroundHover: grey[96],
		colorSubtleBackgroundPressed: grey[88],
		colorSubtleBackgroundSelected: grey[92],
		colorSubtleBackgroundLightAlphaHover: whiteAlpha[70],
		colorSubtleBackgroundLightAlphaPressed: whiteAlpha[50],
		colorSubtleBackgroundLightAlphaSelected: "transparent",
		colorSubtleBackgroundInverted: "transparent",
		colorSubtleBackgroundInvertedHover: blackAlpha[10],
		colorSubtleBackgroundInvertedPressed: blackAlpha[30],
		colorSubtleBackgroundInvertedSelected: blackAlpha[20],
		colorTransparentBackground: "transparent",
		colorTransparentBackgroundHover: "transparent",
		colorTransparentBackgroundPressed: "transparent",
		colorTransparentBackgroundSelected: "transparent",
		colorNeutralBackgroundDisabled: grey[94],
		colorNeutralBackgroundInvertedDisabled: whiteAlpha[10],
		colorNeutralStencil1: grey[90],
		colorNeutralStencil2: grey[98],
		colorNeutralStencil1Alpha: blackAlpha[10],
		colorNeutralStencil2Alpha: blackAlpha[5],
		colorBackgroundOverlay: blackAlpha[40],
		colorScrollbarOverlay: blackAlpha[50],
		colorBrandBackground: brand[80],
		colorBrandBackgroundHover: brand[70],
		colorBrandBackgroundPressed: brand[40],
		colorBrandBackgroundSelected: brand[60],
		colorCompoundBrandBackground: brand[80],
		colorCompoundBrandBackgroundHover: brand[70],
		colorCompoundBrandBackgroundPressed: brand[60],
		colorBrandBackgroundStatic: brand[80],
		colorBrandBackground2: brand[160],
		colorBrandBackground2Hover: brand[150],
		colorBrandBackground2Pressed: brand[130],
		colorBrandBackground3Static: brand[60],
		colorBrandBackground4Static: brand[40],
		colorBrandBackgroundInverted: white,
		colorBrandBackgroundInvertedHover: brand[160],
		colorBrandBackgroundInvertedPressed: brand[140],
		colorBrandBackgroundInvertedSelected: brand[150],
		colorNeutralCardBackground: grey[98],
		colorNeutralCardBackgroundHover: white,
		colorNeutralCardBackgroundPressed: grey[96],
		colorNeutralCardBackgroundSelected: grey[92],
		colorNeutralCardBackgroundDisabled: grey[94],
		colorNeutralStrokeAccessible: grey[38],
		colorNeutralStrokeAccessibleHover: grey[34],
		colorNeutralStrokeAccessiblePressed: grey[30],
		colorNeutralStrokeAccessibleSelected: brand[80],
		colorNeutralStroke1: grey[82],
		colorNeutralStroke1Hover: grey[78],
		colorNeutralStroke1Pressed: grey[70],
		colorNeutralStroke1Selected: grey[74],
		colorNeutralStroke2: grey[88],
		colorNeutralStroke3: grey[94],
		colorNeutralStrokeSubtle: grey[88],
		colorNeutralStrokeOnBrand: white,
		colorNeutralStrokeOnBrand2: white,
		colorNeutralStrokeOnBrand2Hover: white,
		colorNeutralStrokeOnBrand2Pressed: white,
		colorNeutralStrokeOnBrand2Selected: white,
		colorBrandStroke1: brand[80],
		colorBrandStroke2: brand[140],
		colorBrandStroke2Hover: brand[120],
		colorBrandStroke2Pressed: brand[80],
		colorBrandStroke2Contrast: brand[140],
		colorCompoundBrandStroke: brand[80],
		colorCompoundBrandStrokeHover: brand[70],
		colorCompoundBrandStrokePressed: brand[60],
		colorNeutralStrokeDisabled: grey[88],
		colorNeutralStrokeInvertedDisabled: whiteAlpha[40],
		colorTransparentStroke: "transparent",
		colorTransparentStrokeInteractive: "transparent",
		colorTransparentStrokeDisabled: "transparent",
		colorNeutralStrokeAlpha: blackAlpha[5],
		colorNeutralStrokeAlpha2: whiteAlpha[20],
		colorStrokeFocus1: white,
		colorStrokeFocus2: black,
		colorNeutralShadowAmbient: "rgba(0,0,0,0.12)",
		colorNeutralShadowKey: "rgba(0,0,0,0.14)",
		colorNeutralShadowAmbientLighter: "rgba(0,0,0,0.06)",
		colorNeutralShadowKeyLighter: "rgba(0,0,0,0.07)",
		colorNeutralShadowAmbientDarker: "rgba(0,0,0,0.20)",
		colorNeutralShadowKeyDarker: "rgba(0,0,0,0.24)",
		colorBrandShadowAmbient: "rgba(0,0,0,0.30)",
		colorBrandShadowKey: "rgba(0,0,0,0.25)"
	});

//#endregion
//#region node_modules/@fluentui/tokens/lib/global/borderRadius.js
	const borderRadius = {
		borderRadiusNone: "0",
		borderRadiusSmall: "2px",
		borderRadiusMedium: "4px",
		borderRadiusLarge: "6px",
		borderRadiusXLarge: "8px",
		borderRadiusCircular: "10000px"
	};

//#endregion
//#region node_modules/@fluentui/tokens/lib/global/curves.js
	const curves$1 = {
		curveAccelerateMax: "cubic-bezier(0.9,0.1,1,0.2)",
		curveAccelerateMid: "cubic-bezier(1,0,1,1)",
		curveAccelerateMin: "cubic-bezier(0.8,0,0.78,1)",
		curveDecelerateMax: "cubic-bezier(0.1,0.9,0.2,1)",
		curveDecelerateMid: "cubic-bezier(0,0,0,1)",
		curveDecelerateMin: "cubic-bezier(0.33,0,0.1,1)",
		curveEasyEaseMax: "cubic-bezier(0.8,0,0.2,1)",
		curveEasyEase: "cubic-bezier(0.33,0,0.67,1)",
		curveLinear: "cubic-bezier(0,0,1,1)"
	};

//#endregion
//#region node_modules/@fluentui/tokens/lib/global/durations.js
	const durations$2 = {
		durationUltraFast: "50ms",
		durationFaster: "100ms",
		durationFast: "150ms",
		durationNormal: "200ms",
		durationGentle: "250ms",
		durationSlow: "300ms",
		durationSlower: "400ms",
		durationUltraSlow: "500ms"
	};

//#endregion
//#region node_modules/@fluentui/tokens/lib/global/fonts.js
	const fontSizes = {
		fontSizeBase100: "10px",
		fontSizeBase200: "12px",
		fontSizeBase300: "14px",
		fontSizeBase400: "16px",
		fontSizeBase500: "20px",
		fontSizeBase600: "24px",
		fontSizeHero700: "28px",
		fontSizeHero800: "32px",
		fontSizeHero900: "40px",
		fontSizeHero1000: "68px"
	};
	const lineHeights = {
		lineHeightBase100: "14px",
		lineHeightBase200: "16px",
		lineHeightBase300: "20px",
		lineHeightBase400: "22px",
		lineHeightBase500: "28px",
		lineHeightBase600: "32px",
		lineHeightHero700: "36px",
		lineHeightHero800: "40px",
		lineHeightHero900: "52px",
		lineHeightHero1000: "92px"
	};
	const fontWeights = {
		fontWeightRegular: 400,
		fontWeightMedium: 500,
		fontWeightSemibold: 600,
		fontWeightBold: 700
	};
	const fontFamilies$1 = {
		fontFamilyBase: "'Segoe UI', 'Segoe UI Web (West European)', -apple-system, BlinkMacSystemFont, Roboto, 'Helvetica Neue', sans-serif",
		fontFamilyMonospace: "Consolas, 'Courier New', Courier, monospace",
		fontFamilyNumeric: "Bahnschrift, 'Segoe UI', 'Segoe UI Web (West European)', -apple-system, BlinkMacSystemFont, Roboto, 'Helvetica Neue', sans-serif"
	};

//#endregion
//#region node_modules/@fluentui/tokens/lib/global/spacings.js
	const spacings = {
		none: "0",
		xxs: "2px",
		xs: "4px",
		sNudge: "6px",
		s: "8px",
		mNudge: "10px",
		m: "12px",
		l: "16px",
		xl: "20px",
		xxl: "24px",
		xxxl: "32px"
	};
	const horizontalSpacings = {
		spacingHorizontalNone: spacings.none,
		spacingHorizontalXXS: spacings.xxs,
		spacingHorizontalXS: spacings.xs,
		spacingHorizontalSNudge: spacings.sNudge,
		spacingHorizontalS: spacings.s,
		spacingHorizontalMNudge: spacings.mNudge,
		spacingHorizontalM: spacings.m,
		spacingHorizontalL: spacings.l,
		spacingHorizontalXL: spacings.xl,
		spacingHorizontalXXL: spacings.xxl,
		spacingHorizontalXXXL: spacings.xxxl
	};
	const verticalSpacings = {
		spacingVerticalNone: spacings.none,
		spacingVerticalXXS: spacings.xxs,
		spacingVerticalXS: spacings.xs,
		spacingVerticalSNudge: spacings.sNudge,
		spacingVerticalS: spacings.s,
		spacingVerticalMNudge: spacings.mNudge,
		spacingVerticalM: spacings.m,
		spacingVerticalL: spacings.l,
		spacingVerticalXL: spacings.xl,
		spacingVerticalXXL: spacings.xxl,
		spacingVerticalXXXL: spacings.xxxl
	};

//#endregion
//#region node_modules/@fluentui/tokens/lib/global/strokeWidths.js
	const strokeWidths = {
		strokeWidthThin: "1px",
		strokeWidthThick: "2px",
		strokeWidthThicker: "3px",
		strokeWidthThickest: "4px"
	};

//#endregion
//#region node_modules/@fluentui/tokens/lib/tokens.js
	const tokens = {
		colorNeutralForeground1: "var(--colorNeutralForeground1)",
		colorNeutralForeground1Hover: "var(--colorNeutralForeground1Hover)",
		colorNeutralForeground1Pressed: "var(--colorNeutralForeground1Pressed)",
		colorNeutralForeground1Selected: "var(--colorNeutralForeground1Selected)",
		colorNeutralForeground2: "var(--colorNeutralForeground2)",
		colorNeutralForeground2Hover: "var(--colorNeutralForeground2Hover)",
		colorNeutralForeground2Pressed: "var(--colorNeutralForeground2Pressed)",
		colorNeutralForeground2Selected: "var(--colorNeutralForeground2Selected)",
		colorNeutralForeground2BrandHover: "var(--colorNeutralForeground2BrandHover)",
		colorNeutralForeground2BrandPressed: "var(--colorNeutralForeground2BrandPressed)",
		colorNeutralForeground2BrandSelected: "var(--colorNeutralForeground2BrandSelected)",
		colorNeutralForeground3: "var(--colorNeutralForeground3)",
		colorNeutralForeground3Hover: "var(--colorNeutralForeground3Hover)",
		colorNeutralForeground3Pressed: "var(--colorNeutralForeground3Pressed)",
		colorNeutralForeground3Selected: "var(--colorNeutralForeground3Selected)",
		colorNeutralForeground3BrandHover: "var(--colorNeutralForeground3BrandHover)",
		colorNeutralForeground3BrandPressed: "var(--colorNeutralForeground3BrandPressed)",
		colorNeutralForeground3BrandSelected: "var(--colorNeutralForeground3BrandSelected)",
		colorNeutralForeground4: "var(--colorNeutralForeground4)",
		colorNeutralForegroundDisabled: "var(--colorNeutralForegroundDisabled)",
		colorBrandForegroundLink: "var(--colorBrandForegroundLink)",
		colorBrandForegroundLinkHover: "var(--colorBrandForegroundLinkHover)",
		colorBrandForegroundLinkPressed: "var(--colorBrandForegroundLinkPressed)",
		colorBrandForegroundLinkSelected: "var(--colorBrandForegroundLinkSelected)",
		colorNeutralForeground2Link: "var(--colorNeutralForeground2Link)",
		colorNeutralForeground2LinkHover: "var(--colorNeutralForeground2LinkHover)",
		colorNeutralForeground2LinkPressed: "var(--colorNeutralForeground2LinkPressed)",
		colorNeutralForeground2LinkSelected: "var(--colorNeutralForeground2LinkSelected)",
		colorCompoundBrandForeground1: "var(--colorCompoundBrandForeground1)",
		colorCompoundBrandForeground1Hover: "var(--colorCompoundBrandForeground1Hover)",
		colorCompoundBrandForeground1Pressed: "var(--colorCompoundBrandForeground1Pressed)",
		colorNeutralForegroundOnBrand: "var(--colorNeutralForegroundOnBrand)",
		colorNeutralForegroundInverted: "var(--colorNeutralForegroundInverted)",
		colorNeutralForegroundInvertedHover: "var(--colorNeutralForegroundInvertedHover)",
		colorNeutralForegroundInvertedPressed: "var(--colorNeutralForegroundInvertedPressed)",
		colorNeutralForegroundInvertedSelected: "var(--colorNeutralForegroundInvertedSelected)",
		colorNeutralForegroundInverted2: "var(--colorNeutralForegroundInverted2)",
		colorNeutralForegroundStaticInverted: "var(--colorNeutralForegroundStaticInverted)",
		colorNeutralForegroundInvertedLink: "var(--colorNeutralForegroundInvertedLink)",
		colorNeutralForegroundInvertedLinkHover: "var(--colorNeutralForegroundInvertedLinkHover)",
		colorNeutralForegroundInvertedLinkPressed: "var(--colorNeutralForegroundInvertedLinkPressed)",
		colorNeutralForegroundInvertedLinkSelected: "var(--colorNeutralForegroundInvertedLinkSelected)",
		colorNeutralForegroundInvertedDisabled: "var(--colorNeutralForegroundInvertedDisabled)",
		colorBrandForeground1: "var(--colorBrandForeground1)",
		colorBrandForeground2: "var(--colorBrandForeground2)",
		colorBrandForeground2Hover: "var(--colorBrandForeground2Hover)",
		colorBrandForeground2Pressed: "var(--colorBrandForeground2Pressed)",
		colorNeutralForeground1Static: "var(--colorNeutralForeground1Static)",
		colorBrandForegroundInverted: "var(--colorBrandForegroundInverted)",
		colorBrandForegroundInvertedHover: "var(--colorBrandForegroundInvertedHover)",
		colorBrandForegroundInvertedPressed: "var(--colorBrandForegroundInvertedPressed)",
		colorBrandForegroundOnLight: "var(--colorBrandForegroundOnLight)",
		colorBrandForegroundOnLightHover: "var(--colorBrandForegroundOnLightHover)",
		colorBrandForegroundOnLightPressed: "var(--colorBrandForegroundOnLightPressed)",
		colorBrandForegroundOnLightSelected: "var(--colorBrandForegroundOnLightSelected)",
		colorNeutralBackground1: "var(--colorNeutralBackground1)",
		colorNeutralBackground1Hover: "var(--colorNeutralBackground1Hover)",
		colorNeutralBackground1Pressed: "var(--colorNeutralBackground1Pressed)",
		colorNeutralBackground1Selected: "var(--colorNeutralBackground1Selected)",
		colorNeutralBackground2: "var(--colorNeutralBackground2)",
		colorNeutralBackground2Hover: "var(--colorNeutralBackground2Hover)",
		colorNeutralBackground2Pressed: "var(--colorNeutralBackground2Pressed)",
		colorNeutralBackground2Selected: "var(--colorNeutralBackground2Selected)",
		colorNeutralBackground3: "var(--colorNeutralBackground3)",
		colorNeutralBackground3Hover: "var(--colorNeutralBackground3Hover)",
		colorNeutralBackground3Pressed: "var(--colorNeutralBackground3Pressed)",
		colorNeutralBackground3Selected: "var(--colorNeutralBackground3Selected)",
		colorNeutralBackground4: "var(--colorNeutralBackground4)",
		colorNeutralBackground4Hover: "var(--colorNeutralBackground4Hover)",
		colorNeutralBackground4Pressed: "var(--colorNeutralBackground4Pressed)",
		colorNeutralBackground4Selected: "var(--colorNeutralBackground4Selected)",
		colorNeutralBackground5: "var(--colorNeutralBackground5)",
		colorNeutralBackground5Hover: "var(--colorNeutralBackground5Hover)",
		colorNeutralBackground5Pressed: "var(--colorNeutralBackground5Pressed)",
		colorNeutralBackground5Selected: "var(--colorNeutralBackground5Selected)",
		colorNeutralBackground6: "var(--colorNeutralBackground6)",
		colorNeutralBackgroundInverted: "var(--colorNeutralBackgroundInverted)",
		colorNeutralBackgroundStatic: "var(--colorNeutralBackgroundStatic)",
		colorNeutralBackgroundAlpha: "var(--colorNeutralBackgroundAlpha)",
		colorNeutralBackgroundAlpha2: "var(--colorNeutralBackgroundAlpha2)",
		colorSubtleBackground: "var(--colorSubtleBackground)",
		colorSubtleBackgroundHover: "var(--colorSubtleBackgroundHover)",
		colorSubtleBackgroundPressed: "var(--colorSubtleBackgroundPressed)",
		colorSubtleBackgroundSelected: "var(--colorSubtleBackgroundSelected)",
		colorSubtleBackgroundLightAlphaHover: "var(--colorSubtleBackgroundLightAlphaHover)",
		colorSubtleBackgroundLightAlphaPressed: "var(--colorSubtleBackgroundLightAlphaPressed)",
		colorSubtleBackgroundLightAlphaSelected: "var(--colorSubtleBackgroundLightAlphaSelected)",
		colorSubtleBackgroundInverted: "var(--colorSubtleBackgroundInverted)",
		colorSubtleBackgroundInvertedHover: "var(--colorSubtleBackgroundInvertedHover)",
		colorSubtleBackgroundInvertedPressed: "var(--colorSubtleBackgroundInvertedPressed)",
		colorSubtleBackgroundInvertedSelected: "var(--colorSubtleBackgroundInvertedSelected)",
		colorTransparentBackground: "var(--colorTransparentBackground)",
		colorTransparentBackgroundHover: "var(--colorTransparentBackgroundHover)",
		colorTransparentBackgroundPressed: "var(--colorTransparentBackgroundPressed)",
		colorTransparentBackgroundSelected: "var(--colorTransparentBackgroundSelected)",
		colorNeutralBackgroundDisabled: "var(--colorNeutralBackgroundDisabled)",
		colorNeutralBackgroundInvertedDisabled: "var(--colorNeutralBackgroundInvertedDisabled)",
		colorNeutralStencil1: "var(--colorNeutralStencil1)",
		colorNeutralStencil2: "var(--colorNeutralStencil2)",
		colorNeutralStencil1Alpha: "var(--colorNeutralStencil1Alpha)",
		colorNeutralStencil2Alpha: "var(--colorNeutralStencil2Alpha)",
		colorBackgroundOverlay: "var(--colorBackgroundOverlay)",
		colorScrollbarOverlay: "var(--colorScrollbarOverlay)",
		colorBrandBackground: "var(--colorBrandBackground)",
		colorBrandBackgroundHover: "var(--colorBrandBackgroundHover)",
		colorBrandBackgroundPressed: "var(--colorBrandBackgroundPressed)",
		colorBrandBackgroundSelected: "var(--colorBrandBackgroundSelected)",
		colorCompoundBrandBackground: "var(--colorCompoundBrandBackground)",
		colorCompoundBrandBackgroundHover: "var(--colorCompoundBrandBackgroundHover)",
		colorCompoundBrandBackgroundPressed: "var(--colorCompoundBrandBackgroundPressed)",
		colorBrandBackgroundStatic: "var(--colorBrandBackgroundStatic)",
		colorBrandBackground2: "var(--colorBrandBackground2)",
		colorBrandBackground2Hover: "var(--colorBrandBackground2Hover)",
		colorBrandBackground2Pressed: "var(--colorBrandBackground2Pressed)",
		colorBrandBackground3Static: "var(--colorBrandBackground3Static)",
		colorBrandBackground4Static: "var(--colorBrandBackground4Static)",
		colorBrandBackgroundInverted: "var(--colorBrandBackgroundInverted)",
		colorBrandBackgroundInvertedHover: "var(--colorBrandBackgroundInvertedHover)",
		colorBrandBackgroundInvertedPressed: "var(--colorBrandBackgroundInvertedPressed)",
		colorBrandBackgroundInvertedSelected: "var(--colorBrandBackgroundInvertedSelected)",
		colorNeutralCardBackground: "var(--colorNeutralCardBackground)",
		colorNeutralCardBackgroundHover: "var(--colorNeutralCardBackgroundHover)",
		colorNeutralCardBackgroundPressed: "var(--colorNeutralCardBackgroundPressed)",
		colorNeutralCardBackgroundSelected: "var(--colorNeutralCardBackgroundSelected)",
		colorNeutralCardBackgroundDisabled: "var(--colorNeutralCardBackgroundDisabled)",
		colorNeutralStrokeAccessible: "var(--colorNeutralStrokeAccessible)",
		colorNeutralStrokeAccessibleHover: "var(--colorNeutralStrokeAccessibleHover)",
		colorNeutralStrokeAccessiblePressed: "var(--colorNeutralStrokeAccessiblePressed)",
		colorNeutralStrokeAccessibleSelected: "var(--colorNeutralStrokeAccessibleSelected)",
		colorNeutralStroke1: "var(--colorNeutralStroke1)",
		colorNeutralStroke1Hover: "var(--colorNeutralStroke1Hover)",
		colorNeutralStroke1Pressed: "var(--colorNeutralStroke1Pressed)",
		colorNeutralStroke1Selected: "var(--colorNeutralStroke1Selected)",
		colorNeutralStroke2: "var(--colorNeutralStroke2)",
		colorNeutralStroke3: "var(--colorNeutralStroke3)",
		colorNeutralStrokeSubtle: "var(--colorNeutralStrokeSubtle)",
		colorNeutralStrokeOnBrand: "var(--colorNeutralStrokeOnBrand)",
		colorNeutralStrokeOnBrand2: "var(--colorNeutralStrokeOnBrand2)",
		colorNeutralStrokeOnBrand2Hover: "var(--colorNeutralStrokeOnBrand2Hover)",
		colorNeutralStrokeOnBrand2Pressed: "var(--colorNeutralStrokeOnBrand2Pressed)",
		colorNeutralStrokeOnBrand2Selected: "var(--colorNeutralStrokeOnBrand2Selected)",
		colorBrandStroke1: "var(--colorBrandStroke1)",
		colorBrandStroke2: "var(--colorBrandStroke2)",
		colorBrandStroke2Hover: "var(--colorBrandStroke2Hover)",
		colorBrandStroke2Pressed: "var(--colorBrandStroke2Pressed)",
		colorBrandStroke2Contrast: "var(--colorBrandStroke2Contrast)",
		colorCompoundBrandStroke: "var(--colorCompoundBrandStroke)",
		colorCompoundBrandStrokeHover: "var(--colorCompoundBrandStrokeHover)",
		colorCompoundBrandStrokePressed: "var(--colorCompoundBrandStrokePressed)",
		colorNeutralStrokeDisabled: "var(--colorNeutralStrokeDisabled)",
		colorNeutralStrokeInvertedDisabled: "var(--colorNeutralStrokeInvertedDisabled)",
		colorTransparentStroke: "var(--colorTransparentStroke)",
		colorTransparentStrokeInteractive: "var(--colorTransparentStrokeInteractive)",
		colorTransparentStrokeDisabled: "var(--colorTransparentStrokeDisabled)",
		colorNeutralStrokeAlpha: "var(--colorNeutralStrokeAlpha)",
		colorNeutralStrokeAlpha2: "var(--colorNeutralStrokeAlpha2)",
		colorStrokeFocus1: "var(--colorStrokeFocus1)",
		colorStrokeFocus2: "var(--colorStrokeFocus2)",
		colorNeutralShadowAmbient: "var(--colorNeutralShadowAmbient)",
		colorNeutralShadowKey: "var(--colorNeutralShadowKey)",
		colorNeutralShadowAmbientLighter: "var(--colorNeutralShadowAmbientLighter)",
		colorNeutralShadowKeyLighter: "var(--colorNeutralShadowKeyLighter)",
		colorNeutralShadowAmbientDarker: "var(--colorNeutralShadowAmbientDarker)",
		colorNeutralShadowKeyDarker: "var(--colorNeutralShadowKeyDarker)",
		colorBrandShadowAmbient: "var(--colorBrandShadowAmbient)",
		colorBrandShadowKey: "var(--colorBrandShadowKey)",
		colorPaletteRedBackground1: "var(--colorPaletteRedBackground1)",
		colorPaletteRedBackground2: "var(--colorPaletteRedBackground2)",
		colorPaletteRedBackground3: "var(--colorPaletteRedBackground3)",
		colorPaletteRedBorderActive: "var(--colorPaletteRedBorderActive)",
		colorPaletteRedBorder1: "var(--colorPaletteRedBorder1)",
		colorPaletteRedBorder2: "var(--colorPaletteRedBorder2)",
		colorPaletteRedForeground1: "var(--colorPaletteRedForeground1)",
		colorPaletteRedForeground2: "var(--colorPaletteRedForeground2)",
		colorPaletteRedForeground3: "var(--colorPaletteRedForeground3)",
		colorPaletteRedForegroundInverted: "var(--colorPaletteRedForegroundInverted)",
		colorPaletteGreenBackground1: "var(--colorPaletteGreenBackground1)",
		colorPaletteGreenBackground2: "var(--colorPaletteGreenBackground2)",
		colorPaletteGreenBackground3: "var(--colorPaletteGreenBackground3)",
		colorPaletteGreenBorderActive: "var(--colorPaletteGreenBorderActive)",
		colorPaletteGreenBorder1: "var(--colorPaletteGreenBorder1)",
		colorPaletteGreenBorder2: "var(--colorPaletteGreenBorder2)",
		colorPaletteGreenForeground1: "var(--colorPaletteGreenForeground1)",
		colorPaletteGreenForeground2: "var(--colorPaletteGreenForeground2)",
		colorPaletteGreenForeground3: "var(--colorPaletteGreenForeground3)",
		colorPaletteGreenForegroundInverted: "var(--colorPaletteGreenForegroundInverted)",
		colorPaletteDarkOrangeBackground1: "var(--colorPaletteDarkOrangeBackground1)",
		colorPaletteDarkOrangeBackground2: "var(--colorPaletteDarkOrangeBackground2)",
		colorPaletteDarkOrangeBackground3: "var(--colorPaletteDarkOrangeBackground3)",
		colorPaletteDarkOrangeBorderActive: "var(--colorPaletteDarkOrangeBorderActive)",
		colorPaletteDarkOrangeBorder1: "var(--colorPaletteDarkOrangeBorder1)",
		colorPaletteDarkOrangeBorder2: "var(--colorPaletteDarkOrangeBorder2)",
		colorPaletteDarkOrangeForeground1: "var(--colorPaletteDarkOrangeForeground1)",
		colorPaletteDarkOrangeForeground2: "var(--colorPaletteDarkOrangeForeground2)",
		colorPaletteDarkOrangeForeground3: "var(--colorPaletteDarkOrangeForeground3)",
		colorPaletteYellowBackground1: "var(--colorPaletteYellowBackground1)",
		colorPaletteYellowBackground2: "var(--colorPaletteYellowBackground2)",
		colorPaletteYellowBackground3: "var(--colorPaletteYellowBackground3)",
		colorPaletteYellowBorderActive: "var(--colorPaletteYellowBorderActive)",
		colorPaletteYellowBorder1: "var(--colorPaletteYellowBorder1)",
		colorPaletteYellowBorder2: "var(--colorPaletteYellowBorder2)",
		colorPaletteYellowForeground1: "var(--colorPaletteYellowForeground1)",
		colorPaletteYellowForeground2: "var(--colorPaletteYellowForeground2)",
		colorPaletteYellowForeground3: "var(--colorPaletteYellowForeground3)",
		colorPaletteYellowForegroundInverted: "var(--colorPaletteYellowForegroundInverted)",
		colorPaletteBerryBackground1: "var(--colorPaletteBerryBackground1)",
		colorPaletteBerryBackground2: "var(--colorPaletteBerryBackground2)",
		colorPaletteBerryBackground3: "var(--colorPaletteBerryBackground3)",
		colorPaletteBerryBorderActive: "var(--colorPaletteBerryBorderActive)",
		colorPaletteBerryBorder1: "var(--colorPaletteBerryBorder1)",
		colorPaletteBerryBorder2: "var(--colorPaletteBerryBorder2)",
		colorPaletteBerryForeground1: "var(--colorPaletteBerryForeground1)",
		colorPaletteBerryForeground2: "var(--colorPaletteBerryForeground2)",
		colorPaletteBerryForeground3: "var(--colorPaletteBerryForeground3)",
		colorPaletteMarigoldBackground1: "var(--colorPaletteMarigoldBackground1)",
		colorPaletteMarigoldBackground2: "var(--colorPaletteMarigoldBackground2)",
		colorPaletteMarigoldBackground3: "var(--colorPaletteMarigoldBackground3)",
		colorPaletteMarigoldBorderActive: "var(--colorPaletteMarigoldBorderActive)",
		colorPaletteMarigoldBorder1: "var(--colorPaletteMarigoldBorder1)",
		colorPaletteMarigoldBorder2: "var(--colorPaletteMarigoldBorder2)",
		colorPaletteMarigoldForeground1: "var(--colorPaletteMarigoldForeground1)",
		colorPaletteMarigoldForeground2: "var(--colorPaletteMarigoldForeground2)",
		colorPaletteMarigoldForeground3: "var(--colorPaletteMarigoldForeground3)",
		colorPaletteLightGreenBackground1: "var(--colorPaletteLightGreenBackground1)",
		colorPaletteLightGreenBackground2: "var(--colorPaletteLightGreenBackground2)",
		colorPaletteLightGreenBackground3: "var(--colorPaletteLightGreenBackground3)",
		colorPaletteLightGreenBorderActive: "var(--colorPaletteLightGreenBorderActive)",
		colorPaletteLightGreenBorder1: "var(--colorPaletteLightGreenBorder1)",
		colorPaletteLightGreenBorder2: "var(--colorPaletteLightGreenBorder2)",
		colorPaletteLightGreenForeground1: "var(--colorPaletteLightGreenForeground1)",
		colorPaletteLightGreenForeground2: "var(--colorPaletteLightGreenForeground2)",
		colorPaletteLightGreenForeground3: "var(--colorPaletteLightGreenForeground3)",
		colorPaletteAnchorBackground2: "var(--colorPaletteAnchorBackground2)",
		colorPaletteAnchorBorderActive: "var(--colorPaletteAnchorBorderActive)",
		colorPaletteAnchorForeground2: "var(--colorPaletteAnchorForeground2)",
		colorPaletteBeigeBackground2: "var(--colorPaletteBeigeBackground2)",
		colorPaletteBeigeBorderActive: "var(--colorPaletteBeigeBorderActive)",
		colorPaletteBeigeForeground2: "var(--colorPaletteBeigeForeground2)",
		colorPaletteBlueBackground2: "var(--colorPaletteBlueBackground2)",
		colorPaletteBlueBorderActive: "var(--colorPaletteBlueBorderActive)",
		colorPaletteBlueForeground2: "var(--colorPaletteBlueForeground2)",
		colorPaletteBrassBackground2: "var(--colorPaletteBrassBackground2)",
		colorPaletteBrassBorderActive: "var(--colorPaletteBrassBorderActive)",
		colorPaletteBrassForeground2: "var(--colorPaletteBrassForeground2)",
		colorPaletteBrownBackground2: "var(--colorPaletteBrownBackground2)",
		colorPaletteBrownBorderActive: "var(--colorPaletteBrownBorderActive)",
		colorPaletteBrownForeground2: "var(--colorPaletteBrownForeground2)",
		colorPaletteCornflowerBackground2: "var(--colorPaletteCornflowerBackground2)",
		colorPaletteCornflowerBorderActive: "var(--colorPaletteCornflowerBorderActive)",
		colorPaletteCornflowerForeground2: "var(--colorPaletteCornflowerForeground2)",
		colorPaletteCranberryBackground2: "var(--colorPaletteCranberryBackground2)",
		colorPaletteCranberryBorderActive: "var(--colorPaletteCranberryBorderActive)",
		colorPaletteCranberryForeground2: "var(--colorPaletteCranberryForeground2)",
		colorPaletteDarkGreenBackground2: "var(--colorPaletteDarkGreenBackground2)",
		colorPaletteDarkGreenBorderActive: "var(--colorPaletteDarkGreenBorderActive)",
		colorPaletteDarkGreenForeground2: "var(--colorPaletteDarkGreenForeground2)",
		colorPaletteDarkRedBackground2: "var(--colorPaletteDarkRedBackground2)",
		colorPaletteDarkRedBorderActive: "var(--colorPaletteDarkRedBorderActive)",
		colorPaletteDarkRedForeground2: "var(--colorPaletteDarkRedForeground2)",
		colorPaletteForestBackground2: "var(--colorPaletteForestBackground2)",
		colorPaletteForestBorderActive: "var(--colorPaletteForestBorderActive)",
		colorPaletteForestForeground2: "var(--colorPaletteForestForeground2)",
		colorPaletteGoldBackground2: "var(--colorPaletteGoldBackground2)",
		colorPaletteGoldBorderActive: "var(--colorPaletteGoldBorderActive)",
		colorPaletteGoldForeground2: "var(--colorPaletteGoldForeground2)",
		colorPaletteGrapeBackground2: "var(--colorPaletteGrapeBackground2)",
		colorPaletteGrapeBorderActive: "var(--colorPaletteGrapeBorderActive)",
		colorPaletteGrapeForeground2: "var(--colorPaletteGrapeForeground2)",
		colorPaletteLavenderBackground2: "var(--colorPaletteLavenderBackground2)",
		colorPaletteLavenderBorderActive: "var(--colorPaletteLavenderBorderActive)",
		colorPaletteLavenderForeground2: "var(--colorPaletteLavenderForeground2)",
		colorPaletteLightTealBackground2: "var(--colorPaletteLightTealBackground2)",
		colorPaletteLightTealBorderActive: "var(--colorPaletteLightTealBorderActive)",
		colorPaletteLightTealForeground2: "var(--colorPaletteLightTealForeground2)",
		colorPaletteLilacBackground2: "var(--colorPaletteLilacBackground2)",
		colorPaletteLilacBorderActive: "var(--colorPaletteLilacBorderActive)",
		colorPaletteLilacForeground2: "var(--colorPaletteLilacForeground2)",
		colorPaletteMagentaBackground2: "var(--colorPaletteMagentaBackground2)",
		colorPaletteMagentaBorderActive: "var(--colorPaletteMagentaBorderActive)",
		colorPaletteMagentaForeground2: "var(--colorPaletteMagentaForeground2)",
		colorPaletteMinkBackground2: "var(--colorPaletteMinkBackground2)",
		colorPaletteMinkBorderActive: "var(--colorPaletteMinkBorderActive)",
		colorPaletteMinkForeground2: "var(--colorPaletteMinkForeground2)",
		colorPaletteNavyBackground2: "var(--colorPaletteNavyBackground2)",
		colorPaletteNavyBorderActive: "var(--colorPaletteNavyBorderActive)",
		colorPaletteNavyForeground2: "var(--colorPaletteNavyForeground2)",
		colorPalettePeachBackground2: "var(--colorPalettePeachBackground2)",
		colorPalettePeachBorderActive: "var(--colorPalettePeachBorderActive)",
		colorPalettePeachForeground2: "var(--colorPalettePeachForeground2)",
		colorPalettePinkBackground2: "var(--colorPalettePinkBackground2)",
		colorPalettePinkBorderActive: "var(--colorPalettePinkBorderActive)",
		colorPalettePinkForeground2: "var(--colorPalettePinkForeground2)",
		colorPalettePlatinumBackground2: "var(--colorPalettePlatinumBackground2)",
		colorPalettePlatinumBorderActive: "var(--colorPalettePlatinumBorderActive)",
		colorPalettePlatinumForeground2: "var(--colorPalettePlatinumForeground2)",
		colorPalettePlumBackground2: "var(--colorPalettePlumBackground2)",
		colorPalettePlumBorderActive: "var(--colorPalettePlumBorderActive)",
		colorPalettePlumForeground2: "var(--colorPalettePlumForeground2)",
		colorPalettePumpkinBackground2: "var(--colorPalettePumpkinBackground2)",
		colorPalettePumpkinBorderActive: "var(--colorPalettePumpkinBorderActive)",
		colorPalettePumpkinForeground2: "var(--colorPalettePumpkinForeground2)",
		colorPalettePurpleBackground2: "var(--colorPalettePurpleBackground2)",
		colorPalettePurpleBorderActive: "var(--colorPalettePurpleBorderActive)",
		colorPalettePurpleForeground2: "var(--colorPalettePurpleForeground2)",
		colorPaletteRoyalBlueBackground2: "var(--colorPaletteRoyalBlueBackground2)",
		colorPaletteRoyalBlueBorderActive: "var(--colorPaletteRoyalBlueBorderActive)",
		colorPaletteRoyalBlueForeground2: "var(--colorPaletteRoyalBlueForeground2)",
		colorPaletteSeafoamBackground2: "var(--colorPaletteSeafoamBackground2)",
		colorPaletteSeafoamBorderActive: "var(--colorPaletteSeafoamBorderActive)",
		colorPaletteSeafoamForeground2: "var(--colorPaletteSeafoamForeground2)",
		colorPaletteSteelBackground2: "var(--colorPaletteSteelBackground2)",
		colorPaletteSteelBorderActive: "var(--colorPaletteSteelBorderActive)",
		colorPaletteSteelForeground2: "var(--colorPaletteSteelForeground2)",
		colorPaletteTealBackground2: "var(--colorPaletteTealBackground2)",
		colorPaletteTealBorderActive: "var(--colorPaletteTealBorderActive)",
		colorPaletteTealForeground2: "var(--colorPaletteTealForeground2)",
		colorStatusSuccessBackground1: "var(--colorStatusSuccessBackground1)",
		colorStatusSuccessBackground2: "var(--colorStatusSuccessBackground2)",
		colorStatusSuccessBackground3: "var(--colorStatusSuccessBackground3)",
		colorStatusSuccessForeground1: "var(--colorStatusSuccessForeground1)",
		colorStatusSuccessForeground2: "var(--colorStatusSuccessForeground2)",
		colorStatusSuccessForeground3: "var(--colorStatusSuccessForeground3)",
		colorStatusSuccessForegroundInverted: "var(--colorStatusSuccessForegroundInverted)",
		colorStatusSuccessBorderActive: "var(--colorStatusSuccessBorderActive)",
		colorStatusSuccessBorder1: "var(--colorStatusSuccessBorder1)",
		colorStatusSuccessBorder2: "var(--colorStatusSuccessBorder2)",
		colorStatusWarningBackground1: "var(--colorStatusWarningBackground1)",
		colorStatusWarningBackground2: "var(--colorStatusWarningBackground2)",
		colorStatusWarningBackground3: "var(--colorStatusWarningBackground3)",
		colorStatusWarningForeground1: "var(--colorStatusWarningForeground1)",
		colorStatusWarningForeground2: "var(--colorStatusWarningForeground2)",
		colorStatusWarningForeground3: "var(--colorStatusWarningForeground3)",
		colorStatusWarningForegroundInverted: "var(--colorStatusWarningForegroundInverted)",
		colorStatusWarningBorderActive: "var(--colorStatusWarningBorderActive)",
		colorStatusWarningBorder1: "var(--colorStatusWarningBorder1)",
		colorStatusWarningBorder2: "var(--colorStatusWarningBorder2)",
		colorStatusDangerBackground1: "var(--colorStatusDangerBackground1)",
		colorStatusDangerBackground2: "var(--colorStatusDangerBackground2)",
		colorStatusDangerBackground3: "var(--colorStatusDangerBackground3)",
		colorStatusDangerBackground3Hover: "var(--colorStatusDangerBackground3Hover)",
		colorStatusDangerBackground3Pressed: "var(--colorStatusDangerBackground3Pressed)",
		colorStatusDangerForeground1: "var(--colorStatusDangerForeground1)",
		colorStatusDangerForeground2: "var(--colorStatusDangerForeground2)",
		colorStatusDangerForeground3: "var(--colorStatusDangerForeground3)",
		colorStatusDangerForegroundInverted: "var(--colorStatusDangerForegroundInverted)",
		colorStatusDangerBorderActive: "var(--colorStatusDangerBorderActive)",
		colorStatusDangerBorder1: "var(--colorStatusDangerBorder1)",
		colorStatusDangerBorder2: "var(--colorStatusDangerBorder2)",
		borderRadiusNone: "var(--borderRadiusNone)",
		borderRadiusSmall: "var(--borderRadiusSmall)",
		borderRadiusMedium: "var(--borderRadiusMedium)",
		borderRadiusLarge: "var(--borderRadiusLarge)",
		borderRadiusXLarge: "var(--borderRadiusXLarge)",
		borderRadiusCircular: "var(--borderRadiusCircular)",
		fontFamilyBase: "var(--fontFamilyBase)",
		fontFamilyMonospace: "var(--fontFamilyMonospace)",
		fontFamilyNumeric: "var(--fontFamilyNumeric)",
		fontSizeBase100: "var(--fontSizeBase100)",
		fontSizeBase200: "var(--fontSizeBase200)",
		fontSizeBase300: "var(--fontSizeBase300)",
		fontSizeBase400: "var(--fontSizeBase400)",
		fontSizeBase500: "var(--fontSizeBase500)",
		fontSizeBase600: "var(--fontSizeBase600)",
		fontSizeHero700: "var(--fontSizeHero700)",
		fontSizeHero800: "var(--fontSizeHero800)",
		fontSizeHero900: "var(--fontSizeHero900)",
		fontSizeHero1000: "var(--fontSizeHero1000)",
		fontWeightRegular: "var(--fontWeightRegular)",
		fontWeightMedium: "var(--fontWeightMedium)",
		fontWeightSemibold: "var(--fontWeightSemibold)",
		fontWeightBold: "var(--fontWeightBold)",
		lineHeightBase100: "var(--lineHeightBase100)",
		lineHeightBase200: "var(--lineHeightBase200)",
		lineHeightBase300: "var(--lineHeightBase300)",
		lineHeightBase400: "var(--lineHeightBase400)",
		lineHeightBase500: "var(--lineHeightBase500)",
		lineHeightBase600: "var(--lineHeightBase600)",
		lineHeightHero700: "var(--lineHeightHero700)",
		lineHeightHero800: "var(--lineHeightHero800)",
		lineHeightHero900: "var(--lineHeightHero900)",
		lineHeightHero1000: "var(--lineHeightHero1000)",
		shadow2: "var(--shadow2)",
		shadow4: "var(--shadow4)",
		shadow8: "var(--shadow8)",
		shadow16: "var(--shadow16)",
		shadow28: "var(--shadow28)",
		shadow64: "var(--shadow64)",
		shadow2Brand: "var(--shadow2Brand)",
		shadow4Brand: "var(--shadow4Brand)",
		shadow8Brand: "var(--shadow8Brand)",
		shadow16Brand: "var(--shadow16Brand)",
		shadow28Brand: "var(--shadow28Brand)",
		shadow64Brand: "var(--shadow64Brand)",
		strokeWidthThin: "var(--strokeWidthThin)",
		strokeWidthThick: "var(--strokeWidthThick)",
		strokeWidthThicker: "var(--strokeWidthThicker)",
		strokeWidthThickest: "var(--strokeWidthThickest)",
		spacingHorizontalNone: "var(--spacingHorizontalNone)",
		spacingHorizontalXXS: "var(--spacingHorizontalXXS)",
		spacingHorizontalXS: "var(--spacingHorizontalXS)",
		spacingHorizontalSNudge: "var(--spacingHorizontalSNudge)",
		spacingHorizontalS: "var(--spacingHorizontalS)",
		spacingHorizontalMNudge: "var(--spacingHorizontalMNudge)",
		spacingHorizontalM: "var(--spacingHorizontalM)",
		spacingHorizontalL: "var(--spacingHorizontalL)",
		spacingHorizontalXL: "var(--spacingHorizontalXL)",
		spacingHorizontalXXL: "var(--spacingHorizontalXXL)",
		spacingHorizontalXXXL: "var(--spacingHorizontalXXXL)",
		spacingVerticalNone: "var(--spacingVerticalNone)",
		spacingVerticalXXS: "var(--spacingVerticalXXS)",
		spacingVerticalXS: "var(--spacingVerticalXS)",
		spacingVerticalSNudge: "var(--spacingVerticalSNudge)",
		spacingVerticalS: "var(--spacingVerticalS)",
		spacingVerticalMNudge: "var(--spacingVerticalMNudge)",
		spacingVerticalM: "var(--spacingVerticalM)",
		spacingVerticalL: "var(--spacingVerticalL)",
		spacingVerticalXL: "var(--spacingVerticalXL)",
		spacingVerticalXXL: "var(--spacingVerticalXXL)",
		spacingVerticalXXXL: "var(--spacingVerticalXXXL)",
		durationUltraFast: "var(--durationUltraFast)",
		durationFaster: "var(--durationFaster)",
		durationFast: "var(--durationFast)",
		durationNormal: "var(--durationNormal)",
		durationGentle: "var(--durationGentle)",
		durationSlow: "var(--durationSlow)",
		durationSlower: "var(--durationSlower)",
		durationUltraSlow: "var(--durationUltraSlow)",
		curveAccelerateMax: "var(--curveAccelerateMax)",
		curveAccelerateMid: "var(--curveAccelerateMid)",
		curveAccelerateMin: "var(--curveAccelerateMin)",
		curveDecelerateMax: "var(--curveDecelerateMax)",
		curveDecelerateMid: "var(--curveDecelerateMid)",
		curveDecelerateMin: "var(--curveDecelerateMin)",
		curveEasyEaseMax: "var(--curveEasyEaseMax)",
		curveEasyEase: "var(--curveEasyEase)",
		curveLinear: "var(--curveLinear)",
		zIndexBackground: "var(--zIndexBackground, 0)",
		zIndexContent: "var(--zIndexContent, 1)",
		zIndexOverlay: "var(--zIndexOverlay, 1000)",
		zIndexPopup: "var(--zIndexPopup, 2000)",
		zIndexMessages: "var(--zIndexMessages, 3000)",
		zIndexFloating: "var(--zIndexFloating, 4000)",
		zIndexPriority: "var(--zIndexPriority, 5000)",
		zIndexDebug: "var(--zIndexDebug, 6000)"
	};

//#endregion
//#region node_modules/@fluentui/tokens/lib/global/typographyStyles.js
/**
	* Global typography styles (fontSize, fontWeight, and lineHeight)
	*/ const typographyStyles = {
		body1: {
			fontFamily: tokens.fontFamilyBase,
			fontSize: tokens.fontSizeBase300,
			fontWeight: tokens.fontWeightRegular,
			lineHeight: tokens.lineHeightBase300
		},
		body1Strong: {
			fontFamily: tokens.fontFamilyBase,
			fontSize: tokens.fontSizeBase300,
			fontWeight: tokens.fontWeightSemibold,
			lineHeight: tokens.lineHeightBase300
		},
		body1Stronger: {
			fontFamily: tokens.fontFamilyBase,
			fontSize: tokens.fontSizeBase300,
			fontWeight: tokens.fontWeightBold,
			lineHeight: tokens.lineHeightBase300
		},
		body2: {
			fontFamily: tokens.fontFamilyBase,
			fontSize: tokens.fontSizeBase400,
			fontWeight: tokens.fontWeightRegular,
			lineHeight: tokens.lineHeightBase400
		},
		caption1: {
			fontFamily: tokens.fontFamilyBase,
			fontSize: tokens.fontSizeBase200,
			fontWeight: tokens.fontWeightRegular,
			lineHeight: tokens.lineHeightBase200
		},
		caption1Strong: {
			fontFamily: tokens.fontFamilyBase,
			fontSize: tokens.fontSizeBase200,
			fontWeight: tokens.fontWeightSemibold,
			lineHeight: tokens.lineHeightBase200
		},
		caption1Stronger: {
			fontFamily: tokens.fontFamilyBase,
			fontSize: tokens.fontSizeBase200,
			fontWeight: tokens.fontWeightBold,
			lineHeight: tokens.lineHeightBase200
		},
		caption2: {
			fontFamily: tokens.fontFamilyBase,
			fontSize: tokens.fontSizeBase100,
			fontWeight: tokens.fontWeightRegular,
			lineHeight: tokens.lineHeightBase100
		},
		caption2Strong: {
			fontFamily: tokens.fontFamilyBase,
			fontSize: tokens.fontSizeBase100,
			fontWeight: tokens.fontWeightSemibold,
			lineHeight: tokens.lineHeightBase100
		},
		subtitle1: {
			fontFamily: tokens.fontFamilyBase,
			fontSize: tokens.fontSizeBase500,
			fontWeight: tokens.fontWeightSemibold,
			lineHeight: tokens.lineHeightBase500
		},
		subtitle2: {
			fontFamily: tokens.fontFamilyBase,
			fontSize: tokens.fontSizeBase400,
			fontWeight: tokens.fontWeightSemibold,
			lineHeight: tokens.lineHeightBase400
		},
		subtitle2Stronger: {
			fontFamily: tokens.fontFamilyBase,
			fontSize: tokens.fontSizeBase400,
			fontWeight: tokens.fontWeightBold,
			lineHeight: tokens.lineHeightBase400
		},
		title1: {
			fontFamily: tokens.fontFamilyBase,
			fontSize: tokens.fontSizeHero800,
			fontWeight: tokens.fontWeightSemibold,
			lineHeight: tokens.lineHeightHero800
		},
		title2: {
			fontFamily: tokens.fontFamilyBase,
			fontSize: tokens.fontSizeHero700,
			fontWeight: tokens.fontWeightSemibold,
			lineHeight: tokens.lineHeightHero700
		},
		title3: {
			fontFamily: tokens.fontFamilyBase,
			fontSize: tokens.fontSizeBase600,
			fontWeight: tokens.fontWeightSemibold,
			lineHeight: tokens.lineHeightBase600
		},
		largeTitle: {
			fontFamily: tokens.fontFamilyBase,
			fontSize: tokens.fontSizeHero900,
			fontWeight: tokens.fontWeightSemibold,
			lineHeight: tokens.lineHeightHero900
		},
		display: {
			fontFamily: tokens.fontFamilyBase,
			fontSize: tokens.fontSizeHero1000,
			fontWeight: tokens.fontWeightSemibold,
			lineHeight: tokens.lineHeightHero1000
		}
	};

//#endregion
//#region node_modules/@fluentui/tokens/lib/utils/shadows.js
	function createShadowTokens(ambientColor, keyColor, tokenSuffix = "") {
		return {
			[`shadow2${tokenSuffix}`]: `0 0 2px ${ambientColor}, 0 1px 2px ${keyColor}`,
			[`shadow4${tokenSuffix}`]: `0 0 2px ${ambientColor}, 0 2px 4px ${keyColor}`,
			[`shadow8${tokenSuffix}`]: `0 0 2px ${ambientColor}, 0 4px 8px ${keyColor}`,
			[`shadow16${tokenSuffix}`]: `0 0 2px ${ambientColor}, 0 8px 16px ${keyColor}`,
			[`shadow28${tokenSuffix}`]: `0 0 8px ${ambientColor}, 0 14px 28px ${keyColor}`,
			[`shadow64${tokenSuffix}`]: `0 0 8px ${ambientColor}, 0 32px 64px ${keyColor}`
		};
	}

//#endregion
//#region node_modules/@fluentui/tokens/lib/utils/createLightTheme.js
	const createLightTheme = (brand) => {
		const colorTokens = generateColorTokens$3(brand);
		return {
			...borderRadius,
			...fontSizes,
			...lineHeights,
			...fontFamilies$1,
			...fontWeights,
			...strokeWidths,
			...horizontalSpacings,
			...verticalSpacings,
			...durations$2,
			...curves$1,
			...colorTokens,
			...colorPaletteTokens$2,
			...colorStatusTokens$2,
			...createShadowTokens(colorTokens.colorNeutralShadowAmbient, colorTokens.colorNeutralShadowKey),
			...createShadowTokens(colorTokens.colorBrandShadowAmbient, colorTokens.colorBrandShadowKey, "Brand")
		};
	};

//#endregion
//#region node_modules/@fluentui/tokens/lib/global/brandColors.js
	const brandWeb = {
		10: `#061724`,
		20: `#082338`,
		30: `#0a2e4a`,
		40: `#0c3b5e`,
		50: `#0e4775`,
		60: `#0f548c`,
		70: `#115ea3`,
		80: `#0f6cbd`,
		90: `#2886de`,
		100: `#479ef5`,
		110: `#62abf5`,
		120: `#77b7f7`,
		130: `#96c6fa`,
		140: `#b4d6fa`,
		150: `#cfe4fa`,
		160: `#ebf3fc`
	};
	const brandTeams = {
		10: `#2b2b40`,
		20: `#2f2f4a`,
		30: `#333357`,
		40: `#383966`,
		50: `#3d3e78`,
		60: `#444791`,
		70: `#4f52b2`,
		80: `#5b5fc7`,
		90: `#7579eb`,
		100: `#7f85f5`,
		110: `#9299f7`,
		120: `#aab1fa`,
		130: `#b6bcfa`,
		140: `#c5cbfa`,
		150: `#dce0fa`,
		160: `#e8ebfa`
	};
	const brandTeamsV21 = {
		10: `#29274f`,
		20: `#2f2a5e`,
		30: `#352e70`,
		40: `#3b3185`,
		50: `#44359e`,
		60: `#4d3aba`,
		70: `#5a40db`,
		80: `#654cf5`,
		90: `#7769fa`,
		100: `#887dff`,
		110: `#9791ff`,
		120: `#aba8ff`,
		130: `#bab8ff`,
		140: `#c8c7ff`,
		150: `#dcdbff`,
		160: `#e8e8ff`
	};

//#endregion
//#region node_modules/@fluentui/tokens/lib/alias/teamsFontFamilies.js
	const fontFamilies = {
		...fontFamilies$1,
		fontFamilyBase: "-apple-system, BlinkMacSystemFont, \"Segoe UI\", system-ui, \"Apple Color Emoji\", \"Segoe UI Emoji\", sans-serif"
	};

//#endregion
//#region node_modules/@fluentui/tokens/lib/themes/teams/lightTheme.js
	const teamsLightTheme = {
		...createLightTheme(brandTeams),
		...fontFamilies
	};
	const teamsLightV21Theme = {
		...createLightTheme(brandTeamsV21),
		...fontFamilies
	};

//#endregion
//#region node_modules/@fluentui/tokens/lib/alias/darkColorPalette.js
	const statusColorPaletteTokens$1 = statusSharedColorNames.reduce((acc, sharedColor) => {
		const color$1 = sharedColor.slice(0, 1).toUpperCase() + sharedColor.slice(1);
		const sharedColorTokens = {
			[`colorPalette${color$1}Background1`]: statusSharedColors[sharedColor].shade40,
			[`colorPalette${color$1}Background2`]: statusSharedColors[sharedColor].shade30,
			[`colorPalette${color$1}Background3`]: statusSharedColors[sharedColor].primary,
			[`colorPalette${color$1}Foreground1`]: statusSharedColors[sharedColor].tint30,
			[`colorPalette${color$1}Foreground2`]: statusSharedColors[sharedColor].tint40,
			[`colorPalette${color$1}Foreground3`]: statusSharedColors[sharedColor].tint20,
			[`colorPalette${color$1}BorderActive`]: statusSharedColors[sharedColor].tint30,
			[`colorPalette${color$1}Border1`]: statusSharedColors[sharedColor].primary,
			[`colorPalette${color$1}Border2`]: statusSharedColors[sharedColor].tint20
		};
		return Object.assign(acc, sharedColorTokens);
	}, {});
	statusColorPaletteTokens$1.colorPaletteRedForeground3 = statusSharedColors.red.tint30;
	statusColorPaletteTokens$1.colorPaletteRedBorder2 = statusSharedColors.red.tint30;
	statusColorPaletteTokens$1.colorPaletteGreenForeground3 = statusSharedColors.green.tint40;
	statusColorPaletteTokens$1.colorPaletteGreenBorder2 = statusSharedColors.green.tint40;
	statusColorPaletteTokens$1.colorPaletteDarkOrangeForeground3 = statusSharedColors.darkOrange.tint30;
	statusColorPaletteTokens$1.colorPaletteDarkOrangeBorder2 = statusSharedColors.darkOrange.tint30;
	statusColorPaletteTokens$1.colorPaletteRedForegroundInverted = statusSharedColors.red.primary;
	statusColorPaletteTokens$1.colorPaletteGreenForegroundInverted = statusSharedColors.green.primary;
	statusColorPaletteTokens$1.colorPaletteYellowForegroundInverted = statusSharedColors.yellow.shade30;
	const personaColorPaletteTokens$1 = personaSharedColorNames.reduce((acc, sharedColor) => {
		const color$1 = sharedColor.slice(0, 1).toUpperCase() + sharedColor.slice(1);
		const sharedColorTokens = {
			[`colorPalette${color$1}Background2`]: personaSharedColors[sharedColor].shade30,
			[`colorPalette${color$1}Foreground2`]: personaSharedColors[sharedColor].tint40,
			[`colorPalette${color$1}BorderActive`]: personaSharedColors[sharedColor].tint30
		};
		return Object.assign(acc, sharedColorTokens);
	}, {});
	personaColorPaletteTokens$1.colorPaletteDarkRedBackground2 = personaSharedColors.darkRed.shade20;
	personaColorPaletteTokens$1.colorPalettePlumBackground2 = personaSharedColors.plum.shade20;
	const colorPaletteTokens$1 = {
		...statusColorPaletteTokens$1,
		...personaColorPaletteTokens$1
	};
	const colorStatusTokens$1 = Object.entries(statusColorMapping).reduce((acc, [statusColor, sharedColor]) => {
		const color$1 = statusColor.slice(0, 1).toUpperCase() + statusColor.slice(1);
		const statusColorTokens = {
			[`colorStatus${color$1}Background1`]: mappedStatusColors[sharedColor].shade40,
			[`colorStatus${color$1}Background2`]: mappedStatusColors[sharedColor].shade30,
			[`colorStatus${color$1}Background3`]: mappedStatusColors[sharedColor].primary,
			[`colorStatus${color$1}Foreground1`]: mappedStatusColors[sharedColor].tint30,
			[`colorStatus${color$1}Foreground2`]: mappedStatusColors[sharedColor].tint40,
			[`colorStatus${color$1}Foreground3`]: mappedStatusColors[sharedColor].tint20,
			[`colorStatus${color$1}BorderActive`]: mappedStatusColors[sharedColor].tint30,
			[`colorStatus${color$1}ForegroundInverted`]: mappedStatusColors[sharedColor].shade10,
			[`colorStatus${color$1}Border1`]: mappedStatusColors[sharedColor].primary,
			[`colorStatus${color$1}Border2`]: mappedStatusColors[sharedColor].tint20
		};
		return Object.assign(acc, statusColorTokens);
	}, {});
	colorStatusTokens$1.colorStatusDangerBackground3Hover = mappedStatusColors[statusColorMapping.danger].shade10;
	colorStatusTokens$1.colorStatusDangerBackground3Pressed = mappedStatusColors[statusColorMapping.danger].shade20;
	colorStatusTokens$1.colorStatusDangerForeground3 = mappedStatusColors[statusColorMapping.danger].tint40;
	colorStatusTokens$1.colorStatusDangerBorder2 = mappedStatusColors[statusColorMapping.danger].tint30;
	colorStatusTokens$1.colorStatusSuccessForeground3 = mappedStatusColors[statusColorMapping.success].tint40;
	colorStatusTokens$1.colorStatusSuccessBorder2 = mappedStatusColors[statusColorMapping.success].tint40;
	colorStatusTokens$1.colorStatusWarningForegroundInverted = mappedStatusColors[statusColorMapping.warning].shade20;

//#endregion
//#region node_modules/@fluentui/tokens/lib/alias/teamsDarkColor.js
	const generateColorTokens$2 = (brand) => ({
		colorNeutralForeground1: white,
		colorNeutralForeground1Hover: white,
		colorNeutralForeground1Pressed: white,
		colorNeutralForeground1Selected: white,
		colorNeutralForeground2: grey[84],
		colorNeutralForeground2Hover: white,
		colorNeutralForeground2Pressed: white,
		colorNeutralForeground2Selected: white,
		colorNeutralForeground2BrandHover: brand[100],
		colorNeutralForeground2BrandPressed: brand[90],
		colorNeutralForeground2BrandSelected: brand[100],
		colorNeutralForeground3: grey[68],
		colorNeutralForeground3Hover: grey[84],
		colorNeutralForeground3Pressed: grey[84],
		colorNeutralForeground3Selected: grey[84],
		colorNeutralForeground3BrandHover: brand[100],
		colorNeutralForeground3BrandPressed: brand[90],
		colorNeutralForeground3BrandSelected: brand[100],
		colorNeutralForeground4: grey[60],
		colorNeutralForegroundDisabled: grey[36],
		colorNeutralForegroundInvertedDisabled: whiteAlpha[40],
		colorBrandForegroundLink: brand[100],
		colorBrandForegroundLinkHover: brand[110],
		colorBrandForegroundLinkPressed: brand[90],
		colorBrandForegroundLinkSelected: brand[100],
		colorNeutralForeground2Link: grey[84],
		colorNeutralForeground2LinkHover: white,
		colorNeutralForeground2LinkPressed: white,
		colorNeutralForeground2LinkSelected: white,
		colorCompoundBrandForeground1: brand[100],
		colorCompoundBrandForeground1Hover: brand[110],
		colorCompoundBrandForeground1Pressed: brand[90],
		colorBrandForeground1: brand[100],
		colorBrandForeground2: brand[120],
		colorBrandForeground2Hover: brand[130],
		colorBrandForeground2Pressed: brand[160],
		colorNeutralForeground1Static: grey[14],
		colorNeutralForegroundStaticInverted: white,
		colorNeutralForegroundInverted: grey[14],
		colorNeutralForegroundInvertedHover: grey[14],
		colorNeutralForegroundInvertedPressed: grey[14],
		colorNeutralForegroundInvertedSelected: grey[14],
		colorNeutralForegroundInverted2: grey[14],
		colorNeutralForegroundOnBrand: white,
		colorNeutralForegroundInvertedLink: white,
		colorNeutralForegroundInvertedLinkHover: white,
		colorNeutralForegroundInvertedLinkPressed: white,
		colorNeutralForegroundInvertedLinkSelected: white,
		colorBrandForegroundInverted: brand[80],
		colorBrandForegroundInvertedHover: brand[70],
		colorBrandForegroundInvertedPressed: brand[60],
		colorBrandForegroundOnLight: brand[80],
		colorBrandForegroundOnLightHover: brand[70],
		colorBrandForegroundOnLightPressed: brand[50],
		colorBrandForegroundOnLightSelected: brand[60],
		colorNeutralBackground1: grey[16],
		colorNeutralBackground1Hover: grey[24],
		colorNeutralBackground1Pressed: grey[12],
		colorNeutralBackground1Selected: grey[22],
		colorNeutralBackground2: grey[14],
		colorNeutralBackground2Hover: grey[22],
		colorNeutralBackground2Pressed: grey[10],
		colorNeutralBackground2Selected: grey[20],
		colorNeutralBackground3: grey[12],
		colorNeutralBackground3Hover: grey[20],
		colorNeutralBackground3Pressed: grey[8],
		colorNeutralBackground3Selected: grey[18],
		colorNeutralBackground4: grey[8],
		colorNeutralBackground4Hover: grey[16],
		colorNeutralBackground4Pressed: grey[4],
		colorNeutralBackground4Selected: grey[14],
		colorNeutralBackground5: grey[4],
		colorNeutralBackground5Hover: grey[12],
		colorNeutralBackground5Pressed: black,
		colorNeutralBackground5Selected: grey[10],
		colorNeutralBackground6: grey[20],
		colorNeutralBackgroundInverted: white,
		colorNeutralBackgroundStatic: grey[24],
		colorNeutralBackgroundAlpha: grey10Alpha[50],
		colorNeutralBackgroundAlpha2: grey12Alpha[70],
		colorSubtleBackground: "transparent",
		colorSubtleBackgroundHover: grey[22],
		colorSubtleBackgroundPressed: grey[18],
		colorSubtleBackgroundSelected: grey[20],
		colorSubtleBackgroundLightAlphaHover: grey14Alpha[80],
		colorSubtleBackgroundLightAlphaPressed: grey14Alpha[50],
		colorSubtleBackgroundLightAlphaSelected: "transparent",
		colorSubtleBackgroundInverted: "transparent",
		colorSubtleBackgroundInvertedHover: blackAlpha[10],
		colorSubtleBackgroundInvertedPressed: blackAlpha[30],
		colorSubtleBackgroundInvertedSelected: blackAlpha[20],
		colorTransparentBackground: "transparent",
		colorTransparentBackgroundHover: "transparent",
		colorTransparentBackgroundPressed: "transparent",
		colorTransparentBackgroundSelected: "transparent",
		colorNeutralBackgroundDisabled: grey[8],
		colorNeutralBackgroundInvertedDisabled: whiteAlpha[10],
		colorNeutralStencil1: grey[34],
		colorNeutralStencil2: grey[20],
		colorNeutralStencil1Alpha: whiteAlpha[10],
		colorNeutralStencil2Alpha: whiteAlpha[5],
		colorBackgroundOverlay: blackAlpha[50],
		colorScrollbarOverlay: whiteAlpha[60],
		colorBrandBackground: brand[70],
		colorBrandBackgroundHover: brand[80],
		colorBrandBackgroundPressed: brand[40],
		colorBrandBackgroundSelected: brand[60],
		colorCompoundBrandBackground: brand[100],
		colorCompoundBrandBackgroundHover: brand[110],
		colorCompoundBrandBackgroundPressed: brand[90],
		colorBrandBackgroundStatic: brand[80],
		colorBrandBackground2: brand[20],
		colorBrandBackground2Hover: brand[40],
		colorBrandBackground2Pressed: brand[10],
		colorBrandBackground3Static: brand[60],
		colorBrandBackground4Static: brand[40],
		colorBrandBackgroundInverted: white,
		colorBrandBackgroundInvertedHover: brand[160],
		colorBrandBackgroundInvertedPressed: brand[140],
		colorBrandBackgroundInvertedSelected: brand[150],
		colorNeutralCardBackground: grey[20],
		colorNeutralCardBackgroundHover: grey[24],
		colorNeutralCardBackgroundPressed: grey[18],
		colorNeutralCardBackgroundSelected: grey[22],
		colorNeutralCardBackgroundDisabled: grey[8],
		colorNeutralStrokeAccessible: grey[68],
		colorNeutralStrokeAccessibleHover: grey[74],
		colorNeutralStrokeAccessiblePressed: grey[70],
		colorNeutralStrokeAccessibleSelected: brand[100],
		colorNeutralStroke1: grey[40],
		colorNeutralStroke1Hover: grey[46],
		colorNeutralStroke1Pressed: grey[42],
		colorNeutralStroke1Selected: grey[44],
		colorNeutralStroke2: grey[32],
		colorNeutralStroke3: grey[24],
		colorNeutralStrokeSubtle: grey[4],
		colorNeutralStrokeOnBrand: grey[16],
		colorNeutralStrokeOnBrand2: white,
		colorNeutralStrokeOnBrand2Hover: white,
		colorNeutralStrokeOnBrand2Pressed: white,
		colorNeutralStrokeOnBrand2Selected: white,
		colorBrandStroke1: brand[100],
		colorBrandStroke2: brand[50],
		colorBrandStroke2Hover: brand[50],
		colorBrandStroke2Pressed: brand[30],
		colorBrandStroke2Contrast: brand[50],
		colorCompoundBrandStroke: brand[90],
		colorCompoundBrandStrokeHover: brand[100],
		colorCompoundBrandStrokePressed: brand[80],
		colorNeutralStrokeDisabled: grey[26],
		colorNeutralStrokeInvertedDisabled: whiteAlpha[40],
		colorTransparentStroke: "transparent",
		colorTransparentStrokeInteractive: "transparent",
		colorTransparentStrokeDisabled: "transparent",
		colorNeutralStrokeAlpha: whiteAlpha[10],
		colorNeutralStrokeAlpha2: whiteAlpha[20],
		colorStrokeFocus1: black,
		colorStrokeFocus2: white,
		colorNeutralShadowAmbient: "rgba(0,0,0,0.24)",
		colorNeutralShadowKey: "rgba(0,0,0,0.28)",
		colorNeutralShadowAmbientLighter: "rgba(0,0,0,0.12)",
		colorNeutralShadowKeyLighter: "rgba(0,0,0,0.14)",
		colorNeutralShadowAmbientDarker: "rgba(0,0,0,0.40)",
		colorNeutralShadowKeyDarker: "rgba(0,0,0,0.48)",
		colorBrandShadowAmbient: "rgba(0,0,0,0.30)",
		colorBrandShadowKey: "rgba(0,0,0,0.25)"
	});

//#endregion
//#region node_modules/@fluentui/tokens/lib/utils/createTeamsDarkTheme.js
	const createTeamsDarkTheme = (brand) => {
		const colorTokens = generateColorTokens$2(brand);
		return {
			...borderRadius,
			...fontSizes,
			...lineHeights,
			...fontFamilies$1,
			...fontWeights,
			...strokeWidths,
			...horizontalSpacings,
			...verticalSpacings,
			...durations$2,
			...curves$1,
			...colorTokens,
			...colorPaletteTokens$1,
			...colorStatusTokens$1,
			...createShadowTokens(colorTokens.colorNeutralShadowAmbient, colorTokens.colorNeutralShadowKey),
			...createShadowTokens(colorTokens.colorBrandShadowAmbient, colorTokens.colorBrandShadowKey, "Brand")
		};
	};

//#endregion
//#region node_modules/@fluentui/tokens/lib/themes/teams/darkTheme.js
	const teamsDarkTheme = {
		...createTeamsDarkTheme(brandTeams),
		...fontFamilies
	};
	const teamsDarkV21Theme = {
		...createTeamsDarkTheme(brandTeamsV21),
		...fontFamilies
	};

//#endregion
//#region node_modules/@fluentui/tokens/lib/alias/highContrastColorPalette.js
	const statusColorPaletteTokens = statusSharedColorNames.reduce((acc, sharedColor) => {
		const color$1 = sharedColor.slice(0, 1).toUpperCase() + sharedColor.slice(1);
		const sharedColorTokens = {
			[`colorPalette${color$1}Background1`]: hcCanvas,
			[`colorPalette${color$1}Background2`]: hcCanvas,
			[`colorPalette${color$1}Background3`]: hcCanvasText,
			[`colorPalette${color$1}Foreground1`]: hcCanvasText,
			[`colorPalette${color$1}Foreground2`]: hcCanvasText,
			[`colorPalette${color$1}Foreground3`]: hcCanvasText,
			[`colorPalette${color$1}BorderActive`]: hcHighlight,
			[`colorPalette${color$1}Border1`]: hcCanvasText,
			[`colorPalette${color$1}Border2`]: hcCanvasText
		};
		return Object.assign(acc, sharedColorTokens);
	}, {});
	statusColorPaletteTokens.colorPaletteRedForegroundInverted = hcCanvasText;
	statusColorPaletteTokens.colorPaletteGreenForegroundInverted = hcCanvasText;
	statusColorPaletteTokens.colorPaletteYellowForegroundInverted = hcCanvasText;
	const personaColorPaletteTokens = personaSharedColorNames.reduce((acc, sharedColor) => {
		const color$1 = sharedColor.slice(0, 1).toUpperCase() + sharedColor.slice(1);
		const sharedColorTokens = {
			[`colorPalette${color$1}Background2`]: hcCanvas,
			[`colorPalette${color$1}Foreground2`]: hcCanvasText,
			[`colorPalette${color$1}BorderActive`]: hcHighlight
		};
		return Object.assign(acc, sharedColorTokens);
	}, {});
	const colorPaletteTokens = {
		...statusColorPaletteTokens,
		...personaColorPaletteTokens
	};
	const colorStatusTokens = Object.entries(statusColorMapping).reduce((acc, [statusColor, sharedColor]) => {
		const color$1 = statusColor.slice(0, 1).toUpperCase() + statusColor.slice(1);
		const statusColorTokens = {
			[`colorStatus${color$1}Background1`]: hcCanvas,
			[`colorStatus${color$1}Background2`]: hcCanvas,
			[`colorStatus${color$1}Background3`]: hcCanvasText,
			[`colorStatus${color$1}Foreground1`]: hcCanvasText,
			[`colorStatus${color$1}Foreground2`]: hcCanvasText,
			[`colorStatus${color$1}Foreground3`]: hcCanvasText,
			[`colorStatus${color$1}BorderActive`]: hcHighlight,
			[`colorStatus${color$1}ForegroundInverted`]: hcCanvasText,
			[`colorStatus${color$1}Border1`]: hcCanvasText,
			[`colorStatus${color$1}Border2`]: hcCanvasText
		};
		return Object.assign(acc, statusColorTokens);
	}, {});
	colorStatusTokens.colorStatusDangerBackground3Hover = hcHighlight;
	colorStatusTokens.colorStatusDangerBackground3Pressed = hcHighlight;

//#endregion
//#region node_modules/@fluentui/tokens/lib/alias/highContrastColor.js
	const generateColorTokens$1 = () => ({
		colorNeutralForeground1: hcCanvasText,
		colorNeutralForeground1Hover: hcHighlightText,
		colorNeutralForeground1Pressed: hcHighlightText,
		colorNeutralForeground1Selected: hcHighlightText,
		colorNeutralForeground2: hcCanvasText,
		colorNeutralForeground2Hover: hcHighlightText,
		colorNeutralForeground2Pressed: hcHighlightText,
		colorNeutralForeground2Selected: hcHighlightText,
		colorNeutralForeground2BrandHover: hcHighlightText,
		colorNeutralForeground2BrandPressed: hcHighlightText,
		colorNeutralForeground2BrandSelected: hcHighlightText,
		colorNeutralForeground3: hcCanvasText,
		colorNeutralForeground3Hover: hcHighlightText,
		colorNeutralForeground3Pressed: hcHighlightText,
		colorNeutralForeground3Selected: hcHighlightText,
		colorNeutralForeground3BrandHover: hcHighlightText,
		colorNeutralForeground3BrandPressed: hcHighlightText,
		colorNeutralForeground3BrandSelected: hcHighlightText,
		colorNeutralForeground4: hcCanvasText,
		colorNeutralForegroundDisabled: hcDisabled,
		colorNeutralForegroundInvertedDisabled: hcDisabled,
		colorBrandForegroundLink: hcHyperlink,
		colorBrandForegroundLinkHover: hcHyperlink,
		colorBrandForegroundLinkPressed: hcHyperlink,
		colorBrandForegroundLinkSelected: hcHyperlink,
		colorNeutralForeground2Link: hcHyperlink,
		colorNeutralForeground2LinkHover: hcHyperlink,
		colorNeutralForeground2LinkPressed: hcHyperlink,
		colorNeutralForeground2LinkSelected: hcHyperlink,
		colorCompoundBrandForeground1: hcHighlight,
		colorCompoundBrandForeground1Hover: hcHighlight,
		colorCompoundBrandForeground1Pressed: hcHighlight,
		colorBrandForeground1: hcCanvasText,
		colorBrandForeground2: hcCanvasText,
		colorBrandForeground2Hover: hcCanvasText,
		colorBrandForeground2Pressed: hcCanvasText,
		colorNeutralForeground1Static: hcCanvas,
		colorNeutralForegroundStaticInverted: hcCanvasText,
		colorNeutralForegroundInverted: hcHighlightText,
		colorNeutralForegroundInvertedHover: hcHighlightText,
		colorNeutralForegroundInvertedPressed: hcHighlightText,
		colorNeutralForegroundInvertedSelected: hcHighlightText,
		colorNeutralForegroundInverted2: hcCanvasText,
		colorNeutralForegroundOnBrand: hcButtonText,
		colorNeutralForegroundInvertedLink: hcHyperlink,
		colorNeutralForegroundInvertedLinkHover: hcHyperlink,
		colorNeutralForegroundInvertedLinkPressed: hcHyperlink,
		colorNeutralForegroundInvertedLinkSelected: hcHyperlink,
		colorBrandForegroundInverted: hcCanvasText,
		colorBrandForegroundInvertedHover: hcHighlightText,
		colorBrandForegroundInvertedPressed: hcHighlightText,
		colorBrandForegroundOnLight: hcButtonText,
		colorBrandForegroundOnLightHover: hcHighlightText,
		colorBrandForegroundOnLightPressed: hcHighlightText,
		colorBrandForegroundOnLightSelected: hcHighlightText,
		colorNeutralBackground1: hcCanvas,
		colorNeutralBackground1Hover: hcHighlight,
		colorNeutralBackground1Pressed: hcHighlight,
		colorNeutralBackground1Selected: hcHighlight,
		colorNeutralBackground2: hcCanvas,
		colorNeutralBackground2Hover: hcHighlight,
		colorNeutralBackground2Pressed: hcHighlight,
		colorNeutralBackground2Selected: hcHighlight,
		colorNeutralBackground3: hcCanvas,
		colorNeutralBackground3Hover: hcHighlight,
		colorNeutralBackground3Pressed: hcHighlight,
		colorNeutralBackground3Selected: hcHighlight,
		colorNeutralBackground4: hcCanvas,
		colorNeutralBackground4Hover: hcHighlight,
		colorNeutralBackground4Pressed: hcHighlight,
		colorNeutralBackground4Selected: hcHighlight,
		colorNeutralBackground5: hcCanvas,
		colorNeutralBackground5Hover: hcHighlight,
		colorNeutralBackground5Pressed: hcHighlight,
		colorNeutralBackground5Selected: hcHighlight,
		colorNeutralBackground6: hcCanvas,
		colorNeutralBackgroundInverted: hcCanvas,
		colorNeutralBackgroundStatic: hcCanvas,
		colorNeutralBackgroundAlpha: hcCanvas,
		colorNeutralBackgroundAlpha2: hcCanvas,
		colorSubtleBackground: "transparent",
		colorSubtleBackgroundHover: hcHighlight,
		colorSubtleBackgroundPressed: hcHighlight,
		colorSubtleBackgroundSelected: hcHighlight,
		colorSubtleBackgroundLightAlphaHover: hcHighlight,
		colorSubtleBackgroundLightAlphaPressed: hcHighlight,
		colorSubtleBackgroundLightAlphaSelected: hcHighlight,
		colorSubtleBackgroundInverted: "transparent",
		colorSubtleBackgroundInvertedHover: hcHighlight,
		colorSubtleBackgroundInvertedPressed: hcHighlight,
		colorSubtleBackgroundInvertedSelected: hcHighlight,
		colorTransparentBackground: "transparent",
		colorTransparentBackgroundHover: hcHighlight,
		colorTransparentBackgroundPressed: hcHighlight,
		colorTransparentBackgroundSelected: hcHighlight,
		colorNeutralBackgroundDisabled: hcCanvas,
		colorNeutralBackgroundInvertedDisabled: hcCanvas,
		colorNeutralStencil1: hcCanvasText,
		colorNeutralStencil2: hcCanvasText,
		colorNeutralStencil1Alpha: hcCanvasText,
		colorNeutralStencil2Alpha: hcCanvasText,
		colorBackgroundOverlay: blackAlpha[50],
		colorScrollbarOverlay: hcButtonFace,
		colorBrandBackground: hcButtonFace,
		colorBrandBackgroundHover: hcHighlight,
		colorBrandBackgroundPressed: hcHighlight,
		colorBrandBackgroundSelected: hcHighlight,
		colorCompoundBrandBackground: hcHighlight,
		colorCompoundBrandBackgroundHover: hcHighlight,
		colorCompoundBrandBackgroundPressed: hcHighlight,
		colorBrandBackgroundStatic: hcCanvas,
		colorBrandBackground2: hcCanvas,
		colorBrandBackground2Hover: hcCanvas,
		colorBrandBackground2Pressed: hcCanvas,
		colorBrandBackground3Static: hcCanvas,
		colorBrandBackground4Static: hcCanvas,
		colorBrandBackgroundInverted: hcButtonFace,
		colorBrandBackgroundInvertedHover: hcHighlight,
		colorBrandBackgroundInvertedPressed: hcHighlight,
		colorBrandBackgroundInvertedSelected: hcHighlight,
		colorNeutralCardBackground: hcCanvas,
		colorNeutralCardBackgroundHover: hcHighlight,
		colorNeutralCardBackgroundPressed: hcHighlight,
		colorNeutralCardBackgroundSelected: hcHighlight,
		colorNeutralCardBackgroundDisabled: hcCanvas,
		colorNeutralStrokeAccessible: hcCanvasText,
		colorNeutralStrokeAccessibleHover: hcHighlight,
		colorNeutralStrokeAccessiblePressed: hcHighlight,
		colorNeutralStrokeAccessibleSelected: hcHighlight,
		colorNeutralStroke1: hcCanvasText,
		colorNeutralStroke1Hover: hcHighlight,
		colorNeutralStroke1Pressed: hcHighlight,
		colorNeutralStroke1Selected: hcHighlight,
		colorNeutralStroke2: hcCanvasText,
		colorNeutralStroke3: hcCanvasText,
		colorNeutralStrokeSubtle: hcCanvasText,
		colorNeutralStrokeOnBrand: hcCanvas,
		colorNeutralStrokeOnBrand2: hcCanvasText,
		colorNeutralStrokeOnBrand2Hover: hcCanvasText,
		colorNeutralStrokeOnBrand2Pressed: hcCanvasText,
		colorNeutralStrokeOnBrand2Selected: hcCanvasText,
		colorBrandStroke1: hcCanvasText,
		colorBrandStroke2: hcCanvasText,
		colorBrandStroke2Hover: hcHighlight,
		colorBrandStroke2Pressed: hcHighlight,
		colorBrandStroke2Contrast: hcCanvas,
		colorCompoundBrandStroke: hcHighlight,
		colorCompoundBrandStrokeHover: hcHighlight,
		colorCompoundBrandStrokePressed: hcHighlight,
		colorNeutralStrokeDisabled: hcDisabled,
		colorNeutralStrokeInvertedDisabled: hcDisabled,
		colorTransparentStroke: hcCanvasText,
		colorTransparentStrokeInteractive: hcHighlight,
		colorTransparentStrokeDisabled: hcDisabled,
		colorNeutralStrokeAlpha: hcCanvasText,
		colorNeutralStrokeAlpha2: hcCanvas,
		colorStrokeFocus1: hcCanvas,
		colorStrokeFocus2: hcHighlight,
		colorNeutralShadowAmbient: "rgba(0,0,0,0.24)",
		colorNeutralShadowKey: "rgba(0,0,0,0.28)",
		colorNeutralShadowAmbientLighter: "rgba(0,0,0,0.12)",
		colorNeutralShadowKeyLighter: "rgba(0,0,0,0.14)",
		colorNeutralShadowAmbientDarker: "rgba(0,0,0,0.40)",
		colorNeutralShadowKeyDarker: "rgba(0,0,0,0.48)",
		colorBrandShadowAmbient: "rgba(0,0,0,0.30)",
		colorBrandShadowKey: "rgba(0,0,0,0.25)"
	});

//#endregion
//#region node_modules/@fluentui/tokens/lib/utils/createHighContrastTheme.js
	const createHighContrastTheme = () => {
		const colorTokens = generateColorTokens$1();
		return {
			...borderRadius,
			...fontSizes,
			...lineHeights,
			...fontFamilies$1,
			...fontWeights,
			...strokeWidths,
			...horizontalSpacings,
			...verticalSpacings,
			...durations$2,
			...curves$1,
			...colorTokens,
			...colorPaletteTokens,
			...colorStatusTokens,
			...createShadowTokens(colorTokens.colorNeutralShadowAmbient, colorTokens.colorNeutralShadowKey),
			...createShadowTokens(colorTokens.colorBrandShadowAmbient, colorTokens.colorBrandShadowKey, "Brand")
		};
	};

//#endregion
//#region node_modules/@fluentui/tokens/lib/themes/teams/highContrastTheme.js
	const teamsHighContrastTheme = {
		...createHighContrastTheme(),
		...fontFamilies
	};

//#endregion
//#region node_modules/@fluentui/tokens/lib/themes/web/lightTheme.js
	const webLightTheme = createLightTheme(brandWeb);

//#endregion
//#region node_modules/@fluentui/tokens/lib/alias/darkColor.js
	const generateColorTokens = (brand) => ({
		colorNeutralForeground1: white,
		colorNeutralForeground1Hover: white,
		colorNeutralForeground1Pressed: white,
		colorNeutralForeground1Selected: white,
		colorNeutralForeground2: grey[84],
		colorNeutralForeground2Hover: white,
		colorNeutralForeground2Pressed: white,
		colorNeutralForeground2Selected: white,
		colorNeutralForeground2BrandHover: brand[100],
		colorNeutralForeground2BrandPressed: brand[90],
		colorNeutralForeground2BrandSelected: brand[100],
		colorNeutralForeground3: grey[68],
		colorNeutralForeground3Hover: grey[84],
		colorNeutralForeground3Pressed: grey[84],
		colorNeutralForeground3Selected: grey[84],
		colorNeutralForeground3BrandHover: brand[100],
		colorNeutralForeground3BrandPressed: brand[90],
		colorNeutralForeground3BrandSelected: brand[100],
		colorNeutralForeground4: grey[60],
		colorNeutralForegroundDisabled: grey[36],
		colorNeutralForegroundInvertedDisabled: whiteAlpha[40],
		colorBrandForegroundLink: brand[100],
		colorBrandForegroundLinkHover: brand[110],
		colorBrandForegroundLinkPressed: brand[90],
		colorBrandForegroundLinkSelected: brand[100],
		colorNeutralForeground2Link: grey[84],
		colorNeutralForeground2LinkHover: white,
		colorNeutralForeground2LinkPressed: white,
		colorNeutralForeground2LinkSelected: white,
		colorCompoundBrandForeground1: brand[100],
		colorCompoundBrandForeground1Hover: brand[110],
		colorCompoundBrandForeground1Pressed: brand[90],
		colorBrandForeground1: brand[100],
		colorBrandForeground2: brand[110],
		colorBrandForeground2Hover: brand[130],
		colorBrandForeground2Pressed: brand[160],
		colorNeutralForeground1Static: grey[14],
		colorNeutralForegroundStaticInverted: white,
		colorNeutralForegroundInverted: grey[14],
		colorNeutralForegroundInvertedHover: grey[14],
		colorNeutralForegroundInvertedPressed: grey[14],
		colorNeutralForegroundInvertedSelected: grey[14],
		colorNeutralForegroundInverted2: grey[14],
		colorNeutralForegroundOnBrand: white,
		colorNeutralForegroundInvertedLink: white,
		colorNeutralForegroundInvertedLinkHover: white,
		colorNeutralForegroundInvertedLinkPressed: white,
		colorNeutralForegroundInvertedLinkSelected: white,
		colorBrandForegroundInverted: brand[80],
		colorBrandForegroundInvertedHover: brand[70],
		colorBrandForegroundInvertedPressed: brand[60],
		colorBrandForegroundOnLight: brand[80],
		colorBrandForegroundOnLightHover: brand[70],
		colorBrandForegroundOnLightPressed: brand[50],
		colorBrandForegroundOnLightSelected: brand[60],
		colorNeutralBackground1: grey[16],
		colorNeutralBackground1Hover: grey[24],
		colorNeutralBackground1Pressed: grey[12],
		colorNeutralBackground1Selected: grey[22],
		colorNeutralBackground2: grey[12],
		colorNeutralBackground2Hover: grey[20],
		colorNeutralBackground2Pressed: grey[8],
		colorNeutralBackground2Selected: grey[18],
		colorNeutralBackground3: grey[8],
		colorNeutralBackground3Hover: grey[16],
		colorNeutralBackground3Pressed: grey[4],
		colorNeutralBackground3Selected: grey[14],
		colorNeutralBackground4: grey[4],
		colorNeutralBackground4Hover: grey[12],
		colorNeutralBackground4Pressed: black,
		colorNeutralBackground4Selected: grey[10],
		colorNeutralBackground5: black,
		colorNeutralBackground5Hover: grey[8],
		colorNeutralBackground5Pressed: grey[2],
		colorNeutralBackground5Selected: grey[6],
		colorNeutralBackground6: grey[20],
		colorNeutralBackgroundInverted: white,
		colorNeutralBackgroundStatic: grey[24],
		colorNeutralBackgroundAlpha: grey10Alpha[50],
		colorNeutralBackgroundAlpha2: grey12Alpha[70],
		colorSubtleBackground: "transparent",
		colorSubtleBackgroundHover: grey[22],
		colorSubtleBackgroundPressed: grey[18],
		colorSubtleBackgroundSelected: grey[20],
		colorSubtleBackgroundLightAlphaHover: grey14Alpha[80],
		colorSubtleBackgroundLightAlphaPressed: grey14Alpha[50],
		colorSubtleBackgroundLightAlphaSelected: "transparent",
		colorSubtleBackgroundInverted: "transparent",
		colorSubtleBackgroundInvertedHover: blackAlpha[10],
		colorSubtleBackgroundInvertedPressed: blackAlpha[30],
		colorSubtleBackgroundInvertedSelected: blackAlpha[20],
		colorTransparentBackground: "transparent",
		colorTransparentBackgroundHover: "transparent",
		colorTransparentBackgroundPressed: "transparent",
		colorTransparentBackgroundSelected: "transparent",
		colorNeutralBackgroundDisabled: grey[8],
		colorNeutralBackgroundInvertedDisabled: whiteAlpha[10],
		colorNeutralStencil1: grey[34],
		colorNeutralStencil2: grey[20],
		colorNeutralStencil1Alpha: whiteAlpha[10],
		colorNeutralStencil2Alpha: whiteAlpha[5],
		colorBackgroundOverlay: blackAlpha[50],
		colorScrollbarOverlay: whiteAlpha[60],
		colorBrandBackground: brand[70],
		colorBrandBackgroundHover: brand[80],
		colorBrandBackgroundPressed: brand[40],
		colorBrandBackgroundSelected: brand[60],
		colorCompoundBrandBackground: brand[100],
		colorCompoundBrandBackgroundHover: brand[110],
		colorCompoundBrandBackgroundPressed: brand[90],
		colorBrandBackgroundStatic: brand[80],
		colorBrandBackground2: brand[20],
		colorBrandBackground2Hover: brand[40],
		colorBrandBackground2Pressed: brand[10],
		colorBrandBackground3Static: brand[60],
		colorBrandBackground4Static: brand[40],
		colorBrandBackgroundInverted: white,
		colorBrandBackgroundInvertedHover: brand[160],
		colorBrandBackgroundInvertedPressed: brand[140],
		colorBrandBackgroundInvertedSelected: brand[150],
		colorNeutralCardBackground: grey[20],
		colorNeutralCardBackgroundHover: grey[24],
		colorNeutralCardBackgroundPressed: grey[18],
		colorNeutralCardBackgroundSelected: grey[22],
		colorNeutralCardBackgroundDisabled: grey[8],
		colorNeutralStrokeAccessible: grey[68],
		colorNeutralStrokeAccessibleHover: grey[74],
		colorNeutralStrokeAccessiblePressed: grey[70],
		colorNeutralStrokeAccessibleSelected: brand[100],
		colorNeutralStroke1: grey[40],
		colorNeutralStroke1Hover: grey[46],
		colorNeutralStroke1Pressed: grey[42],
		colorNeutralStroke1Selected: grey[44],
		colorNeutralStroke2: grey[32],
		colorNeutralStroke3: grey[24],
		colorNeutralStrokeSubtle: grey[4],
		colorNeutralStrokeOnBrand: grey[16],
		colorNeutralStrokeOnBrand2: white,
		colorNeutralStrokeOnBrand2Hover: white,
		colorNeutralStrokeOnBrand2Pressed: white,
		colorNeutralStrokeOnBrand2Selected: white,
		colorBrandStroke1: brand[100],
		colorBrandStroke2: brand[50],
		colorBrandStroke2Hover: brand[50],
		colorBrandStroke2Pressed: brand[30],
		colorBrandStroke2Contrast: brand[50],
		colorCompoundBrandStroke: brand[100],
		colorCompoundBrandStrokeHover: brand[110],
		colorCompoundBrandStrokePressed: brand[90],
		colorNeutralStrokeDisabled: grey[26],
		colorNeutralStrokeInvertedDisabled: whiteAlpha[40],
		colorTransparentStroke: "transparent",
		colorTransparentStrokeInteractive: "transparent",
		colorTransparentStrokeDisabled: "transparent",
		colorNeutralStrokeAlpha: whiteAlpha[10],
		colorNeutralStrokeAlpha2: whiteAlpha[20],
		colorStrokeFocus1: black,
		colorStrokeFocus2: white,
		colorNeutralShadowAmbient: "rgba(0,0,0,0.24)",
		colorNeutralShadowKey: "rgba(0,0,0,0.28)",
		colorNeutralShadowAmbientLighter: "rgba(0,0,0,0.12)",
		colorNeutralShadowKeyLighter: "rgba(0,0,0,0.14)",
		colorNeutralShadowAmbientDarker: "rgba(0,0,0,0.40)",
		colorNeutralShadowKeyDarker: "rgba(0,0,0,0.48)",
		colorBrandShadowAmbient: "rgba(0,0,0,0.30)",
		colorBrandShadowKey: "rgba(0,0,0,0.25)"
	});

//#endregion
//#region node_modules/@fluentui/tokens/lib/utils/createDarkTheme.js
	const createDarkTheme = (brand) => {
		const colorTokens = generateColorTokens(brand);
		return {
			...borderRadius,
			...fontSizes,
			...lineHeights,
			...fontFamilies$1,
			...fontWeights,
			...strokeWidths,
			...horizontalSpacings,
			...verticalSpacings,
			...durations$2,
			...curves$1,
			...colorTokens,
			...colorPaletteTokens$1,
			...colorStatusTokens$1,
			...createShadowTokens(colorTokens.colorNeutralShadowAmbient, colorTokens.colorNeutralShadowKey),
			...createShadowTokens(colorTokens.colorBrandShadowAmbient, colorTokens.colorBrandShadowKey, "Brand")
		};
	};

//#endregion
//#region node_modules/@fluentui/tokens/lib/themes/web/darkTheme.js
	const webDarkTheme = createDarkTheme(brandWeb);

//#endregion
//#region node_modules/@fluentui/tokens/lib/themeToTokensObject.js
/**
	* Programmatically generates a tokens to css variables mapping object from the keys in a theme.
	* This helps with ease of use as a user of a custom theme does not have to manually construct this object, but it could
	* affect tree-shaking since bundlers do not know the shape of the output.
	*
	* @param theme - Theme from which to get the keys to generate the tokens to css variables mapping object
	* @returns Tokens to css variables mapping object corresponding to the passed theme
	*/ function themeToTokensObject(theme) {
		const tokens$1 = {};
		const keys = Object.keys(theme);
		for (const key of keys) tokens$1[key] = `var(--${String(key)})`;
		return tokens$1;
	}

//#endregion
//#region node_modules/@fluentui/react-tabster/lib/focus/createFocusOutlineStyle.js
/**
	* Get the position of the focus outline
	*
	* @param options - Configures the style of the focus outline
	* @param position - The position of the focus outline
	* @returns CSS value for the position of the focus outline
	*/ function getOutlinePosition({ outlineWidth, outlineOffset }, position$1) {
		const offsetValue = (outlineOffset === null || outlineOffset === void 0 ? void 0 : outlineOffset[position$1]) || outlineOffset;
		if (!outlineOffset) return `calc(${outlineWidth} * -1)`;
		return `calc(0px - ${outlineWidth} - ${offsetValue})`;
	}
	/**
	* NOTE: the element with the focus outline needs to have `position: relative` so that the
	* pseudo element can be properly positioned.
	*
	* @param options - Configures the style of the focus outline
	* @returns focus outline styles object
	*/ const getFocusOutlineStyles = (options) => {
		const { outlineRadius, outlineColor, outlineWidth } = options;
		return {
			...shorthands.borderColor("transparent"),
			"@media (forced-colors: active)": { "::after": { ...shorthands.borderColor("Highlight") } },
			"::after": {
				content: "\"\"",
				position: "absolute",
				pointerEvents: "none",
				zIndex: 1,
				border: `${outlineWidth} solid ${outlineColor}`,
				borderRadius: outlineRadius,
				top: getOutlinePosition(options, "top"),
				right: getOutlinePosition(options, "right"),
				bottom: getOutlinePosition(options, "bottom"),
				left: getOutlinePosition(options, "left")
			}
		};
	};
	/**
	* NOTE: The element with the focus outline needs to have `position: relative` so that the
	* pseudo element can be properly positioned.
	*
	* @param options - Configure the style of the focus outline
	* @returns focus outline styles object for @see makeStyles
	*/ const createFocusOutlineStyle = ({ enableOutline = false, selector = defaultOptions$2.selector, customizeSelector, style = defaultOptions$2.style } = defaultOptions$2) => ({
		":focus": { outlineStyle: enableOutline ? void 0 : "none" },
		":focus-visible": { outlineStyle: enableOutline ? void 0 : "none" },
		...createCustomFocusIndicatorStyle(getFocusOutlineStyles({
			outlineColor: tokens.colorStrokeFocus2,
			outlineRadius: tokens.borderRadiusMedium,
			outlineWidth: "2px",
			...style
		}), {
			selector,
			customizeSelector
		})
	});

//#endregion
//#region node_modules/@fluentui/react-provider/lib/components/FluentProvider/useFluentProviderStyles.styles.js
	const fluentProviderClassNames = { root: "fui-FluentProvider" };
	const useStyles$107 = /* @__PURE__ */ __styles$1({ root: {
		sj55zd: "f19n0e5",
		De3pzq: "fxugw4r",
		fsow6f: ["f1o700av", "fes3tcz"],
		Bahqtrf: "fk6fouc",
		Be2twd7: "fkhj508",
		Bhrd7zp: "figsok6",
		Bg96gwp: "f1i3iumi"
	} }, { d: [
		".f19n0e5{color:var(--colorNeutralForeground1);}",
		".fxugw4r{background-color:var(--colorNeutralBackground1);}",
		".f1o700av{text-align:left;}",
		".fes3tcz{text-align:right;}",
		".fk6fouc{font-family:var(--fontFamilyBase);}",
		".fkhj508{font-size:var(--fontSizeBase300);}",
		".figsok6{font-weight:var(--fontWeightRegular);}",
		".f1i3iumi{line-height:var(--lineHeightBase300);}"
	] });
	/** Applies style classnames to slots */
	const useFluentProviderStyles_unstable = (state) => {
		"use no memo";
		const renderer = useRenderer();
		const styles = useStyles$107({
			dir: state.dir,
			renderer
		});
		state.root.className = mergeClasses(fluentProviderClassNames.root, state.themeClassName, styles.root, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-provider/lib/components/FluentProvider/useFluentProviderThemeStyleTag.js
	const useInsertionEffect$1 = react["useInsertionEffect"] ? react["useInsertionEffect"] : useIsomorphicLayoutEffect;
	const createStyleTag = (target, elementAttributes) => {
		if (!(target === null || target === void 0 ? void 0 : target.head)) return;
		const tag = target.createElement("style");
		Object.keys(elementAttributes).forEach((attrName) => {
			tag.setAttribute(attrName, elementAttributes[attrName]);
		});
		target.head.appendChild(tag);
		return tag;
	};
	const insertSheet = (tag, rule) => {
		const sheet = tag.sheet;
		if (sheet) {
			if (sheet.cssRules.length > 0) sheet.deleteRule(0);
			sheet.insertRule(rule, 0);
		} else console.error("FluentProvider: No sheet available on styleTag, styles will not be inserted into DOM.");
	};
	/**
	* Writes a theme as css variables in a style tag on the provided targetDocument as a rule applied to a CSS class
	* @internal
	* @returns CSS class to apply the rule
	*/ const useFluentProviderThemeStyleTag = (options) => {
		"use no memo";
		const { targetDocument, theme, rendererAttributes } = options;
		const styleTag = react.useRef(void 0);
		const styleTagId = useId(fluentProviderClassNames.root);
		const styleElementAttributes = rendererAttributes;
		const rule = react.useMemo(() => createCSSRuleFromTheme(`.${styleTagId}`, theme), [theme, styleTagId]);
		react.useMemo(() => {
			if (targetDocument) {
				var _styleElement_textContent;
				const providerElementSelector = `.${fluentProviderClassNames.root}.${styleTagId}`;
				const providerElements = targetDocument.querySelectorAll(providerElementSelector);
				const styleElementSelector = `style[id="${styleTagId}"]`;
				const styleElements = targetDocument.querySelectorAll(styleElementSelector);
				if (styleElements.length > 1) {
					console.error([
						"@fluentui/react-provider: We found multiple <style> elements with same IDs in your DOM.",
						"Please make sure that you configured your application properly.",
						"\n",
						"\n",
						"Configuration guide: https://aka.ms/fluentui-conflicting-ids"
					].join(" "));
					return;
				}
				const styleElement = styleElements.item(0);
				var _styleElement_textContent_length;
				const elementsCount = ((_styleElement_textContent_length = styleElement === null || styleElement === void 0 ? void 0 : (_styleElement_textContent = styleElement.textContent) === null || _styleElement_textContent === void 0 ? void 0 : _styleElement_textContent.length) !== null && _styleElement_textContent_length !== void 0 ? _styleElement_textContent_length : 0) > 0 ? 1 : 0;
				if (providerElements.length > elementsCount) console.error([
					"@fluentui/react-provider: There are conflicting ids in your DOM.",
					"Please make sure that you configured your application properly.",
					"\n",
					"\n",
					"Configuration guide: https://aka.ms/fluentui-conflicting-ids"
				].join(" "));
			}
		}, []);
		useHandleSSRStyleElements(targetDocument, styleTagId);
		useInsertionEffect$1(() => {
			const ssrStyleElement = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.getElementById(styleTagId);
			if (ssrStyleElement) styleTag.current = ssrStyleElement;
			else {
				styleTag.current = createStyleTag(targetDocument, {
					...styleElementAttributes,
					id: styleTagId
				});
				if (styleTag.current) insertSheet(styleTag.current, rule);
			}
			return () => {
				var _styleTag_current;
				(_styleTag_current = styleTag.current) === null || _styleTag_current === void 0 || _styleTag_current.remove();
			};
		}, [
			styleTagId,
			targetDocument,
			rule,
			styleElementAttributes
		]);
		return {
			styleTagId,
			rule
		};
	};
	function useHandleSSRStyleElements(targetDocument, styleTagId) {
		react.useState(() => {
			if (!targetDocument) return;
			const themeStyleElement = targetDocument.getElementById(styleTagId);
			if (themeStyleElement) targetDocument.head.append(themeStyleElement);
		});
	}

//#endregion
//#region node_modules/@fluentui/react-provider/lib/components/FluentProvider/useFluentProvider.js
	const DEFAULT_STYLE_HOOKS = {};
	const DEFAULT_RENDERER_ATTRIBUTES = {};
	/**
	* Create the state required to render FluentProvider.
	*
	* The returned state can be modified with hooks such as useFluentProviderStyles_unstable,
	* before being passed to renderFluentProvider_unstable.
	*
	* @param props - props from this instance of FluentProvider
	* @param ref - reference to root HTMLElement of FluentProvider
	*/ const useFluentProvider_unstable = (props, ref) => {
		"use no memo";
		const parentContext = useFluent();
		const parentTheme = useTheme();
		const parentOverrides = useOverrides();
		const parentCustomStyleHooks = react.useContext(CustomStyleHooksContext) || DEFAULT_STYLE_HOOKS;
		/**
		* TODO: add merge functions to "dir" merge,
		* nesting providers with the same "dir" should not add additional attributes to DOM
		* see https://github.com/microsoft/fluentui/blob/0dc74a19f3aa5a058224c20505016fbdb84db172/packages/fluentui/react-northstar/src/utils/mergeProviderContexts.ts#L89-L93
		*/ const { applyStylesToPortals = true, customStyleHooks_unstable, dir = parentContext.dir, targetDocument = parentContext.targetDocument, theme, overrides_unstable: overrides = {} } = props;
		const mergedTheme = shallowMerge(parentTheme, theme);
		const mergedOverrides = shallowMerge(parentOverrides, overrides);
		const mergedCustomStyleHooks = shallowMerge(parentCustomStyleHooks, customStyleHooks_unstable);
		const renderer = useRenderer();
		var _renderer_styleElementAttributes;
		const { styleTagId, rule } = useFluentProviderThemeStyleTag({
			theme: mergedTheme,
			targetDocument,
			rendererAttributes: (_renderer_styleElementAttributes = renderer.styleElementAttributes) !== null && _renderer_styleElementAttributes !== void 0 ? _renderer_styleElementAttributes : DEFAULT_RENDERER_ATTRIBUTES
		});
		react.useEffect(() => {
			if (mergedTheme === void 0) console.warn(["@fluentui/react-provider: FluentProvider does not have your \"theme\" defined.", "Make sure that your top-level FluentProvider has set a `theme` prop or you're setting the theme in your child FluentProvider."].join(" "));
		}, []);
		return {
			applyStylesToPortals,
			customStyleHooks_unstable: mergedCustomStyleHooks,
			dir,
			targetDocument,
			theme: mergedTheme,
			overrides_unstable: mergedOverrides,
			themeClassName: styleTagId,
			components: { root: "div" },
			root: always(getIntrinsicElementProps("div", {
				...props,
				dir,
				ref: useMergedRefs(ref, useFocusVisible({ targetDocument }))
			}), { elementType: "div" }),
			serverStyleProps: {
				cssRule: rule,
				attributes: {
					...renderer.styleElementAttributes,
					id: styleTagId
				}
			}
		};
	};
	function shallowMerge(a, b) {
		if (a && b) return {
			...a,
			...b
		};
		if (a) return a;
		return b;
	}
	function useTheme() {
		return react.useContext(ThemeContext);
	}

//#endregion
//#region node_modules/@fluentui/react-provider/lib/components/FluentProvider/useFluentProviderContextValues.js
	function useFluentProviderContextValues_unstable(state) {
		const { applyStylesToPortals, customStyleHooks_unstable, dir, root, targetDocument, theme, themeClassName, overrides_unstable } = state;
		const provider = react.useMemo(() => ({
			dir,
			targetDocument
		}), [dir, targetDocument]);
		const [tooltip] = react.useState(() => ({}));
		return {
			customStyleHooks_unstable,
			overrides_unstable,
			provider,
			textDirection: dir,
			iconDirection: react.useMemo(() => ({ textDirection: dir }), [dir]),
			tooltip,
			theme,
			themeClassName: applyStylesToPortals ? root.className : themeClassName
		};
	}

//#endregion
//#region node_modules/@fluentui/react-provider/lib/components/FluentProvider/FluentProvider.js
	const FluentProvider = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useFluentProvider_unstable(props, ref);
		useFluentProviderStyles_unstable(state);
		return renderFluentProvider_unstable(state, useFluentProviderContextValues_unstable(state));
	});
	FluentProvider.displayName = "FluentProvider";

//#endregion
//#region node_modules/scheduler/cjs/scheduler.development.js
/**
	* @license React
	* scheduler.development.js
	*
	* Copyright (c) Facebook, Inc. and its affiliates.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	var require_scheduler_development = /* @__PURE__ */ __commonJSMin(((exports) => {
		(function() {
			"use strict";
			if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(/* @__PURE__ */ new Error());
			var enableSchedulerDebugging = false;
			var enableProfiling = false;
			var frameYieldMs = 5;
			function push(heap, node$1) {
				var index = heap.length;
				heap.push(node$1);
				siftUp(heap, node$1, index);
			}
			function peek$1(heap) {
				return heap.length === 0 ? null : heap[0];
			}
			function pop(heap) {
				if (heap.length === 0) return null;
				var first = heap[0];
				var last = heap.pop();
				if (last !== first) {
					heap[0] = last;
					siftDown(heap, last, 0);
				}
				return first;
			}
			function siftUp(heap, node$1, i) {
				var index = i;
				while (index > 0) {
					var parentIndex = index - 1 >>> 1;
					var parent$1 = heap[parentIndex];
					if (compare(parent$1, node$1) > 0) {
						heap[parentIndex] = node$1;
						heap[index] = parent$1;
						index = parentIndex;
					} else return;
				}
			}
			function siftDown(heap, node$1, i) {
				var index = i;
				var length$1 = heap.length;
				var halfLength = length$1 >>> 1;
				while (index < halfLength) {
					var leftIndex = (index + 1) * 2 - 1;
					var left$1 = heap[leftIndex];
					var rightIndex = leftIndex + 1;
					var right$1 = heap[rightIndex];
					if (compare(left$1, node$1) < 0) if (rightIndex < length$1 && compare(right$1, left$1) < 0) {
						heap[index] = right$1;
						heap[rightIndex] = node$1;
						index = rightIndex;
					} else {
						heap[index] = left$1;
						heap[leftIndex] = node$1;
						index = leftIndex;
					}
					else if (rightIndex < length$1 && compare(right$1, node$1) < 0) {
						heap[index] = right$1;
						heap[rightIndex] = node$1;
						index = rightIndex;
					} else return;
				}
			}
			function compare(a, b) {
				var diff = a.sortIndex - b.sortIndex;
				return diff !== 0 ? diff : a.id - b.id;
			}
			var ImmediatePriority = 1;
			var UserBlockingPriority = 2;
			var NormalPriority$1 = 3;
			var LowPriority = 4;
			var IdlePriority = 5;
			function markTaskErrored(task, ms) {}
			if (typeof performance === "object" && typeof performance.now === "function") {
				var localPerformance = performance;
				exports.unstable_now = function() {
					return localPerformance.now();
				};
			} else {
				var localDate = Date;
				var initialTime = localDate.now();
				exports.unstable_now = function() {
					return localDate.now() - initialTime;
				};
			}
			var maxSigned31BitInt = 1073741823;
			var IMMEDIATE_PRIORITY_TIMEOUT = -1;
			var USER_BLOCKING_PRIORITY_TIMEOUT = 250;
			var NORMAL_PRIORITY_TIMEOUT = 5e3;
			var LOW_PRIORITY_TIMEOUT = 1e4;
			var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;
			var taskQueue = [];
			var timerQueue = [];
			var taskIdCounter = 1;
			var currentTask = null;
			var currentPriorityLevel = NormalPriority$1;
			var isPerformingWork = false;
			var isHostCallbackScheduled = false;
			var isHostTimeoutScheduled = false;
			var localSetTimeout = typeof setTimeout === "function" ? setTimeout : null;
			var localClearTimeout = typeof clearTimeout === "function" ? clearTimeout : null;
			var localSetImmediate = typeof setImmediate !== "undefined" ? setImmediate : null;
			typeof navigator !== "undefined" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
			function advanceTimers(currentTime) {
				var timer = peek$1(timerQueue);
				while (timer !== null) {
					if (timer.callback === null) pop(timerQueue);
					else if (timer.startTime <= currentTime) {
						pop(timerQueue);
						timer.sortIndex = timer.expirationTime;
						push(taskQueue, timer);
					} else return;
					timer = peek$1(timerQueue);
				}
			}
			function handleTimeout(currentTime) {
				isHostTimeoutScheduled = false;
				advanceTimers(currentTime);
				if (!isHostCallbackScheduled) if (peek$1(taskQueue) !== null) {
					isHostCallbackScheduled = true;
					requestHostCallback(flushWork);
				} else {
					var firstTimer = peek$1(timerQueue);
					if (firstTimer !== null) requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
				}
			}
			function flushWork(hasTimeRemaining, initialTime$1) {
				isHostCallbackScheduled = false;
				if (isHostTimeoutScheduled) {
					isHostTimeoutScheduled = false;
					cancelHostTimeout();
				}
				isPerformingWork = true;
				var previousPriorityLevel = currentPriorityLevel;
				try {
					if (enableProfiling) try {
						return workLoop(hasTimeRemaining, initialTime$1);
					} catch (error) {
						if (currentTask !== null) {
							var currentTime = exports.unstable_now();
							markTaskErrored(currentTask, currentTime);
							currentTask.isQueued = false;
						}
						throw error;
					}
					else return workLoop(hasTimeRemaining, initialTime$1);
				} finally {
					currentTask = null;
					currentPriorityLevel = previousPriorityLevel;
					isPerformingWork = false;
				}
			}
			function workLoop(hasTimeRemaining, initialTime$1) {
				var currentTime = initialTime$1;
				advanceTimers(currentTime);
				currentTask = peek$1(taskQueue);
				while (currentTask !== null && !enableSchedulerDebugging) {
					if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) break;
					var callback = currentTask.callback;
					if (typeof callback === "function") {
						currentTask.callback = null;
						currentPriorityLevel = currentTask.priorityLevel;
						var continuationCallback = callback(currentTask.expirationTime <= currentTime);
						currentTime = exports.unstable_now();
						if (typeof continuationCallback === "function") currentTask.callback = continuationCallback;
						else if (currentTask === peek$1(taskQueue)) pop(taskQueue);
						advanceTimers(currentTime);
					} else pop(taskQueue);
					currentTask = peek$1(taskQueue);
				}
				if (currentTask !== null) return true;
				else {
					var firstTimer = peek$1(timerQueue);
					if (firstTimer !== null) requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
					return false;
				}
			}
			function unstable_runWithPriority(priorityLevel, eventHandler) {
				switch (priorityLevel) {
					case ImmediatePriority:
					case UserBlockingPriority:
					case NormalPriority$1:
					case LowPriority:
					case IdlePriority: break;
					default: priorityLevel = NormalPriority$1;
				}
				var previousPriorityLevel = currentPriorityLevel;
				currentPriorityLevel = priorityLevel;
				try {
					return eventHandler();
				} finally {
					currentPriorityLevel = previousPriorityLevel;
				}
			}
			function unstable_next(eventHandler) {
				var priorityLevel;
				switch (currentPriorityLevel) {
					case ImmediatePriority:
					case UserBlockingPriority:
					case NormalPriority$1:
						priorityLevel = NormalPriority$1;
						break;
					default:
						priorityLevel = currentPriorityLevel;
						break;
				}
				var previousPriorityLevel = currentPriorityLevel;
				currentPriorityLevel = priorityLevel;
				try {
					return eventHandler();
				} finally {
					currentPriorityLevel = previousPriorityLevel;
				}
			}
			function unstable_wrapCallback(callback) {
				var parentPriorityLevel = currentPriorityLevel;
				return function() {
					var previousPriorityLevel = currentPriorityLevel;
					currentPriorityLevel = parentPriorityLevel;
					try {
						return callback.apply(this, arguments);
					} finally {
						currentPriorityLevel = previousPriorityLevel;
					}
				};
			}
			function unstable_scheduleCallback(priorityLevel, callback, options) {
				var currentTime = exports.unstable_now();
				var startTime$1;
				if (typeof options === "object" && options !== null) {
					var delay = options.delay;
					if (typeof delay === "number" && delay > 0) startTime$1 = currentTime + delay;
					else startTime$1 = currentTime;
				} else startTime$1 = currentTime;
				var timeout;
				switch (priorityLevel) {
					case ImmediatePriority:
						timeout = IMMEDIATE_PRIORITY_TIMEOUT;
						break;
					case UserBlockingPriority:
						timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
						break;
					case IdlePriority:
						timeout = IDLE_PRIORITY_TIMEOUT;
						break;
					case LowPriority:
						timeout = LOW_PRIORITY_TIMEOUT;
						break;
					case NormalPriority$1:
					default:
						timeout = NORMAL_PRIORITY_TIMEOUT;
						break;
				}
				var expirationTime = startTime$1 + timeout;
				var newTask = {
					id: taskIdCounter++,
					callback,
					priorityLevel,
					startTime: startTime$1,
					expirationTime,
					sortIndex: -1
				};
				if (startTime$1 > currentTime) {
					newTask.sortIndex = startTime$1;
					push(timerQueue, newTask);
					if (peek$1(taskQueue) === null && newTask === peek$1(timerQueue)) {
						if (isHostTimeoutScheduled) cancelHostTimeout();
						else isHostTimeoutScheduled = true;
						requestHostTimeout(handleTimeout, startTime$1 - currentTime);
					}
				} else {
					newTask.sortIndex = expirationTime;
					push(taskQueue, newTask);
					if (!isHostCallbackScheduled && !isPerformingWork) {
						isHostCallbackScheduled = true;
						requestHostCallback(flushWork);
					}
				}
				return newTask;
			}
			function unstable_pauseExecution() {}
			function unstable_continueExecution() {
				if (!isHostCallbackScheduled && !isPerformingWork) {
					isHostCallbackScheduled = true;
					requestHostCallback(flushWork);
				}
			}
			function unstable_getFirstCallbackNode() {
				return peek$1(taskQueue);
			}
			function unstable_cancelCallback(task) {
				task.callback = null;
			}
			function unstable_getCurrentPriorityLevel() {
				return currentPriorityLevel;
			}
			var isMessageLoopRunning = false;
			var scheduledHostCallback = null;
			var taskTimeoutID = -1;
			var frameInterval = frameYieldMs;
			var startTime = -1;
			function shouldYieldToHost() {
				if (exports.unstable_now() - startTime < frameInterval) return false;
				return true;
			}
			function requestPaint() {}
			function forceFrameRate(fps) {
				if (fps < 0 || fps > 125) {
					console["error"]("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
					return;
				}
				if (fps > 0) frameInterval = Math.floor(1e3 / fps);
				else frameInterval = frameYieldMs;
			}
			var performWorkUntilDeadline = function() {
				if (scheduledHostCallback !== null) {
					var currentTime = exports.unstable_now();
					startTime = currentTime;
					var hasTimeRemaining = true;
					var hasMoreWork = true;
					try {
						hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);
					} finally {
						if (hasMoreWork) schedulePerformWorkUntilDeadline();
						else {
							isMessageLoopRunning = false;
							scheduledHostCallback = null;
						}
					}
				} else isMessageLoopRunning = false;
			};
			var schedulePerformWorkUntilDeadline;
			if (typeof localSetImmediate === "function") schedulePerformWorkUntilDeadline = function() {
				localSetImmediate(performWorkUntilDeadline);
			};
			else if (typeof MessageChannel !== "undefined") {
				var channel = new MessageChannel();
				var port = channel.port2;
				channel.port1.onmessage = performWorkUntilDeadline;
				schedulePerformWorkUntilDeadline = function() {
					port.postMessage(null);
				};
			} else schedulePerformWorkUntilDeadline = function() {
				localSetTimeout(performWorkUntilDeadline, 0);
			};
			function requestHostCallback(callback) {
				scheduledHostCallback = callback;
				if (!isMessageLoopRunning) {
					isMessageLoopRunning = true;
					schedulePerformWorkUntilDeadline();
				}
			}
			function requestHostTimeout(callback, ms) {
				taskTimeoutID = localSetTimeout(function() {
					callback(exports.unstable_now());
				}, ms);
			}
			function cancelHostTimeout() {
				localClearTimeout(taskTimeoutID);
				taskTimeoutID = -1;
			}
			var unstable_requestPaint = requestPaint;
			var unstable_Profiling = null;
			exports.unstable_IdlePriority = IdlePriority;
			exports.unstable_ImmediatePriority = ImmediatePriority;
			exports.unstable_LowPriority = LowPriority;
			exports.unstable_NormalPriority = NormalPriority$1;
			exports.unstable_Profiling = unstable_Profiling;
			exports.unstable_UserBlockingPriority = UserBlockingPriority;
			exports.unstable_cancelCallback = unstable_cancelCallback;
			exports.unstable_continueExecution = unstable_continueExecution;
			exports.unstable_forceFrameRate = forceFrameRate;
			exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;
			exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;
			exports.unstable_next = unstable_next;
			exports.unstable_pauseExecution = unstable_pauseExecution;
			exports.unstable_requestPaint = unstable_requestPaint;
			exports.unstable_runWithPriority = unstable_runWithPriority;
			exports.unstable_scheduleCallback = unstable_scheduleCallback;
			exports.unstable_shouldYield = shouldYieldToHost;
			exports.unstable_wrapCallback = unstable_wrapCallback;
			if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(/* @__PURE__ */ new Error());
		})();
	}));

//#endregion
//#region node_modules/scheduler/index.js
	var require_scheduler = /* @__PURE__ */ __commonJSMin(((exports, module) => {
		module.exports = require_scheduler_development();
	}));

//#endregion
//#region node_modules/@fluentui/react-context-selector/lib/createContext.js
	var import_scheduler = require_scheduler();
	const createProvider = (Original) => {
		const Provider$1 = (props) => {
			const valueRef = react.useRef(props.value);
			const versionRef = react.useRef(0);
			const contextValue = react.useRef(null);
			if (!contextValue.current) contextValue.current = {
				value: valueRef,
				version: versionRef,
				listeners: []
			};
			useIsomorphicLayoutEffect(() => {
				valueRef.current = props.value;
				versionRef.current += 1;
				(0, import_scheduler.unstable_runWithPriority)(import_scheduler.unstable_NormalPriority, () => {
					contextValue.current.listeners.forEach((listener) => {
						listener([versionRef.current, props.value]);
					});
				});
			}, [props.value]);
			return react.createElement(Original, { value: contextValue.current }, props.children);
		};
		Provider$1.displayName = "ContextSelector.Provider";
		return Provider$1;
	};
	/**
	* @internal
	*/ const createContext = (defaultValue) => {
		const context = react.createContext({
			value: { current: defaultValue },
			version: { current: -1 },
			listeners: []
		});
		context.Provider = createProvider(context.Provider);
		delete context.Consumer;
		return context;
	};

//#endregion
//#region node_modules/@fluentui/react-context-selector/lib/useContextSelector.js
/**
	* @internal
	* This hook returns context selected value by selector.
	* It will only accept context created by `createContext`.
	* It will trigger re-render if only the selected value is referentially changed.
	*/ const useContextSelector = (context, selector) => {
		const { value: { current: value }, version: { current: version }, listeners } = react.useContext(context);
		const selected = selector(value);
		const [state, setState] = react.useState([value, selected]);
		const dispatch = (payload) => {
			setState((prevState) => {
				if (!payload) return [value, selected];
				if (payload[0] <= version) {
					if (Object.is(prevState[1], selected)) return prevState;
					return [value, selected];
				}
				try {
					if (Object.is(prevState[0], payload[1])) return prevState;
					const nextSelected = selector(payload[1]);
					if (Object.is(prevState[1], nextSelected)) return prevState;
					return [payload[1], nextSelected];
				} catch (e) {}
				return [prevState[0], prevState[1]];
			});
		};
		if (!Object.is(state[1], selected)) dispatch(void 0);
		const stableDispatch = useEventCallback(dispatch);
		useIsomorphicLayoutEffect(() => {
			listeners.push(stableDispatch);
			return () => {
				const index = listeners.indexOf(stableDispatch);
				listeners.splice(index, 1);
			};
		}, [stableDispatch, listeners]);
		return state[1];
	};

//#endregion
//#region node_modules/@fluentui/react-context-selector/lib/useHasParentContext.js
/**
	* @internal
	* Utility hook for contexts created by react-context-selector to determine if a parent context exists
	* WARNING: This hook will not work for native React contexts
	*
	* @param context - context created by react-context-selector
	* @returns whether the hook is wrapped by a parent context
	*/ function useHasParentContext(context) {
		const contextValue = react.useContext(context);
		if (contextValue.version) return contextValue.version.current !== -1;
		return false;
	}

//#endregion
//#region node_modules/@fluentui/react-accordion/lib/contexts/accordion.js
	const AccordionContext = createContext(void 0);
	const accordionContextDefaultValue = {
		openItems: [],
		collapsible: false,
		multiple: false,
		navigation: void 0,
		requestToggle() {}
	};
	const { Provider: AccordionProvider } = AccordionContext;
	const useAccordionContext_unstable = (selector) => useContextSelector(AccordionContext, (ctx = accordionContextDefaultValue) => selector(ctx));

//#endregion
//#region node_modules/@fluentui/react-accordion/lib/components/Accordion/renderAccordion.js
/**
	* Function that renders the final JSX of the component
	*/ const renderAccordion_unstable = (state, contextValues) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, { children: /* @__PURE__ */ jsx(AccordionProvider, {
			value: contextValues.accordion,
			children: state.root.children
		}) });
	};

//#endregion
//#region node_modules/@fluentui/react-accordion/lib/components/Accordion/useAccordion.js
/**
	* Returns the props and state required to render the component
	* @param props - Accordion properties
	* @param ref - reference to root HTMLElement of Accordion
	*/ const useAccordion_unstable = (props, ref) => {
		const { openItems: controlledOpenItems, defaultOpenItems, multiple = false, collapsible = false, onToggle, navigation, ...rest } = props;
		const [openItems, setOpenItems] = useControllableState({
			state: react.useMemo(() => normalizeValues(controlledOpenItems), [controlledOpenItems]),
			defaultState: defaultOpenItems && (() => initializeUncontrolledOpenItems({
				defaultOpenItems,
				multiple
			})),
			initialState: []
		});
		/** FIXME: deprecated will be removed after navigation prop is removed */ const arrowNavigationProps = useArrowNavigationGroup({
			circular: navigation === "circular",
			tabbable: true
		});
		return {
			collapsible,
			multiple,
			navigation,
			openItems,
			requestToggle: useEventCallback((data) => {
				const nextOpenItems = updateOpenItems(data.value, openItems, multiple, collapsible);
				onToggle === null || onToggle === void 0 || onToggle(data.event, {
					value: data.value,
					openItems: nextOpenItems
				});
				setOpenItems(nextOpenItems);
			}),
			components: { root: "div" },
			root: always(getIntrinsicElementProps("div", {
				...rest,
				...navigation ? arrowNavigationProps : void 0,
				ref
			}), { elementType: "div" })
		};
	};
	/**
	* Initial value for the uncontrolled case of the list of open indexes
	*/ function initializeUncontrolledOpenItems({ defaultOpenItems, multiple }) {
		if (defaultOpenItems !== void 0) {
			if (Array.isArray(defaultOpenItems)) return multiple ? defaultOpenItems : [defaultOpenItems[0]];
			return [defaultOpenItems];
		}
		return [];
	}
	/**
	* Updates the list of open indexes based on an index that changes
	* @param value - the index that will change
	* @param previousOpenItems - list of current open indexes
	* @param multiple - if Accordion support multiple Panels opened at the same time
	* @param collapsible - if Accordion support multiple Panels closed at the same time
	*/ function updateOpenItems(value, previousOpenItems, multiple, collapsible) {
		if (multiple) if (previousOpenItems.includes(value)) {
			if (previousOpenItems.length > 1 || collapsible) return previousOpenItems.filter((i) => i !== value);
		} else return [...previousOpenItems, value].sort();
		else return previousOpenItems[0] === value && collapsible ? [] : [value];
		return previousOpenItems;
	}
	/**
	* Normalizes Accordion index into an array of indexes
	*/ function normalizeValues(index) {
		if (index === void 0) return;
		return Array.isArray(index) ? index : [index];
	}

//#endregion
//#region node_modules/@fluentui/react-accordion/lib/components/Accordion/useAccordionContextValues.js
	function useAccordionContextValues_unstable(state) {
		const { navigation, openItems, requestToggle, multiple, collapsible } = state;
		return { accordion: {
			navigation,
			openItems,
			requestToggle,
			collapsible,
			multiple
		} };
	}

//#endregion
//#region node_modules/@fluentui/react-accordion/lib/components/Accordion/useAccordionStyles.styles.js
	const accordionClassNames = { root: "fui-Accordion" };
	const useAccordionStyles_unstable = (state) => {
		"use no memo";
		state.root.className = mergeClasses(accordionClassNames.root, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-accordion/lib/components/Accordion/Accordion.js
/**
	* Define a styled Accordion, using the `useAccordion_unstable` and `useAccordionStyles_unstable` hooks.
	*/ const Accordion = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useAccordion_unstable(props, ref);
		const contextValues = useAccordionContextValues_unstable(state);
		useAccordionStyles_unstable(state);
		useCustomStyleHook("useAccordionStyles_unstable")(state);
		return renderAccordion_unstable(state, contextValues);
	});
	Accordion.displayName = "Accordion";

//#endregion
//#region node_modules/@fluentui/react-accordion/lib/components/AccordionItem/useAccordionItem.js
/**
	* Returns the props and state required to render the component
	* @param props - AccordionItem properties
	* @param ref - reference to root HTMLElement of AccordionItem
	*/ const useAccordionItem_unstable = (props, ref) => {
		const { value, disabled = false } = props;
		const requestToggle = useAccordionContext_unstable((ctx) => ctx.requestToggle);
		return {
			open: useAccordionContext_unstable((ctx) => ctx.openItems.includes(value)),
			value,
			disabled,
			onHeaderClick: useEventCallback((event) => requestToggle({
				event,
				value
			})),
			components: { root: "div" },
			root: always(getIntrinsicElementProps("div", {
				ref,
				...props
			}), { elementType: "div" })
		};
	};

//#endregion
//#region node_modules/@fluentui/react-accordion/lib/components/AccordionItem/useAccordionItemContextValues.js
	function useAccordionItemContextValues_unstable(state) {
		const { disabled, open, value, onHeaderClick } = state;
		return { accordionItem: react.useMemo(() => ({
			disabled,
			open,
			value,
			onHeaderClick
		}), [
			disabled,
			open,
			value,
			onHeaderClick
		]) };
	}

//#endregion
//#region node_modules/@fluentui/react-accordion/lib/contexts/accordionItem.js
	const AccordionItemContext = react.createContext(void 0);
	const accordionItemContextDefaultValue = {
		open: false,
		disabled: false,
		value: void 0,
		onHeaderClick() {}
	};
	const { Provider: AccordionItemProvider } = AccordionItemContext;
	const useAccordionItemContext_unstable = () => {
		var _React_useContext;
		return (_React_useContext = react.useContext(AccordionItemContext)) !== null && _React_useContext !== void 0 ? _React_useContext : accordionItemContextDefaultValue;
	};

//#endregion
//#region node_modules/@fluentui/react-accordion/lib/components/AccordionItem/renderAccordionItem.js
/**
	* Function that renders the final JSX of the component
	*/ const renderAccordionItem_unstable = (state, contextValues) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, { children: /* @__PURE__ */ jsx(AccordionItemProvider, {
			value: contextValues.accordionItem,
			children: state.root.children
		}) });
	};

//#endregion
//#region node_modules/@fluentui/react-accordion/lib/components/AccordionItem/useAccordionItemStyles.styles.js
	const accordionItemClassNames = { root: "fui-AccordionItem" };
	const useAccordionItemStyles_unstable = (state) => {
		"use no memo";
		state.root.className = mergeClasses(accordionItemClassNames.root, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-accordion/lib/components/AccordionItem/AccordionItem.js
/**
	* Define a styled AccordionItem, using the `useAccordionItem_unstable` and `useAccordionItemStyles_unstable` hooks.
	*/ const AccordionItem = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useAccordionItem_unstable(props, ref);
		const contextValues = useAccordionItemContextValues_unstable(state);
		useAccordionItemStyles_unstable(state);
		useCustomStyleHook("useAccordionItemStyles_unstable")(state);
		return renderAccordionItem_unstable(state, contextValues);
	});
	AccordionItem.displayName = "AccordionItem";

//#endregion
//#region node_modules/@fluentui/keyboard-keys/lib/keys.js
	const Shift = "Shift";
	const Enter = "Enter";
	const Space = " ";
	const Tab$1 = "Tab";
	const ArrowDown = "ArrowDown";
	const ArrowLeft = "ArrowLeft";
	const ArrowRight = "ArrowRight";
	const ArrowUp = "ArrowUp";
	const End = "End";
	const Home = "Home";
	const PageDown = "PageDown";
	const PageUp = "PageUp";
	const Backspace = "Backspace";
	const Delete = "Delete";
	const Escape = "Escape";

//#endregion
//#region node_modules/@fluentui/react-aria/lib/button/useARIAButtonProps.js
/**
	* @internal
	*
	* Button keyboard handling, role, disabled and tabIndex implementation that ensures ARIA spec
	* for multiple scenarios of non native button elements. Ensuring 1st rule of ARIA for cases
	* where no attribute addition is required.
	*
	* @param type - the proper scenario to be interpreted by the hook.
	*  1. `button` - Minimal interference from the hook, as semantic button already supports most of the states
	*  2. `a` or `div` - Proper keyboard/mouse handling plus other support to ensure ARIA behavior
	* @param props - the props to be passed down the line to the desired element.
	* This hook will encapsulate proper properties, such as `onClick`, `onKeyDown`, `onKeyUp`, etc,.
	*
	* @example
	* ```tsx
	* const buttonProps = useARIAButtonProps('a', {
	*   href: './some-route'
	*   onClick: () => console.log('this should run both on click and Space and Enter')
	* })
	*
	* // ...
	*
	* return (
	*  <a {...buttonProps}>This anchor will behave as a proper button</a>
	* )
	* ```
	*/ function useARIAButtonProps(type, props) {
		const { disabled, disabledFocusable = false, ["aria-disabled"]: ariaDisabled, onClick, onKeyDown, onKeyUp, ...rest } = props !== null && props !== void 0 ? props : {};
		const normalizedARIADisabled = typeof ariaDisabled === "string" ? ariaDisabled === "true" : ariaDisabled;
		const isDisabled = disabled || disabledFocusable || normalizedARIADisabled;
		const handleClick = useEventCallback((ev) => {
			if (isDisabled) {
				ev.preventDefault();
				ev.stopPropagation();
			} else onClick === null || onClick === void 0 || onClick(ev);
		});
		const handleKeyDown = useEventCallback((ev) => {
			onKeyDown === null || onKeyDown === void 0 || onKeyDown(ev);
			if (ev.isDefaultPrevented()) return;
			const key = ev.key;
			if (isDisabled && (key === Enter || key === Space)) {
				ev.preventDefault();
				ev.stopPropagation();
				return;
			}
			if (key === Space) {
				ev.preventDefault();
				return;
			} else if (key === Enter) {
				ev.preventDefault();
				ev.currentTarget.click();
			}
		});
		const handleKeyUp = useEventCallback((ev) => {
			onKeyUp === null || onKeyUp === void 0 || onKeyUp(ev);
			if (ev.isDefaultPrevented()) return;
			const key = ev.key;
			if (isDisabled && (key === Enter || key === Space)) {
				ev.preventDefault();
				ev.stopPropagation();
				return;
			}
			if (key === Space) {
				ev.preventDefault();
				ev.currentTarget.click();
			}
		});
		if (type === "button" || type === void 0) return {
			...rest,
			disabled: disabled && !disabledFocusable,
			"aria-disabled": disabledFocusable ? true : normalizedARIADisabled,
			onClick: disabledFocusable ? void 0 : handleClick,
			onKeyUp: disabledFocusable ? void 0 : onKeyUp,
			onKeyDown: disabledFocusable ? void 0 : onKeyDown
		};
		else {
			const isLink = !!rest.href;
			let roleOverride = isLink ? void 0 : "button";
			if (!roleOverride && isDisabled) roleOverride = "link";
			const resultProps = {
				role: roleOverride,
				tabIndex: disabledFocusable || !isLink && !disabled ? 0 : void 0,
				...rest,
				onClick: handleClick,
				onKeyUp: handleKeyUp,
				onKeyDown: handleKeyDown,
				"aria-disabled": isDisabled
			};
			if (type === "a" && isDisabled) resultProps.href = void 0;
			return resultProps;
		}
	}

//#endregion
//#region node_modules/@fluentui/react-aria/lib/activedescendant/ActiveDescendantContext.js
	const noop$9 = () => void 0;
	const activeDescendantContextDefaultValue = { controller: {
		active: noop$9,
		blur: noop$9,
		find: noop$9,
		first: noop$9,
		focus: noop$9,
		focusLastActive: noop$9,
		scrollActiveIntoView: noop$9,
		last: noop$9,
		next: noop$9,
		prev: noop$9,
		showAttributes: noop$9,
		hideAttributes: noop$9,
		showFocusVisibleAttributes: noop$9,
		hideFocusVisibleAttributes: noop$9
	} };
	const ActiveDescendantContext = react.createContext(void 0);
	const ActiveDescendantContextProvider = ActiveDescendantContext.Provider;
	const useActiveDescendantContext = () => {
		var _React_useContext;
		return (_React_useContext = react.useContext(ActiveDescendantContext)) !== null && _React_useContext !== void 0 ? _React_useContext : activeDescendantContextDefaultValue;
	};
	const useHasParentActiveDescendantContext = () => !!react.useContext(ActiveDescendantContext);

//#endregion
//#region node_modules/@fluentui/react-aria/lib/activedescendant/useOptionWalker.js
	function useOptionWalker(options) {
		const { matchOption } = options;
		const { targetDocument } = useFluent();
		const treeWalkerRef = react.useRef(null);
		const listboxRef = react.useRef(null);
		const optionFilter = react.useCallback((node$1) => {
			if (isHTMLElement(node$1) && matchOption(node$1)) return NodeFilter.FILTER_ACCEPT;
			return NodeFilter.FILTER_SKIP;
		}, [matchOption]);
		const setListbox = react.useCallback((el) => {
			if (el && targetDocument) {
				listboxRef.current = el;
				treeWalkerRef.current = targetDocument.createTreeWalker(el, NodeFilter.SHOW_ELEMENT, optionFilter);
			} else {
				listboxRef.current = null;
				treeWalkerRef.current = null;
			}
		}, [targetDocument, optionFilter]);
		return {
			optionWalker: react.useMemo(() => ({
				first: () => {
					if (!treeWalkerRef.current || !listboxRef.current) return null;
					treeWalkerRef.current.currentNode = listboxRef.current;
					return treeWalkerRef.current.firstChild();
				},
				last: () => {
					if (!treeWalkerRef.current || !listboxRef.current) return null;
					treeWalkerRef.current.currentNode = listboxRef.current;
					return treeWalkerRef.current.lastChild();
				},
				next: () => {
					if (!treeWalkerRef.current) return null;
					return treeWalkerRef.current.nextNode();
				},
				prev: () => {
					if (!treeWalkerRef.current) return null;
					return treeWalkerRef.current.previousNode();
				},
				find: (predicate, startFrom) => {
					if (!treeWalkerRef.current || !listboxRef.current) return null;
					const start = startFrom ? targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.getElementById(startFrom) : null;
					treeWalkerRef.current.currentNode = start !== null && start !== void 0 ? start : listboxRef.current;
					let cur = treeWalkerRef.current.currentNode;
					while (cur && !predicate(cur.id)) cur = treeWalkerRef.current.nextNode();
					return cur;
				},
				setCurrent: (el) => {
					if (!treeWalkerRef.current) return;
					treeWalkerRef.current.currentNode = el;
				}
			}), [targetDocument]),
			listboxCallbackRef: setListbox
		};
	}

//#endregion
//#region node_modules/@fluentui/react-aria/lib/activedescendant/constants.js
/**
	* Applied to the element that is active descendant
	*/ const ACTIVEDESCENDANT_ATTRIBUTE = "data-activedescendant";
	/**
	* Applied to the active descendant when the user is navigating with keyboard
	*/ const ACTIVEDESCENDANT_FOCUSVISIBLE_ATTRIBUTE = "data-activedescendant-focusvisible";

//#endregion
//#region node_modules/@fluentui/react-aria/lib/activedescendant/scrollIntoView.js
	const scrollIntoView = (target) => {
		if (!target) return;
		const scrollParent = findScrollableParent(target.parentElement);
		if (!scrollParent) return;
		const { offsetHeight } = target;
		const offsetTop = getTotalOffsetTop(target, scrollParent);
		const { scrollMarginTop, scrollMarginBottom } = getScrollMargins(target);
		const { offsetHeight: parentOffsetHeight, scrollTop } = scrollParent;
		const isAbove = offsetTop - scrollMarginTop < scrollTop;
		const isBelow = offsetTop + offsetHeight + scrollMarginBottom > scrollTop + parentOffsetHeight;
		const buffer = 2;
		if (isAbove) scrollParent.scrollTo(0, offsetTop - scrollMarginTop - buffer);
		else if (isBelow) scrollParent.scrollTo(0, offsetTop + offsetHeight + scrollMarginBottom - parentOffsetHeight + buffer);
	};
	const findScrollableParent = (element) => {
		if (!element) return null;
		if (element.scrollHeight > element.offsetHeight) return element;
		return findScrollableParent(element.parentElement);
	};
	const getTotalOffsetTop = (element, scrollParent) => {
		if (!element || element === scrollParent) return 0;
		if (element.contains(scrollParent)) return scrollParent.offsetTop * -1;
		return element.offsetTop + getTotalOffsetTop(element.offsetParent, scrollParent);
	};
	const getScrollMargins = (element) => {
		var _element_ownerDocument;
		const win = (_element_ownerDocument = element.ownerDocument) === null || _element_ownerDocument === void 0 ? void 0 : _element_ownerDocument.defaultView;
		if (!win) return {
			scrollMarginTop: 0,
			scrollMarginBottom: 0
		};
		const computedStyles = win.getComputedStyle(element);
		var _getIntValueOfComputedStyle;
		const scrollMarginTop = (_getIntValueOfComputedStyle = getIntValueOfComputedStyle(computedStyles.scrollMarginTop)) !== null && _getIntValueOfComputedStyle !== void 0 ? _getIntValueOfComputedStyle : getIntValueOfComputedStyle(computedStyles.scrollMarginBlockStart);
		var _getIntValueOfComputedStyle1;
		return {
			scrollMarginTop,
			scrollMarginBottom: (_getIntValueOfComputedStyle1 = getIntValueOfComputedStyle(computedStyles.scrollMarginBottom)) !== null && _getIntValueOfComputedStyle1 !== void 0 ? _getIntValueOfComputedStyle1 : getIntValueOfComputedStyle(computedStyles.scrollMarginBlockEnd)
		};
	};
	const getIntValueOfComputedStyle = (computedStyle) => {
		return computedStyle ? parseInt(computedStyle, 10) : 0;
	};

//#endregion
//#region node_modules/@fluentui/react-aria/lib/activedescendant/useActiveDescendant.js
	const createActiveDescendantChangeEvent = (detail) => new CustomEvent("activedescendantchange", {
		bubbles: true,
		cancelable: false,
		composed: true,
		detail
	});
	function useActiveDescendant(options) {
		const { imperativeRef, matchOption: matchOptionUnstable } = options;
		const focusVisibleRef = react.useRef(false);
		const shouldShowFocusVisibleAttrRef = react.useRef(true);
		const activeIdRef = react.useRef(null);
		const lastActiveIdRef = react.useRef(null);
		const activeParentRef = react.useRef(null);
		const attributeVisibilityRef = react.useRef(true);
		const removeAttribute = react.useCallback(() => {
			var _activeParentRef_current;
			(_activeParentRef_current = activeParentRef.current) === null || _activeParentRef_current === void 0 || _activeParentRef_current.removeAttribute("aria-activedescendant");
		}, []);
		const setAttribute = react.useCallback((id) => {
			if (id) activeIdRef.current = id;
			if (attributeVisibilityRef.current && activeIdRef.current) {
				var _activeParentRef_current;
				(_activeParentRef_current = activeParentRef.current) === null || _activeParentRef_current === void 0 || _activeParentRef_current.setAttribute("aria-activedescendant", activeIdRef.current);
			}
		}, []);
		useOnKeyboardNavigationChange((isNavigatingWithKeyboard) => {
			focusVisibleRef.current = isNavigatingWithKeyboard;
			const active = getActiveDescendant();
			if (!active) return;
			if (isNavigatingWithKeyboard && shouldShowFocusVisibleAttrRef.current) active.setAttribute(ACTIVEDESCENDANT_FOCUSVISIBLE_ATTRIBUTE, "");
			else active.removeAttribute(ACTIVEDESCENDANT_FOCUSVISIBLE_ATTRIBUTE);
		});
		const matchOption = useEventCallback(matchOptionUnstable);
		const listboxRef = react.useRef(null);
		const { optionWalker, listboxCallbackRef } = useOptionWalker({ matchOption });
		const getActiveDescendant = react.useCallback(() => {
			var _listboxRef_current;
			return (_listboxRef_current = listboxRef.current) === null || _listboxRef_current === void 0 ? void 0 : _listboxRef_current.querySelector(`#${activeIdRef.current}`);
		}, [listboxRef]);
		const setShouldShowFocusVisibleAttribute = react.useCallback((shouldShow) => {
			shouldShowFocusVisibleAttrRef.current = shouldShow;
			const active = getActiveDescendant();
			if (!active) return;
			if (shouldShow && focusVisibleRef.current) active.setAttribute(ACTIVEDESCENDANT_FOCUSVISIBLE_ATTRIBUTE, "");
			else active.removeAttribute(ACTIVEDESCENDANT_FOCUSVISIBLE_ATTRIBUTE);
		}, [getActiveDescendant]);
		const blurActiveDescendant = react.useCallback(() => {
			const active = getActiveDescendant();
			if (active) {
				active.removeAttribute(ACTIVEDESCENDANT_ATTRIBUTE);
				active.removeAttribute(ACTIVEDESCENDANT_FOCUSVISIBLE_ATTRIBUTE);
			}
			removeAttribute();
			lastActiveIdRef.current = activeIdRef.current;
			activeIdRef.current = null;
			var _active_id;
			return (_active_id = active === null || active === void 0 ? void 0 : active.id) !== null && _active_id !== void 0 ? _active_id : null;
		}, [getActiveDescendant, removeAttribute]);
		const focusActiveDescendant = react.useCallback((nextActive) => {
			if (!nextActive) return;
			const previousActiveId = blurActiveDescendant();
			scrollIntoView(nextActive);
			setAttribute(nextActive.id);
			nextActive.setAttribute(ACTIVEDESCENDANT_ATTRIBUTE, "");
			if (focusVisibleRef.current && shouldShowFocusVisibleAttrRef.current) nextActive.setAttribute(ACTIVEDESCENDANT_FOCUSVISIBLE_ATTRIBUTE, "");
			const event = createActiveDescendantChangeEvent({
				id: nextActive.id,
				previousId: previousActiveId
			});
			nextActive.dispatchEvent(event);
		}, [blurActiveDescendant, setAttribute]);
		const controller = react.useMemo(() => ({
			first: ({ passive } = {}) => {
				const first = optionWalker.first();
				if (!passive) focusActiveDescendant(first);
				return first === null || first === void 0 ? void 0 : first.id;
			},
			last: ({ passive } = {}) => {
				const last = optionWalker.last();
				if (!passive) focusActiveDescendant(last);
				return last === null || last === void 0 ? void 0 : last.id;
			},
			next: ({ passive } = {}) => {
				const active = getActiveDescendant();
				if (!active) return;
				optionWalker.setCurrent(active);
				const next$1 = optionWalker.next();
				if (!passive) focusActiveDescendant(next$1);
				return next$1 === null || next$1 === void 0 ? void 0 : next$1.id;
			},
			prev: ({ passive } = {}) => {
				const active = getActiveDescendant();
				if (!active) return;
				optionWalker.setCurrent(active);
				const next$1 = optionWalker.prev();
				if (!passive) focusActiveDescendant(next$1);
				return next$1 === null || next$1 === void 0 ? void 0 : next$1.id;
			},
			blur: () => {
				blurActiveDescendant();
			},
			active: () => {
				var _getActiveDescendant;
				return (_getActiveDescendant = getActiveDescendant()) === null || _getActiveDescendant === void 0 ? void 0 : _getActiveDescendant.id;
			},
			focus: (id) => {
				if (!listboxRef.current) return;
				const target = listboxRef.current.querySelector(`#${id}`);
				if (target) focusActiveDescendant(target);
			},
			focusLastActive: () => {
				if (!listboxRef.current || !lastActiveIdRef.current) return;
				const target = listboxRef.current.querySelector(`#${lastActiveIdRef.current}`);
				if (target) {
					focusActiveDescendant(target);
					return true;
				}
			},
			find(predicate, { passive, startFrom } = {}) {
				const target = optionWalker.find(predicate, startFrom);
				if (!passive) focusActiveDescendant(target);
				return target === null || target === void 0 ? void 0 : target.id;
			},
			scrollActiveIntoView: () => {
				if (!listboxRef.current) return;
				const active = getActiveDescendant();
				if (!active) return;
				scrollIntoView(active);
			},
			showAttributes() {
				attributeVisibilityRef.current = true;
				setAttribute();
			},
			hideAttributes() {
				attributeVisibilityRef.current = false;
				removeAttribute();
			},
			showFocusVisibleAttributes() {
				setShouldShowFocusVisibleAttribute(true);
			},
			hideFocusVisibleAttributes() {
				setShouldShowFocusVisibleAttribute(false);
			}
		}), [
			optionWalker,
			listboxRef,
			setAttribute,
			removeAttribute,
			focusActiveDescendant,
			blurActiveDescendant,
			getActiveDescendant,
			setShouldShowFocusVisibleAttribute
		]);
		react.useImperativeHandle(imperativeRef, () => controller);
		return {
			listboxRef: useMergedRefs(listboxRef, listboxCallbackRef),
			activeParentRef,
			controller
		};
	}

//#endregion
//#region node_modules/@fluentui/react-aria/lib/AriaLiveAnnouncer/renderAriaLiveAnnouncer.js
	const renderAriaLiveAnnouncer_unstable = (state, contextValues) => {
		return /* @__PURE__ */ react.createElement(AnnounceProvider, { value: contextValues.announce }, state.children);
	};

//#endregion
//#region node_modules/@fluentui/react-aria/lib/AriaLiveAnnouncer/useDomAnnounce.js
/** The duration the message needs to be in present in DOM for screen readers to register a change and announce */ const MESSAGE_DURATION$1 = 500;
	const VISUALLY_HIDDEN_STYLES = {
		clip: "rect(0px, 0px, 0px, 0px)",
		height: "1px",
		margin: "-1px",
		width: "1px",
		position: "absolute",
		overflow: "hidden",
		textWrap: "nowrap"
	};
	const useDomAnnounce_unstable = () => {
		const { targetDocument } = useFluent();
		const timeoutRef = react.useRef(void 0);
		const [setAnnounceTimeout, clearAnnounceTimeout] = useTimeout();
		const tabsterNeverHiddenAttributes = useDangerousNeverHidden_unstable();
		const elementRef = react.useRef(null);
		const order = react.useRef(0);
		const batchMessages = react.useRef([]);
		const [messageQueue] = react.useState(() => createPriorityQueue$1((a, b) => {
			if (a.priority !== b.priority) return b.priority - a.priority;
			return a.createdAt - b.createdAt;
		}));
		const queueMessage = react.useCallback(() => {
			if (timeoutRef.current || !elementRef.current) return;
			const runCycle = () => {
				if (!elementRef.current) return;
				if (targetDocument && messageQueue.peek()) {
					const wrappingEl = targetDocument.createElement("span");
					wrappingEl.innerText = messageQueue.all().filter((msg) => msg.message.trim().length > 0).reduce((prevText, currMsg) => prevText + currMsg.message + ". ", "");
					elementRef.current.innerText = "";
					elementRef.current.appendChild(wrappingEl);
					messageQueue.clear();
					batchMessages.current = [];
					timeoutRef.current = setAnnounceTimeout(() => {
						runCycle();
					}, MESSAGE_DURATION$1);
				} else {
					elementRef.current.textContent = "";
					clearAnnounceTimeout();
					timeoutRef.current = void 0;
				}
			};
			timeoutRef.current = setAnnounceTimeout(() => {
				runCycle();
			}, 0);
		}, [
			clearAnnounceTimeout,
			messageQueue,
			setAnnounceTimeout,
			targetDocument
		]);
		const announce = react.useCallback((message, options = {}) => {
			const { alert = false, priority = 0, batchId } = options;
			if (alert) {}
			const liveMessage = {
				message,
				createdAt: order.current++,
				priority,
				batchId
			};
			if (batchId) {
				const batchMessage = batchMessages.current.find((msg) => msg.batchId === batchId);
				if (batchMessage) {
					messageQueue.remove(batchMessage.message);
					batchMessage.message = liveMessage;
				} else batchMessages.current = [...batchMessages.current, {
					batchId,
					message: liveMessage
				}];
			}
			messageQueue.enqueue(liveMessage);
			queueMessage();
		}, [messageQueue, queueMessage]);
		react.useEffect(() => {
			if (!targetDocument) return;
			const element = targetDocument.createElement("div");
			element.setAttribute("aria-live", "assertive");
			Object.entries(tabsterNeverHiddenAttributes).forEach(([key, value]) => {
				element.setAttribute(key, value);
			});
			Object.assign(element.style, VISUALLY_HIDDEN_STYLES);
			targetDocument.body.append(element);
			elementRef.current = element;
			return () => {
				element.remove();
				elementRef.current = null;
				clearAnnounceTimeout();
				timeoutRef.current = void 0;
			};
		}, [
			clearAnnounceTimeout,
			tabsterNeverHiddenAttributes,
			targetDocument
		]);
		return announce;
	};

//#endregion
//#region node_modules/@fluentui/react-aria/lib/AriaLiveAnnouncer/useAriaNotifyAnnounce.js
	const useAriaNotifyAnnounce_unstable = () => {
		const { targetDocument } = useFluent();
		return react.useCallback((message, options = {}) => {
			if (!targetDocument) return;
			const { alert = false, polite } = options;
			const defaultPriority = polite ? 0 : alert ? 2 : 1;
			var _options_priority;
			const ariaNotifyOptions = { priority: ((_options_priority = options.priority) !== null && _options_priority !== void 0 ? _options_priority : defaultPriority) > 1 ? "high" : "normal" };
			targetDocument.ariaNotify(message, ariaNotifyOptions);
		}, [targetDocument]);
	};

//#endregion
//#region node_modules/@fluentui/react-aria/lib/AriaLiveAnnouncer/useAriaLiveAnnouncer.js
	const useAriaLiveAnnouncer_unstable = (props) => {
		const { targetDocument } = useFluent();
		const domAnnounce = useDomAnnounce_unstable();
		const ariaNotifyAnnounce = useAriaNotifyAnnounce_unstable();
		return {
			announce: react.useMemo(() => {
				return typeof (targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.ariaNotify) === "function" ? ariaNotifyAnnounce : domAnnounce;
			}, [
				targetDocument,
				ariaNotifyAnnounce,
				domAnnounce
			]),
			children: props.children
		};
	};

//#endregion
//#region node_modules/@fluentui/react-aria/lib/AriaLiveAnnouncer/useAriaLiveAnnouncerContextValues.js
	function useAriaLiveAnnouncerContextValues_unstable(state) {
		const { announce } = state;
		return react.useMemo(() => ({ announce: { announce } }), [announce]);
	}

//#endregion
//#region node_modules/@fluentui/react-aria/lib/AriaLiveAnnouncer/AriaLiveAnnouncer.js
/**
	* A sample implementation of a component that manages aria live announcements.
	*/ const AriaLiveAnnouncer = (props) => {
		const state = useAriaLiveAnnouncer_unstable(props);
		return renderAriaLiveAnnouncer_unstable(state, useAriaLiveAnnouncerContextValues_unstable(state));
	};
	AriaLiveAnnouncer.displayName = "AriaLiveAnnouncer";

//#endregion
//#region node_modules/@fluentui/react-aria/lib/useTypingAnnounce/useTypingAnnounce.js
	const valueMutationOptions = {
		attributes: true,
		subtree: true,
		characterData: true,
		attributeFilter: ["value"]
	};
	function useTypingAnnounce() {
		const { targetDocument } = useFluent();
		const { announce } = useAnnounce();
		const inputRef = react.useRef(null);
		const observer = react.useRef(void 0);
		const [setTypingTimeout, clearTypingTimeout] = useTimeout();
		const messageQueue = react.useRef([]);
		const callback = react.useCallback((mutationList, mutationObserver) => {
			setTypingTimeout(() => {
				messageQueue.current.forEach(({ message, options }) => {
					announce(message, options);
				});
				messageQueue.current.length = 0;
				mutationObserver.disconnect();
			}, 500);
		}, [announce, setTypingTimeout]);
		const typingAnnounce = react.useCallback((message, options = {}) => {
			messageQueue.current.push({
				message,
				options
			});
			if (inputRef.current && observer.current) observer.current.observe(inputRef.current, valueMutationOptions);
			setTypingTimeout(() => {
				observer.current && callback([], observer.current);
			}, 500);
		}, [
			callback,
			inputRef,
			setTypingTimeout
		]);
		react.useEffect(() => {
			const win = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView;
			if (!win) return;
			if (!observer.current) observer.current = new win.MutationObserver(callback);
			return () => {
				if (observer.current) {
					observer.current.disconnect();
					clearTypingTimeout();
				}
			};
		}, [
			callback,
			clearTypingTimeout,
			targetDocument
		]);
		return {
			typingAnnounce,
			inputRef
		};
	}

//#endregion
//#region node_modules/@fluentui/react-icons/lib/utils/useIconStyles.styles.js
	const useStyles$106 = __styles({
		"root": {
			"mc9l5x": "f1w7gpdv",
			"Bg96gwp": "fez10in"
		},
		"rtl": { "Bz10aip": "f13rod7r" }
	}, { "d": [
		".f1w7gpdv{display:inline;}",
		".fez10in{line-height:0;}",
		".f13rod7r{transform:scaleX(-1);}"
	] });

//#endregion
//#region node_modules/@fluentui/react-icons/lib/utils/useIconState.js
	const useIconState = (props, options) => {
		const { title, primaryFill = "currentColor", ...rest } = props;
		const state = {
			...rest,
			title: void 0,
			fill: primaryFill
		};
		const styles = useStyles$106();
		const iconContext = useIconContext();
		state.className = mergeClasses(styles.root, (options === null || options === void 0 ? void 0 : options.flipInRtl) && (iconContext === null || iconContext === void 0 ? void 0 : iconContext.textDirection) === "rtl" && styles.rtl, state.className);
		if (title) state["aria-label"] = title;
		if (!state["aria-label"] && !state["aria-labelledby"]) state["aria-hidden"] = true;
		else state["role"] = "img";
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-icons/lib/utils/createFluentIcon.styles.js
	const useRootStyles$29 = __styles({ "root": { "B8gzw0y": "f1dd5bof" } }, { "m": [["@media (forced-colors: active){.f1dd5bof{forced-color-adjust:auto;}}", { "m": "(forced-colors: active)" }]] });

//#endregion
//#region node_modules/@fluentui/react-icons/lib/utils/createFluentIcon.js
	const createFluentIcon = (displayName, width, pathsOrSvg, options) => {
		const viewBoxWidth = width === "1em" ? "20" : width;
		const Icon = react.forwardRef((props, ref) => {
			const styles = useRootStyles$29();
			const iconState = useIconState(props, { flipInRtl: options === null || options === void 0 ? void 0 : options.flipInRtl });
			const state = {
				...iconState,
				className: mergeClasses(iconState.className, styles.root),
				ref,
				width,
				height: width,
				viewBox: `0 0 ${viewBoxWidth} ${viewBoxWidth}`,
				xmlns: "http://www.w3.org/2000/svg"
			};
			if (typeof pathsOrSvg === "string") return react.createElement("svg", {
				...state,
				dangerouslySetInnerHTML: { __html: pathsOrSvg }
			});
			else return react.createElement("svg", state, ...pathsOrSvg.map((d) => react.createElement("path", {
				d,
				fill: state.fill
			})));
		});
		Icon.displayName = displayName;
		return Icon;
	};

//#endregion
//#region node_modules/@fluentui/react-icons/lib/icons/chunk-0.js
	const ProhibitedFilled = /* @__PURE__ */ createFluentIcon("ProhibitedFilled", "1em", ["M18 10a8 8 0 1 1-16 0 8 8 0 0 1 16 0Zm-1.5 0c0-1.52-.53-2.93-1.4-4.04L5.96 15.1A6.5 6.5 0 0 0 16.5 10ZM4.9 14.04l9.14-9.14a6.5 6.5 0 0 0-9.13 9.13Z"]);
	const SearchRegular = /* @__PURE__ */ createFluentIcon("SearchRegular", "1em", ["M13.73 14.44a6.5 6.5 0 1 1 .7-.7l3.42 3.4a.5.5 0 0 1-.63.77l-.07-.06-3.42-3.41Zm-.71-.71A5.54 5.54 0 0 0 15 9.5a5.5 5.5 0 1 0-1.98 4.23Z"]);

//#endregion
//#region node_modules/@fluentui/react-icons/lib/icons/chunk-1.js
	const MoreHorizontalFilled = /* @__PURE__ */ createFluentIcon("MoreHorizontalFilled", "1em", ["M6.75 10a1.75 1.75 0 1 1-3.5 0 1.75 1.75 0 0 1 3.5 0Zm5 0a1.75 1.75 0 1 1-3.5 0 1.75 1.75 0 0 1 3.5 0ZM15 11.75a1.75 1.75 0 1 0 0-3.5 1.75 1.75 0 0 0 0 3.5Z"]);
	const MoreHorizontalRegular = /* @__PURE__ */ createFluentIcon("MoreHorizontalRegular", "1em", ["M6.25 10a1.25 1.25 0 1 1-2.5 0 1.25 1.25 0 0 1 2.5 0Zm5 0a1.25 1.25 0 1 1-2.5 0 1.25 1.25 0 0 1 2.5 0ZM15 11.25a1.25 1.25 0 1 0 0-2.5 1.25 1.25 0 0 0 0 2.5Z"]);

//#endregion
//#region node_modules/@fluentui/react-icons/lib/icons/chunk-6.js
	const PersonRegular = /* @__PURE__ */ createFluentIcon("PersonRegular", "1em", ["M10 2a4 4 0 1 0 0 8 4 4 0 0 0 0-8ZM7 6a3 3 0 1 1 6 0 3 3 0 0 1-6 0Zm-2 5a2 2 0 0 0-2 2c0 1.7.83 2.97 2.13 3.8A9.14 9.14 0 0 0 10 18c1.85 0 3.58-.39 4.87-1.2A4.35 4.35 0 0 0 17 13a2 2 0 0 0-2-2H5Zm-1 2a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1c0 1.3-.62 2.28-1.67 2.95A8.16 8.16 0 0 1 10 17a8.16 8.16 0 0 1-4.33-1.05A3.36 3.36 0 0 1 4 13Z"]);

//#endregion
//#region node_modules/@fluentui/react-icons/lib/icons/chunk-10.js
	const WarningFilled = /* @__PURE__ */ createFluentIcon("WarningFilled", "1em", ["M8.68 2.79a1.5 1.5 0 0 1 2.64 0l6.5 12A1.5 1.5 0 0 1 16.5 17h-13a1.5 1.5 0 0 1-1.32-2.21l6.5-12ZM10.5 7.5a.5.5 0 0 0-1 0v4a.5.5 0 0 0 1 0v-4Zm.25 6.25a.75.75 0 1 0-1.5 0 .75.75 0 0 0 1.5 0Z"]);

//#endregion
//#region node_modules/@fluentui/react-icons/lib/icons/chunk-11.js
	const StarFilled = /* @__PURE__ */ createFluentIcon("StarFilled", "1em", ["M9.1 2.9a1 1 0 0 1 1.8 0l1.93 3.91 4.31.63a1 1 0 0 1 .56 1.7l-3.12 3.05.73 4.3a1 1 0 0 1-1.45 1.05L10 15.51l-3.86 2.03a1 1 0 0 1-1.45-1.05l.74-4.3L2.3 9.14a1 1 0 0 1 .56-1.7l4.31-.63L9.1 2.9Z"]);
	const StarRegular = /* @__PURE__ */ createFluentIcon("StarRegular", "1em", ["M9.1 2.9a1 1 0 0 1 1.8 0l1.93 3.91 4.31.63a1 1 0 0 1 .56 1.7l-3.12 3.05.73 4.3a1 1 0 0 1-1.45 1.05L10 15.51l-3.86 2.03a1 1 0 0 1-1.45-1.05l.74-4.3L2.3 9.14a1 1 0 0 1 .56-1.7l4.31-.63L9.1 2.9Zm.9.44L8.07 7.25a1 1 0 0 1-.75.55L3 8.43l3.12 3.04a1 1 0 0 1 .3.89l-.75 4.3 3.87-2.03a1 1 0 0 1 .93 0l3.86 2.03-.74-4.3a1 1 0 0 1 .29-.89L17 8.43l-4.32-.63a1 1 0 0 1-.75-.55L10 3.35Z"]);

//#endregion
//#region node_modules/@fluentui/react-icons/lib/icons/chunk-12.js
	const InfoFilled = /* @__PURE__ */ createFluentIcon("InfoFilled", "1em", ["M18 10a8 8 0 1 0-16 0 8 8 0 0 0 16 0ZM9.5 8.91a.5.5 0 0 1 1 0V13.6a.5.5 0 0 1-1 0V8.9Zm-.25-2.16a.75.75 0 1 1 1.5 0 .75.75 0 0 1-1.5 0Z"]);

//#endregion
//#region node_modules/@fluentui/react-icons/lib/icons/chunk-13.js
	const PlayCircleRegular = /* @__PURE__ */ createFluentIcon("PlayCircleRegular", "1em", ["M9.13 7.18A.75.75 0 0 0 8 7.83v4.34c0 .57.63.94 1.13.65l4.12-2.39a.5.5 0 0 0 0-.86L9.13 7.18ZM2 10a8 8 0 1 1 16 0 8 8 0 0 1-16 0Zm8-7a7 7 0 1 0 0 14 7 7 0 0 0 0-14Z"]);

//#endregion
//#region node_modules/@fluentui/react-icons/lib/icons/chunk-16.js
	const CircleFilled = /* @__PURE__ */ createFluentIcon("CircleFilled", "1em", ["M10 2a8 8 0 1 0 0 16 8 8 0 0 0 0-16Z"]);

//#endregion
//#region node_modules/@fluentui/react-icons/lib/icons/chunk-21.js
	const ArrowDownRegular = /* @__PURE__ */ createFluentIcon("ArrowDownRegular", "1em", ["M16.87 10.84a.5.5 0 1 0-.74-.68l-5.63 6.17V2.5a.5.5 0 0 0-1 0v13.83l-5.63-6.17a.5.5 0 0 0-.74.68l6.31 6.91a.75.75 0 0 0 1.11 0l6.32-6.91Z"]);
	const ArrowUpRegular = /* @__PURE__ */ createFluentIcon("ArrowUpRegular", "1em", ["M3.13 9.16a.5.5 0 1 0 .74.68L9.5 3.67V17.5a.5.5 0 1 0 1 0V3.67l5.63 6.17a.5.5 0 0 0 .74-.68l-6.32-6.92a.75.75 0 0 0-1.1 0L3.13 9.16Z"], { flipInRtl: true });
	const PauseCircleRegular = /* @__PURE__ */ createFluentIcon("PauseCircleRegular", "1em", ["M10 2a8 8 0 1 1 0 16 8 8 0 0 1 0-16Zm0 1a7 7 0 1 0 0 14 7 7 0 0 0 0-14ZM8.5 6.5c.28 0 .5.22.5.5v6a.5.5 0 0 1-1 0V7c0-.28.22-.5.5-.5Zm3 0c.28 0 .5.22.5.5v6a.5.5 0 0 1-1 0V7c0-.28.22-.5.5-.5Z"]);

//#endregion
//#region node_modules/@fluentui/react-icons/lib/icons/chunk-24.js
	const CheckmarkFilled = /* @__PURE__ */ createFluentIcon("CheckmarkFilled", "1em", ["M7.03 13.9 3.56 10a.75.75 0 0 0-1.12 1l4 4.5c.29.32.79.34 1.09.03l10.5-10.5a.75.75 0 0 0-1.06-1.06l-9.94 9.94Z"]);
	const CheckmarkCircleFilled = /* @__PURE__ */ createFluentIcon("CheckmarkCircleFilled", "1em", ["M10 2a8 8 0 1 1 0 16 8 8 0 0 1 0-16Zm3.36 5.65a.5.5 0 0 0-.64-.06l-.07.06L9 11.3 7.35 9.65l-.07-.06a.5.5 0 0 0-.7.7l.07.07 2 2 .07.06c.17.11.4.11.56 0l.07-.06 4-4 .07-.08a.5.5 0 0 0-.06-.63Z"]);
	const ChevronDownRegular = /* @__PURE__ */ createFluentIcon("ChevronDownRegular", "1em", ["M15.85 7.65c.2.2.2.5 0 .7l-5.46 5.49a.55.55 0 0 1-.78 0L4.15 8.35a.5.5 0 1 1 .7-.7L10 12.8l5.15-5.16c.2-.2.5-.2.7 0Z"]);
	const ChevronLeftFilled = /* @__PURE__ */ createFluentIcon("ChevronLeftFilled", "1em", ["M12.27 15.8a.75.75 0 0 1-1.06-.03l-5-5.25a.75.75 0 0 1 0-1.04l5-5.25a.75.75 0 1 1 1.08 1.04L7.8 10l4.5 4.73c.29.3.28.78-.02 1.06Z"]);
	const ChevronLeftRegular = /* @__PURE__ */ createFluentIcon("ChevronLeftRegular", "1em", ["M12.35 15.85a.5.5 0 0 1-.7 0L6.16 10.4a.55.55 0 0 1 0-.78l5.49-5.46a.5.5 0 1 1 .7.7L7.2 10l5.16 5.15c.2.2.2.5 0 .7Z"]);
	const ChevronRightFilled = /* @__PURE__ */ createFluentIcon("ChevronRightFilled", "1em", ["M7.73 4.2a.75.75 0 0 1 1.06.03l5 5.25c.28.3.28.75 0 1.04l-5 5.25a.75.75 0 1 1-1.08-1.04L12.2 10l-4.5-4.73a.75.75 0 0 1 .02-1.06Z"]);
	const ChevronRightRegular = /* @__PURE__ */ createFluentIcon("ChevronRightRegular", "1em", ["M7.65 4.15c.2-.2.5-.2.7 0l5.49 5.46c.21.22.21.57 0 .78l-5.49 5.46a.5.5 0 0 1-.7-.7L12.8 10 7.65 4.85a.5.5 0 0 1 0-.7Z"]);

//#endregion
//#region node_modules/@fluentui/react-icons/lib/icons/chunk-28.js
	const DismissFilled = /* @__PURE__ */ createFluentIcon("DismissFilled", "1em", ["m3.9 4.05.07-.08a.75.75 0 0 1 .98-.07l.08.07L10 8.94l4.97-4.97a.75.75 0 0 1 .98-.07l.08.07c.27.27.3.68.07.98l-.07.08L11.06 10l4.97 4.97c.27.27.3.68.07.98l-.07.08a.75.75 0 0 1-.98.07l-.08-.07L10 11.06l-4.97 4.97a.75.75 0 0 1-.98.07l-.08-.07a.75.75 0 0 1-.07-.98l.07-.08L8.94 10 3.97 5.03a.75.75 0 0 1-.07-.98l.07-.08-.07.08Z"]);
	const DismissRegular = /* @__PURE__ */ createFluentIcon("DismissRegular", "1em", ["m4.09 4.22.06-.07a.5.5 0 0 1 .63-.06l.07.06L10 9.29l5.15-5.14a.5.5 0 0 1 .63-.06l.07.06c.18.17.2.44.06.63l-.06.07L10.71 10l5.14 5.15c.18.17.2.44.06.63l-.06.07a.5.5 0 0 1-.63.06l-.07-.06L10 10.71l-5.15 5.14a.5.5 0 0 1-.63.06l-.07-.06a.5.5 0 0 1-.06-.63l.06-.07L9.29 10 4.15 4.85a.5.5 0 0 1-.06-.63l.06-.07-.06.07Z"]);
	const DismissCircleFilled = /* @__PURE__ */ createFluentIcon("DismissCircleFilled", "1em", ["M10 2a8 8 0 1 1 0 16 8 8 0 0 1 0-16ZM7.8 7.11a.5.5 0 0 0-.63.06l-.06.07a.5.5 0 0 0 .06.64L9.3 10l-2.12 2.12-.06.07a.5.5 0 0 0 .06.64l.07.06c.2.13.47.11.64-.06L10 10.7l2.12 2.12.07.06c.2.13.46.11.64-.06l.06-.07a.5.5 0 0 0-.06-.64L10.7 10l2.12-2.12.06-.07a.5.5 0 0 0-.06-.64l-.07-.06a.5.5 0 0 0-.64.06L10 9.3 7.88 7.17l-.07-.06Z"]);

//#endregion
//#region node_modules/@fluentui/react-icons/lib/sizedIcons/chunk-10.js
	const Warning12Filled = /* @__PURE__ */ createFluentIcon("Warning12Filled", "12", ["M5.21 1.46a.9.9 0 0 1 1.58 0l4.09 7.17a.92.92 0 0 1-.79 1.37H1.91a.92.92 0 0 1-.79-1.37l4.1-7.17ZM5.5 4.5v1a.5.5 0 0 0 1 0v-1a.5.5 0 0 0-1 0ZM6 6.75a.75.75 0 1 0 0 1.5.75.75 0 0 0 0-1.5Z"]);

//#endregion
//#region node_modules/@fluentui/react-icons/lib/sizedIcons/chunk-12.js
	const Info12Filled = /* @__PURE__ */ createFluentIcon("Info12Filled", "12", ["M11 6A5 5 0 1 1 1 6a5 5 0 0 1 10 0Zm-5.5.5V8a.5.5 0 0 0 1 0V6.5a.5.5 0 0 0-1 0ZM6 3.75a.75.75 0 1 0 0 1.5.75.75 0 0 0 0-1.5Z"]);
	const Info12Regular = /* @__PURE__ */ createFluentIcon("Info12Regular", "12", ["M5.5 6.5a.5.5 0 0 1 1 0V8a.5.5 0 0 1-1 0V6.5ZM6 3.75a.75.75 0 1 0 0 1.5.75.75 0 0 0 0-1.5ZM1 6a5 5 0 1 1 10 0A5 5 0 0 1 1 6Zm5-4a4 4 0 1 0 0 8 4 4 0 0 0 0-8Z"]);
	const Info16Filled = /* @__PURE__ */ createFluentIcon("Info16Filled", "16", ["M8 1a7 7 0 1 1 0 14A7 7 0 0 1 8 1Zm0 5.25a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5Zm.5 1.25a.5.5 0 0 0-1 0v3a.5.5 0 0 0 1 0v-3Z"]);
	const Info16Regular = /* @__PURE__ */ createFluentIcon("Info16Regular", "16", ["M8.5 7.5a.5.5 0 1 0-1 0v3a.5.5 0 0 0 1 0v-3Zm.25-2a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0ZM8 1a7 7 0 1 0 0 14A7 7 0 0 0 8 1ZM2 8a6 6 0 1 1 12 0A6 6 0 0 1 2 8Z"]);
	const Info20Filled = /* @__PURE__ */ createFluentIcon("Info20Filled", "20", ["M18 10a8 8 0 1 0-16 0 8 8 0 0 0 16 0ZM9.5 8.91a.5.5 0 0 1 1 0V13.6a.5.5 0 0 1-1 0V8.9Zm-.25-2.16a.75.75 0 1 1 1.5 0 .75.75 0 0 1-1.5 0Z"]);
	const Info20Regular = /* @__PURE__ */ createFluentIcon("Info20Regular", "20", ["M10.5 8.91a.5.5 0 0 0-1 .09v4.6a.5.5 0 0 0 1-.1V8.91Zm.3-2.16a.75.75 0 1 0-1.5 0 .75.75 0 0 0 1.5 0ZM18 10a8 8 0 1 0-16 0 8 8 0 0 0 16 0ZM3 10a7 7 0 1 1 14 0 7 7 0 0 1-14 0Z"]);

//#endregion
//#region node_modules/@fluentui/react-icons/lib/sizedIcons/chunk-18.js
	const Navigation20Filled = /* @__PURE__ */ createFluentIcon("Navigation20Filled", "20", ["M2 4.75c0-.41.34-.75.75-.75h14.5a.75.75 0 0 1 0 1.5H2.75A.75.75 0 0 1 2 4.75Zm0 5c0-.41.34-.75.75-.75h14.5a.75.75 0 0 1 0 1.5H2.75A.75.75 0 0 1 2 9.75ZM2.75 14a.75.75 0 0 0 0 1.5h14.5a.75.75 0 0 0 0-1.5H2.75Z"]);

//#endregion
//#region node_modules/@fluentui/react-icons/lib/sizedIcons/chunk-19.js
	const Lightbulb16Regular = /* @__PURE__ */ createFluentIcon("Lightbulb16Regular", "16", ["M4.5 6.5A3.5 3.5 0 1 1 10.45 9c-.19.19-.36.43-.44.73L9.66 11H6.34l-.35-1.27c-.08-.3-.25-.54-.44-.73A3.49 3.49 0 0 1 4.5 6.5ZM6.6 12h2.8l-.18.63a.5.5 0 0 1-.48.37H7.26a.5.5 0 0 1-.48-.37L6.61 12ZM8 2a4.5 4.5 0 0 0-3.16 7.7c.1.1.16.2.19.3l.79 2.9c.17.65.77 1.1 1.44 1.1h1.48a1.5 1.5 0 0 0 1.44-1.1l.8-2.9c.02-.1.08-.2.18-.3A4.49 4.49 0 0 0 8 2Z"]);

//#endregion
//#region node_modules/@fluentui/react-icons/lib/sizedIcons/chunk-20.js
	const Pin20Regular = /* @__PURE__ */ createFluentIcon("Pin20Regular", "20", ["M10.12 3.14a2 2 0 0 1 3.2-.52l4.06 4.05a2 2 0 0 1-.52 3.2l-3.46 1.74a1.5 1.5 0 0 0-.72.78L11.25 16a1 1 0 0 1-1.64.33L7 13.7 3.7 17H3v-.7L6.3 13l-2.62-2.61a1 1 0 0 1 .34-1.64L7.6 7.32c.34-.14.62-.4.78-.72l1.73-3.46Zm2.5.18a1 1 0 0 0-1.6.26L9.29 7.04a2.5 2.5 0 0 1-1.31 1.2L4.39 9.69l5.93 5.93 1.43-3.59a2.5 2.5 0 0 1 1.2-1.3l3.46-1.74a1 1 0 0 0 .26-1.6l-4.05-4.06Z"]);

//#endregion
//#region node_modules/@fluentui/react-icons/lib/sizedIcons/chunk-22.js
	const PresenceAvailable10Filled = /* @__PURE__ */ createFluentIcon("PresenceAvailable10Filled", "10", ["M5 10A5 5 0 1 0 5 0a5 5 0 0 0 0 10Zm2.1-5.9L4.85 6.35a.5.5 0 0 1-.7 0l-1-1a.5.5 0 0 1 .7-.7l.65.64 1.9-1.9a.5.5 0 0 1 .7.71Z"]);
	const PresenceAvailable10Regular = /* @__PURE__ */ createFluentIcon("PresenceAvailable10Regular", "10", ["M5 0a5 5 0 1 0 0 10A5 5 0 0 0 5 0ZM1 5a4 4 0 1 1 8 0 4 4 0 0 1-8 0Zm6.1-1.6c.2.2.2.5 0 .7L4.85 6.35a.5.5 0 0 1-.7 0l-1-1a.5.5 0 1 1 .7-.7l.65.64 1.9-1.9c.2-.19.5-.19.7 0Z"]);
	const PresenceAvailable12Filled = /* @__PURE__ */ createFluentIcon("PresenceAvailable12Filled", "12", ["M6 12A6 6 0 1 0 6 0a6 6 0 0 0 0 12Zm2.53-6.72L5.78 8.03c-.3.3-.77.3-1.06 0l-1-1a.75.75 0 0 1 1.06-1.06l.47.47 2.22-2.22a.75.75 0 0 1 1.06 1.06Z"]);
	const PresenceAvailable12Regular = /* @__PURE__ */ createFluentIcon("PresenceAvailable12Regular", "12", ["M6 0a6 6 0 1 0 0 12A6 6 0 0 0 6 0ZM1.5 6a4.5 4.5 0 1 1 9 0 4.5 4.5 0 0 1-9 0Zm7.03-1.78c.3.3.3.77 0 1.06L5.78 8.03c-.3.3-.77.3-1.06 0l-1-1a.75.75 0 0 1 1.06-1.06l.47.47 2.22-2.22c.3-.3.77-.3 1.06 0Z"]);
	const PresenceAvailable16Filled = /* @__PURE__ */ createFluentIcon("PresenceAvailable16Filled", "16", ["M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16Zm3.7-9.3-4 4a1 1 0 0 1-1.41 0l-2-2a1 1 0 1 1 1.42-1.4L7 8.58l3.3-3.3a1 1 0 0 1 1.4 1.42Z"]);
	const PresenceAvailable16Regular = /* @__PURE__ */ createFluentIcon("PresenceAvailable16Regular", "16", ["M11.7 6.7a1 1 0 0 0-1.4-1.4L7 8.58l-1.3-1.3a1 1 0 0 0-1.4 1.42l2 2a1 1 0 0 0 1.4 0l4-4ZM0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6a6 6 0 1 0 0 12A6 6 0 0 0 8 2Z"]);
	const PresenceAvailable20Filled = /* @__PURE__ */ createFluentIcon("PresenceAvailable20Filled", "20", ["M10 20a10 10 0 1 0 0-20 10 10 0 0 0 0 20Zm4.2-11.8-4.5 4.5a1 1 0 0 1-1.4 0l-2-2a1 1 0 1 1 1.4-1.4L9 10.58l3.8-3.8a1 1 0 1 1 1.4 1.42Z"]);
	const PresenceAvailable20Regular = /* @__PURE__ */ createFluentIcon("PresenceAvailable20Regular", "20", ["M10 0a10 10 0 1 0 0 20 10 10 0 0 0 0-20ZM2 10a8 8 0 1 1 16 0 8 8 0 0 1-16 0Zm12.2-3.2a1 1 0 0 1 0 1.4l-4.5 4.5a1 1 0 0 1-1.4 0l-2-2a1 1 0 0 1 1.4-1.4L9 10.58l3.8-3.8a1 1 0 0 1 1.4 0Z"]);
	const PresenceAway10Filled = /* @__PURE__ */ createFluentIcon("PresenceAway10Filled", "10", ["M5 10A5 5 0 1 0 5 0a5 5 0 0 0 0 10Zm0-7v1.8l1.35 1.35a.5.5 0 1 1-.7.7l-1.5-1.5A.5.5 0 0 1 4 5V3a.5.5 0 0 1 1 0Z"]);
	const PresenceAway10Regular = /* @__PURE__ */ createFluentIcon("PresenceAway10Regular", "10", ["M5 4.8V3a.5.5 0 0 0-1 0v2c0 .13.05.26.15.35l1.5 1.5a.5.5 0 1 0 .7-.7L5 4.79Zm5 .2A5 5 0 1 1 0 5a5 5 0 0 1 10 0ZM9 5a4 4 0 1 0-8 0 4 4 0 0 0 8 0Z"]);
	const PresenceAway12Filled = /* @__PURE__ */ createFluentIcon("PresenceAway12Filled", "12", ["M6 12A6 6 0 1 0 6 0a6 6 0 0 0 0 12Zm.5-8.75v2.4l1.49 1.28A.75.75 0 1 1 7 8.07l-1.75-1.5A.75.75 0 0 1 5 6V3.25a.75.75 0 0 1 1.5 0Z"]);
	const PresenceAway12Regular = /* @__PURE__ */ createFluentIcon("PresenceAway12Regular", "12", ["M6.5 5.66V3.25a.75.75 0 0 0-1.5 0V6c0 .22.1.43.26.57l1.75 1.5A.75.75 0 1 0 8 6.93L6.5 5.66ZM12 6A6 6 0 1 1 0 6a6 6 0 0 1 12 0Zm-1.5 0a4.5 4.5 0 1 0-9 0 4.5 4.5 0 0 0 9 0Z"]);
	const PresenceAway16Filled = /* @__PURE__ */ createFluentIcon("PresenceAway16Filled", "16", ["M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16Zm.5-11.5v3.02l2.12 1.7a1 1 0 1 1-1.24 1.56l-2.5-2A1 1 0 0 1 6.5 8V4.5a1 1 0 0 1 2 0Z"]);
	const PresenceAway16Regular = /* @__PURE__ */ createFluentIcon("PresenceAway16Regular", "16", ["M8.5 7.52V4.5a1 1 0 1 0-2 0V8c0 .3.14.6.38.78l2.5 2a1 1 0 1 0 1.24-1.56L8.5 7.52ZM8 0a8 8 0 1 0 0 16A8 8 0 0 0 8 0ZM2 8a6 6 0 1 1 12 0A6 6 0 0 1 2 8Z"]);
	const PresenceAway20Filled = /* @__PURE__ */ createFluentIcon("PresenceAway20Filled", "20", ["M10 20a10 10 0 1 0 0-20 10 10 0 0 0 0 20Zm0-14V9.6l2.7 2.7a1 1 0 0 1-1.4 1.42l-3-3A1 1 0 0 1 8 10V6a1 1 0 1 1 2 0Z"]);
	const PresenceAway20Regular = /* @__PURE__ */ createFluentIcon("PresenceAway20Regular", "20", ["M10 9.59V6a1 1 0 1 0-2 0V10c0 .27.1.52.3.7l3 3a1 1 0 1 0 1.4-1.4L10 9.58Zm-10 .4a10 10 0 1 1 20 0 10 10 0 0 1-20 0ZM10 2a8 8 0 1 0 0 16 8 8 0 0 0 0-16Z"]);
	const PresenceBlocked10Regular = /* @__PURE__ */ createFluentIcon("PresenceBlocked10Regular", "10", ["M10 5A5 5 0 1 0 0 5a5 5 0 0 0 10 0ZM9 5a4 4 0 0 1-6.45 3.16l5.61-5.61C8.69 3.22 9 4.08 9 5ZM7.45 1.84 1.84 7.45a4 4 0 0 1 5.61-5.61Z"]);
	const PresenceBlocked12Regular = /* @__PURE__ */ createFluentIcon("PresenceBlocked12Regular", "12", ["M12 6A6 6 0 1 1 0 6a6 6 0 0 1 12 0Zm-1.5 0c0-.97-.3-1.87-.83-2.6L3.39 9.66A4.5 4.5 0 0 0 10.5 6ZM8.6 2.33a4.5 4.5 0 0 0-6.28 6.28l6.29-6.28Z"]);
	const PresenceBlocked16Regular = /* @__PURE__ */ createFluentIcon("PresenceBlocked16Regular", "16", ["M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0Zm-2 0c0-1.3-.41-2.5-1.1-3.48L4.51 12.9A6 6 0 0 0 14 8Zm-2.52-4.9a6 6 0 0 0-8.37 8.37l8.37-8.36Z"]);
	const PresenceBlocked20Regular = /* @__PURE__ */ createFluentIcon("PresenceBlocked20Regular", "20", ["M20 10a10 10 0 1 0-20 0 10 10 0 0 0 20 0Zm-2 0a8 8 0 0 1-12.9 6.32L16.31 5.09A7.97 7.97 0 0 1 18 10Zm-3.1-6.32L3.69 14.91A8 8 0 0 1 14.91 3.68Z"]);
	const PresenceBusy10Filled = /* @__PURE__ */ createFluentIcon("PresenceBusy10Filled", "10", ["M10 5A5 5 0 1 1 0 5a5 5 0 0 1 10 0Z"]);
	const PresenceBusy12Filled = /* @__PURE__ */ createFluentIcon("PresenceBusy12Filled", "12", ["M12 6A6 6 0 1 1 0 6a6 6 0 0 1 12 0Z"]);
	const PresenceBusy16Filled = /* @__PURE__ */ createFluentIcon("PresenceBusy16Filled", "16", ["M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0Z"]);
	const PresenceBusy20Filled = /* @__PURE__ */ createFluentIcon("PresenceBusy20Filled", "20", ["M20 10a10 10 0 1 1-20 0 10 10 0 0 1 20 0Z"]);
	const PresenceDnd10Filled = /* @__PURE__ */ createFluentIcon("PresenceDnd10Filled", "10", ["M5 10A5 5 0 1 0 5 0a5 5 0 0 0 0 10ZM3.5 4.5h3a.5.5 0 0 1 0 1h-3a.5.5 0 0 1 0-1Z"]);
	const PresenceDnd10Regular = /* @__PURE__ */ createFluentIcon("PresenceDnd10Regular", "10", ["M5 0a5 5 0 1 0 0 10A5 5 0 0 0 5 0ZM1 5a4 4 0 1 1 8 0 4 4 0 0 1-8 0Zm2 0c0-.28.22-.5.5-.5h3a.5.5 0 0 1 0 1h-3A.5.5 0 0 1 3 5Z"]);
	const PresenceDnd12Filled = /* @__PURE__ */ createFluentIcon("PresenceDnd12Filled", "12", ["M6 12A6 6 0 1 0 6 0a6 6 0 0 0 0 12ZM3.75 5.25h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5Z"]);
	const PresenceDnd12Regular = /* @__PURE__ */ createFluentIcon("PresenceDnd12Regular", "12", ["M6 0a6 6 0 1 0 0 12A6 6 0 0 0 6 0ZM1.5 6a4.5 4.5 0 1 1 9 0 4.5 4.5 0 0 1-9 0ZM3 6c0-.41.34-.75.75-.75h4.5a.75.75 0 0 1 0 1.5h-4.5A.75.75 0 0 1 3 6Z"]);
	const PresenceDnd16Filled = /* @__PURE__ */ createFluentIcon("PresenceDnd16Filled", "16", ["M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16ZM5.25 7h5.5a1 1 0 1 1 0 2h-5.5a1 1 0 1 1 0-2Z"]);
	const PresenceDnd16Regular = /* @__PURE__ */ createFluentIcon("PresenceDnd16Regular", "16", ["M5.25 7a1 1 0 0 0 0 2h5.5a1 1 0 1 0 0-2h-5.5ZM0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6a6 6 0 1 0 0 12A6 6 0 0 0 8 2Z"]);
	const PresenceDnd20Filled = /* @__PURE__ */ createFluentIcon("PresenceDnd20Filled", "20", ["M10 20a10 10 0 1 0 0-20 10 10 0 0 0 0 20ZM7 9h6a1 1 0 1 1 0 2H7a1 1 0 1 1 0-2Z"]);
	const PresenceDnd20Regular = /* @__PURE__ */ createFluentIcon("PresenceDnd20Regular", "20", ["M10 0a10 10 0 1 0 0 20 10 10 0 0 0 0-20ZM2 10a8 8 0 1 1 16 0 8 8 0 0 1-16 0Zm4 0a1 1 0 0 1 1-1h6a1 1 0 1 1 0 2H7a1 1 0 0 1-1-1Z"]);
	const PresenceOffline10Regular = /* @__PURE__ */ createFluentIcon("PresenceOffline10Regular", "10", ["M6.85 3.15c.2.2.2.5 0 .7L5.71 5l1.14 1.15a.5.5 0 1 1-.7.7L5 5.71 3.85 6.85a.5.5 0 1 1-.7-.7L4.29 5 3.15 3.85a.5.5 0 1 1 .7-.7L5 4.29l1.15-1.14c.2-.2.5-.2.7 0ZM0 5a5 5 0 1 1 10 0A5 5 0 0 1 0 5Zm5-4a4 4 0 1 0 0 8 4 4 0 0 0 0-8Z"]);
	const PresenceOffline12Regular = /* @__PURE__ */ createFluentIcon("PresenceOffline12Regular", "12", ["M8.03 3.97c.3.3.3.77 0 1.06L7.06 6l.97.97a.75.75 0 0 1-1.06 1.06L6 7.06l-.97.97a.75.75 0 0 1-1.06-1.06L4.94 6l-.97-.97a.75.75 0 0 1 1.06-1.06l.97.97.97-.97c.3-.3.77-.3 1.06 0ZM0 6a6 6 0 1 1 12 0A6 6 0 0 1 0 6Zm6-4.5a4.5 4.5 0 1 0 0 9 4.5 4.5 0 0 0 0-9Z"]);
	const PresenceOffline16Regular = /* @__PURE__ */ createFluentIcon("PresenceOffline16Regular", "16", ["M10.7 5.3a1 1 0 0 1 0 1.4L9.42 8l1.3 1.3a1 1 0 0 1-1.42 1.4L8 9.42l-1.3 1.3a1 1 0 0 1-1.4-1.42L6.58 8l-1.3-1.3a1 1 0 0 1 1.42-1.4L8 6.58l1.3-1.3a1 1 0 0 1 1.4 0ZM0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6a6 6 0 1 0 0 12A6 6 0 0 0 8 2Z"]);
	const PresenceOffline20Regular = /* @__PURE__ */ createFluentIcon("PresenceOffline20Regular", "20", ["M13.7 6.3a1 1 0 0 1 0 1.4L11.42 10l2.3 2.3a1 1 0 0 1-1.42 1.4L10 11.42l-2.3 2.3a1 1 0 0 1-1.4-1.42L8.58 10l-2.3-2.3a1 1 0 0 1 1.42-1.4L10 8.58l2.3-2.3a1 1 0 0 1 1.4 0ZM0 10a10 10 0 1 1 20 0 10 10 0 0 1-20 0Zm10-8a8 8 0 1 0 0 16 8 8 0 0 0 0-16Z"]);
	const PresenceOof10Regular = /* @__PURE__ */ createFluentIcon("PresenceOof10Regular", "10", ["M5.35 3.85a.5.5 0 1 0-.7-.7l-1.5 1.5a.5.5 0 0 0 0 .7l1.5 1.5a.5.5 0 1 0 .7-.7L4.7 5.5h1.8a.5.5 0 1 0 0-1H4.7l.65-.65ZM5 0a5 5 0 1 0 0 10A5 5 0 0 0 5 0ZM1 5a4 4 0 1 1 8 0 4 4 0 0 1-8 0Z"]);
	const PresenceOof12Regular = /* @__PURE__ */ createFluentIcon("PresenceOof12Regular", "12", ["M6.28 4.53a.75.75 0 0 0-1.06-1.06l-2 2c-.3.3-.3.77 0 1.06l2 2a.75.75 0 0 0 1.06-1.06l-.72-.72h2.69a.75.75 0 1 0 0-1.5h-2.7l.73-.72ZM6 0a6 6 0 1 0 0 12A6 6 0 0 0 6 0ZM1.5 6a4.5 4.5 0 1 1 9 0 4.5 4.5 0 0 1-9 0Z"]);
	const PresenceOof16Regular = /* @__PURE__ */ createFluentIcon("PresenceOof16Regular", "16", ["M8.2 6.2a1 1 0 1 0-1.4-1.4L4.3 7.3a1 1 0 0 0 0 1.4l2.5 2.5a1 1 0 0 0 1.4-1.4L7.42 9H11a1 1 0 1 0 0-2H7.41l.8-.8ZM8 0a8 8 0 1 0 0 16A8 8 0 0 0 8 0ZM2 8a6 6 0 1 1 12 0A6 6 0 0 1 2 8Z"]);
	const PresenceOof20Regular = /* @__PURE__ */ createFluentIcon("PresenceOof20Regular", "20", ["M10.7 7.7A1 1 0 1 0 9.28 6.3l-3 3a1 1 0 0 0 0 1.41l3 3a1 1 0 1 0 1.42-1.41l-1.3-1.3H13a1 1 0 1 0 0-2H9.4l1.3-1.29ZM10 0a10 10 0 1 0 0 20 10 10 0 0 0 0-20ZM2 10a8 8 0 1 1 16 0 8 8 0 0 1-16 0Z"]);
	const PresenceUnknown10Regular = /* @__PURE__ */ createFluentIcon("PresenceUnknown10Regular", "10", ["M5 1a4 4 0 1 0 0 8 4 4 0 0 0 0-8ZM0 5a5 5 0 1 1 10 0A5 5 0 0 1 0 5Z"]);
	const PresenceUnknown12Regular = /* @__PURE__ */ createFluentIcon("PresenceUnknown12Regular", "12", ["M6 1.5a4.5 4.5 0 1 0 0 9 4.5 4.5 0 0 0 0-9ZM0 6a6 6 0 1 1 12 0A6 6 0 0 1 0 6Z"]);
	const PresenceUnknown16Regular = /* @__PURE__ */ createFluentIcon("PresenceUnknown16Regular", "16", ["M8 2a6 6 0 1 0 0 12A6 6 0 0 0 8 2ZM0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Z"]);
	const PresenceUnknown20Regular = /* @__PURE__ */ createFluentIcon("PresenceUnknown20Regular", "20", ["M10 2a8 8 0 1 0 0 16 8 8 0 0 0 0-16ZM0 10a10 10 0 1 1 20 0 10 10 0 0 1-20 0Z"]);

//#endregion
//#region node_modules/@fluentui/react-icons/lib/sizedIcons/chunk-24.js
	const Checkmark12Filled = /* @__PURE__ */ createFluentIcon("Checkmark12Filled", "12", ["M9.76 3.2c.3.29.32.76.04 1.06l-4.25 4.5a.75.75 0 0 1-1.08.02L2.22 6.53a.75.75 0 0 1 1.06-1.06l1.7 1.7L8.7 3.24a.75.75 0 0 1 1.06-.04Z"]);
	const Checkmark16Filled = /* @__PURE__ */ createFluentIcon("Checkmark16Filled", "16", ["M14.05 3.49c.28.3.27.77-.04 1.06l-7.93 7.47A.85.85 0 0 1 4.9 12L2.22 9.28a.75.75 0 1 1 1.06-1.06l2.24 2.27 7.47-7.04a.75.75 0 0 1 1.06.04Z"]);
	const CheckmarkCircle12Filled = /* @__PURE__ */ createFluentIcon("CheckmarkCircle12Filled", "12", ["M1 6a5 5 0 1 1 10 0A5 5 0 0 1 1 6Zm7.35-.9a.5.5 0 1 0-.7-.7L5.5 6.54 4.35 5.4a.5.5 0 1 0-.7.7l1.5 1.5c.2.2.5.2.7 0l2.5-2.5Z"]);
	const ChevronDown16Regular = /* @__PURE__ */ createFluentIcon("ChevronDown16Regular", "16", ["M3.15 5.65c.2-.2.5-.2.7 0L8 9.79l4.15-4.14a.5.5 0 0 1 .7.7l-4.5 4.5a.5.5 0 0 1-.7 0l-4.5-4.5a.5.5 0 0 1 0-.7Z"]);
	const ChevronDown20Regular = /* @__PURE__ */ createFluentIcon("ChevronDown20Regular", "20", ["M15.85 7.65c.2.2.2.5 0 .7l-5.46 5.49a.55.55 0 0 1-.78 0L4.15 8.35a.5.5 0 1 1 .7-.7L10 12.8l5.15-5.16c.2-.2.5-.2.7 0Z"]);
	const ChevronRight12Regular = /* @__PURE__ */ createFluentIcon("ChevronRight12Regular", "12", ["M4.65 2.15a.5.5 0 0 0 0 .7L7.79 6 4.65 9.15a.5.5 0 1 0 .7.7l3.5-3.5a.5.5 0 0 0 0-.7l-3.5-3.5a.5.5 0 0 0-.7 0Z"]);
	const ChevronUp16Regular = /* @__PURE__ */ createFluentIcon("ChevronUp16Regular", "16", ["M3.15 10.35c.2.2.5.2.7 0L8 6.21l4.15 4.14a.5.5 0 0 0 .7-.7l-4.5-4.5a.5.5 0 0 0-.7 0l-4.5 4.5a.5.5 0 0 0 0 .7Z"]);

//#endregion
//#region node_modules/@fluentui/react-icons/lib/sizedIcons/chunk-25.js
	const Square12Filled = /* @__PURE__ */ createFluentIcon("Square12Filled", "12", ["M2 4c0-1.1.9-2 2-2h4a2 2 0 0 1 2 2v4a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V4Z"]);
	const Square16Filled = /* @__PURE__ */ createFluentIcon("Square16Filled", "16", ["M2 4.5A2.5 2.5 0 0 1 4.5 2h7A2.5 2.5 0 0 1 14 4.5v7a2.5 2.5 0 0 1-2.5 2.5h-7A2.5 2.5 0 0 1 2 11.5v-7Z"]);

//#endregion
//#region node_modules/@fluentui/react-icons/lib/sizedIcons/chunk-26.js
	const ErrorCircle12Filled = /* @__PURE__ */ createFluentIcon("ErrorCircle12Filled", "12", ["M6 11A5 5 0 1 0 6 1a5 5 0 0 0 0 10Zm-.75-2.75a.75.75 0 1 1 1.5 0 .75.75 0 0 1-1.5 0Zm.26-4.84a.5.5 0 0 1 .98 0l.01.09v2.59a.5.5 0 0 1-1 0V3.41Z"]);

//#endregion
//#region node_modules/@fluentui/react-icons/lib/sizedIcons/chunk-28.js
	const Dismiss12Regular = /* @__PURE__ */ createFluentIcon("Dismiss12Regular", "12", ["m2.09 2.22.06-.07a.5.5 0 0 1 .63-.06l.07.06L6 5.29l3.15-3.14a.5.5 0 1 1 .7.7L6.71 6l3.14 3.15c.18.17.2.44.06.63l-.06.07a.5.5 0 0 1-.63.06l-.07-.06L6 6.71 2.85 9.85a.5.5 0 0 1-.7-.7L5.29 6 2.15 2.85a.5.5 0 0 1-.06-.63l.06-.07-.06.07Z"]);
	const Dismiss20Regular = /* @__PURE__ */ createFluentIcon("Dismiss20Regular", "20", ["m4.09 4.22.06-.07a.5.5 0 0 1 .63-.06l.07.06L10 9.29l5.15-5.14a.5.5 0 0 1 .63-.06l.07.06c.18.17.2.44.06.63l-.06.07L10.71 10l5.14 5.15c.18.17.2.44.06.63l-.06.07a.5.5 0 0 1-.63.06l-.07-.06L10 10.71l-5.15 5.14a.5.5 0 0 1-.63.06l-.07-.06a.5.5 0 0 1-.06-.63l.06-.07L9.29 10 4.15 4.85a.5.5 0 0 1-.06-.63l.06-.07-.06.07Z"]);

//#endregion
//#region node_modules/@fluentui/react-icons/lib/utils/constants.js
	const iconFilledClassName = "fui-Icon-filled";
	const iconRegularClassName = "fui-Icon-regular";

//#endregion
//#region node_modules/@fluentui/react-icons/lib/utils/bundleIcon.styles.js
	const useBundledIconStyles = __styles({
		"root": { "mc9l5x": "fjseox" },
		"visible": { "mc9l5x": "f1w7gpdv" }
	}, { "d": [".fjseox{display:none;}", ".f1w7gpdv{display:inline;}"] });

//#endregion
//#region node_modules/@fluentui/react-icons/lib/utils/bundleIcon.js
	const bundleIcon = (FilledIcon, RegularIcon) => {
		const Component = (props) => {
			const { className, filled, ...rest } = props;
			const styles = useBundledIconStyles();
			return react.createElement(react.Fragment, null, react.createElement(FilledIcon, Object.assign({}, rest, { className: mergeClasses(styles.root, filled && styles.visible, iconFilledClassName, className) })), react.createElement(RegularIcon, Object.assign({}, rest, { className: mergeClasses(styles.root, !filled && styles.visible, iconRegularClassName, className) })));
		};
		Component.displayName = "CompoundIcon";
		return Component;
	};
	var bundleIcon_default = bundleIcon;

//#endregion
//#region node_modules/@fluentui/react-motion/lib/motions/motionTokens.js
	const durations$1 = {
		durationUltraFast: 50,
		durationFaster: 100,
		durationFast: 150,
		durationNormal: 200,
		durationGentle: 250,
		durationSlow: 300,
		durationSlower: 400,
		durationUltraSlow: 500
	};
	const curves = {
		curveAccelerateMax: "cubic-bezier(0.9,0.1,1,0.2)",
		curveAccelerateMid: "cubic-bezier(1,0,1,1)",
		curveAccelerateMin: "cubic-bezier(0.8,0,0.78,1)",
		curveDecelerateMax: "cubic-bezier(0.1,0.9,0.2,1)",
		curveDecelerateMid: "cubic-bezier(0,0,0,1)",
		curveDecelerateMin: "cubic-bezier(0.33,0,0.1,1)",
		curveEasyEaseMax: "cubic-bezier(0.8,0,0.2,1)",
		curveEasyEase: "cubic-bezier(0.33,0,0.67,1)",
		curveLinear: "cubic-bezier(0,0,1,1)"
	};
	const motionTokens = {
		...durations$1,
		...curves
	};

//#endregion
//#region node_modules/@fluentui/react-motion/lib/utils/isAnimationRunning.js
/**
	* Checks if the animation is running at the moment.
	*/ function isAnimationRunning(animation) {
		if (animation.playState === "running") {
			var _animation_effect;
			if (animation.overallProgress !== void 0) {
				var _animation_overallProgress;
				const overallProgress = (_animation_overallProgress = animation.overallProgress) !== null && _animation_overallProgress !== void 0 ? _animation_overallProgress : 0;
				return overallProgress > 0 && overallProgress < 1;
			}
			var _animation_currentTime;
			const currentTime = Number((_animation_currentTime = animation.currentTime) !== null && _animation_currentTime !== void 0 ? _animation_currentTime : 0);
			var _animation_effect_getTiming_duration;
			const totalTime = Number((_animation_effect_getTiming_duration = (_animation_effect = animation.effect) === null || _animation_effect === void 0 ? void 0 : _animation_effect.getTiming().duration) !== null && _animation_effect_getTiming_duration !== void 0 ? _animation_effect_getTiming_duration : 0);
			return currentTime > 0 && currentTime < totalTime;
		}
		return false;
	}

//#endregion
//#region node_modules/@fluentui/react-motion/lib/hooks/useAnimateAtoms.js
	const DEFAULT_ANIMATION_OPTIONS = { fill: "forwards" };
	const DEFAULT_REDUCED_MOTION_ATOM = { duration: 1 };
	function useAnimateAtomsInSupportedEnvironment() {
		var _window_Animation;
		const SUPPORTS_PERSIST = typeof window !== "undefined" && typeof ((_window_Animation = window.Animation) === null || _window_Animation === void 0 ? void 0 : _window_Animation.prototype.persist) === "function";
		return react.useCallback((element, value, options) => {
			const atoms = Array.isArray(value) ? value : [value];
			const { isReducedMotion } = options;
			const animations = atoms.map((motion) => {
				const { keyframes: motionKeyframes, reducedMotion = DEFAULT_REDUCED_MOTION_ATOM, ...params } = motion;
				const { keyframes: reducedMotionKeyframes = motionKeyframes, ...reducedMotionParams } = reducedMotion;
				const animationKeyframes = isReducedMotion ? reducedMotionKeyframes : motionKeyframes;
				const animationParams = {
					...DEFAULT_ANIMATION_OPTIONS,
					...params,
					...isReducedMotion && reducedMotionParams
				};
				try {
					const animation = element.animate(animationKeyframes, animationParams);
					if (SUPPORTS_PERSIST) animation === null || animation === void 0 || animation.persist();
					else {
						const resultKeyframe = animationKeyframes[animationKeyframes.length - 1];
						var _element_style;
						Object.assign((_element_style = element.style) !== null && _element_style !== void 0 ? _element_style : {}, resultKeyframe);
					}
					return animation;
				} catch (e) {
					return null;
				}
			}).filter((animation) => !!animation);
			return {
				set playbackRate(rate) {
					animations.forEach((animation) => {
						animation.playbackRate = rate;
					});
				},
				setMotionEndCallbacks(onfinish, oncancel) {
					const promises = animations.map((animation) => {
						return new Promise((resolve, reject) => {
							animation.onfinish = () => resolve();
							animation.oncancel = () => reject();
						});
					});
					Promise.all(promises).then(() => {
						onfinish();
					}).catch(() => {
						oncancel();
					});
				},
				isRunning() {
					return animations.some((animation) => isAnimationRunning(animation));
				},
				cancel: () => {
					animations.forEach((animation) => {
						animation.cancel();
					});
				},
				pause: () => {
					animations.forEach((animation) => {
						animation.pause();
					});
				},
				play: () => {
					animations.forEach((animation) => {
						animation.play();
					});
				},
				finish: () => {
					animations.forEach((animation) => {
						animation.finish();
					});
				},
				reverse: () => {
					animations.forEach((animation) => {
						animation.reverse();
					});
				}
			};
		}, [SUPPORTS_PERSIST]);
	}
	/**
	* @internal
	*/ function useAnimateAtoms() {
		"use no memo";
		return useAnimateAtomsInSupportedEnvironment();
	}

//#endregion
//#region node_modules/@fluentui/react-motion/lib/hooks/useMotionImperativeRef.js
	function useMotionImperativeRef(imperativeRef) {
		const animationRef = react.useRef(void 0);
		react.useImperativeHandle(imperativeRef, () => ({
			setPlayState: (state) => {
				if (state === "running") {
					var _animationRef_current;
					(_animationRef_current = animationRef.current) === null || _animationRef_current === void 0 || _animationRef_current.play();
				}
				if (state === "paused") {
					var _animationRef_current1;
					(_animationRef_current1 = animationRef.current) === null || _animationRef_current1 === void 0 || _animationRef_current1.pause();
				}
			},
			setPlaybackRate: (rate) => {
				if (animationRef.current) animationRef.current.playbackRate = rate;
			}
		}));
		return animationRef;
	}

//#endregion
//#region node_modules/@fluentui/react-motion/lib/hooks/useIsReducedMotion.js
	const REDUCED_MEDIA_QUERY = "screen and (prefers-reduced-motion: reduce)";
	function useIsReducedMotion() {
		const { targetDocument } = useFluent();
		var _targetDocument_defaultView;
		const targetWindow = (_targetDocument_defaultView = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView) !== null && _targetDocument_defaultView !== void 0 ? _targetDocument_defaultView : null;
		const queryValue = react.useRef(false);
		const isEnabled = react.useCallback(() => queryValue.current, []);
		useIsomorphicLayoutEffect(() => {
			if (targetWindow === null || typeof targetWindow.matchMedia !== "function") return;
			const queryMatch = targetWindow.matchMedia(REDUCED_MEDIA_QUERY);
			if (queryMatch.matches) queryValue.current = true;
			const matchListener = (e) => {
				queryValue.current = e.matches;
			};
			queryMatch.addEventListener("change", matchListener);
			return () => {
				queryMatch.removeEventListener("change", matchListener);
			};
		}, [targetWindow]);
		return isEnabled;
	}

//#endregion
//#region node_modules/@fluentui/react-motion/lib/utils/useChildElement.js
	const CHILD_ERROR_MESSAGE = [
		"@fluentui/react-motion: Invalid child element.",
		"\n",
		"Motion factories require a single child element to be passed. ",
		"That element element should support ref forwarding i.e. it should be either an intrinsic element (e.g. div) or a component that uses React.forwardRef()."
	].join("");
	/**
	* Validates the child and returns a cloned child element with a ref.
	*
	* Throws an error if the child is not a valid React element, similar to "React.Children.only".
	* Logs a warning in development mode if the ref is not set as the component remains functional.
	*/ function useChildElement(children, mounted = true) {
		const childRef = react.useRef(null);
		react.useEffect(() => {
			if (mounted && !childRef.current) console.error(CHILD_ERROR_MESSAGE);
		}, [mounted]);
		try {
			const child = react.Children.only(children);
			if (react.isValidElement(child)) return [react.cloneElement(child, { ref: useMergedRefs(childRef, getReactElementRef(child)) }), childRef];
		} catch {}
		throw new Error(CHILD_ERROR_MESSAGE);
	}

//#endregion
//#region node_modules/@fluentui/react-motion/lib/contexts/MotionBehaviourContext.js
	const MotionBehaviourContext = react.createContext(void 0);
	const MotionBehaviourProvider = MotionBehaviourContext.Provider;
	const useMotionBehaviourContext = () => {
		var _React_useContext;
		return (_React_useContext = react.useContext(MotionBehaviourContext)) !== null && _React_useContext !== void 0 ? _React_useContext : "default";
	};

//#endregion
//#region node_modules/@fluentui/react-motion/lib/factories/createMotionComponent.js
/**
	* @internal A private symbol to store the motion definition on the component for variants.
	*/ const MOTION_DEFINITION = Symbol("MOTION_DEFINITION");
	/**
	* Creates a component that will animate the children using the provided motion.
	*
	* @param value - A motion definition.
	*/ function createMotionComponent(value) {
		const Atom = (props) => {
			"use no memo";
			const { children, imperativeRef, onMotionFinish: onMotionFinishProp, onMotionStart: onMotionStartProp, onMotionCancel: onMotionCancelProp, ..._rest } = props;
			const params = _rest;
			const [child, childRef] = useChildElement(children);
			const handleRef = useMotionImperativeRef(imperativeRef);
			const skipMotions = useMotionBehaviourContext() === "skip";
			const optionsRef = react.useRef({
				skipMotions,
				params
			});
			const animateAtoms = useAnimateAtoms();
			const isReducedMotion = useIsReducedMotion();
			const onMotionStart = useEventCallback(() => {
				onMotionStartProp === null || onMotionStartProp === void 0 || onMotionStartProp(null);
			});
			const onMotionFinish = useEventCallback(() => {
				onMotionFinishProp === null || onMotionFinishProp === void 0 || onMotionFinishProp(null);
			});
			const onMotionCancel = useEventCallback(() => {
				onMotionCancelProp === null || onMotionCancelProp === void 0 || onMotionCancelProp(null);
			});
			useIsomorphicLayoutEffect(() => {
				optionsRef.current = {
					skipMotions,
					params
				};
			});
			useIsomorphicLayoutEffect(() => {
				const element = childRef.current;
				if (element) {
					const atoms = typeof value === "function" ? value({
						element,
						...optionsRef.current.params
					}) : value;
					onMotionStart();
					const handle = animateAtoms(element, atoms, { isReducedMotion: isReducedMotion() });
					handleRef.current = handle;
					handle.setMotionEndCallbacks(onMotionFinish, onMotionCancel);
					if (optionsRef.current.skipMotions) handle.finish();
					return () => {
						handle.cancel();
					};
				}
			}, [
				animateAtoms,
				childRef,
				handleRef,
				isReducedMotion,
				onMotionFinish,
				onMotionStart,
				onMotionCancel
			]);
			return child;
		};
		return Object.assign(Atom, { [MOTION_DEFINITION]: typeof value === "function" ? value : () => value });
	}

//#endregion
//#region node_modules/@fluentui/react-motion/lib/factories/createMotionComponentVariant.js
/**
	* @internal
	*
	* Create a variant function that wraps a motion function to customize it.
	* The new motion function has the supplied variant params as defaults,
	* but these can still be overridden by runtime params when the new function is called.
	*/ function createMotionFnVariant(motionFn, variantParams) {
		const variantFn = (runtimeParams) => motionFn({
			...variantParams,
			...runtimeParams
		});
		return variantFn;
	}
	/**
	* Create a new motion component based on another motion component,
	* using the provided variant parameters as defaults.
	*
	* @param component - A component created by `createMotionComponent`.
	* @param variantParams - An object containing the variant parameters to be used as defaults.
	* The variant parameters should match the type of the component's motion parameters.
	* @returns A new motion component that uses the provided variant parameters as defaults.
	* The new component can still accept runtime parameters that override the defaults.
	*/ function createMotionComponentVariant(component, variantParams) {
		const originalFn = component[MOTION_DEFINITION];
		return createMotionComponent(createMotionFnVariant(originalFn, variantParams));
	}

//#endregion
//#region node_modules/@fluentui/react-motion/lib/contexts/PresenceGroupChildContext.js
/**
	* @internal
	*/ const PresenceGroupChildContext = react.createContext(void 0);
	const PresenceGroupChildProvider = PresenceGroupChildContext.Provider;

//#endregion
//#region node_modules/@fluentui/react-motion/lib/hooks/useMountedState.js
/**
	* This hook manages the mounted state of a component, based on the "visible" and "unmountOnExit" props.
	* It simulates the behavior of getDerivedStateFromProps(), which is not available in functional components.
	*/ function useMountedState(visible = false, unmountOnExit = false) {
		const mountedRef = react.useRef(unmountOnExit ? visible : true);
		const forceUpdate = useForceUpdate();
		const setMounted = react.useCallback((newValue) => {
			if (mountedRef.current !== newValue) {
				mountedRef.current = newValue;
				forceUpdate();
			}
		}, [forceUpdate]);
		react.useEffect(() => {
			if (visible) mountedRef.current = visible;
		});
		return [visible || mountedRef.current, setMounted];
	}

//#endregion
//#region node_modules/@fluentui/react-motion/lib/factories/createPresenceComponent.js
/**
	* @internal A private symbol to store the motion definition on the component for variants.
	*/ const PRESENCE_MOTION_DEFINITION = Symbol("PRESENCE_MOTION_DEFINITION");
	const INTERRUPTABLE_MOTION_SYMBOL = Symbol.for("interruptablePresence");
	function createPresenceComponent(value) {
		return Object.assign((props) => {
			"use no memo";
			const merged = {
				...react.useContext(PresenceGroupChildContext),
				...props
			};
			const skipMotions = useMotionBehaviourContext() === "skip";
			const { appear, children, imperativeRef, onExit, onMotionFinish, onMotionStart, onMotionCancel, visible, unmountOnExit, ..._rest } = merged;
			const params = _rest;
			const [mounted, setMounted] = useMountedState(visible, unmountOnExit);
			const [child, childRef] = useChildElement(children, mounted);
			const handleRef = useMotionImperativeRef(imperativeRef);
			const optionsRef = react.useRef({
				appear,
				params,
				skipMotions
			});
			const animateAtoms = useAnimateAtoms();
			const isFirstMount = useFirstMount();
			const isReducedMotion = useIsReducedMotion();
			const handleMotionStart = useEventCallback((direction) => {
				onMotionStart === null || onMotionStart === void 0 || onMotionStart(null, { direction });
			});
			const handleMotionFinish = useEventCallback((direction) => {
				onMotionFinish === null || onMotionFinish === void 0 || onMotionFinish(null, { direction });
				if (direction === "exit" && unmountOnExit) {
					setMounted(false);
					onExit === null || onExit === void 0 || onExit();
				}
			});
			const handleMotionCancel = useEventCallback((direction) => {
				onMotionCancel === null || onMotionCancel === void 0 || onMotionCancel(null, { direction });
			});
			useIsomorphicLayoutEffect(() => {
				optionsRef.current = {
					appear,
					params,
					skipMotions
				};
			});
			useIsomorphicLayoutEffect(() => {
				const element = childRef.current;
				if (!element) return;
				let handle;
				function cleanup() {
					if (!handle) return;
					if (IS_EXPERIMENTAL_INTERRUPTIBLE_MOTION && handle.isRunning()) return;
					handle.cancel();
					handleRef.current = void 0;
				}
				const presenceMotion = typeof value === "function" ? value({
					element,
					...optionsRef.current.params
				}) : value;
				const IS_EXPERIMENTAL_INTERRUPTIBLE_MOTION = presenceMotion[INTERRUPTABLE_MOTION_SYMBOL];
				if (IS_EXPERIMENTAL_INTERRUPTIBLE_MOTION) {
					handle = handleRef.current;
					if (handle && handle.isRunning()) {
						handle.reverse();
						return cleanup;
					}
				}
				const atoms = visible ? presenceMotion.enter : presenceMotion.exit;
				const direction = visible ? "enter" : "exit";
				const applyInitialStyles = !optionsRef.current.appear && isFirstMount;
				const skipAnimationByConfig = optionsRef.current.skipMotions;
				if (!applyInitialStyles) handleMotionStart(direction);
				handle = animateAtoms(element, atoms, { isReducedMotion: isReducedMotion() });
				if (applyInitialStyles) {
					handle.finish();
					return cleanup;
				}
				handleRef.current = handle;
				handle.setMotionEndCallbacks(() => handleMotionFinish(direction), () => handleMotionCancel(direction));
				if (skipAnimationByConfig) handle.finish();
				return cleanup;
			}, [
				animateAtoms,
				childRef,
				handleRef,
				isReducedMotion,
				handleMotionFinish,
				handleMotionStart,
				handleMotionCancel,
				visible
			]);
			if (mounted) return child;
			return null;
		}, { [PRESENCE_MOTION_DEFINITION]: typeof value === "function" ? value : () => value }, {
			In: createMotionComponent(typeof value === "function" ? (...args) => value(...args).enter : value.enter),
			Out: createMotionComponent(typeof value === "function" ? (...args) => value(...args).exit : value.exit)
		});
	}

//#endregion
//#region node_modules/@fluentui/react-motion/lib/factories/createPresenceComponentVariant.js
/**
	* @internal
	*
	* Create a variant function that wraps a presence function to customize it.
	* The new presence function has the supplied variant params as defaults,
	* but these can still be overridden by runtime params when the new function is called.
	*/ function createPresenceFnVariant(presenceFn, variantParams) {
		const variantFn = (runtimeParams) => presenceFn({
			...variantParams,
			...runtimeParams
		});
		return variantFn;
	}
	/**
	* Create a new presence component based on another presence component,
	* using the provided variant parameters as defaults.
	*
	* @param component - A component created by `createPresenceComponent`.
	* @param variantParams - An object containing the variant parameters to be used as defaults.
	* The variant parameters should match the type of the component's motion parameters.
	* @returns A new presence component that uses the provided variant parameters as defaults.
	* The new component can still accept runtime parameters that override the defaults.
	*/ function createPresenceComponentVariant(component, variantParams) {
		const originalFn = component[PRESENCE_MOTION_DEFINITION];
		return createPresenceComponent(createPresenceFnVariant(originalFn, variantParams));
	}

//#endregion
//#region node_modules/@swc/helpers/esm/_define_property.js
	function _define_property(obj, key, value) {
		if (key in obj) Object.defineProperty(obj, key, {
			value,
			enumerable: true,
			configurable: true,
			writable: true
		});
		else obj[key] = value;
		return obj;
	}

//#endregion
//#region node_modules/@fluentui/react-motion/lib/utils/groups/mergeChildMappings.js
/**
	* When you're adding or removing children some may be added or removed in the same render pass. We want to show *both*
	* since we want to simultaneously animate elements in and out. This function takes a previous set of keys and a new set
	* of keys and merges them with its best guess of the correct ordering.
	*/ function mergeChildMappings(prevMapping, nextMapping) {
		function getValueForKey(key) {
			return key in nextMapping ? nextMapping[key] : prevMapping[key];
		}
		const nextKeysPending = {};
		let pendingKeys = [];
		for (const prevKey in prevMapping) {
			if (prevKey in nextMapping) {
				if (pendingKeys.length) {
					nextKeysPending[prevKey] = pendingKeys;
					pendingKeys = [];
				}
				continue;
			}
			pendingKeys.push(prevKey);
		}
		const childMapping = {};
		for (const nextKey in nextMapping) {
			if (nextKeysPending[nextKey]) for (const pendingNextKey of nextKeysPending[nextKey]) childMapping[pendingNextKey] = getValueForKey(pendingNextKey);
			childMapping[nextKey] = getValueForKey(nextKey);
		}
		for (const pendingKey of pendingKeys) childMapping[pendingKey] = getValueForKey(pendingKey);
		return childMapping;
	}

//#endregion
//#region node_modules/@fluentui/react-motion/lib/utils/groups/getNextChildMapping.js
	function getNextChildMapping(prevChildMapping, nextChildMapping) {
		const childrenMapping = mergeChildMappings(prevChildMapping, nextChildMapping);
		Object.entries(childrenMapping).forEach(([key, childDefinition]) => {
			const hasPrev = key in prevChildMapping;
			if (key in nextChildMapping) {
				if (hasPrev) {
					childrenMapping[key] = { ...childDefinition };
					return;
				}
				childrenMapping[key] = {
					...childDefinition,
					appear: true,
					visible: true
				};
				return;
			}
			childrenMapping[key] = {
				...childDefinition,
				visible: false
			};
		});
		return childrenMapping;
	}

//#endregion
//#region node_modules/@fluentui/react-motion/lib/utils/groups/getChildMapping.js
/**
	* Given `children`, return an object mapping key to child.
	*/ function getChildMapping(children) {
		const childMapping = {};
		if (children) react.Children.toArray(children).forEach((child) => {
			if (react.isValidElement(child)) {
				var _child_key;
				childMapping[(_child_key = child.key) !== null && _child_key !== void 0 ? _child_key : ""] = {
					appear: false,
					element: child,
					visible: true,
					unmountOnExit: true
				};
			}
		});
		return childMapping;
	}

//#endregion
//#region node_modules/@fluentui/react-motion/lib/components/PresenceGroupItemProvider.js
/**
	* @internal
	*
	* Provides context for a single child of a `PresenceGroup`. Exists only to make a stable context value for a child.
	* Not intended for direct use.
	*/ const PresenceGroupItemProvider = (props) => {
		const { appear, childKey, onExit, visible, unmountOnExit } = props;
		const contextValue = react.useMemo(() => ({
			appear,
			visible,
			onExit: () => onExit(childKey),
			unmountOnExit
		}), [
			appear,
			childKey,
			onExit,
			visible,
			unmountOnExit
		]);
		return /* @__PURE__ */ react.createElement(PresenceGroupChildContext.Provider, { value: contextValue }, props.children);
	};

//#endregion
//#region node_modules/@fluentui/react-motion/lib/components/PresenceGroup.js
	var PresenceGroup = class extends react.Component {
		static getDerivedStateFromProps(nextProps, { childMapping: prevChildMapping, firstRender }) {
			const nextChildMapping = getChildMapping(nextProps.children);
			return {
				childMapping: firstRender ? nextChildMapping : getNextChildMapping(prevChildMapping, nextChildMapping),
				firstRender: false
			};
		}
		componentDidMount() {
			this.mounted = true;
		}
		componentWillUnmount() {
			this.mounted = false;
		}
		render() {
			return /* @__PURE__ */ react.createElement(react.Fragment, null, Object.entries(this.state.childMapping).map(([childKey, childProps]) => /* @__PURE__ */ react.createElement(PresenceGroupItemProvider, {
				...childProps,
				childKey,
				key: childKey,
				onExit: this.handleExit
			}, childProps.element)));
		}
		constructor(props, context) {
			super(props, context), _define_property(this, "mounted", false), _define_property(this, "handleExit", (childKey) => {
				if (childKey in getChildMapping(this.props.children)) return;
				if (this.mounted) this.setState((state) => {
					const childMapping = { ...state.childMapping };
					delete childMapping[childKey];
					return { childMapping };
				});
			});
			this.state = {
				childMapping: {},
				firstRender: true
			};
		}
	};

//#endregion
//#region node_modules/@fluentui/react-motion/lib/slots/presenceMotionSlot.js
	function presenceMotionSlot(motion, options) {
		const { as, children, ...rest } = motion !== null && motion !== void 0 ? motion : {};
		if (typeof as !== "undefined") throw new Error(`@fluentui/react-motion: "as" property is not supported on motion slots.`);
		if (motion === null) {
			const isUnmounted = !options.defaultProps.visible && options.defaultProps.unmountOnExit;
			const renderFn = (_, props) => isUnmounted ? null : /* @__PURE__ */ react.createElement(react.Fragment, null, props.children);
			/**
			* Casting is required here as SlotComponentType is a function, not an object.
			* Although SlotComponentType has a function signature, it is still just an object.
			* This is required to make a slot callable (JSX compatible), this is the exact same approach
			* that is used on `@types/react` components
			*/ return {
				[SLOT_RENDER_FUNCTION_SYMBOL]: renderFn,
				[SLOT_ELEMENT_TYPE_SYMBOL]: options.elementType
			};
		}
		/**
		* Casting is required here as SlotComponentType is a function, not an object.
		* Although SlotComponentType has a function signature, it is still just an object.
		* This is required to make a slot callable (JSX compatible), this is the exact same approach
		* that is used on `@types/react` components
		*/ const propsWithMetadata = {
			...options.defaultProps,
			...rest,
			[SLOT_ELEMENT_TYPE_SYMBOL]: options.elementType
		};
		if (typeof children === "function") propsWithMetadata[SLOT_RENDER_FUNCTION_SYMBOL] = children;
		return propsWithMetadata;
	}

//#endregion
//#region node_modules/@fluentui/react-accordion/lib/components/AccordionHeader/useAccordionHeader.js
/**
	* Returns the props and state required to render the component
	* @param props - AccordionHeader properties
	* @param ref - reference to root HTMLElement of AccordionHeader
	*/ const useAccordionHeader_unstable = (props, ref) => {
		const { icon, button, expandIcon, inline = false, size: size$2 = "medium", expandIconPosition = "start" } = props;
		const { value, disabled, open } = useAccordionItemContext_unstable();
		const requestToggle = useAccordionContext_unstable((ctx) => ctx.requestToggle);
		/**
		* force disabled state on button if accordion isn't collapsible
		* and this is the only item opened
		*/ const disabledFocusable = useAccordionContext_unstable((ctx) => !ctx.collapsible && ctx.openItems.length === 1 && open);
		const { dir } = useFluent();
		let expandIconRotation;
		if (expandIconPosition === "end") expandIconRotation = open ? -90 : 90;
		else expandIconRotation = open ? 90 : dir !== "rtl" ? 0 : 180;
		const buttonSlot = always(button, {
			elementType: "button",
			defaultProps: {
				disabled,
				disabledFocusable,
				"aria-expanded": open,
				type: "button"
			}
		});
		buttonSlot.onClick = useEventCallback((event) => {
			if (isResolvedShorthand(button)) {
				var _button_onClick;
				(_button_onClick = button.onClick) === null || _button_onClick === void 0 || _button_onClick.call(button, event);
			}
			if (!event.defaultPrevented) requestToggle({
				value,
				event
			});
		});
		return {
			disabled,
			open,
			size: size$2,
			inline,
			expandIconPosition,
			components: {
				root: "div",
				button: "button",
				expandIcon: "span",
				icon: "div"
			},
			root: always(getIntrinsicElementProps("div", {
				ref,
				...props
			}), { elementType: "div" }),
			icon: optional(icon, { elementType: "div" }),
			expandIcon: optional(expandIcon, {
				renderByDefault: true,
				defaultProps: {
					children: /* @__PURE__ */ react.createElement(ChevronRightRegular, { style: {
						transform: `rotate(${expandIconRotation}deg)`,
						transition: `transform ${motionTokens.durationNormal}ms ease-out`
					} }),
					"aria-hidden": true
				},
				elementType: "span"
			}),
			button: useARIAButtonProps(buttonSlot.as, buttonSlot)
		};
	};

//#endregion
//#region node_modules/@fluentui/react-accordion/lib/contexts/accordionHeader.js
	const AccordionHeaderContext = react.createContext(void 0);
	const { Provider: AccordionHeaderProvider } = AccordionHeaderContext;

//#endregion
//#region node_modules/@fluentui/react-accordion/lib/components/AccordionHeader/renderAccordionHeader.js
/**
	* Function that renders the final JSX of the component
	*/ const renderAccordionHeader_unstable = (state, contextValues) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(AccordionHeaderProvider, {
			value: contextValues.accordionHeader,
			children: /* @__PURE__ */ jsx(state.root, { children: /* @__PURE__ */ jsxs(state.button, { children: [
				state.expandIconPosition === "start" && state.expandIcon && /* @__PURE__ */ jsx(state.expandIcon, {}),
				state.icon && /* @__PURE__ */ jsx(state.icon, {}),
				state.root.children,
				state.expandIconPosition === "end" && state.expandIcon && /* @__PURE__ */ jsx(state.expandIcon, {})
			] }) })
		});
	};

//#endregion
//#region node_modules/@fluentui/react-accordion/lib/components/AccordionHeader/useAccordionHeaderStyles.styles.js
	const accordionHeaderClassNames = {
		root: "fui-AccordionHeader",
		button: "fui-AccordionHeader__button",
		expandIcon: "fui-AccordionHeader__expandIcon",
		icon: "fui-AccordionHeader__icon"
	};
	const useStyles$105 = /* @__PURE__ */ __styles({
		resetButton: {
			B7ck84d: "f1e4lqlz",
			De3pzq: "f1u2r49w",
			sj55zd: "f1ym3bx4",
			Bahqtrf: "f1mo0ibp",
			Be2twd7: "fjoy568",
			Bg96gwp: "fytdu2e",
			B68tc82: 0,
			Bmxbyg5: 0,
			Bpg54ce: "f1gl81tg",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f1mk8lai",
			Bv0vk6g: "f37px4s",
			fsow6f: "fgusgyc"
		},
		focusIndicator: {
			Brovlpu: "ftqa4ok",
			B486eqv: "f2hkw1w",
			B8q5s1w: "f8hki3x",
			Bci5o5g: ["f1d2448m", "ffh67wi"],
			n8qw10: "f1bjia2o",
			Bdrgwmp: ["ffh67wi", "f1d2448m"],
			Bqhya38: "f1j6vpng",
			Bwxa6fj: ["f1pniga2", "f1ffjurs"],
			Bdhvstf: "f987i1v",
			B7zbvrb: ["f1ffjurs", "f1pniga2"],
			Bm4h7ae: "f15bsgw9",
			B7ys5i9: "f14e48fq",
			Busjfv9: "f18yb2kv",
			Bhk32uz: "fd6o370",
			f6g5ot: 0,
			Boxcth7: 0,
			Bhdgwq3: 0,
			hgwjuy: 0,
			Bshpdp8: 0,
			Bsom6fd: 0,
			Blkhhs4: 0,
			Bonggc9: 0,
			Ddfuxk: 0,
			i03rao: 0,
			kclons: 0,
			clg4pj: 0,
			Bpqj9nj: 0,
			B6dhp37: 0,
			Bf4ptjt: 0,
			Bqtpl0w: 0,
			i4rwgc: "ffwy5si",
			Dah5zi: 0,
			B1tsrr9: 0,
			qqdqy8: 0,
			Bkh64rk: 0,
			e3fwne: "f3znvyf",
			J0r882: "f57olzd",
			Bule8hv: ["f4stah7", "fs1por5"],
			Bjwuhne: "f480a47",
			Ghsupd: ["fs1por5", "f4stah7"]
		},
		root: {
			sj55zd: "f19n0e5",
			De3pzq: "f1c21dwh",
			jrapky: 0,
			Frg6f3: 0,
			t21cq0: 0,
			B6of3ja: 0,
			B74szlk: "f1s184ao",
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "ft85np5"
		},
		rootDisabled: {
			Bcmaq0h: "fwrgwhw",
			sj55zd: "f1s2aq7o"
		},
		rootInline: { mc9l5x: "f14t3ns0" },
		button: {
			qhf8xq: "f10pi13n",
			a9b677: "fly5x3f",
			B4j52fo: "fre7gi1",
			Bekrc4i: ["f1358rze", "f1rvrf73"],
			Bn0qgzm: "fqdk4by",
			ibv6hh: ["f1rvrf73", "f1358rze"],
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: ["f1rmphuq", "f26yw9j"],
			sshi5w: "f5pgtk9",
			mc9l5x: "f22iagw",
			Bt984gj: "f122n59",
			Bceei9c: "f1k6fduh",
			Bahqtrf: "fk6fouc",
			Be2twd7: "fkhj508",
			Bhrd7zp: "figsok6",
			Bg96gwp: "f1i3iumi",
			B7ck84d: "f1ewtqcl"
		},
		buttonSmall: {
			sshi5w: "f1nxs5xn",
			Be2twd7: "fy9rknc"
		},
		buttonLarge: {
			Bg96gwp: "faaz57k",
			Be2twd7: "fod5ikn"
		},
		buttonExtraLarge: {
			Bg96gwp: "f106mvju",
			Be2twd7: "f1pp30po"
		},
		buttonInline: { mc9l5x: "ftuwxu6" },
		buttonExpandIconEndNoIcon: { uwmqm3: ["f1uw59to", "fw5db7e"] },
		buttonExpandIconEnd: { z189sj: ["f11gcy0p", "f1ng84yb"] },
		buttonDisabled: { Bceei9c: "fdrzuqr" },
		expandIcon: {
			Bqenvij: "f1l02sjl",
			mc9l5x: "f22iagw",
			Bt984gj: "f122n59",
			Bg96gwp: "f106mvju",
			Be2twd7: "f1pp30po"
		},
		expandIconStart: { z189sj: ["f1vdfbxk", "f1f5gg8d"] },
		expandIconEnd: {
			Bh6795r: "fqerorx",
			Bnnss6s: "f1neuvcm",
			xawz: "flqd7gy",
			mc9l5x: "f22iagw",
			Brf1p80: "f9c4gz4",
			uwmqm3: ["f1f5gg8d", "f1vdfbxk"]
		},
		icon: {
			Bqenvij: "f1l02sjl",
			mc9l5x: "f22iagw",
			Bt984gj: "f122n59",
			z189sj: ["f1vdfbxk", "f1f5gg8d"],
			Bg96gwp: "f106mvju",
			Be2twd7: "f1pp30po"
		}
	}, {
		d: [
			".f1e4lqlz{box-sizing:content-box;}",
			".f1u2r49w{background-color:inherit;}",
			".f1ym3bx4{color:inherit;}",
			".f1mo0ibp{font-family:inherit;}",
			".fjoy568{font-size:inherit;}",
			".fytdu2e{line-height:normal;}",
			[".f1gl81tg{overflow:visible;}", { p: -1 }],
			[".f1mk8lai{padding:0;}", { p: -1 }],
			".f37px4s{-webkit-appearance:button;}",
			".fgusgyc{text-align:unset;}",
			".f8hki3x[data-fui-focus-visible]{border-top-color:transparent;}",
			".f1d2448m[data-fui-focus-visible]{border-right-color:transparent;}",
			".ffh67wi[data-fui-focus-visible]{border-left-color:transparent;}",
			".f1bjia2o[data-fui-focus-visible]{border-bottom-color:transparent;}",
			".f15bsgw9[data-fui-focus-visible]::after{content:\"\";}",
			".f14e48fq[data-fui-focus-visible]::after{position:absolute;}",
			".f18yb2kv[data-fui-focus-visible]::after{pointer-events:none;}",
			".fd6o370[data-fui-focus-visible]::after{z-index:1;}",
			[".ffwy5si[data-fui-focus-visible]::after{border:2px solid var(--colorStrokeFocus2);}", { p: -2 }],
			[".f3znvyf[data-fui-focus-visible]::after{border-radius:var(--borderRadiusMedium);}", { p: -1 }],
			".f57olzd[data-fui-focus-visible]::after{top:calc(2px * -1);}",
			".f4stah7[data-fui-focus-visible]::after{right:calc(2px * -1);}",
			".fs1por5[data-fui-focus-visible]::after{left:calc(2px * -1);}",
			".f480a47[data-fui-focus-visible]::after{bottom:calc(2px * -1);}",
			".f19n0e5{color:var(--colorNeutralForeground1);}",
			".f1c21dwh{background-color:var(--colorTransparentBackground);}",
			[".f1s184ao{margin:0;}", { p: -1 }],
			[".ft85np5{border-radius:var(--borderRadiusMedium);}", { p: -1 }],
			".fwrgwhw{background-image:none;}",
			".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}",
			".f14t3ns0{display:inline-block;}",
			".f10pi13n{position:relative;}",
			".fly5x3f{width:100%;}",
			".fre7gi1{border-top-width:0;}",
			".f1358rze{border-right-width:0;}",
			".f1rvrf73{border-left-width:0;}",
			".fqdk4by{border-bottom-width:0;}",
			[".f1rmphuq{padding:0 var(--spacingHorizontalM) 0 var(--spacingHorizontalMNudge);}", { p: -1 }],
			[".f26yw9j{padding:0 var(--spacingHorizontalMNudge) 0 var(--spacingHorizontalM);}", { p: -1 }],
			".f5pgtk9{min-height:44px;}",
			".f22iagw{display:flex;}",
			".f122n59{align-items:center;}",
			".f1k6fduh{cursor:pointer;}",
			".fk6fouc{font-family:var(--fontFamilyBase);}",
			".fkhj508{font-size:var(--fontSizeBase300);}",
			".figsok6{font-weight:var(--fontWeightRegular);}",
			".f1i3iumi{line-height:var(--lineHeightBase300);}",
			".f1ewtqcl{box-sizing:border-box;}",
			".f1nxs5xn{min-height:32px;}",
			".fy9rknc{font-size:var(--fontSizeBase200);}",
			".faaz57k{line-height:var(--lineHeightBase400);}",
			".fod5ikn{font-size:var(--fontSizeBase400);}",
			".f106mvju{line-height:var(--lineHeightBase500);}",
			".f1pp30po{font-size:var(--fontSizeBase500);}",
			".ftuwxu6{display:inline-flex;}",
			".f1uw59to{padding-left:var(--spacingHorizontalM);}",
			".fw5db7e{padding-right:var(--spacingHorizontalM);}",
			".f11gcy0p{padding-right:var(--spacingHorizontalMNudge);}",
			".f1ng84yb{padding-left:var(--spacingHorizontalMNudge);}",
			".fdrzuqr{cursor:not-allowed;}",
			".f1l02sjl{height:100%;}",
			".f1vdfbxk{padding-right:var(--spacingHorizontalS);}",
			".f1f5gg8d{padding-left:var(--spacingHorizontalS);}",
			".fqerorx{flex-grow:1;}",
			".f1neuvcm{flex-shrink:1;}",
			".flqd7gy{flex-basis:0%;}",
			".f9c4gz4{justify-content:flex-end;}"
		],
		f: [".ftqa4ok:focus{outline-style:none;}"],
		i: [".f2hkw1w:focus-visible{outline-style:none;}"],
		m: [
			["@media (forced-colors: active){.f1j6vpng[data-fui-focus-visible]::after{border-top-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1ffjurs[data-fui-focus-visible]::after{border-left-color:Highlight;}.f1pniga2[data-fui-focus-visible]::after{border-right-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f987i1v[data-fui-focus-visible]::after{border-bottom-color:Highlight;}}", { m: "(forced-colors: active)" }]
		]
	});
	/** Applies style classnames to slots */
	const useAccordionHeaderStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$105();
		state.root.className = mergeClasses(accordionHeaderClassNames.root, styles.root, state.inline && styles.rootInline, state.disabled && styles.rootDisabled, state.root.className);
		state.button.className = mergeClasses(accordionHeaderClassNames.button, styles.resetButton, styles.button, styles.focusIndicator, state.expandIconPosition === "end" && !state.icon && styles.buttonExpandIconEndNoIcon, state.expandIconPosition === "end" && styles.buttonExpandIconEnd, state.inline && styles.buttonInline, state.size === "small" && styles.buttonSmall, state.size === "large" && styles.buttonLarge, state.size === "extra-large" && styles.buttonExtraLarge, state.disabled && styles.buttonDisabled, state.button.className);
		if (state.expandIcon) state.expandIcon.className = mergeClasses(accordionHeaderClassNames.expandIcon, styles.expandIcon, state.expandIconPosition === "start" && styles.expandIconStart, state.expandIconPosition === "end" && styles.expandIconEnd, state.expandIcon.className);
		if (state.icon) state.icon.className = mergeClasses(accordionHeaderClassNames.icon, styles.icon, state.icon.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-accordion/lib/components/AccordionHeader/useAccordionHeaderContextValues.js
	function useAccordionHeaderContextValues_unstable(state) {
		const { disabled, expandIconPosition, open, size: size$2 } = state;
		return { accordionHeader: react.useMemo(() => ({
			disabled,
			expandIconPosition,
			open,
			size: size$2
		}), [
			disabled,
			expandIconPosition,
			open,
			size$2
		]) };
	}

//#endregion
//#region node_modules/@fluentui/react-accordion/lib/components/AccordionHeader/AccordionHeader.js
/**
	* Define a styled AccordionHeader, using the `useAccordionHeader_unstable` and `useAccordionHeaderStyles_unstable`
	* hooks.
	*/ const AccordionHeader = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useAccordionHeader_unstable(props, ref);
		const contextValues = useAccordionHeaderContextValues_unstable(state);
		useAccordionHeaderStyles_unstable(state);
		useCustomStyleHook("useAccordionHeaderStyles_unstable")(state);
		return renderAccordionHeader_unstable(state, contextValues);
	});
	AccordionHeader.displayName = "AccordionHeader";

//#endregion
//#region node_modules/@fluentui/react-motion-components-preview/lib/components/Collapse/collapse-atoms.js
	const sizeValuesForOrientation = (orientation, element) => {
		return {
			sizeName: orientation === "horizontal" ? "maxWidth" : "maxHeight",
			overflowName: orientation === "horizontal" ? "overflowX" : "overflowY",
			toSize: `${orientation === "horizontal" ? element.scrollWidth : element.scrollHeight}px`
		};
	};
	const sizeEnterAtom = ({ orientation, duration, easing, element, fromSize = "0", delay = 0 }) => {
		const { sizeName, overflowName, toSize } = sizeValuesForOrientation(orientation, element);
		return {
			keyframes: [
				{
					[sizeName]: fromSize,
					[overflowName]: "hidden"
				},
				{
					[sizeName]: toSize,
					offset: .9999,
					[overflowName]: "hidden"
				},
				{
					[sizeName]: "unset",
					[overflowName]: "unset"
				}
			],
			duration,
			easing,
			delay,
			fill: "both"
		};
	};
	const sizeExitAtom = ({ orientation, duration, easing, element, delay = 0, fromSize = "0" }) => {
		const { sizeName, overflowName, toSize } = sizeValuesForOrientation(orientation, element);
		return {
			keyframes: [{
				[sizeName]: toSize,
				[overflowName]: "hidden"
			}, {
				[sizeName]: fromSize,
				[overflowName]: "hidden"
			}],
			duration,
			easing,
			delay,
			fill: "both"
		};
	};
	const whitespaceValuesForOrientation = (orientation) => {
		if (orientation === "horizontal") return {
			paddingStart: "paddingInlineStart",
			paddingEnd: "paddingInlineEnd",
			marginStart: "marginInlineStart",
			marginEnd: "marginInlineEnd"
		};
		return {
			paddingStart: "paddingBlockStart",
			paddingEnd: "paddingBlockEnd",
			marginStart: "marginBlockStart",
			marginEnd: "marginBlockEnd"
		};
	};
	/**
	* A collapse animates an element's height to zero,
	but the zero height does not eliminate padding or margin in the box model.
	So here we generate keyframes to animate those whitespace properties to zero.
	*/ const whitespaceAtom = ({ direction, orientation, duration, easing, delay = 0 }) => {
		const { paddingStart, paddingEnd, marginStart, marginEnd } = whitespaceValuesForOrientation(orientation);
		const offset$3 = direction === "enter" ? 0 : 1;
		return {
			keyframes: [{
				[paddingStart]: "0",
				[paddingEnd]: "0",
				[marginStart]: "0",
				[marginEnd]: "0",
				offset: offset$3
			}],
			duration,
			easing,
			delay,
			fill: "both"
		};
	};

//#endregion
//#region node_modules/@fluentui/react-motion-components-preview/lib/atoms/fade-atom.js
/**
	* Generates a motion atom object for a fade-in or fade-out.
	* @param direction - The functional direction of the motion: 'enter' or 'exit'.
	* @param duration - The duration of the motion in milliseconds.
	* @param easing - The easing curve for the motion. Defaults to `motionTokens.curveLinear`.
	* @param delay - The delay before the motion starts. Defaults to 0.
	* @param fromOpacity - The starting opacity value. Defaults to 0.
	* @param toOpacity - The ending opacity value. Defaults to 1.
	* @returns A motion atom object with opacity keyframes and the supplied duration and easing.
	*/ const fadeAtom = ({ direction, duration, easing = motionTokens.curveLinear, delay = 0, fromOpacity = 0, toOpacity = 1 }) => {
		const keyframes = [{ opacity: fromOpacity }, { opacity: toOpacity }];
		if (direction === "exit") keyframes.reverse();
		return {
			keyframes,
			duration,
			easing,
			delay,
			fill: "both"
		};
	};

//#endregion
//#region node_modules/@fluentui/react-motion-components-preview/lib/components/Collapse/Collapse.js
/**
	* Define a presence motion for collapse/expand
	*
	* @param element - The element to apply the collapse motion to
	* @param duration - Time (ms) for the enter transition (expand). Defaults to the `durationNormal` value (200 ms)
	* @param easing - Easing curve for the enter transition. Defaults to the `curveEasyEaseMax` value
	* @param delay - Time (ms) to delay the entire enter transition. Defaults to 0
	* @param exitDuration - Time (ms) for the exit transition (collapse). Defaults to the `duration` param for symmetry
	* @param exitEasing - Easing curve for the exit transition. Defaults to the `easing` param for symmetry
	* @param exitDelay - Time (ms) to delay the entire exit transition. Defaults to the `delay` param for symmetry
	* @param staggerDelay - Time (ms) offset between the size and opacity animations. Defaults to 0
	* @param exitStaggerDelay - Time (ms) offset between the size and opacity animations on exit. Defaults to the `staggerDelay` param for symmetry
	* @param sizeDuration - Time (ms) for the size animation during enter. Defaults to `duration` for unified timing
	* @param opacityDuration - Time (ms) for the opacity animation during enter. Defaults to `sizeDuration` for synchronized timing
	* @param exitSizeDuration - Time (ms) for the size animation during exit. Defaults to `exitDuration` for unified timing
	* @param exitOpacityDuration - Time (ms) for the opacity animation during exit. Defaults to `exitSizeDuration` for synchronized timing
	* @param animateOpacity - Whether to animate the opacity. Defaults to `true`
	* @param orientation - The orientation of the size animation. Defaults to `'vertical'` to expand/collapse the height
	* @param fromSize - The starting size for the expand animation. Defaults to `'0px'`
	*/ const collapsePresenceFn = ({ element, duration = motionTokens.durationNormal, exitDuration = duration, sizeDuration = duration, opacityDuration = sizeDuration, exitSizeDuration = exitDuration, exitOpacityDuration = exitSizeDuration, easing = motionTokens.curveEasyEaseMax, delay = 0, exitEasing = easing, exitDelay = delay, staggerDelay = 0, exitStaggerDelay = staggerDelay, animateOpacity = true, orientation = "vertical", fromSize = "0px" }) => {
		const enterAtoms = [sizeEnterAtom({
			orientation,
			duration: sizeDuration,
			easing,
			element,
			fromSize,
			delay
		}), whitespaceAtom({
			direction: "enter",
			orientation,
			duration: sizeDuration,
			easing,
			delay
		})];
		if (animateOpacity) enterAtoms.push(fadeAtom({
			direction: "enter",
			duration: opacityDuration,
			easing,
			delay: delay + staggerDelay
		}));
		const exitAtoms = [];
		if (animateOpacity) exitAtoms.push(fadeAtom({
			direction: "exit",
			duration: exitOpacityDuration,
			easing: exitEasing,
			delay: exitDelay
		}));
		exitAtoms.push(sizeExitAtom({
			orientation,
			duration: exitSizeDuration,
			easing: exitEasing,
			element,
			delay: exitDelay + exitStaggerDelay,
			fromSize
		}), whitespaceAtom({
			direction: "exit",
			orientation,
			duration: exitSizeDuration,
			easing: exitEasing,
			delay: exitDelay + exitStaggerDelay
		}));
		return {
			enter: enterAtoms,
			exit: exitAtoms
		};
	};
	/** A React component that applies collapse/expand transitions to its children. */ const Collapse = createPresenceComponent(collapsePresenceFn);
	const CollapseSnappy = createPresenceComponentVariant(Collapse, { duration: motionTokens.durationFast });
	const CollapseRelaxed = createPresenceComponentVariant(Collapse, { duration: motionTokens.durationSlower });
	/** A React component that applies collapse/expand transitions with delayed fade to its children. */ const CollapseDelayed = createPresenceComponentVariant(Collapse, {
		sizeDuration: motionTokens.durationNormal,
		opacityDuration: motionTokens.durationSlower,
		staggerDelay: motionTokens.durationNormal,
		exitSizeDuration: motionTokens.durationNormal,
		exitOpacityDuration: motionTokens.durationSlower,
		exitStaggerDelay: motionTokens.durationSlower,
		easing: motionTokens.curveEasyEase,
		exitEasing: motionTokens.curveEasyEase
	});

//#endregion
//#region node_modules/@fluentui/react-motion-components-preview/lib/components/Fade/Fade.js
/**
	* Define a presence motion for fade in/out
	*
	* @param duration - Time (ms) for the enter transition (fade-in). Defaults to the `durationNormal` value (200 ms).
	* @param easing - Easing curve for the enter transition (fade-in). Defaults to the `curveEasyEase` value.
	* @param delay - Time (ms) to delay the enter transition. Defaults to 0.
	* @param exitDuration - Time (ms) for the exit transition (fade-out). Defaults to the `duration` param for symmetry.
	* @param exitEasing - Easing curve for the exit transition (fade-out). Defaults to the `easing` param for symmetry.
	* @param exitDelay - Time (ms) to delay the exit transition. Defaults to the `delay` param for symmetry.
	* @param fromOpacity - The starting opacity value. Defaults to 0.
	* @param toOpacity - The ending opacity value. Defaults to 1.
	*/ const fadePresenceFn = ({ duration = motionTokens.durationNormal, easing = motionTokens.curveEasyEase, delay = 0, exitDuration = duration, exitEasing = easing, exitDelay = delay, fromOpacity = 0, toOpacity = 1 }) => {
		return {
			enter: fadeAtom({
				direction: "enter",
				duration,
				easing,
				delay,
				fromOpacity,
				toOpacity
			}),
			exit: fadeAtom({
				direction: "exit",
				duration: exitDuration,
				easing: exitEasing,
				delay: exitDelay,
				fromOpacity,
				toOpacity
			})
		};
	};
	/** A React component that applies fade in/out transitions to its children. */ const Fade$1 = createPresenceComponent(fadePresenceFn);
	const FadeSnappy = createPresenceComponentVariant(Fade$1, { duration: motionTokens.durationFast });
	const FadeRelaxed = createPresenceComponentVariant(Fade$1, { duration: motionTokens.durationGentle });

//#endregion
//#region node_modules/@fluentui/react-motion-components-preview/lib/atoms/scale-atom.js
/**
	* Generates a motion atom object for a scale in or scale out.
	* @param direction - The functional direction of the motion: 'enter' or 'exit'.
	* @param duration - The duration of the motion in milliseconds.
	* @param easing - The easing curve for the motion. Defaults to `motionTokens.curveLinear`.
	* @param fromScale - The starting scale value. Defaults to 0.9.
	* @param toScale - The ending scale value. Defaults to 1.
	* @param delay - Time (ms) to delay the animation. Defaults to 0.
	* @returns A motion atom object with scale keyframes and the supplied duration and easing.
	*/ const scaleAtom = ({ direction, duration, easing = motionTokens.curveLinear, delay = 0, fromScale = .9, toScale = 1 }) => {
		const keyframes = [{ scale: fromScale }, { scale: toScale }];
		if (direction === "exit") keyframes.reverse();
		return {
			keyframes,
			duration,
			easing,
			delay
		};
	};

//#endregion
//#region node_modules/@fluentui/react-motion-components-preview/lib/components/Scale/Scale.js
/**
	* Define a presence motion for scale in/out
	*
	* @param duration - Time (ms) for the enter transition (scale-in). Defaults to the `durationGentle` value (250 ms).
	* @param easing - Easing curve for the enter transition (scale-in). Defaults to the `curveDecelerateMax` value.
	* @param delay - Time (ms) to delay the enter transition. Defaults to 0.
	* @param exitDuration - Time (ms) for the exit transition (scale-out). Defaults to the `durationNormal` value (200 ms).
	* @param exitEasing - Easing curve for the exit transition (scale-out). Defaults to the `curveAccelerateMax` value.
	* @param exitDelay - Time (ms) to delay the exit transition. Defaults to the `delay` param for symmetry.
	* @param fromScale - The scale value to animate from. Defaults to `0.9`.
	* @param toScale - The scale value to animate to. Defaults to `1`.
	* @param animateOpacity - Whether to animate the opacity. Defaults to `true`.
	*/ const scalePresenceFn = ({ duration = motionTokens.durationGentle, easing = motionTokens.curveDecelerateMax, delay = 0, exitDuration = motionTokens.durationNormal, exitEasing = motionTokens.curveAccelerateMax, exitDelay = delay, fromScale = .9, toScale = 1, animateOpacity = true }) => {
		const enterAtoms = [scaleAtom({
			direction: "enter",
			duration,
			easing,
			delay,
			fromScale,
			toScale
		})];
		const exitAtoms = [scaleAtom({
			direction: "exit",
			duration: exitDuration,
			easing: exitEasing,
			delay: exitDelay,
			fromScale,
			toScale
		})];
		if (animateOpacity) {
			enterAtoms.push(fadeAtom({
				direction: "enter",
				duration,
				easing,
				delay
			}));
			exitAtoms.push(fadeAtom({
				direction: "exit",
				duration: exitDuration,
				easing: exitEasing,
				delay: exitDelay
			}));
		}
		return {
			enter: enterAtoms,
			exit: exitAtoms
		};
	};
	/** A React component that applies scale in/out transitions to its children. */ const Scale = createPresenceComponent(scalePresenceFn);
	const ScaleSnappy = createPresenceComponentVariant(Scale, {
		duration: motionTokens.durationNormal,
		exitDuration: motionTokens.durationFast
	});
	const ScaleRelaxed = createPresenceComponentVariant(Scale, {
		duration: motionTokens.durationSlow,
		exitDuration: motionTokens.durationGentle
	});

//#endregion
//#region node_modules/@fluentui/react-motion-components-preview/lib/atoms/slide-atom.js
/**
	* Generates a motion atom object for a slide-in or slide-out.
	* @param direction - The functional direction of the motion: 'enter' or 'exit'.
	* @param duration - The duration of the motion in milliseconds.
	* @param easing - The easing curve for the motion. Defaults to `motionTokens.curveLinear`.
	* @param fromX - The starting X translate value with units (e.g., '50px', '100%'). Defaults to '0px'.
	* @param fromY - The starting Y translate value with units (e.g., '50px', '100%'). Defaults to '0px'.
	* @param toX - The ending X translate value with units (e.g.'5px', '10%'). Defaults to '0px'.
	* @param toY - The ending Y translate value with units (e.g., '5px', '10%'). Defaults to '0px'.
	* @param delay - Time (ms) to delay the animation. Defaults to 0.
	* @returns A motion atom object with translate keyframes and the supplied duration and easing.
	*/ const slideAtom = ({ direction, duration, easing = motionTokens.curveLinear, delay = 0, fromX = "0px", fromY = "0px", toX = "0px", toY = "0px" }) => {
		const keyframes = [{ translate: `${fromX} ${fromY}` }, { translate: `${toX} ${toY}` }];
		if (direction === "exit") keyframes.reverse();
		return {
			keyframes,
			duration,
			easing,
			delay
		};
	};

//#endregion
//#region node_modules/@fluentui/react-motion-components-preview/lib/atoms/rotate-atom.js
	const createRotateValue = (axis, angle) => {
		return `${axis.toLowerCase()} ${angle}deg`;
	};
	/**
	* Generates a motion atom object for a rotation around a single axis.
	* @param direction - The functional direction of the motion: 'enter' or 'exit'.
	* @param duration - The duration of the motion in milliseconds.
	* @param easing - The easing curve for the motion. Defaults to `motionTokens.curveLinear`.
	* @param axis - The axis of rotation: 'x', 'y', or 'z'. Defaults to 'y'.
	* @param fromAngle - The starting rotation angle in degrees. Defaults to -90.
	* @param toAngle - The ending rotation angle in degrees. Defaults to 0.
	* @param delay - Time (ms) to delay the animation. Defaults to 0.
	* @returns A motion atom object with rotate keyframes and the supplied duration and easing.
	*/ const rotateAtom = ({ direction, duration, easing = motionTokens.curveLinear, delay = 0, axis = "z", fromAngle = -90, toAngle = 0 }) => {
		const keyframes = [{ rotate: createRotateValue(axis, fromAngle) }, { rotate: createRotateValue(axis, toAngle) }];
		if (direction === "exit") keyframes.reverse();
		return {
			keyframes,
			duration,
			easing,
			delay
		};
	};

//#endregion
//#region node_modules/@fluentui/react-motion-components-preview/lib/components/Rotate/Rotate.js
/**
	* Define a presence motion for rotate in/out
	*
	* @param duration - Time (ms) for the enter transition (rotate-in). Defaults to the `durationGentle` value.
	* @param easing - Easing curve for the enter transition (rotate-in). Defaults to the `curveDecelerateMax` value.
	* @param delay - Time (ms) to delay the enter transition. Defaults to 0.
	* @param exitDuration - Time (ms) for the exit transition (rotate-out). Defaults to the `duration` param for symmetry.
	* @param exitEasing - Easing curve for the exit transition (rotate-out). Defaults to the `curveAccelerateMax` value.
	* @param exitDelay - Time (ms) to delay the exit transition. Defaults to the `delay` param for symmetry.
	* @param axis - The axis of rotation: 'x', 'y', or 'z'. Defaults to 'z'.
	* @param fromAngle - The starting rotation angle in degrees. Defaults to -90.
	* @param toAngle - The ending rotation angle in degrees. Defaults to 0.
	* @param animateOpacity - Whether to animate the opacity during the rotation. Defaults to `true`.
	*/ const rotatePresenceFn = ({ duration = motionTokens.durationGentle, easing = motionTokens.curveDecelerateMax, delay = 0, exitDuration = duration, exitEasing = motionTokens.curveAccelerateMax, exitDelay = delay, axis = "z", fromAngle = -90, toAngle = 0, animateOpacity = true }) => {
		const enterAtoms = [rotateAtom({
			direction: "enter",
			duration,
			easing,
			delay,
			axis,
			fromAngle,
			toAngle
		})];
		const exitAtoms = [rotateAtom({
			direction: "exit",
			duration: exitDuration,
			easing: exitEasing,
			delay: exitDelay,
			axis,
			fromAngle,
			toAngle
		})];
		if (animateOpacity) {
			enterAtoms.push(fadeAtom({
				direction: "enter",
				duration,
				easing,
				delay
			}));
			exitAtoms.push(fadeAtom({
				direction: "exit",
				duration: exitDuration,
				easing: exitEasing,
				delay: exitDelay
			}));
		}
		return {
			enter: enterAtoms,
			exit: exitAtoms
		};
	};
	const Rotate = createPresenceComponent(rotatePresenceFn);

//#endregion
//#region node_modules/@fluentui/react-accordion/lib/components/AccordionPanel/useAccordionPanel.js
/**
	* Returns the props and state required to render the component
	* @param props - AccordionPanel properties
	* @param ref - reference to root HTMLElement of AccordionPanel
	*/ const useAccordionPanel_unstable = (props, ref) => {
		const { open } = useAccordionItemContext_unstable();
		const focusableProps = useTabsterAttributes({ focusable: { excludeFromMover: true } });
		const navigation = useAccordionContext_unstable((ctx) => ctx.navigation);
		return {
			open,
			components: {
				root: "div",
				collapseMotion: Collapse
			},
			root: always(getIntrinsicElementProps("div", {
				ref,
				...props,
				...navigation && focusableProps
			}), { elementType: "div" }),
			collapseMotion: presenceMotionSlot(props.collapseMotion, {
				elementType: Collapse,
				defaultProps: {
					visible: open,
					unmountOnExit: true
				}
			})
		};
	};

//#endregion
//#region node_modules/@fluentui/react-accordion/lib/components/AccordionPanel/renderAccordionPanel.js
/**
	* Function that renders the final JSX of the component
	*/ const renderAccordionPanel_unstable = (state) => {
		assertSlots(state);
		return state.collapseMotion ? /* @__PURE__ */ jsx(state.collapseMotion, { children: /* @__PURE__ */ jsx(state.root, {}) }) : /* @__PURE__ */ jsx(state.root, {});
	};

//#endregion
//#region node_modules/@fluentui/react-accordion/lib/components/AccordionPanel/useAccordionPanelStyles.styles.js
	const accordionPanelClassNames = { root: "fui-AccordionPanel" };
	/**
	* Styles for the root slot
	*/
	const useStyles$104 = /* @__PURE__ */ __styles({ root: {
		jrapky: 0,
		Frg6f3: 0,
		t21cq0: 0,
		B6of3ja: 0,
		B74szlk: "f1axvtxu"
	} }, { d: [[".f1axvtxu{margin:0 var(--spacingHorizontalM);}", { p: -1 }]] });
	/** Applies style classnames to slots */
	const useAccordionPanelStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$104();
		state.root.className = mergeClasses(accordionPanelClassNames.root, styles.root, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-accordion/lib/components/AccordionPanel/AccordionPanel.js
/**
	* Define a styled AccordionPanel, using the `useAccordionPanel_unstable` and `useAccordionPanelStyles_unstable` hooks.
	*/ const AccordionPanel = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useAccordionPanel_unstable(props, ref);
		useAccordionPanelStyles_unstable(state);
		useCustomStyleHook("useAccordionPanelStyles_unstable")(state);
		return renderAccordionPanel_unstable(state);
	});
	AccordionPanel.displayName = "AccordionPanel";

//#endregion
//#region node_modules/@fluentui/react-avatar/lib/components/Avatar/renderAvatar.js
	const renderAvatar_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(state.root, { children: [
			state.initials && /* @__PURE__ */ jsx(state.initials, {}),
			state.icon && /* @__PURE__ */ jsx(state.icon, {}),
			state.image && /* @__PURE__ */ jsx(state.image, {}),
			state.badge && /* @__PURE__ */ jsx(state.badge, {}),
			state.activeAriaLabelElement
		] });
	};

//#endregion
//#region node_modules/@fluentui/react-avatar/lib/utils/getInitials.js
/**
	* Regular expressions matching characters to ignore when calculating the initials.
	*/
	/**
	* Regular expression matching characters within various types of enclosures, including the enclosures themselves
	*  so for example, (xyz) [xyz] {xyz} all would be ignored
	*/ const UNWANTED_ENCLOSURES_REGEX = /[\(\[\{][^\)\]\}]*[\)\]\}]/g;
	/**
	* Regular expression matching special ASCII characters except space, plus some unicode special characters.
	* Applies after unwanted enclosures have been removed
	*/ const UNWANTED_CHARS_REGEX = /[\0-\u001F\!-/:-@\[-`\{-\u00BF\u0250-\u036F\uD800-\uFFFF]/g;
	/**
	* Regular expression matching phone numbers. Applied after chars matching UNWANTED_CHARS_REGEX have been removed
	* and number has been trimmed for whitespaces
	*/ const PHONENUMBER_REGEX = /^\d+[\d\s]*(:?ext|x|)\s*\d+$/i;
	/** Regular expression matching one or more spaces. */ const MULTIPLE_WHITESPACES_REGEX = /\s+/g;
	/**
	* Regular expression matching languages for which we currently don't support initials.
	* Arabic:   Arabic, Arabic Supplement, Arabic Extended-A.
	* Korean:   Hangul Jamo, Hangul Compatibility Jamo, Hangul Jamo Extended-A, Hangul Syllables, Hangul Jamo Extended-B.
	* Japanese: Hiragana, Katakana.
	* CJK:      CJK Unified Ideographs Extension A, CJK Unified Ideographs, CJK Compatibility Ideographs,
	*             CJK Unified Ideographs Extension B
	*/ const UNSUPPORTED_TEXT_REGEX = /[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\u1100-\u11FF\u3130-\u318F\uA960-\uA97F\uAC00-\uD7AF\uD7B0-\uD7FF\u3040-\u309F\u30A0-\u30FF\u3400-\u4DBF\u4E00-\u9FFF\uF900-\uFAFF]|[\uD840-\uD869][\uDC00-\uDED6]/;
	function getInitialsLatin(displayName, isRtl, firstInitialOnly) {
		let initials = "";
		const splits = displayName.split(" ");
		if (splits.length !== 0) initials += splits[0].charAt(0).toUpperCase();
		if (!firstInitialOnly) {
			if (splits.length === 2) initials += splits[1].charAt(0).toUpperCase();
			else if (splits.length === 3) initials += splits[2].charAt(0).toUpperCase();
		}
		if (isRtl && initials.length > 1) return initials.charAt(1) + initials.charAt(0);
		return initials;
	}
	function cleanupDisplayName(displayName) {
		displayName = displayName.replace(UNWANTED_ENCLOSURES_REGEX, "");
		displayName = displayName.replace(UNWANTED_CHARS_REGEX, "");
		displayName = displayName.replace(MULTIPLE_WHITESPACES_REGEX, " ");
		displayName = displayName.trim();
		return displayName;
	}
	/**
	* Get (up to 2 characters) initials based on display name of the persona.
	*
	* @param displayName - The full name of the person or entity
	* @param isRtl - Whether the display is in RTL
	* @param options - Extra options to control the behavior of getInitials
	*
	* @returns The 1 or 2 character initials based on the name. Or an empty string if no initials
	* could be derived from the name.
	*
	* @internal
	*/ function getInitials(displayName, isRtl, options) {
		if (!displayName) return "";
		displayName = cleanupDisplayName(displayName);
		if (UNSUPPORTED_TEXT_REGEX.test(displayName) || !(options === null || options === void 0 ? void 0 : options.allowPhoneInitials) && PHONENUMBER_REGEX.test(displayName)) return "";
		return getInitialsLatin(displayName, isRtl, options === null || options === void 0 ? void 0 : options.firstInitialOnly);
	}

//#endregion
//#region node_modules/@fluentui/react-avatar/lib/utils/partitionAvatarGroupItems.js
/**
	* Get the inline items and overflowing items based on the array of AvatarGroupItems needed for AvatarGroup.
	*
	* @param options - Configure the partition options
	*
	* @returns Two arrays split into inline items and overflow items based on maxInlineItems.
	*/ const partitionAvatarGroupItems = (options) => {
		const { items } = options;
		if (options.layout === "pie") return {
			inlineItems: items.slice(0, 3),
			overflowItems: items.length > 0 ? items : void 0
		};
		var _options_maxInlineItems;
		const maxInlineItems = (_options_maxInlineItems = options.maxInlineItems) !== null && _options_maxInlineItems !== void 0 ? _options_maxInlineItems : 5;
		const inlineCount = -(maxInlineItems - (items.length > maxInlineItems ? 1 : 0));
		const overflowItems = items.slice(0, inlineCount);
		return {
			inlineItems: items.slice(inlineCount),
			overflowItems: overflowItems.length > 0 ? overflowItems : void 0
		};
	};

//#endregion
//#region node_modules/@fluentui/react-badge/lib/components/Badge/useBadge.js
/**
	* Returns the props and state required to render the component
	*/ const useBadge_unstable = (props, ref) => {
		const { shape = "circular", size: size$2 = "medium", iconPosition = "before", appearance = "filled", color: color$1 = "brand" } = props;
		return {
			shape,
			size: size$2,
			iconPosition,
			appearance,
			color: color$1,
			components: {
				root: "div",
				icon: "span"
			},
			root: always(getIntrinsicElementProps("div", {
				ref,
				...props
			}), { elementType: "div" }),
			icon: optional(props.icon, { elementType: "span" })
		};
	};

//#endregion
//#region node_modules/@fluentui/react-badge/lib/components/Badge/useBadgeStyles.styles.js
	const badgeClassNames = {
		root: "fui-Badge",
		icon: "fui-Badge__icon"
	};
	tokens.spacingHorizontalXXS;
	const useRootClassName$7 = /* @__PURE__ */ __resetStyles("r1iycov", "r115jdol", [
		".r1iycov{display:inline-flex;box-sizing:border-box;align-items:center;justify-content:center;position:relative;font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase200);font-weight:var(--fontWeightSemibold);line-height:var(--lineHeightBase200);height:20px;min-width:20px;padding:0 calc(var(--spacingHorizontalXS) + var(--spacingHorizontalXXS));border-radius:var(--borderRadiusCircular);border-color:var(--colorTransparentStroke);}",
		".r1iycov::after{content:\"\";position:absolute;top:0;left:0;bottom:0;right:0;border-style:solid;border-color:inherit;border-width:var(--strokeWidthThin);border-radius:inherit;}",
		".r115jdol{display:inline-flex;box-sizing:border-box;align-items:center;justify-content:center;position:relative;font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase200);font-weight:var(--fontWeightSemibold);line-height:var(--lineHeightBase200);height:20px;min-width:20px;padding:0 calc(var(--spacingHorizontalXS) + var(--spacingHorizontalXXS));border-radius:var(--borderRadiusCircular);border-color:var(--colorTransparentStroke);}",
		".r115jdol::after{content:\"\";position:absolute;top:0;right:0;bottom:0;left:0;border-style:solid;border-color:inherit;border-width:var(--strokeWidthThin);border-radius:inherit;}"
	]);
	const useRootStyles$28 = /* @__PURE__ */ __styles({
		fontSmallToTiny: {
			Bahqtrf: "fk6fouc",
			Be2twd7: "f13mqy1h",
			Bhrd7zp: "fl43uef",
			Bg96gwp: "fcpl73t"
		},
		tiny: {
			a9b677: "f16dn6v3",
			Bqenvij: "f3mu39s",
			Be2twd7: "f130uwy9",
			Bg96gwp: "fod1mrr",
			Bf4jedk: "f18p0k4z",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f19jm9xf"
		},
		"extra-small": {
			a9b677: "fpd43o0",
			Bqenvij: "f30q22z",
			Be2twd7: "f1tccstq",
			Bg96gwp: "f1y3arg5",
			Bf4jedk: "f18p0k4z",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f19jm9xf"
		},
		small: {
			Bf4jedk: "fq2vo04",
			Bqenvij: "fd461yt",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "fupdldz"
		},
		medium: {},
		large: {
			Bf4jedk: "f17fgpbq",
			Bqenvij: "frvgh55",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f1996nqw"
		},
		"extra-large": {
			Bf4jedk: "fwbmr0d",
			Bqenvij: "f1d2rq10",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "fty64o7"
		},
		square: {
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "f1fabniw"
		},
		rounded: {
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "ft85np5"
		},
		roundedSmallToTiny: {
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "fq9zq91"
		},
		circular: {},
		borderGhost: { ap17g6: "f10ludwy" },
		filled: {},
		"filled-brand": {
			De3pzq: "ffp7eso",
			sj55zd: "f1phragk"
		},
		"filled-danger": {
			De3pzq: "fdl5y0r",
			sj55zd: "f1phragk"
		},
		"filled-important": {
			De3pzq: "f1c73kur",
			sj55zd: "fr0bkrk"
		},
		"filled-informative": {
			De3pzq: "f3vzo32",
			sj55zd: "f11d4kpn"
		},
		"filled-severe": {
			De3pzq: "f1s438gw",
			sj55zd: "f1phragk"
		},
		"filled-subtle": {
			De3pzq: "fxugw4r",
			sj55zd: "f19n0e5"
		},
		"filled-success": {
			De3pzq: "flxk52p",
			sj55zd: "f1phragk"
		},
		"filled-warning": {
			De3pzq: "ffq97bm",
			sj55zd: "ff5vbop"
		},
		ghost: {},
		"ghost-brand": { sj55zd: "f16muhyy" },
		"ghost-danger": { sj55zd: "f1whyuy6" },
		"ghost-important": { sj55zd: "f19n0e5" },
		"ghost-informative": { sj55zd: "f11d4kpn" },
		"ghost-severe": { sj55zd: "f1l8vj45" },
		"ghost-subtle": { sj55zd: "fonrgv7" },
		"ghost-success": { sj55zd: "f1m7fhi8" },
		"ghost-warning": { sj55zd: "fpti2h4" },
		outline: {
			g2u3we: "f23ftbb",
			h3c5rm: ["f1gkuv52", "f1p1bl80"],
			B9xav0g: "fioka3i",
			zhjwy3: ["f1p1bl80", "f1gkuv52"]
		},
		"outline-brand": { sj55zd: "f16muhyy" },
		"outline-danger": {
			sj55zd: "f1whyuy6",
			g2u3we: "fyqpifd",
			h3c5rm: ["f3ukxca", "f1k7dugc"],
			B9xav0g: "f1njxb2b",
			zhjwy3: ["f1k7dugc", "f3ukxca"]
		},
		"outline-important": {
			sj55zd: "f11d4kpn",
			g2u3we: "fq0vr37",
			h3c5rm: ["f1byw159", "f11cr0be"],
			B9xav0g: "f1c1zstj",
			zhjwy3: ["f11cr0be", "f1byw159"]
		},
		"outline-informative": {
			sj55zd: "f11d4kpn",
			g2u3we: "f68mrw8",
			h3c5rm: ["f7pw515", "fw35ms5"],
			B9xav0g: "frpde29",
			zhjwy3: ["fw35ms5", "f7pw515"]
		},
		"outline-severe": { sj55zd: "f1l8vj45" },
		"outline-subtle": { sj55zd: "fonrgv7" },
		"outline-success": {
			sj55zd: "f1m7fhi8",
			g2u3we: "f1mmhl11",
			h3c5rm: ["f1tjpp2f", "f1ocn5n7"],
			B9xav0g: "f1gjv25d",
			zhjwy3: ["f1ocn5n7", "f1tjpp2f"]
		},
		"outline-warning": { sj55zd: "fpti2h4" },
		tint: {},
		"tint-brand": {
			De3pzq: "f16xkysk",
			sj55zd: "faj9fo0",
			g2u3we: "f161y7kd",
			h3c5rm: ["f1c8dzaj", "f1sl6hi9"],
			B9xav0g: "f1619yhw",
			zhjwy3: ["f1sl6hi9", "f1c8dzaj"]
		},
		"tint-danger": {
			De3pzq: "ff0poqj",
			sj55zd: "f1hcrxcs",
			g2u3we: "f1oqjm8o",
			h3c5rm: ["fkgrb8g", "frb5wm0"],
			B9xav0g: "f1iai1ph",
			zhjwy3: ["frb5wm0", "fkgrb8g"]
		},
		"tint-important": {
			De3pzq: "f945g0u",
			sj55zd: "fr0bkrk",
			g2u3we: "fghlq4f",
			h3c5rm: ["f1gn591s", "fjscplz"],
			B9xav0g: "fb073pr",
			zhjwy3: ["fjscplz", "f1gn591s"]
		},
		"tint-informative": {
			De3pzq: "f1ctqxl6",
			sj55zd: "f11d4kpn",
			g2u3we: "f68mrw8",
			h3c5rm: ["f7pw515", "fw35ms5"],
			B9xav0g: "frpde29",
			zhjwy3: ["fw35ms5", "f7pw515"]
		},
		"tint-severe": {
			De3pzq: "f1xzsg4",
			sj55zd: "f1k5f75o",
			g2u3we: "fxy9dsj",
			h3c5rm: ["f54u6j2", "fcm23ze"],
			B9xav0g: "f4vf0uq",
			zhjwy3: ["fcm23ze", "f54u6j2"]
		},
		"tint-subtle": {
			De3pzq: "fxugw4r",
			sj55zd: "f11d4kpn",
			g2u3we: "f68mrw8",
			h3c5rm: ["f7pw515", "fw35ms5"],
			B9xav0g: "frpde29",
			zhjwy3: ["fw35ms5", "f7pw515"]
		},
		"tint-success": {
			De3pzq: "f2vsrz6",
			sj55zd: "ffmvakt",
			g2u3we: "fdmic9h",
			h3c5rm: ["f196y6m", "fetptd8"],
			B9xav0g: "f1pev5xq",
			zhjwy3: ["fetptd8", "f196y6m"]
		},
		"tint-warning": {
			De3pzq: "f10s6hli",
			sj55zd: "f42v8de",
			g2u3we: "fn9i3n",
			h3c5rm: ["f1aw8cx4", "f51if14"],
			B9xav0g: "fvq8iai",
			zhjwy3: ["f51if14", "f1aw8cx4"]
		}
	}, { d: [
		".fk6fouc{font-family:var(--fontFamilyBase);}",
		".f13mqy1h{font-size:var(--fontSizeBase100);}",
		".fl43uef{font-weight:var(--fontWeightSemibold);}",
		".fcpl73t{line-height:var(--lineHeightBase100);}",
		".f16dn6v3{width:6px;}",
		".f3mu39s{height:6px;}",
		".f130uwy9{font-size:4px;}",
		".fod1mrr{line-height:4px;}",
		".f18p0k4z{min-width:unset;}",
		[".f19jm9xf{padding:unset;}", { p: -1 }],
		".fpd43o0{width:10px;}",
		".f30q22z{height:10px;}",
		".f1tccstq{font-size:6px;}",
		".f1y3arg5{line-height:6px;}",
		[".f19jm9xf{padding:unset;}", { p: -1 }],
		".fq2vo04{min-width:16px;}",
		".fd461yt{height:16px;}",
		[".fupdldz{padding:0 calc(var(--spacingHorizontalXXS) + var(--spacingHorizontalXXS));}", { p: -1 }],
		".f17fgpbq{min-width:24px;}",
		".frvgh55{height:24px;}",
		[".f1996nqw{padding:0 calc(var(--spacingHorizontalXS) + var(--spacingHorizontalXXS));}", { p: -1 }],
		".fwbmr0d{min-width:32px;}",
		".f1d2rq10{height:32px;}",
		[".fty64o7{padding:0 calc(var(--spacingHorizontalSNudge) + var(--spacingHorizontalXXS));}", { p: -1 }],
		[".f1fabniw{border-radius:var(--borderRadiusNone);}", { p: -1 }],
		[".ft85np5{border-radius:var(--borderRadiusMedium);}", { p: -1 }],
		[".fq9zq91{border-radius:var(--borderRadiusSmall);}", { p: -1 }],
		".f10ludwy::after{display:none;}",
		".ffp7eso{background-color:var(--colorBrandBackground);}",
		".f1phragk{color:var(--colorNeutralForegroundOnBrand);}",
		".fdl5y0r{background-color:var(--colorPaletteRedBackground3);}",
		".f1c73kur{background-color:var(--colorNeutralForeground1);}",
		".fr0bkrk{color:var(--colorNeutralBackground1);}",
		".f3vzo32{background-color:var(--colorNeutralBackground5);}",
		".f11d4kpn{color:var(--colorNeutralForeground3);}",
		".f1s438gw{background-color:var(--colorPaletteDarkOrangeBackground3);}",
		".fxugw4r{background-color:var(--colorNeutralBackground1);}",
		".f19n0e5{color:var(--colorNeutralForeground1);}",
		".flxk52p{background-color:var(--colorPaletteGreenBackground3);}",
		".ffq97bm{background-color:var(--colorPaletteYellowBackground3);}",
		".ff5vbop{color:var(--colorNeutralForeground1Static);}",
		".f16muhyy{color:var(--colorBrandForeground1);}",
		".f1whyuy6{color:var(--colorPaletteRedForeground3);}",
		".f1l8vj45{color:var(--colorPaletteDarkOrangeForeground3);}",
		".fonrgv7{color:var(--colorNeutralForegroundStaticInverted);}",
		".f1m7fhi8{color:var(--colorPaletteGreenForeground3);}",
		".fpti2h4{color:var(--colorPaletteYellowForeground2);}",
		".f23ftbb{border-top-color:currentColor;}",
		".f1gkuv52{border-right-color:currentColor;}",
		".f1p1bl80{border-left-color:currentColor;}",
		".fioka3i{border-bottom-color:currentColor;}",
		".fyqpifd{border-top-color:var(--colorPaletteRedBorder2);}",
		".f3ukxca{border-right-color:var(--colorPaletteRedBorder2);}",
		".f1k7dugc{border-left-color:var(--colorPaletteRedBorder2);}",
		".f1njxb2b{border-bottom-color:var(--colorPaletteRedBorder2);}",
		".fq0vr37{border-top-color:var(--colorNeutralStrokeAccessible);}",
		".f1byw159{border-right-color:var(--colorNeutralStrokeAccessible);}",
		".f11cr0be{border-left-color:var(--colorNeutralStrokeAccessible);}",
		".f1c1zstj{border-bottom-color:var(--colorNeutralStrokeAccessible);}",
		".f68mrw8{border-top-color:var(--colorNeutralStroke2);}",
		".f7pw515{border-right-color:var(--colorNeutralStroke2);}",
		".fw35ms5{border-left-color:var(--colorNeutralStroke2);}",
		".frpde29{border-bottom-color:var(--colorNeutralStroke2);}",
		".f1mmhl11{border-top-color:var(--colorPaletteGreenBorder2);}",
		".f1tjpp2f{border-right-color:var(--colorPaletteGreenBorder2);}",
		".f1ocn5n7{border-left-color:var(--colorPaletteGreenBorder2);}",
		".f1gjv25d{border-bottom-color:var(--colorPaletteGreenBorder2);}",
		".f16xkysk{background-color:var(--colorBrandBackground2);}",
		".faj9fo0{color:var(--colorBrandForeground2);}",
		".f161y7kd{border-top-color:var(--colorBrandStroke2);}",
		".f1c8dzaj{border-right-color:var(--colorBrandStroke2);}",
		".f1sl6hi9{border-left-color:var(--colorBrandStroke2);}",
		".f1619yhw{border-bottom-color:var(--colorBrandStroke2);}",
		".ff0poqj{background-color:var(--colorPaletteRedBackground1);}",
		".f1hcrxcs{color:var(--colorPaletteRedForeground1);}",
		".f1oqjm8o{border-top-color:var(--colorPaletteRedBorder1);}",
		".fkgrb8g{border-right-color:var(--colorPaletteRedBorder1);}",
		".frb5wm0{border-left-color:var(--colorPaletteRedBorder1);}",
		".f1iai1ph{border-bottom-color:var(--colorPaletteRedBorder1);}",
		".f945g0u{background-color:var(--colorNeutralForeground3);}",
		".fghlq4f{border-top-color:var(--colorTransparentStroke);}",
		".f1gn591s{border-right-color:var(--colorTransparentStroke);}",
		".fjscplz{border-left-color:var(--colorTransparentStroke);}",
		".fb073pr{border-bottom-color:var(--colorTransparentStroke);}",
		".f1ctqxl6{background-color:var(--colorNeutralBackground4);}",
		".f1xzsg4{background-color:var(--colorPaletteDarkOrangeBackground1);}",
		".f1k5f75o{color:var(--colorPaletteDarkOrangeForeground1);}",
		".fxy9dsj{border-top-color:var(--colorPaletteDarkOrangeBorder1);}",
		".f54u6j2{border-right-color:var(--colorPaletteDarkOrangeBorder1);}",
		".fcm23ze{border-left-color:var(--colorPaletteDarkOrangeBorder1);}",
		".f4vf0uq{border-bottom-color:var(--colorPaletteDarkOrangeBorder1);}",
		".f2vsrz6{background-color:var(--colorPaletteGreenBackground1);}",
		".ffmvakt{color:var(--colorPaletteGreenForeground1);}",
		".fdmic9h{border-top-color:var(--colorPaletteGreenBorder1);}",
		".f196y6m{border-right-color:var(--colorPaletteGreenBorder1);}",
		".fetptd8{border-left-color:var(--colorPaletteGreenBorder1);}",
		".f1pev5xq{border-bottom-color:var(--colorPaletteGreenBorder1);}",
		".f10s6hli{background-color:var(--colorPaletteYellowBackground1);}",
		".f42v8de{color:var(--colorPaletteYellowForeground1);}",
		".fn9i3n{border-top-color:var(--colorPaletteYellowBorder1);}",
		".f1aw8cx4{border-right-color:var(--colorPaletteYellowBorder1);}",
		".f51if14{border-left-color:var(--colorPaletteYellowBorder1);}",
		".fvq8iai{border-bottom-color:var(--colorPaletteYellowBorder1);}"
	] });
	const useIconRootClassName = /* @__PURE__ */ __resetStyles("rttl5z0", null, [".rttl5z0{display:flex;line-height:1;margin:0 calc(-1 * var(--spacingHorizontalXXS));font-size:12px;}"]);
	const useIconStyles$12 = /* @__PURE__ */ __styles({
		beforeText: { t21cq0: ["f1t8l4o1", "f11juvx6"] },
		afterText: { Frg6f3: ["f11juvx6", "f1t8l4o1"] },
		beforeTextXL: { t21cq0: ["f1rs9grm", "f1kwmkpi"] },
		afterTextXL: { Frg6f3: ["f1kwmkpi", "f1rs9grm"] },
		tiny: { Be2twd7: "f1tccstq" },
		"extra-small": { Be2twd7: "fnmn6fi" },
		small: { Be2twd7: "f1ugzwwg" },
		medium: {},
		large: { Be2twd7: "f4ybsrx" },
		"extra-large": { Be2twd7: "fe5j1ua" }
	}, { d: [
		".f1t8l4o1{margin-right:calc(var(--spacingHorizontalXXS) + var(--spacingHorizontalXXS));}",
		".f11juvx6{margin-left:calc(var(--spacingHorizontalXXS) + var(--spacingHorizontalXXS));}",
		".f1rs9grm{margin-right:calc(var(--spacingHorizontalXS) + var(--spacingHorizontalXXS));}",
		".f1kwmkpi{margin-left:calc(var(--spacingHorizontalXS) + var(--spacingHorizontalXXS));}",
		".f1tccstq{font-size:6px;}",
		".fnmn6fi{font-size:10px;}",
		".f1ugzwwg{font-size:12px;}",
		".f4ybsrx{font-size:16px;}",
		".fe5j1ua{font-size:20px;}"
	] });
	/**
	* Applies style classnames to slots
	*/
	const useBadgeStyles_unstable = (state) => {
		"use no memo";
		const rootClassName = useRootClassName$7();
		const rootStyles = useRootStyles$28();
		const smallToTiny = state.size === "small" || state.size === "extra-small" || state.size === "tiny";
		state.root.className = mergeClasses(badgeClassNames.root, rootClassName, smallToTiny && rootStyles.fontSmallToTiny, rootStyles[state.size], rootStyles[state.shape], state.shape === "rounded" && smallToTiny && rootStyles.roundedSmallToTiny, state.appearance === "ghost" && rootStyles.borderGhost, rootStyles[state.appearance], rootStyles[`${state.appearance}-${state.color}`], state.root.className);
		const iconRootClassName = useIconRootClassName();
		const iconStyles = useIconStyles$12();
		if (state.icon) {
			let iconPositionClass;
			if (react.Children.toArray(state.root.children).length > 0) if (state.size === "extra-large") iconPositionClass = state.iconPosition === "after" ? iconStyles.afterTextXL : iconStyles.beforeTextXL;
			else iconPositionClass = state.iconPosition === "after" ? iconStyles.afterText : iconStyles.beforeText;
			state.icon.className = mergeClasses(badgeClassNames.icon, iconRootClassName, iconPositionClass, iconStyles[state.size], state.icon.className);
		}
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-badge/lib/components/Badge/renderBadge.js
	const renderBadge_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(state.root, { children: [
			state.iconPosition === "before" && state.icon && /* @__PURE__ */ jsx(state.icon, {}),
			state.root.children,
			state.iconPosition === "after" && state.icon && /* @__PURE__ */ jsx(state.icon, {})
		] });
	};

//#endregion
//#region node_modules/@fluentui/react-badge/lib/components/Badge/Badge.js
/**
	* Define a styled Badge, using the `useBadge_unstable` hook.
	*/ const Badge = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useBadge_unstable(props, ref);
		useBadgeStyles_unstable(state);
		useCustomStyleHook("useBadgeStyles_unstable")(state);
		return renderBadge_unstable(state);
	});
	Badge.displayName = "Badge";

//#endregion
//#region node_modules/@fluentui/react-badge/lib/components/PresenceBadge/presenceIcons.js
	const presenceAwayRegular = {
		tiny: PresenceAway10Regular,
		"extra-small": PresenceAway10Regular,
		small: PresenceAway12Regular,
		medium: PresenceAway16Regular,
		large: PresenceAway20Regular,
		"extra-large": PresenceAway20Regular
	};
	const presenceAwayFilled = {
		tiny: PresenceAway10Filled,
		"extra-small": PresenceAway10Filled,
		small: PresenceAway12Filled,
		medium: PresenceAway16Filled,
		large: PresenceAway20Filled,
		"extra-large": PresenceAway20Filled
	};
	const presenceAvailableRegular = {
		tiny: PresenceAvailable10Regular,
		"extra-small": PresenceAvailable10Regular,
		small: PresenceAvailable12Regular,
		medium: PresenceAvailable16Regular,
		large: PresenceAvailable20Regular,
		"extra-large": PresenceAvailable20Regular
	};
	const presenceAvailableFilled = {
		tiny: PresenceAvailable10Filled,
		"extra-small": PresenceAvailable10Filled,
		small: PresenceAvailable12Filled,
		medium: PresenceAvailable16Filled,
		large: PresenceAvailable20Filled,
		"extra-large": PresenceAvailable20Filled
	};
	const presenceBlockedRegular = {
		tiny: PresenceBlocked10Regular,
		"extra-small": PresenceBlocked10Regular,
		small: PresenceBlocked12Regular,
		medium: PresenceBlocked16Regular,
		large: PresenceBlocked20Regular,
		"extra-large": PresenceBlocked20Regular
	};
	const presenceBusyFilled = {
		tiny: PresenceBusy10Filled,
		"extra-small": PresenceBusy10Filled,
		small: PresenceBusy12Filled,
		medium: PresenceBusy16Filled,
		large: PresenceBusy20Filled,
		"extra-large": PresenceBusy20Filled
	};
	const presenceDndFilled = {
		tiny: PresenceDnd10Filled,
		"extra-small": PresenceDnd10Filled,
		small: PresenceDnd12Filled,
		medium: PresenceDnd16Filled,
		large: PresenceDnd20Filled,
		"extra-large": PresenceDnd20Filled
	};
	const presenceDndRegular = {
		tiny: PresenceDnd10Regular,
		"extra-small": PresenceDnd10Regular,
		small: PresenceDnd12Regular,
		medium: PresenceDnd16Regular,
		large: PresenceDnd20Regular,
		"extra-large": PresenceDnd20Regular
	};
	const presenceOofRegular = {
		tiny: PresenceOof10Regular,
		"extra-small": PresenceOof10Regular,
		small: PresenceOof12Regular,
		medium: PresenceOof16Regular,
		large: PresenceOof20Regular,
		"extra-large": PresenceOof20Regular
	};
	const presenceOfflineRegular = {
		tiny: PresenceOffline10Regular,
		"extra-small": PresenceOffline10Regular,
		small: PresenceOffline12Regular,
		medium: PresenceOffline16Regular,
		large: PresenceOffline20Regular,
		"extra-large": PresenceOffline20Regular
	};
	const presenceUnknownRegular = {
		tiny: PresenceUnknown10Regular,
		"extra-small": PresenceUnknown10Regular,
		small: PresenceUnknown12Regular,
		medium: PresenceUnknown16Regular,
		large: PresenceUnknown20Regular,
		"extra-large": PresenceUnknown20Regular
	};

//#endregion
//#region node_modules/@fluentui/react-badge/lib/components/PresenceBadge/usePresenceBadge.js
	const iconMap = (status, outOfOffice, size$2) => {
		switch (status) {
			case "available": return outOfOffice ? presenceAvailableRegular[size$2] : presenceAvailableFilled[size$2];
			case "away": return outOfOffice ? presenceOofRegular[size$2] : presenceAwayFilled[size$2];
			case "blocked": return presenceBlockedRegular[size$2];
			case "busy": return outOfOffice ? presenceUnknownRegular[size$2] : presenceBusyFilled[size$2];
			case "do-not-disturb": return outOfOffice ? presenceDndRegular[size$2] : presenceDndFilled[size$2];
			case "offline": return outOfOffice ? presenceOofRegular[size$2] : presenceOfflineRegular[size$2];
			case "out-of-office": return presenceOofRegular[size$2];
			case "unknown": return presenceUnknownRegular[size$2];
		}
	};
	const DEFAULT_STRINGS$1 = {
		busy: "busy",
		"out-of-office": "out of office",
		away: "away",
		available: "available",
		offline: "offline",
		"do-not-disturb": "do not disturb",
		unknown: "unknown",
		blocked: "blocked"
	};
	/**
	* Returns the props and state required to render the component
	*/ const usePresenceBadge_unstable = (props, ref) => {
		const { size: size$2 = "medium", status = "available", outOfOffice = false } = props;
		const statusText = DEFAULT_STRINGS$1[status];
		const oofText = props.outOfOffice && props.status !== "out-of-office" ? ` ${DEFAULT_STRINGS$1["out-of-office"]}` : "";
		const IconElement = iconMap(status, outOfOffice, size$2);
		return {
			...useBadge_unstable({
				"aria-label": statusText + oofText,
				role: "img",
				...props,
				size: size$2,
				icon: optional(props.icon, {
					defaultProps: { children: IconElement ? /* @__PURE__ */ react.createElement(IconElement, null) : null },
					renderByDefault: true,
					elementType: "span"
				})
			}, ref),
			status,
			outOfOffice
		};
	};

//#endregion
//#region node_modules/@fluentui/react-badge/lib/components/PresenceBadge/usePresenceBadgeStyles.styles.js
	const presenceBadgeClassNames = {
		root: "fui-PresenceBadge",
		icon: "fui-PresenceBadge__icon"
	};
	const getIsBusy = (status) => {
		if (status === "busy" || status === "do-not-disturb" || status === "blocked") return true;
		return false;
	};
	const useRootClassName$6 = /* @__PURE__ */ __resetStyles("r832ydo", null, [".r832ydo{display:inline-flex;box-sizing:border-box;align-items:center;justify-content:center;border-radius:var(--borderRadiusCircular);background-color:var(--colorNeutralBackground1);padding:1px;background-clip:content-box;}"]);
	const useIconClassName = /* @__PURE__ */ __resetStyles("r11ag4qr", null, [".r11ag4qr{display:flex;margin:-1px;}"]);
	const useStyles$103 = /* @__PURE__ */ __styles({
		statusBusy: { sj55zd: "fvi85wt" },
		statusAway: { sj55zd: "f14k8a89" },
		statusAvailable: { sj55zd: "fqa5hgp" },
		statusOffline: { sj55zd: "f11d4kpn" },
		statusOutOfOffice: { sj55zd: "fdce8r3" },
		statusUnknown: { sj55zd: "f11d4kpn" },
		outOfOffice: { sj55zd: "fr0bkrk" },
		outOfOfficeAvailable: { sj55zd: "fqa5hgp" },
		outOfOfficeBusy: { sj55zd: "fvi85wt" },
		outOfOfficeUnknown: { sj55zd: "f11d4kpn" },
		tiny: {
			Bubjx69: "f9ikmtg",
			a9b677: "f16dn6v3",
			B2eet1l: "f1w2irj7",
			B5pe6w7: "fab5kbq",
			p4uzdd: "f1ms1d91"
		},
		large: {
			Bubjx69: "f9ikmtg",
			a9b677: "f64fuq3",
			B5pe6w7: "f1vfi1yj",
			p4uzdd: "f15s34gz"
		},
		extraLarge: {
			Bubjx69: "f9ikmtg",
			a9b677: "f1w9dchk",
			B5pe6w7: "f14efy9b",
			p4uzdd: "fhipgdu"
		}
	}, { d: [
		".fvi85wt{color:var(--colorPaletteRedBackground3);}",
		".f14k8a89{color:var(--colorPaletteMarigoldBackground3);}",
		".fqa5hgp{color:var(--colorPaletteLightGreenForeground3);}",
		".f11d4kpn{color:var(--colorNeutralForeground3);}",
		".fdce8r3{color:var(--colorPaletteBerryForeground3);}",
		".fr0bkrk{color:var(--colorNeutralBackground1);}",
		".f9ikmtg{aspect-ratio:1;}",
		".f16dn6v3{width:6px;}",
		".f1w2irj7{background-clip:unset;}",
		".fab5kbq svg{width:6px!important;}",
		".f1ms1d91 svg{height:6px!important;}",
		".f64fuq3{width:20px;}",
		".f1vfi1yj svg{width:20px!important;}",
		".f15s34gz svg{height:20px!important;}",
		".f1w9dchk{width:28px;}",
		".f14efy9b svg{width:28px!important;}",
		".fhipgdu svg{height:28px!important;}"
	] });
	/**
	* Applies style classnames to slots
	*/
	const usePresenceBadgeStyles_unstable = (state) => {
		"use no memo";
		const rootClassName = useRootClassName$6();
		const iconClassName = useIconClassName();
		const styles = useStyles$103();
		const isBusy = getIsBusy(state.status);
		state.root.className = mergeClasses(presenceBadgeClassNames.root, rootClassName, isBusy && styles.statusBusy, state.status === "away" && styles.statusAway, state.status === "available" && styles.statusAvailable, state.status === "offline" && styles.statusOffline, state.status === "out-of-office" && styles.statusOutOfOffice, state.status === "unknown" && styles.statusUnknown, state.outOfOffice && styles.outOfOffice, state.outOfOffice && state.status === "available" && styles.outOfOfficeAvailable, state.outOfOffice && isBusy && styles.outOfOfficeBusy, state.outOfOffice && (state.status === "out-of-office" || state.status === "away" || state.status === "offline") && styles.statusOutOfOffice, state.outOfOffice && state.status === "unknown" && styles.outOfOfficeUnknown, state.size === "tiny" && styles.tiny, state.size === "large" && styles.large, state.size === "extra-large" && styles.extraLarge, state.root.className);
		if (state.icon) state.icon.className = mergeClasses(presenceBadgeClassNames.icon, iconClassName, state.icon.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-badge/lib/components/PresenceBadge/PresenceBadge.js
/**
	* Define a styled Badge, using the `useBadge_unstable` hook.
	*/ const PresenceBadge = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = usePresenceBadge_unstable(props, ref);
		usePresenceBadgeStyles_unstable(state);
		useCustomStyleHook("usePresenceBadgeStyles_unstable")(state);
		return renderBadge_unstable(state);
	});
	PresenceBadge.displayName = "PresenceBadge";

//#endregion
//#region node_modules/@fluentui/react-badge/lib/components/CounterBadge/useCounterBadge.js
/**
	* Returns the props and state required to render the component
	*/ const useCounterBadge_unstable = (props, ref) => {
		const { shape = "circular", appearance = "filled", showZero = false, overflowCount = 99, count = 0, dot = false } = props;
		const state = {
			...useBadge_unstable(props, ref),
			shape,
			appearance,
			showZero,
			count,
			dot
		};
		if ((count !== 0 || showZero) && !dot && !state.root.children) state.root.children = count > overflowCount ? `${overflowCount}+` : `${count}`;
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-badge/lib/components/CounterBadge/useCounterBadgeStyles.styles.js
	const counterBadgeClassNames = {
		root: "fui-CounterBadge",
		icon: "fui-CounterBadge__icon"
	};
	const useStyles$102 = /* @__PURE__ */ __styles({
		dot: {
			Bf4jedk: "fgfkb25",
			a9b677: "f16dn6v3",
			Bqenvij: "f3mu39s",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f1mk8lai"
		},
		hide: { mc9l5x: "fjseox" }
	}, { d: [
		".fgfkb25{min-width:auto;}",
		".f16dn6v3{width:6px;}",
		".f3mu39s{height:6px;}",
		[".f1mk8lai{padding:0;}", { p: -1 }],
		".fjseox{display:none;}"
	] });
	/**
	* Applies style classnames to slots
	*/
	const useCounterBadgeStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$102();
		state.root.className = mergeClasses(counterBadgeClassNames.root, state.dot && styles.dot, !state.root.children && !state.dot && styles.hide, state.root.className);
		if (state.icon) state.icon.className = mergeClasses(counterBadgeClassNames.icon, state.icon.className);
		return useBadgeStyles_unstable(state);
	};

//#endregion
//#region node_modules/@fluentui/react-badge/lib/components/CounterBadge/CounterBadge.js
/**
	* Define a styled CounterBadge, using the `useCounterBadge_unstable` hook.
	*/ const CounterBadge = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useCounterBadge_unstable(props, ref);
		useCounterBadgeStyles_unstable(state);
		useCustomStyleHook("useCounterBadgeStyles_unstable")(state);
		return renderBadge_unstable(state);
	});
	CounterBadge.displayName = "CounterBadge";

//#endregion
//#region node_modules/@fluentui/react-avatar/lib/contexts/AvatarContext.js
	const avatarContext = react.createContext(void 0);
	const avatarContextDefaultValue = {};
	/**
	* @internal
	*/ const AvatarContextProvider = avatarContext.Provider;
	/**
	* @internal
	*/ const useAvatarContext = () => {
		var _React_useContext;
		return (_React_useContext = react.useContext(avatarContext)) !== null && _React_useContext !== void 0 ? _React_useContext : avatarContextDefaultValue;
	};

//#endregion
//#region node_modules/@fluentui/react-avatar/lib/components/Avatar/useAvatar.js
	const DEFAULT_STRINGS = {
		active: "active",
		inactive: "inactive"
	};
	const useAvatar_unstable = (props, ref) => {
		const { dir } = useFluent();
		const { shape: contextShape, size: contextSize } = useAvatarContext();
		const { name, size: size$2 = contextSize !== null && contextSize !== void 0 ? contextSize : 32, shape = contextShape !== null && contextShape !== void 0 ? contextShape : "circular", active = "unset", activeAppearance = "ring", idForColor } = props;
		let { color: color$1 = "neutral" } = props;
		if (color$1 === "colorful") {
			var _ref;
			color$1 = avatarColors[getHashCode((_ref = idForColor !== null && idForColor !== void 0 ? idForColor : name) !== null && _ref !== void 0 ? _ref : "") % avatarColors.length];
		}
		const baseId = useId("avatar-");
		const root = always(getIntrinsicElementProps("span", {
			role: "img",
			id: baseId,
			...props,
			ref
		}, ["name"]), { elementType: "span" });
		const [imageHidden, setImageHidden] = react.useState(void 0);
		let image = optional(props.image, {
			defaultProps: {
				alt: "",
				role: "presentation",
				"aria-hidden": true,
				hidden: imageHidden
			},
			elementType: "img"
		});
		if (!(image === null || image === void 0 ? void 0 : image.src)) image = void 0;
		if (image) {
			image.onError = mergeCallbacks(image.onError, () => setImageHidden(true));
			image.onLoad = mergeCallbacks(image.onLoad, () => setImageHidden(void 0));
		}
		let initials = optional(props.initials, {
			renderByDefault: true,
			defaultProps: {
				children: getInitials(name, dir === "rtl", { firstInitialOnly: size$2 <= 16 }),
				id: baseId + "__initials"
			},
			elementType: "span"
		});
		if (!(initials === null || initials === void 0 ? void 0 : initials.children)) initials = void 0;
		let icon = void 0;
		if (!initials && (!image || imageHidden)) icon = optional(props.icon, {
			renderByDefault: true,
			defaultProps: {
				children: /* @__PURE__ */ react.createElement(PersonRegular, null),
				"aria-hidden": true
			},
			elementType: "span"
		});
		const badge = optional(props.badge, {
			defaultProps: {
				size: getBadgeSize(size$2),
				id: baseId + "__badge"
			},
			elementType: PresenceBadge
		});
		let activeAriaLabelElement;
		if (!root["aria-label"] && !root["aria-labelledby"]) {
			if (name) {
				root["aria-label"] = name;
				if (badge) root["aria-labelledby"] = root.id + " " + badge.id;
			} else if (initials) root["aria-labelledby"] = initials.id + (badge ? " " + badge.id : "");
			if (active === "active" || active === "inactive") {
				const activeText = DEFAULT_STRINGS[active];
				if (root["aria-labelledby"]) {
					const activeId = baseId + "__active";
					root["aria-labelledby"] += " " + activeId;
					activeAriaLabelElement = /* @__PURE__ */ react.createElement("span", {
						hidden: true,
						id: activeId
					}, activeText);
				} else if (root["aria-label"]) root["aria-label"] += " " + activeText;
			}
		}
		return {
			size: size$2,
			shape,
			active,
			activeAppearance,
			activeAriaLabelElement,
			color: color$1,
			components: {
				root: "span",
				initials: "span",
				icon: "span",
				image: "img",
				badge: PresenceBadge
			},
			root,
			initials,
			icon,
			image,
			badge
		};
	};
	const getBadgeSize = (size$2) => {
		if (size$2 >= 96) return "extra-large";
		else if (size$2 >= 64) return "large";
		else if (size$2 >= 56) return "medium";
		else if (size$2 >= 40) return "small";
		else if (size$2 >= 28) return "extra-small";
		else return "tiny";
	};
	const avatarColors = [
		"dark-red",
		"cranberry",
		"red",
		"pumpkin",
		"peach",
		"marigold",
		"gold",
		"brass",
		"brown",
		"forest",
		"seafoam",
		"dark-green",
		"light-teal",
		"teal",
		"steel",
		"blue",
		"royal-blue",
		"cornflower",
		"navy",
		"lavender",
		"purple",
		"grape",
		"lilac",
		"pink",
		"magenta",
		"plum",
		"beige",
		"mink",
		"platinum",
		"anchor"
	];
	const getHashCode = (str) => {
		let hashCode = 0;
		for (let len = str.length - 1; len >= 0; len--) {
			const ch = str.charCodeAt(len);
			const shift$3 = len % 8;
			hashCode ^= (ch << shift$3) + (ch >> 8 - shift$3);
		}
		return hashCode;
	};

//#endregion
//#region node_modules/@fluentui/react-avatar/lib/components/Avatar/useAvatarStyles.styles.js
	const avatarClassNames = {
		root: "fui-Avatar",
		image: "fui-Avatar__image",
		initials: "fui-Avatar__initials",
		icon: "fui-Avatar__icon",
		badge: "fui-Avatar__badge"
	};
	const useRootClassName$5 = /* @__PURE__ */ __resetStyles("r81b29z", "r1aatmv", {
		r: [
			".r81b29z{display:inline-block;flex-shrink:0;position:relative;vertical-align:middle;border-radius:var(--borderRadiusCircular);font-family:var(--fontFamilyBase);font-weight:var(--fontWeightSemibold);font-size:var(--fontSizeBase300);width:32px;height:32px;}",
			".r81b29z::before,.r81b29z::after{position:absolute;top:0;left:0;bottom:0;right:0;z-index:-1;margin:calc(-2 * var(--fui-Avatar-ringWidth, 0px));border-radius:inherit;transition-property:margin,opacity;transition-timing-function:var(--curveEasyEaseMax),var(--curveLinear);transition-duration:var(--durationUltraSlow),var(--durationSlower);}",
			".r81b29z::before{border-style:solid;border-width:var(--fui-Avatar-ringWidth);}",
			".r1aatmv{display:inline-block;flex-shrink:0;position:relative;vertical-align:middle;border-radius:var(--borderRadiusCircular);font-family:var(--fontFamilyBase);font-weight:var(--fontWeightSemibold);font-size:var(--fontSizeBase300);width:32px;height:32px;}",
			".r1aatmv::before,.r1aatmv::after{position:absolute;top:0;right:0;bottom:0;left:0;z-index:-1;margin:calc(-2 * var(--fui-Avatar-ringWidth, 0px));border-radius:inherit;transition-property:margin,opacity;transition-timing-function:var(--curveEasyEaseMax),var(--curveLinear);transition-duration:var(--durationUltraSlow),var(--durationSlower);}",
			".r1aatmv::before{border-style:solid;border-width:var(--fui-Avatar-ringWidth);}"
		],
		s: ["@media screen and (prefers-reduced-motion: reduce){.r81b29z::before,.r81b29z::after{transition-duration:0.01ms;}}", "@media screen and (prefers-reduced-motion: reduce){.r1aatmv::before,.r1aatmv::after{transition-duration:0.01ms;}}"]
	});
	const useImageClassName = /* @__PURE__ */ __resetStyles("r136dc0n", "rjly0nl", [".r136dc0n{position:absolute;top:0;left:0;width:100%;height:100%;border-radius:inherit;object-fit:cover;vertical-align:top;}", ".rjly0nl{position:absolute;top:0;right:0;width:100%;height:100%;border-radius:inherit;object-fit:cover;vertical-align:top;}"]);
	const useIconInitialsClassName = /* @__PURE__ */ __resetStyles("rip04v", "r31uzil", [".rip04v{position:absolute;box-sizing:border-box;top:0;left:0;width:100%;height:100%;line-height:1;border:var(--strokeWidthThin) solid var(--colorTransparentStroke);display:flex;align-items:center;justify-content:center;vertical-align:center;text-align:center;-webkit-user-select:none;-moz-user-select:none;user-select:none;border-radius:inherit;}", ".r31uzil{position:absolute;box-sizing:border-box;top:0;right:0;width:100%;height:100%;line-height:1;border:var(--strokeWidthThin) solid var(--colorTransparentStroke);display:flex;align-items:center;justify-content:center;vertical-align:center;text-align:center;-webkit-user-select:none;-moz-user-select:none;user-select:none;border-radius:inherit;}"]);
	const useStyles$101 = /* @__PURE__ */ __styles({
		textCaption2Strong: { Be2twd7: "f13mqy1h" },
		textCaption1Strong: { Be2twd7: "fy9rknc" },
		textSubtitle2: { Be2twd7: "fod5ikn" },
		textSubtitle1: { Be2twd7: "f1pp30po" },
		textTitle3: { Be2twd7: "f1x0m3f5" },
		squareSmall: {
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "fq9zq91"
		},
		squareMedium: {
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "ft85np5"
		},
		squareLarge: {
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "f1o0qvyv"
		},
		squareXLarge: {
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "f1kijzfu"
		},
		activeOrInactive: {
			Bz10aip: "ftfx35i",
			Bmy1vo4: "fv0atk9",
			B3o57yi: "f1iry5bo",
			Bkqvd7p: "f15n41j8",
			Bg24rqe: "f9ttr0w"
		},
		ring: { Ftih45: "f1wl9k8s" },
		ringBadgeCutout: { f4a502: "fp2gujx" },
		ringThick: { of393c: "fq1w1vq" },
		ringThicker: { of393c: "fzg6ace" },
		ringThickest: { of393c: "f1nu8p71" },
		shadow: { Bsft5z2: "f13zj6fq" },
		shadow4: { Be6vj1x: "fcjn15l" },
		shadow8: { Be6vj1x: "f1tm8t9f" },
		shadow16: { Be6vj1x: "f1a1aohj" },
		shadow28: { Be6vj1x: "fond6v5" },
		inactive: {
			abs64n: "fp25eh",
			Bz10aip: "f1clczzi",
			Bkqvd7p: "f1l3s34x",
			Bfgortx: 0,
			Bnvr3x9: 0,
			b2tv09: 0,
			Bucmhp4: 0,
			iayac2: "flkahu5",
			b6ubon: "fw457kn",
			Bqinb2h: "f1wmllxl"
		},
		badge: {
			qhf8xq: "f1euv43f",
			B5kzvoi: "f1yab3r1",
			j35jbq: ["f1e31b4d", "f1vgc2s3"]
		},
		badgeCutout: { btxmck: "f1eugkqs" },
		badgeAlign: { Dnlfbu: ["f1tlnv9o", "f1y9kyih"] },
		tiny: {
			Bdjeniz: "f1uwoubl",
			niu6jh: "fid048z"
		},
		"extra-small": {
			Bdjeniz: "f13ar0e0",
			niu6jh: "fid048z"
		},
		small: {
			Bdjeniz: "fwwuruf",
			niu6jh: "fid048z"
		},
		medium: {
			Bdjeniz: "f1af27q5",
			niu6jh: "fid048z"
		},
		large: {
			Bdjeniz: "f18yy57a",
			niu6jh: "f924bxt"
		},
		"extra-large": {
			Bdjeniz: "f2jg042",
			niu6jh: "f924bxt"
		},
		icon12: { Be2twd7: "f1ugzwwg" },
		icon16: { Be2twd7: "f4ybsrx" },
		icon20: { Be2twd7: "fe5j1ua" },
		icon24: { Be2twd7: "f1rt2boy" },
		icon28: { Be2twd7: "f24l1pt" },
		icon32: { Be2twd7: "ffl51b" },
		icon48: { Be2twd7: "f18m8u13" }
	}, {
		d: [
			".f13mqy1h{font-size:var(--fontSizeBase100);}",
			".fy9rknc{font-size:var(--fontSizeBase200);}",
			".fod5ikn{font-size:var(--fontSizeBase400);}",
			".f1pp30po{font-size:var(--fontSizeBase500);}",
			".f1x0m3f5{font-size:var(--fontSizeBase600);}",
			[".fq9zq91{border-radius:var(--borderRadiusSmall);}", { p: -1 }],
			[".ft85np5{border-radius:var(--borderRadiusMedium);}", { p: -1 }],
			[".f1o0qvyv{border-radius:var(--borderRadiusLarge);}", { p: -1 }],
			[".f1kijzfu{border-radius:var(--borderRadiusXLarge);}", { p: -1 }],
			".ftfx35i{transform:perspective(1px);}",
			".fv0atk9{transition-property:transform,opacity;}",
			".f1iry5bo{transition-duration:var(--durationUltraSlow),var(--durationFaster);}",
			".f15n41j8{transition-timing-function:var(--curveEasyEaseMax),var(--curveLinear);}",
			".f1wl9k8s::before{content:\"\";}",
			".fp2gujx::before{-webkit-mask-image:radial-gradient(circle at bottom calc(var(--fui-Avatar-badgeRadius) + 2 * var(--fui-Avatar-ringWidth)) var(--fui-Avatar-badgeAlign) calc(var(--fui-Avatar-badgeRadius) + 2 * var(--fui-Avatar-ringWidth)), transparent calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) - 0.25px), white calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) + 0.25px));mask-image:radial-gradient(circle at bottom calc(var(--fui-Avatar-badgeRadius) + 2 * var(--fui-Avatar-ringWidth)) var(--fui-Avatar-badgeAlign) calc(var(--fui-Avatar-badgeRadius) + 2 * var(--fui-Avatar-ringWidth)), transparent calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) - 0.25px), white calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) + 0.25px));}",
			".fq1w1vq{--fui-Avatar-ringWidth:var(--strokeWidthThick);}",
			".fzg6ace{--fui-Avatar-ringWidth:var(--strokeWidthThicker);}",
			".f1nu8p71{--fui-Avatar-ringWidth:var(--strokeWidthThickest);}",
			".f13zj6fq::after{content:\"\";}",
			".fcjn15l::after{box-shadow:var(--shadow4);}",
			".f1tm8t9f::after{box-shadow:var(--shadow8);}",
			".f1a1aohj::after{box-shadow:var(--shadow16);}",
			".fond6v5::after{box-shadow:var(--shadow28);}",
			".fp25eh{opacity:0.8;}",
			".f1clczzi{transform:scale(0.875);}",
			".f1l3s34x{transition-timing-function:var(--curveDecelerateMin),var(--curveLinear);}",
			[".flkahu5::before,.flkahu5::after{margin:0;}", { p: -1 }],
			".fw457kn::before,.fw457kn::after{opacity:0;}",
			".f1wmllxl::before,.f1wmllxl::after{transition-timing-function:var(--curveDecelerateMin),var(--curveLinear);}",
			".f1euv43f{position:absolute;}",
			".f1yab3r1{bottom:0;}",
			".f1e31b4d{right:0;}",
			".f1vgc2s3{left:0;}",
			".f1eugkqs{-webkit-mask-image:radial-gradient(circle at bottom var(--fui-Avatar-badgeRadius) var(--fui-Avatar-badgeAlign) var(--fui-Avatar-badgeRadius), transparent calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) - 0.25px), white calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) + 0.25px));mask-image:radial-gradient(circle at bottom var(--fui-Avatar-badgeRadius) var(--fui-Avatar-badgeAlign) var(--fui-Avatar-badgeRadius), transparent calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) - 0.25px), white calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) + 0.25px));}",
			".f1tlnv9o{--fui-Avatar-badgeAlign:right;}",
			".f1y9kyih{--fui-Avatar-badgeAlign:left;}",
			".f1uwoubl{--fui-Avatar-badgeRadius:3px;}",
			".fid048z{--fui-Avatar-badgeGap:var(--strokeWidthThin);}",
			".f13ar0e0{--fui-Avatar-badgeRadius:5px;}",
			".fwwuruf{--fui-Avatar-badgeRadius:6px;}",
			".f1af27q5{--fui-Avatar-badgeRadius:8px;}",
			".f18yy57a{--fui-Avatar-badgeRadius:10px;}",
			".f924bxt{--fui-Avatar-badgeGap:var(--strokeWidthThick);}",
			".f2jg042{--fui-Avatar-badgeRadius:14px;}",
			".f1ugzwwg{font-size:12px;}",
			".f4ybsrx{font-size:16px;}",
			".fe5j1ua{font-size:20px;}",
			".f1rt2boy{font-size:24px;}",
			".f24l1pt{font-size:28px;}",
			".ffl51b{font-size:32px;}",
			".f18m8u13{font-size:48px;}"
		],
		m: [["@media screen and (prefers-reduced-motion: reduce){.f9ttr0w{transition-duration:0.01ms;}}", { m: "screen and (prefers-reduced-motion: reduce)" }]]
	});
	const useSizeStyles$4 = /* @__PURE__ */ __styles({
		"16": {
			a9b677: "fjw5fx7",
			Bqenvij: "fd461yt"
		},
		"20": {
			a9b677: "f64fuq3",
			Bqenvij: "fjamq6b"
		},
		"24": {
			a9b677: "fq4mcun",
			Bqenvij: "frvgh55"
		},
		"28": {
			a9b677: "f1w9dchk",
			Bqenvij: "fxldao9"
		},
		"32": {
			a9b677: "f1szoe96",
			Bqenvij: "f1d2rq10"
		},
		"36": {
			a9b677: "fpdz1er",
			Bqenvij: "f8ljn23"
		},
		"40": {
			a9b677: "feqmc2u",
			Bqenvij: "fbhnoac"
		},
		"48": {
			a9b677: "f124akge",
			Bqenvij: "ff2sm71"
		},
		"56": {
			a9b677: "f1u66zr1",
			Bqenvij: "fzki0ko"
		},
		"64": {
			a9b677: "fa9ln6p",
			Bqenvij: "f16k9i2m"
		},
		"72": {
			a9b677: "fhcae8x",
			Bqenvij: "f1shusfg"
		},
		"96": {
			a9b677: "f1kyr2gn",
			Bqenvij: "fypu0ge"
		},
		"120": {
			a9b677: "fwfqyga",
			Bqenvij: "fjr5b71"
		},
		"128": {
			a9b677: "f1iksgmy",
			Bqenvij: "fele2au"
		}
	}, { d: [
		".fjw5fx7{width:16px;}",
		".fd461yt{height:16px;}",
		".f64fuq3{width:20px;}",
		".fjamq6b{height:20px;}",
		".fq4mcun{width:24px;}",
		".frvgh55{height:24px;}",
		".f1w9dchk{width:28px;}",
		".fxldao9{height:28px;}",
		".f1szoe96{width:32px;}",
		".f1d2rq10{height:32px;}",
		".fpdz1er{width:36px;}",
		".f8ljn23{height:36px;}",
		".feqmc2u{width:40px;}",
		".fbhnoac{height:40px;}",
		".f124akge{width:48px;}",
		".ff2sm71{height:48px;}",
		".f1u66zr1{width:56px;}",
		".fzki0ko{height:56px;}",
		".fa9ln6p{width:64px;}",
		".f16k9i2m{height:64px;}",
		".fhcae8x{width:72px;}",
		".f1shusfg{height:72px;}",
		".f1kyr2gn{width:96px;}",
		".fypu0ge{height:96px;}",
		".fwfqyga{width:120px;}",
		".fjr5b71{height:120px;}",
		".f1iksgmy{width:128px;}",
		".fele2au{height:128px;}"
	] });
	const useColorStyles = /* @__PURE__ */ __styles({
		neutral: {
			sj55zd: "f11d4kpn",
			De3pzq: "f18f03hv"
		},
		brand: {
			sj55zd: "fonrgv7",
			De3pzq: "f1blnnmj"
		},
		"dark-red": {
			sj55zd: "fqjd1y1",
			De3pzq: "f1vq2oo4"
		},
		cranberry: {
			sj55zd: "fg9gses",
			De3pzq: "f1lwxszt"
		},
		red: {
			sj55zd: "f23f7i0",
			De3pzq: "f1q9qhfq"
		},
		pumpkin: {
			sj55zd: "fjnan08",
			De3pzq: "fz91bi3"
		},
		peach: {
			sj55zd: "fknu15p",
			De3pzq: "f1b9nr51"
		},
		marigold: {
			sj55zd: "f9603vw",
			De3pzq: "f3z4w6d"
		},
		gold: {
			sj55zd: "fmq0uwp",
			De3pzq: "fg50kya"
		},
		brass: {
			sj55zd: "f28g5vo",
			De3pzq: "f4w2gd0"
		},
		brown: {
			sj55zd: "ftl572b",
			De3pzq: "f14wu1f4"
		},
		forest: {
			sj55zd: "f1gymlvd",
			De3pzq: "f19ut4y6"
		},
		seafoam: {
			sj55zd: "fnnb6wn",
			De3pzq: "f1n057jc"
		},
		"dark-green": {
			sj55zd: "ff58qw8",
			De3pzq: "f11t05wk"
		},
		"light-teal": {
			sj55zd: "f1up9qbj",
			De3pzq: "f42feg1"
		},
		teal: {
			sj55zd: "f135dsb4",
			De3pzq: "f6hvv1p"
		},
		steel: {
			sj55zd: "f151dlcp",
			De3pzq: "f1lnp8zf"
		},
		blue: {
			sj55zd: "f1rjv50u",
			De3pzq: "f1ggcpy6"
		},
		"royal-blue": {
			sj55zd: "f1emykk5",
			De3pzq: "f12rj61f"
		},
		cornflower: {
			sj55zd: "fqsigj7",
			De3pzq: "f8k7hur"
		},
		navy: {
			sj55zd: "f1nj97xi",
			De3pzq: "f19gw0ux"
		},
		lavender: {
			sj55zd: "fwctg0i",
			De3pzq: "ff379vm"
		},
		purple: {
			sj55zd: "fjrsgpu",
			De3pzq: "f1mzf1e1"
		},
		grape: {
			sj55zd: "f1fiiydq",
			De3pzq: "f1o4k8oy"
		},
		lilac: {
			sj55zd: "f1res9jt",
			De3pzq: "f1x6mz1o"
		},
		pink: {
			sj55zd: "fv3fbbi",
			De3pzq: "fydlv6t"
		},
		magenta: {
			sj55zd: "f1f1fwnz",
			De3pzq: "f4xb6j5"
		},
		plum: {
			sj55zd: "f8ptl6j",
			De3pzq: "fqo8e26"
		},
		beige: {
			sj55zd: "f1ntv3ld",
			De3pzq: "f101elhj"
		},
		mink: {
			sj55zd: "f1fscmp",
			De3pzq: "f13g8o5c"
		},
		platinum: {
			sj55zd: "f1dr00v2",
			De3pzq: "fkh7blw"
		},
		anchor: {
			sj55zd: "f1f3ti53",
			De3pzq: "fu4yj0j"
		}
	}, { d: [
		".f11d4kpn{color:var(--colorNeutralForeground3);}",
		".f18f03hv{background-color:var(--colorNeutralBackground6);}",
		".fonrgv7{color:var(--colorNeutralForegroundStaticInverted);}",
		".f1blnnmj{background-color:var(--colorBrandBackgroundStatic);}",
		".fqjd1y1{color:var(--colorPaletteDarkRedForeground2);}",
		".f1vq2oo4{background-color:var(--colorPaletteDarkRedBackground2);}",
		".fg9gses{color:var(--colorPaletteCranberryForeground2);}",
		".f1lwxszt{background-color:var(--colorPaletteCranberryBackground2);}",
		".f23f7i0{color:var(--colorPaletteRedForeground2);}",
		".f1q9qhfq{background-color:var(--colorPaletteRedBackground2);}",
		".fjnan08{color:var(--colorPalettePumpkinForeground2);}",
		".fz91bi3{background-color:var(--colorPalettePumpkinBackground2);}",
		".fknu15p{color:var(--colorPalettePeachForeground2);}",
		".f1b9nr51{background-color:var(--colorPalettePeachBackground2);}",
		".f9603vw{color:var(--colorPaletteMarigoldForeground2);}",
		".f3z4w6d{background-color:var(--colorPaletteMarigoldBackground2);}",
		".fmq0uwp{color:var(--colorPaletteGoldForeground2);}",
		".fg50kya{background-color:var(--colorPaletteGoldBackground2);}",
		".f28g5vo{color:var(--colorPaletteBrassForeground2);}",
		".f4w2gd0{background-color:var(--colorPaletteBrassBackground2);}",
		".ftl572b{color:var(--colorPaletteBrownForeground2);}",
		".f14wu1f4{background-color:var(--colorPaletteBrownBackground2);}",
		".f1gymlvd{color:var(--colorPaletteForestForeground2);}",
		".f19ut4y6{background-color:var(--colorPaletteForestBackground2);}",
		".fnnb6wn{color:var(--colorPaletteSeafoamForeground2);}",
		".f1n057jc{background-color:var(--colorPaletteSeafoamBackground2);}",
		".ff58qw8{color:var(--colorPaletteDarkGreenForeground2);}",
		".f11t05wk{background-color:var(--colorPaletteDarkGreenBackground2);}",
		".f1up9qbj{color:var(--colorPaletteLightTealForeground2);}",
		".f42feg1{background-color:var(--colorPaletteLightTealBackground2);}",
		".f135dsb4{color:var(--colorPaletteTealForeground2);}",
		".f6hvv1p{background-color:var(--colorPaletteTealBackground2);}",
		".f151dlcp{color:var(--colorPaletteSteelForeground2);}",
		".f1lnp8zf{background-color:var(--colorPaletteSteelBackground2);}",
		".f1rjv50u{color:var(--colorPaletteBlueForeground2);}",
		".f1ggcpy6{background-color:var(--colorPaletteBlueBackground2);}",
		".f1emykk5{color:var(--colorPaletteRoyalBlueForeground2);}",
		".f12rj61f{background-color:var(--colorPaletteRoyalBlueBackground2);}",
		".fqsigj7{color:var(--colorPaletteCornflowerForeground2);}",
		".f8k7hur{background-color:var(--colorPaletteCornflowerBackground2);}",
		".f1nj97xi{color:var(--colorPaletteNavyForeground2);}",
		".f19gw0ux{background-color:var(--colorPaletteNavyBackground2);}",
		".fwctg0i{color:var(--colorPaletteLavenderForeground2);}",
		".ff379vm{background-color:var(--colorPaletteLavenderBackground2);}",
		".fjrsgpu{color:var(--colorPalettePurpleForeground2);}",
		".f1mzf1e1{background-color:var(--colorPalettePurpleBackground2);}",
		".f1fiiydq{color:var(--colorPaletteGrapeForeground2);}",
		".f1o4k8oy{background-color:var(--colorPaletteGrapeBackground2);}",
		".f1res9jt{color:var(--colorPaletteLilacForeground2);}",
		".f1x6mz1o{background-color:var(--colorPaletteLilacBackground2);}",
		".fv3fbbi{color:var(--colorPalettePinkForeground2);}",
		".fydlv6t{background-color:var(--colorPalettePinkBackground2);}",
		".f1f1fwnz{color:var(--colorPaletteMagentaForeground2);}",
		".f4xb6j5{background-color:var(--colorPaletteMagentaBackground2);}",
		".f8ptl6j{color:var(--colorPalettePlumForeground2);}",
		".fqo8e26{background-color:var(--colorPalettePlumBackground2);}",
		".f1ntv3ld{color:var(--colorPaletteBeigeForeground2);}",
		".f101elhj{background-color:var(--colorPaletteBeigeBackground2);}",
		".f1fscmp{color:var(--colorPaletteMinkForeground2);}",
		".f13g8o5c{background-color:var(--colorPaletteMinkBackground2);}",
		".f1dr00v2{color:var(--colorPalettePlatinumForeground2);}",
		".fkh7blw{background-color:var(--colorPalettePlatinumBackground2);}",
		".f1f3ti53{color:var(--colorPaletteAnchorForeground2);}",
		".fu4yj0j{background-color:var(--colorPaletteAnchorBackground2);}"
	] });
	const useRingColorStyles = /* @__PURE__ */ __styles({
		neutral: { Bic5iru: "f1uuiafn" },
		brand: { Bic5iru: "f1uuiafn" },
		"dark-red": { Bic5iru: "f1t2x9on" },
		cranberry: { Bic5iru: "f1pvshc9" },
		red: { Bic5iru: "f1ectbk9" },
		pumpkin: { Bic5iru: "fvzpl0b" },
		peach: { Bic5iru: "fwj2kd7" },
		marigold: { Bic5iru: "fr120vy" },
		gold: { Bic5iru: "f8xmmar" },
		brass: { Bic5iru: "f1hbety2" },
		brown: { Bic5iru: "f1vg3s4g" },
		forest: { Bic5iru: "f1m3olm5" },
		seafoam: { Bic5iru: "f17xiqtr" },
		"dark-green": { Bic5iru: "fx32vyh" },
		"light-teal": { Bic5iru: "f1mkihwv" },
		teal: { Bic5iru: "fecnooh" },
		steel: { Bic5iru: "f15hfgzm" },
		blue: { Bic5iru: "fqproka" },
		"royal-blue": { Bic5iru: "f17v2w59" },
		cornflower: { Bic5iru: "fp0q1mo" },
		navy: { Bic5iru: "f1nlym55" },
		lavender: { Bic5iru: "f62vk8h" },
		purple: { Bic5iru: "f15zl69q" },
		grape: { Bic5iru: "f53w4j7" },
		lilac: { Bic5iru: "fu2771t" },
		pink: { Bic5iru: "fzflscs" },
		magenta: { Bic5iru: "fb6rmqc" },
		plum: { Bic5iru: "f1a4gm5b" },
		beige: { Bic5iru: "f1qpf9z1" },
		mink: { Bic5iru: "f1l7or83" },
		platinum: { Bic5iru: "fzrj0iu" },
		anchor: { Bic5iru: "f8oz6wf" }
	}, { d: [
		".f1uuiafn::before{color:var(--colorBrandStroke1);}",
		".f1t2x9on::before{color:var(--colorPaletteDarkRedBorderActive);}",
		".f1pvshc9::before{color:var(--colorPaletteCranberryBorderActive);}",
		".f1ectbk9::before{color:var(--colorPaletteRedBorderActive);}",
		".fvzpl0b::before{color:var(--colorPalettePumpkinBorderActive);}",
		".fwj2kd7::before{color:var(--colorPalettePeachBorderActive);}",
		".fr120vy::before{color:var(--colorPaletteMarigoldBorderActive);}",
		".f8xmmar::before{color:var(--colorPaletteGoldBorderActive);}",
		".f1hbety2::before{color:var(--colorPaletteBrassBorderActive);}",
		".f1vg3s4g::before{color:var(--colorPaletteBrownBorderActive);}",
		".f1m3olm5::before{color:var(--colorPaletteForestBorderActive);}",
		".f17xiqtr::before{color:var(--colorPaletteSeafoamBorderActive);}",
		".fx32vyh::before{color:var(--colorPaletteDarkGreenBorderActive);}",
		".f1mkihwv::before{color:var(--colorPaletteLightTealBorderActive);}",
		".fecnooh::before{color:var(--colorPaletteTealBorderActive);}",
		".f15hfgzm::before{color:var(--colorPaletteSteelBorderActive);}",
		".fqproka::before{color:var(--colorPaletteBlueBorderActive);}",
		".f17v2w59::before{color:var(--colorPaletteRoyalBlueBorderActive);}",
		".fp0q1mo::before{color:var(--colorPaletteCornflowerBorderActive);}",
		".f1nlym55::before{color:var(--colorPaletteNavyBorderActive);}",
		".f62vk8h::before{color:var(--colorPaletteLavenderBorderActive);}",
		".f15zl69q::before{color:var(--colorPalettePurpleBorderActive);}",
		".f53w4j7::before{color:var(--colorPaletteGrapeBorderActive);}",
		".fu2771t::before{color:var(--colorPaletteLilacBorderActive);}",
		".fzflscs::before{color:var(--colorPalettePinkBorderActive);}",
		".fb6rmqc::before{color:var(--colorPaletteMagentaBorderActive);}",
		".f1a4gm5b::before{color:var(--colorPalettePlumBorderActive);}",
		".f1qpf9z1::before{color:var(--colorPaletteBeigeBorderActive);}",
		".f1l7or83::before{color:var(--colorPaletteMinkBorderActive);}",
		".fzrj0iu::before{color:var(--colorPalettePlatinumBorderActive);}",
		".f8oz6wf::before{color:var(--colorPaletteAnchorBorderActive);}"
	] });
	const useAvatarStyles_unstable = (state) => {
		"use no memo";
		const { size: size$2, shape, active, activeAppearance, color: color$1 } = state;
		const rootClassName = useRootClassName$5();
		const imageClassName = useImageClassName();
		const iconInitialsClassName = useIconInitialsClassName();
		const styles = useStyles$101();
		const sizeStyles = useSizeStyles$4();
		const colorStyles = useColorStyles();
		const ringColorStyles = useRingColorStyles();
		const rootClasses = [rootClassName, size$2 !== 32 && sizeStyles[size$2]];
		if (state.badge) rootClasses.push(styles.badgeAlign, styles[state.badge.size || "medium"]);
		if (size$2 <= 24) rootClasses.push(styles.textCaption2Strong);
		else if (size$2 <= 28) rootClasses.push(styles.textCaption1Strong);
		else if (size$2 <= 40) {} else if (size$2 <= 56) rootClasses.push(styles.textSubtitle2);
		else if (size$2 <= 96) rootClasses.push(styles.textSubtitle1);
		else rootClasses.push(styles.textTitle3);
		if (shape === "square") if (size$2 <= 24) rootClasses.push(styles.squareSmall);
		else if (size$2 <= 48) rootClasses.push(styles.squareMedium);
		else if (size$2 <= 72) rootClasses.push(styles.squareLarge);
		else rootClasses.push(styles.squareXLarge);
		if (active === "active" || active === "inactive") {
			rootClasses.push(styles.activeOrInactive);
			if (activeAppearance === "ring" || activeAppearance === "ring-shadow") {
				rootClasses.push(styles.ring, ringColorStyles[color$1]);
				if (state.badge) rootClasses.push(styles.ringBadgeCutout);
				if (size$2 <= 48) rootClasses.push(styles.ringThick);
				else if (size$2 <= 64) rootClasses.push(styles.ringThicker);
				else rootClasses.push(styles.ringThickest);
			}
			if (activeAppearance === "shadow" || activeAppearance === "ring-shadow") {
				rootClasses.push(styles.shadow);
				if (size$2 <= 28) rootClasses.push(styles.shadow4);
				else if (size$2 <= 48) rootClasses.push(styles.shadow8);
				else if (size$2 <= 64) rootClasses.push(styles.shadow16);
				else rootClasses.push(styles.shadow28);
			}
			if (active === "inactive") rootClasses.push(styles.inactive);
		}
		state.root.className = mergeClasses(avatarClassNames.root, ...rootClasses, state.root.className);
		if (state.badge) state.badge.className = mergeClasses(avatarClassNames.badge, styles.badge, state.badge.className);
		if (state.image) state.image.className = mergeClasses(avatarClassNames.image, imageClassName, colorStyles[color$1], state.badge && styles.badgeCutout, state.image.className);
		if (state.initials) state.initials.className = mergeClasses(avatarClassNames.initials, iconInitialsClassName, colorStyles[color$1], state.badge && styles.badgeCutout, state.initials.className);
		if (state.icon) {
			let iconSizeClass;
			if (size$2 <= 16) iconSizeClass = styles.icon12;
			else if (size$2 <= 24) iconSizeClass = styles.icon16;
			else if (size$2 <= 40) iconSizeClass = styles.icon20;
			else if (size$2 <= 48) iconSizeClass = styles.icon24;
			else if (size$2 <= 56) iconSizeClass = styles.icon28;
			else if (size$2 <= 72) iconSizeClass = styles.icon32;
			else iconSizeClass = styles.icon48;
			state.icon.className = mergeClasses(avatarClassNames.icon, iconInitialsClassName, iconSizeClass, colorStyles[color$1], state.badge && styles.badgeCutout, state.icon.className);
		}
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-avatar/lib/components/Avatar/Avatar.js
	const Avatar = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useAvatar_unstable(props, ref);
		useAvatarStyles_unstable(state);
		useCustomStyleHook("useAvatarStyles_unstable")(state);
		return renderAvatar_unstable(state);
	});
	Avatar.displayName = "Avatar";

//#endregion
//#region node_modules/@fluentui/react-avatar/lib/contexts/AvatarGroupContext.js
/**
	* AvatarGroupContext is provided by AvatarGroup and AvatarGroupPopover. It's consumed by AvatarGroupItem to determine
	* default values of some props.
	*/ const AvatarGroupContext = createContext(void 0);
	const avatarGroupContextDefaultValue = {};
	const AvatarGroupProvider = AvatarGroupContext.Provider;
	const useAvatarGroupContext_unstable = (selector) => useContextSelector(AvatarGroupContext, (ctx = avatarGroupContextDefaultValue) => selector(ctx));

//#endregion
//#region node_modules/@fluentui/react-avatar/lib/components/AvatarGroup/renderAvatarGroup.js
/**
	* Render the final JSX of AvatarGroup
	*/ const renderAvatarGroup_unstable = (state, contextValues) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(AvatarGroupProvider, {
			value: contextValues.avatarGroup,
			children: /* @__PURE__ */ jsx(state.root, {})
		});
	};

//#endregion
//#region node_modules/@fluentui/react-avatar/lib/components/AvatarGroup/useAvatarGroup.js
/**
	* Create the state required to render AvatarGroup.
	*
	* The returned state can be modified with hooks such as useAvatarGroupStyles_unstable,
	* before being passed to renderAvatarGroup_unstable.
	*
	* @param props - props from this instance of AvatarGroup
	* @param ref - reference to root HTMLElement of AvatarGroup
	*/ const useAvatarGroup_unstable = (props, ref) => {
		const { layout = "spread", size: size$2 = defaultAvatarGroupSize } = props;
		return {
			layout,
			size: size$2,
			components: { root: "div" },
			root: always(getIntrinsicElementProps("div", {
				role: "group",
				...props,
				ref
			}, ["size"]), { elementType: "div" })
		};
	};
	const defaultAvatarGroupSize = 32;

//#endregion
//#region node_modules/@fluentui/react-avatar/lib/components/AvatarGroup/useAvatarGroupContextValues.js
	const useAvatarGroupContextValues = (state) => {
		const { layout, size: size$2 } = state;
		return { avatarGroup: {
			layout,
			size: size$2
		} };
	};

//#endregion
//#region node_modules/@fluentui/react-avatar/lib/components/AvatarGroup/useAvatarGroupStyles.styles.js
	const avatarGroupClassNames = { root: "fui-AvatarGroup" };
	/**
	* Styles for the root slot.
	*/
	const useStyles$100 = /* @__PURE__ */ __styles({
		base: {
			mc9l5x: "ftuwxu6",
			qhf8xq: "f10pi13n"
		},
		pie: {
			Bgl5zvf: "f1uz6ud1",
			De3pzq: "f1ganh6p",
			By8wz76: "f1wgxgin"
		}
	}, {
		d: [
			".ftuwxu6{display:inline-flex;}",
			".f10pi13n{position:relative;}",
			".f1uz6ud1{clip-path:circle(50%);}",
			".f1ganh6p{background-color:var(--colorTransparentStroke);}"
		],
		m: [["@media (forced-colors: active){.f1wgxgin{background-color:CanvasText;}}", { m: "(forced-colors: active)" }]]
	});
	/**
	* Apply styling to the AvatarGroup slots based on the state
	*/
	const useAvatarGroupStyles_unstable = (state) => {
		"use no memo";
		const { layout, size: size$2 } = state;
		const styles = useStyles$100();
		const sizeStyles = useSizeStyles$4();
		state.root.className = mergeClasses(avatarGroupClassNames.root, styles.base, layout === "pie" && sizeStyles[size$2], layout === "pie" && styles.pie, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-avatar/lib/components/AvatarGroup/AvatarGroup.js
/**
	* The AvatarGroup component represents a group of multiple people or entities by taking care of the arrangement
	* of individual Avatars in a spread, stack, or pie layout.
	*/ const AvatarGroup = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useAvatarGroup_unstable(props, ref);
		const contextValues = useAvatarGroupContextValues(state);
		useAvatarGroupStyles_unstable(state);
		useCustomStyleHook("useAvatarGroupStyles_unstable")(state);
		return renderAvatarGroup_unstable(state, contextValues);
	});
	AvatarGroup.displayName = "AvatarGroup";

//#endregion
//#region node_modules/@fluentui/react-avatar/lib/components/AvatarGroupItem/renderAvatarGroupItem.js
/**
	* Render the final JSX of AvatarGroupItem
	*/ const renderAvatarGroupItem_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(state.root, { children: [/* @__PURE__ */ jsx(state.avatar, {}), state.isOverflowItem && /* @__PURE__ */ jsx(state.overflowLabel, {})] });
	};

//#endregion
//#region node_modules/@fluentui/react-avatar/lib/components/AvatarGroupItem/useAvatarGroupItem.js
/**
	* Create the state required to render AvatarGroupItem.
	*
	* The returned state can be modified with hooks such as useAvatarGroupItemStyles_unstable,
	* before being passed to renderAvatarGroupItem_unstable.
	*
	* @param props - props from this instance of AvatarGroupItem
	* @param ref - reference to root HTMLElement of AvatarGroupItem
	*/ const useAvatarGroupItem_unstable = (props, ref) => {
		const groupIsOverflow = useAvatarGroupContext_unstable((ctx) => ctx.isOverflow);
		const groupSize = useAvatarGroupContext_unstable((ctx) => ctx.size);
		const layout = useAvatarGroupContext_unstable((ctx) => ctx.layout);
		const { style, className, ...avatarSlotProps } = props;
		const size$2 = groupSize !== null && groupSize !== void 0 ? groupSize : defaultAvatarGroupSize;
		if (!useHasParentContext(AvatarGroupContext)) console.warn("AvatarGroupItem must only be used inside an AvatarGroup component.");
		return {
			isOverflowItem: groupIsOverflow,
			layout,
			size: size$2,
			components: {
				root: groupIsOverflow ? "li" : "div",
				avatar: Avatar,
				overflowLabel: "span"
			},
			root: always(props.root, {
				defaultProps: {
					style,
					className
				},
				elementType: groupIsOverflow ? "li" : "div"
			}),
			avatar: always(props.avatar, {
				defaultProps: {
					ref,
					size: size$2,
					color: "colorful",
					...avatarSlotProps
				},
				elementType: Avatar
			}),
			overflowLabel: always(props.overflowLabel, {
				defaultProps: {
					"aria-hidden": true,
					children: props.name
				},
				elementType: "span"
			})
		};
	};

//#endregion
//#region node_modules/@fluentui/react-avatar/lib/components/AvatarGroupItem/useAvatarGroupItemStyles.styles.js
	const avatarGroupItemClassNames = {
		root: "fui-AvatarGroupItem",
		avatar: "fui-AvatarGroupItem__avatar",
		overflowLabel: "fui-AvatarGroupItem__overflowLabel"
	};
	/**
	* Styles for the root slot
	*/
	const useRootStyles$27 = /* @__PURE__ */ __styles({
		base: {
			Bt984gj: "f122n59",
			mc9l5x: "ftuwxu6",
			Bnnss6s: "fi64zpg",
			qhf8xq: "f10pi13n"
		},
		overflowItem: {
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f16d74zd"
		},
		nonOverflowItem: {
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "f44lkw9"
		}
	}, { d: [
		".f122n59{align-items:center;}",
		".ftuwxu6{display:inline-flex;}",
		".fi64zpg{flex-shrink:0;}",
		".f10pi13n{position:relative;}",
		[".f16d74zd{padding:var(--spacingVerticalXS) var(--spacingHorizontalXS);}", { p: -1 }],
		[".f44lkw9{border-radius:var(--borderRadiusCircular);}", { p: -1 }]
	] });
	/**
	* Styles for the avatar slot
	*/
	const useAvatarStyles = /* @__PURE__ */ __styles({
		nonOverflowItem: { qhf8xq: "f1euv43f" },
		pie: {
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "fokr779"
		}
	}, { d: [".f1euv43f{position:absolute;}", [".fokr779{border-radius:0;}", { p: -1 }]] });
	/**
	* Styles for the label slot
	*/
	const useOverflowLabelStyles = /* @__PURE__ */ __styles({ base: {
		Frg6f3: ["foyynoy", "f1vcna3q"],
		sj55zd: "f19n0e5",
		Bahqtrf: "fk6fouc",
		Be2twd7: "fkhj508",
		Bhrd7zp: "figsok6",
		Bg96gwp: "f1i3iumi"
	} }, { d: [
		".foyynoy{margin-left:var(--spacingHorizontalS);}",
		".f1vcna3q{margin-right:var(--spacingHorizontalS);}",
		".f19n0e5{color:var(--colorNeutralForeground1);}",
		".fk6fouc{font-family:var(--fontFamilyBase);}",
		".fkhj508{font-size:var(--fontSizeBase300);}",
		".figsok6{font-weight:var(--fontWeightRegular);}",
		".f1i3iumi{line-height:var(--lineHeightBase300);}"
	] });
	/**
	* Styles for the stack layout
	*/
	const useStackStyles = /* @__PURE__ */ __styles({
		thick: { E5pizo: "foiuzp5" },
		thicker: { E5pizo: "f1x6o7w7" },
		thickest: { E5pizo: "f2aml1u" },
		xxs: { jhia2w: ["f1cjco14", "f13dxjc9"] },
		xs: { jhia2w: ["f15p6bln", "f1bab3ru"] },
		s: { jhia2w: ["f1v53ncc", "f17pu8r8"] },
		l: { jhia2w: ["flv48ch", "fnh1ydj"] }
	}, { d: [
		".foiuzp5{box-shadow:0 0 0 var(--strokeWidthThick) var(--colorNeutralBackground2);}",
		".f1x6o7w7{box-shadow:0 0 0 var(--strokeWidthThicker) var(--colorNeutralBackground2);}",
		".f2aml1u{box-shadow:0 0 0 var(--strokeWidthThickest) var(--colorNeutralBackground2);}",
		".f1cjco14:not(:first-child){margin-left:calc(-1 * var(--spacingHorizontalXXS));}",
		".f13dxjc9:not(:first-child){margin-right:calc(-1 * var(--spacingHorizontalXXS));}",
		".f15p6bln:not(:first-child){margin-left:calc(-1 * var(--spacingHorizontalXS));}",
		".f1bab3ru:not(:first-child){margin-right:calc(-1 * var(--spacingHorizontalXS));}",
		".f1v53ncc:not(:first-child){margin-left:calc(-1 * var(--spacingHorizontalS));}",
		".f17pu8r8:not(:first-child){margin-right:calc(-1 * var(--spacingHorizontalS));}",
		".flv48ch:not(:first-child){margin-left:calc(-1 * var(--spacingHorizontalL));}",
		".fnh1ydj:not(:first-child){margin-right:calc(-1 * var(--spacingHorizontalL));}"
	] });
	/**
	* Styles for the spread layout
	*/
	const useSpreadStyles = /* @__PURE__ */ __styles({
		s: { jhia2w: ["f7lhxv7", "f6ou2b0"] },
		mNudge: { jhia2w: ["f1h0okno", "fnnqava"] },
		m: { jhia2w: ["f1wkt588", "f1maio5g"] },
		l: { jhia2w: ["f1l333zn", "f1r41m4c"] },
		xl: { jhia2w: ["fahr13a", "f2n7rbo"] }
	}, { d: [
		".f7lhxv7:not(:first-child){margin-left:var(--spacingHorizontalS);}",
		".f6ou2b0:not(:first-child){margin-right:var(--spacingHorizontalS);}",
		".f1h0okno:not(:first-child){margin-left:var(--spacingHorizontalMNudge);}",
		".fnnqava:not(:first-child){margin-right:var(--spacingHorizontalMNudge);}",
		".f1wkt588:not(:first-child){margin-left:var(--spacingHorizontalM);}",
		".f1maio5g:not(:first-child){margin-right:var(--spacingHorizontalM);}",
		".f1l333zn:not(:first-child){margin-left:var(--spacingHorizontalL);}",
		".f1r41m4c:not(:first-child){margin-right:var(--spacingHorizontalL);}",
		".fahr13a:not(:first-child){margin-left:var(--spacingHorizontalXL);}",
		".f2n7rbo:not(:first-child){margin-right:var(--spacingHorizontalXL);}"
	] });
	/**
	* Styles for the pie layout
	*/
	const usePieStyles = /* @__PURE__ */ __styles({
		base: { qhf8xq: "f1euv43f" },
		slices: {
			B3gf25r: "f16m7w7k",
			Be2twx7: ["f1o4hhgz", "fb4gjrz"],
			Bvaow4n: "f1pgb5nx",
			Gpecfs: ["fugirid", "f4sk99m"],
			bhabj1: "fjreaf3",
			B7rc6i7: ["f1k4vw81", "f1w1xcy7"],
			Bwrfys5: "f1ef8vxk",
			Bwuzm9m: ["f1x2qbfv", "f1xwf4nz"],
			fflka: "ff6xuso",
			do7bja: "fzpvk6c",
			Be8zqhl: "f4onu7f",
			Bij0kh0: ["f1ydfez1", "fjensob"],
			Bwexnyt: "f1yv732j",
			Bhe5x6o: "fchq2fj",
			B3kv7bh: "ff5binh"
		},
		rtlSlices: {
			B3gf25r: "f5vdl61",
			Bvaow4n: "f1bnra92",
			bhabj1: "f4ibo7t",
			Bwrfys5: "f17heuis",
			Bwuzm9m: ["f64f2ud", "f1yjglu3"],
			Be8zqhl: "fa6l61x",
			Bij0kh0: ["f1w2396a", "f14ab3yo"]
		},
		thick: { uiicq7: "fnyfzln" },
		thicker: { uiicq7: "f1xdzzot" },
		thickest: { uiicq7: "f1auhru5" }
	}, { d: [
		".f1euv43f{position:absolute;}",
		".f16m7w7k:nth-of-type(1):nth-last-of-type(2){clip-path:inset(0 calc(25% + (var(--fuiAvatarGroupItem__divider--width) / 2)) 0 25%);}",
		".f1o4hhgz:nth-of-type(1):nth-last-of-type(2){left:-25%;}",
		".fb4gjrz:nth-of-type(1):nth-last-of-type(2){right:-25%;}",
		".f1pgb5nx:nth-of-type(2):nth-last-of-type(1){clip-path:inset(0 25% 0 calc(25% + (var(--fuiAvatarGroupItem__divider--width) / 2)));}",
		".fugirid:nth-of-type(2):nth-last-of-type(1){left:25%;}",
		".f4sk99m:nth-of-type(2):nth-last-of-type(1){right:25%;}",
		".fjreaf3:nth-of-type(1):nth-last-of-type(3){clip-path:inset(0 calc(25% + (var(--fuiAvatarGroupItem__divider--width) / 2)) 0 25%);}",
		".f1k4vw81:nth-of-type(1):nth-last-of-type(3){left:-25%;}",
		".f1w1xcy7:nth-of-type(1):nth-last-of-type(3){right:-25%;}",
		".f1ef8vxk:nth-of-type(2):nth-last-of-type(2){clip-path:inset(0 0 var(--fuiAvatarGroupItem__divider--width) var(--fuiAvatarGroupItem__divider--width));}",
		".f1x2qbfv:nth-of-type(2):nth-last-of-type(2){left:50%;}",
		".f1xwf4nz:nth-of-type(2):nth-last-of-type(2){right:50%;}",
		".ff6xuso:nth-of-type(2):nth-last-of-type(2){transform:scale(0.5);}",
		".fzpvk6c:nth-of-type(2):nth-last-of-type(2){transform-origin:0 0;}",
		".f4onu7f:nth-of-type(3):nth-last-of-type(1){clip-path:inset(var(--fuiAvatarGroupItem__divider--width) 0 0 var(--fuiAvatarGroupItem__divider--width));}",
		".f1ydfez1:nth-of-type(3):nth-last-of-type(1){left:50%;}",
		".fjensob:nth-of-type(3):nth-last-of-type(1){right:50%;}",
		".f1yv732j:nth-of-type(3):nth-last-of-type(1){top:50%;}",
		".fchq2fj:nth-of-type(3):nth-last-of-type(1){transform:scale(0.5);}",
		".ff5binh:nth-of-type(3):nth-last-of-type(1){transform-origin:0 0;}",
		".f5vdl61:nth-of-type(1):nth-last-of-type(2){clip-path:inset(0 25% 0 calc(25% + (var(--fuiAvatarGroupItem__divider--width) / 2)));}",
		".f1bnra92:nth-of-type(2):nth-last-of-type(1){clip-path:inset(0 calc(25% + (var(--fuiAvatarGroupItem__divider--width) / 2)) 0 25%);}",
		".f4ibo7t:nth-of-type(1):nth-last-of-type(3){clip-path:inset(0 25% 0 calc(25% + (var(--fuiAvatarGroupItem__divider--width) / 2)));}",
		".f17heuis:nth-of-type(2):nth-last-of-type(2){clip-path:inset(0 var(--fuiAvatarGroupItem__divider--width) var(--fuiAvatarGroupItem__divider--width) 0);}",
		".f64f2ud:nth-of-type(2):nth-last-of-type(2){left:0;}",
		".f1yjglu3:nth-of-type(2):nth-last-of-type(2){right:0;}",
		".fa6l61x:nth-of-type(3):nth-last-of-type(1){clip-path:inset(var(--fuiAvatarGroupItem__divider--width) var(--fuiAvatarGroupItem__divider--width) 0 0);}",
		".f1w2396a:nth-of-type(3):nth-last-of-type(1){left:0;}",
		".f14ab3yo:nth-of-type(3):nth-last-of-type(1){right:0;}",
		".fnyfzln{--fuiAvatarGroupItem__divider--width:var(--strokeWidthThick);}",
		".f1xdzzot{--fuiAvatarGroupItem__divider--width:var(--strokeWidthThicker);}",
		".f1auhru5{--fuiAvatarGroupItem__divider--width:var(--strokeWidthThickest);}"
	] });
	/**
	* Apply styling to the AvatarGroupItem slots based on the state
	*/
	const useAvatarGroupItemStyles_unstable = (state) => {
		"use no memo";
		const { isOverflowItem, layout, size: size$2 } = state;
		const { dir } = useFluent();
		const avatarStyles = useAvatarStyles();
		const overflowLabelStyles = useOverflowLabelStyles();
		const pieStyles = usePieStyles();
		const rootStyles = useRootStyles$27();
		const sizeStyles = useSizeStyles$4();
		const groupChildClassName = useGroupChildClassName(layout, size$2);
		const rootClasses = [rootStyles.base];
		if (!isOverflowItem) {
			rootClasses.push(rootStyles.nonOverflowItem);
			rootClasses.push(groupChildClassName);
			rootClasses.push(sizeStyles[size$2]);
			if (layout === "pie") {
				rootClasses.push(pieStyles.base);
				if (size$2 < 56) rootClasses.push(pieStyles.thick);
				else if (size$2 < 72) rootClasses.push(pieStyles.thicker);
				else rootClasses.push(pieStyles.thickest);
				rootClasses.push(pieStyles.slices);
				if (dir === "rtl") rootClasses.push(pieStyles.rtlSlices);
			}
		} else rootClasses.push(rootStyles.overflowItem);
		state.root.className = mergeClasses(avatarGroupItemClassNames.root, ...rootClasses, state.root.className);
		state.avatar.className = mergeClasses(avatarGroupItemClassNames.avatar, !isOverflowItem && avatarStyles.nonOverflowItem, layout === "pie" && avatarStyles.pie, state.avatar.className);
		if (state.overflowLabel) state.overflowLabel.className = mergeClasses(avatarGroupItemClassNames.overflowLabel, overflowLabelStyles.base, state.overflowLabel.className);
		return state;
	};
	/**
	* Hook for getting the className for the children of AvatarGroup. This hook will provide the spacing and outlines
	* needed for each layout.
	*/
	const useGroupChildClassName = (layout, size$2) => {
		const stackStyles = useStackStyles();
		const spreadStyles = useSpreadStyles();
		const layoutClasses = [];
		if (size$2) {
			if (layout === "stack") {
				if (size$2 < 56) layoutClasses.push(stackStyles.thick);
				else if (size$2 < 72) layoutClasses.push(stackStyles.thicker);
				else layoutClasses.push(stackStyles.thickest);
				if (size$2 < 24) layoutClasses.push(stackStyles.xxs);
				else if (size$2 < 48) layoutClasses.push(stackStyles.xs);
				else if (size$2 < 96) layoutClasses.push(stackStyles.s);
				else layoutClasses.push(stackStyles.l);
			} else if (layout === "spread") if (size$2 < 20) layoutClasses.push(spreadStyles.s);
			else if (size$2 < 32) layoutClasses.push(spreadStyles.mNudge);
			else if (size$2 < 64) layoutClasses.push(spreadStyles.l);
			else layoutClasses.push(spreadStyles.xl);
		}
		return mergeClasses(...layoutClasses);
	};

//#endregion
//#region node_modules/@fluentui/react-avatar/lib/components/AvatarGroupItem/AvatarGroupItem.js
/**
	* The AvatarGroupItem component represents a single person or entity.
	* AvatarGroupItem should only be used in an AvatarGroup component.
	*/ const AvatarGroupItem = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useAvatarGroupItem_unstable(props, ref);
		useAvatarGroupItemStyles_unstable(state);
		useCustomStyleHook("useAvatarGroupItemStyles_unstable")(state);
		return renderAvatarGroupItem_unstable(state);
	});
	AvatarGroupItem.displayName = "AvatarGroupItem";

//#endregion
//#region node_modules/@fluentui/react-positioning/lib/createVirtualElementFromClick.js
/**
	* Creates a virtual element based on the position of a click event
	* Can be used as a target for popper in scenarios such as context menus
	*/ function createVirtualElementFromClick(nativeEvent) {
		const left$1 = nativeEvent.clientX;
		const top = nativeEvent.clientY;
		const right$1 = left$1 + 1;
		const bottom = top + 1;
		function getBoundingClientRect$1() {
			return {
				left: left$1,
				top,
				right: right$1,
				bottom,
				x: left$1,
				y: top,
				height: 1,
				width: 1
			};
		}
		return { getBoundingClientRect: getBoundingClientRect$1 };
	}

//#endregion
//#region node_modules/@fluentui/react-positioning/lib/constants.js
	const DATA_POSITIONING_INTERSECTING = "data-popper-is-intersecting";
	const DATA_POSITIONING_ESCAPED = "data-popper-escaped";
	const DATA_POSITIONING_HIDDEN = "data-popper-reference-hidden";
	const DATA_POSITIONING_PLACEMENT = "data-popper-placement";
	const POSITIONING_END_EVENT = "fui-positioningend";

//#endregion
//#region node_modules/@fluentui/react-positioning/lib/PositioningConfigurationContext.js
	const DEFAULT_CONFIGURATION = ({ options }) => {
		return options;
	};
	const PositioningConfigurationContext = react.createContext(void 0);
	/**
	* A context provider for the positioning configuration.
	*
	* Accepts a function that takes the positioning options and returns them modified.
	*/ const PositioningConfigurationProvider = PositioningConfigurationContext.Provider;
	const usePositioningConfiguration = () => {
		var _React_useContext;
		return (_React_useContext = react.useContext(PositioningConfigurationContext)) !== null && _React_useContext !== void 0 ? _React_useContext : DEFAULT_CONFIGURATION;
	};

//#endregion
//#region node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
/**
	* Custom positioning reference element.
	* @see https://floating-ui.com/docs/virtual-elements
	*/
	const sides = [
		"top",
		"right",
		"bottom",
		"left"
	];
	const min = Math.min;
	const max = Math.max;
	const round = Math.round;
	const createCoords = (v) => ({
		x: v,
		y: v
	});
	const oppositeSideMap = {
		left: "right",
		right: "left",
		bottom: "top",
		top: "bottom"
	};
	const oppositeAlignmentMap = {
		start: "end",
		end: "start"
	};
	function clamp$1(start, value, end) {
		return max(start, min(value, end));
	}
	function evaluate(value, param) {
		return typeof value === "function" ? value(param) : value;
	}
	function getSide(placement) {
		return placement.split("-")[0];
	}
	function getAlignment(placement) {
		return placement.split("-")[1];
	}
	function getOppositeAxis(axis) {
		return axis === "x" ? "y" : "x";
	}
	function getAxisLength(axis) {
		return axis === "y" ? "height" : "width";
	}
	const yAxisSides = /* @__PURE__ */ new Set(["top", "bottom"]);
	function getSideAxis(placement) {
		return yAxisSides.has(getSide(placement)) ? "y" : "x";
	}
	function getAlignmentAxis(placement) {
		return getOppositeAxis(getSideAxis(placement));
	}
	function getAlignmentSides(placement, rects, rtl) {
		if (rtl === void 0) rtl = false;
		const alignment = getAlignment(placement);
		const alignmentAxis = getAlignmentAxis(placement);
		const length$1 = getAxisLength(alignmentAxis);
		let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
		if (rects.reference[length$1] > rects.floating[length$1]) mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
		return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
	}
	function getExpandedPlacements(placement) {
		const oppositePlacement = getOppositePlacement(placement);
		return [
			getOppositeAlignmentPlacement(placement),
			oppositePlacement,
			getOppositeAlignmentPlacement(oppositePlacement)
		];
	}
	function getOppositeAlignmentPlacement(placement) {
		return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
	}
	const lrPlacement = ["left", "right"];
	const rlPlacement = ["right", "left"];
	const tbPlacement = ["top", "bottom"];
	const btPlacement = ["bottom", "top"];
	function getSideList(side, isStart, rtl) {
		switch (side) {
			case "top":
			case "bottom":
				if (rtl) return isStart ? rlPlacement : lrPlacement;
				return isStart ? lrPlacement : rlPlacement;
			case "left":
			case "right": return isStart ? tbPlacement : btPlacement;
			default: return [];
		}
	}
	function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
		const alignment = getAlignment(placement);
		let list = getSideList(getSide(placement), direction === "start", rtl);
		if (alignment) {
			list = list.map((side) => side + "-" + alignment);
			if (flipAlignment) list = list.concat(list.map(getOppositeAlignmentPlacement));
		}
		return list;
	}
	function getOppositePlacement(placement) {
		return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
	}
	function expandPaddingObject(padding$1) {
		return {
			top: 0,
			right: 0,
			bottom: 0,
			left: 0,
			...padding$1
		};
	}
	function getPaddingObject(padding$1) {
		return typeof padding$1 !== "number" ? expandPaddingObject(padding$1) : {
			top: padding$1,
			right: padding$1,
			bottom: padding$1,
			left: padding$1
		};
	}
	function rectToClientRect(rect) {
		const { x, y, width, height } = rect;
		return {
			width,
			height,
			top: y,
			left: x,
			right: x + width,
			bottom: y + height,
			x,
			y
		};
	}

//#endregion
//#region node_modules/@floating-ui/core/dist/floating-ui.core.mjs
	function computeCoordsFromPlacement(_ref, placement, rtl) {
		let { reference, floating } = _ref;
		const sideAxis = getSideAxis(placement);
		const alignmentAxis = getAlignmentAxis(placement);
		const alignLength = getAxisLength(alignmentAxis);
		const side = getSide(placement);
		const isVertical = sideAxis === "y";
		const commonX = reference.x + reference.width / 2 - floating.width / 2;
		const commonY = reference.y + reference.height / 2 - floating.height / 2;
		const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
		let coords;
		switch (side) {
			case "top":
				coords = {
					x: commonX,
					y: reference.y - floating.height
				};
				break;
			case "bottom":
				coords = {
					x: commonX,
					y: reference.y + reference.height
				};
				break;
			case "right":
				coords = {
					x: reference.x + reference.width,
					y: commonY
				};
				break;
			case "left":
				coords = {
					x: reference.x - floating.width,
					y: commonY
				};
				break;
			default: coords = {
				x: reference.x,
				y: reference.y
			};
		}
		switch (getAlignment(placement)) {
			case "start":
				coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
				break;
			case "end":
				coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
				break;
		}
		return coords;
	}
	/**
	* Computes the `x` and `y` coordinates that will place the floating element
	* next to a given reference element.
	*
	* This export does not have any `platform` interface logic. You will need to
	* write one for the platform you are using Floating UI with.
	*/
	const computePosition$1 = async (reference, floating, config) => {
		const { placement = "bottom", strategy = "absolute", middleware: middleware$1 = [], platform: platform$1 } = config;
		const validMiddleware = middleware$1.filter(Boolean);
		const rtl = await (platform$1.isRTL == null ? void 0 : platform$1.isRTL(floating));
		let rects = await platform$1.getElementRects({
			reference,
			floating,
			strategy
		});
		let { x, y } = computeCoordsFromPlacement(rects, placement, rtl);
		let statefulPlacement = placement;
		let middlewareData = {};
		let resetCount = 0;
		for (let i = 0; i < validMiddleware.length; i++) {
			const { name, fn } = validMiddleware[i];
			const { x: nextX, y: nextY, data, reset } = await fn({
				x,
				y,
				initialPlacement: placement,
				placement: statefulPlacement,
				strategy,
				middlewareData,
				rects,
				platform: platform$1,
				elements: {
					reference,
					floating
				}
			});
			x = nextX != null ? nextX : x;
			y = nextY != null ? nextY : y;
			middlewareData = {
				...middlewareData,
				[name]: {
					...middlewareData[name],
					...data
				}
			};
			if (reset && resetCount <= 50) {
				resetCount++;
				if (typeof reset === "object") {
					if (reset.placement) statefulPlacement = reset.placement;
					if (reset.rects) rects = reset.rects === true ? await platform$1.getElementRects({
						reference,
						floating,
						strategy
					}) : reset.rects;
					({x, y} = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
				}
				i = -1;
			}
		}
		return {
			x,
			y,
			placement: statefulPlacement,
			strategy,
			middlewareData
		};
	};
	/**
	* Resolves with an object of overflow side offsets that determine how much the
	* element is overflowing a given clipping boundary on each side.
	* - positive = overflowing the boundary by that number of pixels
	* - negative = how many pixels left before it will overflow
	* - 0 = lies flush with the boundary
	* @see https://floating-ui.com/docs/detectOverflow
	*/
	async function detectOverflow$1(state, options) {
		var _await$platform$isEle;
		if (options === void 0) options = {};
		const { x, y, platform: platform$1, rects, elements, strategy } = state;
		const { boundary = "clippingAncestors", rootBoundary = "viewport", elementContext = "floating", altBoundary = false, padding: padding$1 = 0 } = evaluate(options, state);
		const paddingObject = getPaddingObject(padding$1);
		const element = elements[altBoundary ? elementContext === "floating" ? "reference" : "floating" : elementContext];
		const clippingClientRect = rectToClientRect(await platform$1.getClippingRect({
			element: ((_await$platform$isEle = await (platform$1.isElement == null ? void 0 : platform$1.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform$1.getDocumentElement == null ? void 0 : platform$1.getDocumentElement(elements.floating)),
			boundary,
			rootBoundary,
			strategy
		}));
		const rect = elementContext === "floating" ? {
			x,
			y,
			width: rects.floating.width,
			height: rects.floating.height
		} : rects.reference;
		const offsetParent = await (platform$1.getOffsetParent == null ? void 0 : platform$1.getOffsetParent(elements.floating));
		const offsetScale = await (platform$1.isElement == null ? void 0 : platform$1.isElement(offsetParent)) ? await (platform$1.getScale == null ? void 0 : platform$1.getScale(offsetParent)) || {
			x: 1,
			y: 1
		} : {
			x: 1,
			y: 1
		};
		const elementClientRect = rectToClientRect(platform$1.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform$1.convertOffsetParentRelativeRectToViewportRelativeRect({
			elements,
			rect,
			offsetParent,
			strategy
		}) : rect);
		return {
			top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
			bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
			left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
			right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
		};
	}
	/**
	* Provides data to position an inner element of the floating element so that it
	* appears centered to the reference element.
	* @see https://floating-ui.com/docs/arrow
	*/
	const arrow$1 = (options) => ({
		name: "arrow",
		options,
		async fn(state) {
			const { x, y, placement, rects, platform: platform$1, elements, middlewareData } = state;
			const { element, padding: padding$1 = 0 } = evaluate(options, state) || {};
			if (element == null) return {};
			const paddingObject = getPaddingObject(padding$1);
			const coords = {
				x,
				y
			};
			const axis = getAlignmentAxis(placement);
			const length$1 = getAxisLength(axis);
			const arrowDimensions = await platform$1.getDimensions(element);
			const isYAxis = axis === "y";
			const minProp = isYAxis ? "top" : "left";
			const maxProp = isYAxis ? "bottom" : "right";
			const clientProp = isYAxis ? "clientHeight" : "clientWidth";
			const endDiff = rects.reference[length$1] + rects.reference[axis] - coords[axis] - rects.floating[length$1];
			const startDiff = coords[axis] - rects.reference[axis];
			const arrowOffsetParent = await (platform$1.getOffsetParent == null ? void 0 : platform$1.getOffsetParent(element));
			let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
			if (!clientSize || !await (platform$1.isElement == null ? void 0 : platform$1.isElement(arrowOffsetParent))) clientSize = elements.floating[clientProp] || rects.floating[length$1];
			const centerToReference = endDiff / 2 - startDiff / 2;
			const largestPossiblePadding = clientSize / 2 - arrowDimensions[length$1] / 2 - 1;
			const minPadding = min(paddingObject[minProp], largestPossiblePadding);
			const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
			const min$1 = minPadding;
			const max$1 = clientSize - arrowDimensions[length$1] - maxPadding;
			const center = clientSize / 2 - arrowDimensions[length$1] / 2 + centerToReference;
			const offset$3 = clamp$1(min$1, center, max$1);
			const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset$3 && rects.reference[length$1] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length$1] / 2 < 0;
			const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max$1 : 0;
			return {
				[axis]: coords[axis] + alignmentOffset,
				data: {
					[axis]: offset$3,
					centerOffset: center - offset$3 - alignmentOffset,
					...shouldAddOffset && { alignmentOffset }
				},
				reset: shouldAddOffset
			};
		}
	});
	/**
	* Optimizes the visibility of the floating element by flipping the `placement`
	* in order to keep it in view when the preferred placement(s) will overflow the
	* clipping boundary. Alternative to `autoPlacement`.
	* @see https://floating-ui.com/docs/flip
	*/
	const flip$2 = function(options) {
		if (options === void 0) options = {};
		return {
			name: "flip",
			options,
			async fn(state) {
				var _middlewareData$arrow, _middlewareData$flip;
				const { placement, middlewareData, rects, initialPlacement, platform: platform$1, elements } = state;
				const { mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = true, fallbackPlacements: specifiedFallbackPlacements, fallbackStrategy = "bestFit", fallbackAxisSideDirection = "none", flipAlignment = true, ...detectOverflowOptions } = evaluate(options, state);
				if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) return {};
				const side = getSide(placement);
				const initialSideAxis = getSideAxis(initialPlacement);
				const isBasePlacement = getSide(initialPlacement) === initialPlacement;
				const rtl = await (platform$1.isRTL == null ? void 0 : platform$1.isRTL(elements.floating));
				const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
				const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
				if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
				const placements = [initialPlacement, ...fallbackPlacements];
				const overflow$1 = await detectOverflow$1(state, detectOverflowOptions);
				const overflows = [];
				let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
				if (checkMainAxis) overflows.push(overflow$1[side]);
				if (checkCrossAxis) {
					const sides$1 = getAlignmentSides(placement, rects, rtl);
					overflows.push(overflow$1[sides$1[0]], overflow$1[sides$1[1]]);
				}
				overflowsData = [...overflowsData, {
					placement,
					overflows
				}];
				if (!overflows.every((side$1) => side$1 <= 0)) {
					var _middlewareData$flip2, _overflowsData$filter;
					const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
					const nextPlacement = placements[nextIndex];
					if (nextPlacement) {
						if (!(checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false) || overflowsData.every((d) => getSideAxis(d.placement) === initialSideAxis ? d.overflows[0] > 0 : true)) return {
							data: {
								index: nextIndex,
								overflows: overflowsData
							},
							reset: { placement: nextPlacement }
						};
					}
					let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
					if (!resetPlacement) switch (fallbackStrategy) {
						case "bestFit": {
							var _overflowsData$filter2;
							const placement$1 = (_overflowsData$filter2 = overflowsData.filter((d) => {
								if (hasFallbackAxisSideDirection) {
									const currentSideAxis = getSideAxis(d.placement);
									return currentSideAxis === initialSideAxis || currentSideAxis === "y";
								}
								return true;
							}).map((d) => [d.placement, d.overflows.filter((overflow$2) => overflow$2 > 0).reduce((acc, overflow$2) => acc + overflow$2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
							if (placement$1) resetPlacement = placement$1;
							break;
						}
						case "initialPlacement":
							resetPlacement = initialPlacement;
							break;
					}
					if (placement !== resetPlacement) return { reset: { placement: resetPlacement } };
				}
				return {};
			}
		};
	};
	function getSideOffsets(overflow$1, rect) {
		return {
			top: overflow$1.top - rect.height,
			right: overflow$1.right - rect.width,
			bottom: overflow$1.bottom - rect.height,
			left: overflow$1.left - rect.width
		};
	}
	function isAnySideFullyClipped(overflow$1) {
		return sides.some((side) => overflow$1[side] >= 0);
	}
	/**
	* Provides data to hide the floating element in applicable situations, such as
	* when it is not in the same clipping context as the reference element.
	* @see https://floating-ui.com/docs/hide
	*/
	const hide$1 = function(options) {
		if (options === void 0) options = {};
		return {
			name: "hide",
			options,
			async fn(state) {
				const { rects } = state;
				const { strategy = "referenceHidden", ...detectOverflowOptions } = evaluate(options, state);
				switch (strategy) {
					case "referenceHidden": {
						const offsets = getSideOffsets(await detectOverflow$1(state, {
							...detectOverflowOptions,
							elementContext: "reference"
						}), rects.reference);
						return { data: {
							referenceHiddenOffsets: offsets,
							referenceHidden: isAnySideFullyClipped(offsets)
						} };
					}
					case "escaped": {
						const offsets = getSideOffsets(await detectOverflow$1(state, {
							...detectOverflowOptions,
							altBoundary: true
						}), rects.floating);
						return { data: {
							escapedOffsets: offsets,
							escaped: isAnySideFullyClipped(offsets)
						} };
					}
					default: return {};
				}
			}
		};
	};
	const originSides = /* @__PURE__ */ new Set(["left", "top"]);
	async function convertValueToCoords(state, options) {
		const { placement, platform: platform$1, elements } = state;
		const rtl = await (platform$1.isRTL == null ? void 0 : platform$1.isRTL(elements.floating));
		const side = getSide(placement);
		const alignment = getAlignment(placement);
		const isVertical = getSideAxis(placement) === "y";
		const mainAxisMulti = originSides.has(side) ? -1 : 1;
		const crossAxisMulti = rtl && isVertical ? -1 : 1;
		const rawValue = evaluate(options, state);
		let { mainAxis, crossAxis, alignmentAxis } = typeof rawValue === "number" ? {
			mainAxis: rawValue,
			crossAxis: 0,
			alignmentAxis: null
		} : {
			mainAxis: rawValue.mainAxis || 0,
			crossAxis: rawValue.crossAxis || 0,
			alignmentAxis: rawValue.alignmentAxis
		};
		if (alignment && typeof alignmentAxis === "number") crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
		return isVertical ? {
			x: crossAxis * crossAxisMulti,
			y: mainAxis * mainAxisMulti
		} : {
			x: mainAxis * mainAxisMulti,
			y: crossAxis * crossAxisMulti
		};
	}
	/**
	* Modifies the placement by translating the floating element along the
	* specified axes.
	* A number (shorthand for `mainAxis` or distance), or an axes configuration
	* object may be passed.
	* @see https://floating-ui.com/docs/offset
	*/
	const offset$2 = function(options) {
		if (options === void 0) options = 0;
		return {
			name: "offset",
			options,
			async fn(state) {
				var _middlewareData$offse, _middlewareData$arrow;
				const { x, y, placement, middlewareData } = state;
				const diffCoords = await convertValueToCoords(state, options);
				if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) return {};
				return {
					x: x + diffCoords.x,
					y: y + diffCoords.y,
					data: {
						...diffCoords,
						placement
					}
				};
			}
		};
	};
	/**
	* Optimizes the visibility of the floating element by shifting it in order to
	* keep it in view when it will overflow the clipping boundary.
	* @see https://floating-ui.com/docs/shift
	*/
	const shift$2 = function(options) {
		if (options === void 0) options = {};
		return {
			name: "shift",
			options,
			async fn(state) {
				const { x, y, placement } = state;
				const { mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = false, limiter = { fn: (_ref) => {
					let { x: x$1, y: y$1 } = _ref;
					return {
						x: x$1,
						y: y$1
					};
				} }, ...detectOverflowOptions } = evaluate(options, state);
				const coords = {
					x,
					y
				};
				const overflow$1 = await detectOverflow$1(state, detectOverflowOptions);
				const crossAxis = getSideAxis(getSide(placement));
				const mainAxis = getOppositeAxis(crossAxis);
				let mainAxisCoord = coords[mainAxis];
				let crossAxisCoord = coords[crossAxis];
				if (checkMainAxis) {
					const minSide = mainAxis === "y" ? "top" : "left";
					const maxSide = mainAxis === "y" ? "bottom" : "right";
					const min$1 = mainAxisCoord + overflow$1[minSide];
					const max$1 = mainAxisCoord - overflow$1[maxSide];
					mainAxisCoord = clamp$1(min$1, mainAxisCoord, max$1);
				}
				if (checkCrossAxis) {
					const minSide = crossAxis === "y" ? "top" : "left";
					const maxSide = crossAxis === "y" ? "bottom" : "right";
					const min$1 = crossAxisCoord + overflow$1[minSide];
					const max$1 = crossAxisCoord - overflow$1[maxSide];
					crossAxisCoord = clamp$1(min$1, crossAxisCoord, max$1);
				}
				const limitedCoords = limiter.fn({
					...state,
					[mainAxis]: mainAxisCoord,
					[crossAxis]: crossAxisCoord
				});
				return {
					...limitedCoords,
					data: {
						x: limitedCoords.x - x,
						y: limitedCoords.y - y,
						enabled: {
							[mainAxis]: checkMainAxis,
							[crossAxis]: checkCrossAxis
						}
					}
				};
			}
		};
	};
	/**
	* Built-in `limiter` that will stop `shift()` at a certain point.
	*/
	const limitShift$1 = function(options) {
		if (options === void 0) options = {};
		return {
			options,
			fn(state) {
				const { x, y, placement, rects, middlewareData } = state;
				const { offset: offset$3 = 0, mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = true } = evaluate(options, state);
				const coords = {
					x,
					y
				};
				const crossAxis = getSideAxis(placement);
				const mainAxis = getOppositeAxis(crossAxis);
				let mainAxisCoord = coords[mainAxis];
				let crossAxisCoord = coords[crossAxis];
				const rawOffset = evaluate(offset$3, state);
				const computedOffset = typeof rawOffset === "number" ? {
					mainAxis: rawOffset,
					crossAxis: 0
				} : {
					mainAxis: 0,
					crossAxis: 0,
					...rawOffset
				};
				if (checkMainAxis) {
					const len = mainAxis === "y" ? "height" : "width";
					const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
					const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
					if (mainAxisCoord < limitMin) mainAxisCoord = limitMin;
					else if (mainAxisCoord > limitMax) mainAxisCoord = limitMax;
				}
				if (checkCrossAxis) {
					var _middlewareData$offse, _middlewareData$offse2;
					const len = mainAxis === "y" ? "width" : "height";
					const isOriginSide = originSides.has(getSide(placement));
					const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
					const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
					if (crossAxisCoord < limitMin) crossAxisCoord = limitMin;
					else if (crossAxisCoord > limitMax) crossAxisCoord = limitMax;
				}
				return {
					[mainAxis]: mainAxisCoord,
					[crossAxis]: crossAxisCoord
				};
			}
		};
	};
	/**
	* Provides data that allows you to change the size of the floating element 
	* for instance, prevent it from overflowing the clipping boundary or match the
	* width of the reference element.
	* @see https://floating-ui.com/docs/size
	*/
	const size$1 = function(options) {
		if (options === void 0) options = {};
		return {
			name: "size",
			options,
			async fn(state) {
				var _state$middlewareData, _state$middlewareData2;
				const { placement, rects, platform: platform$1, elements } = state;
				const { apply = () => {}, ...detectOverflowOptions } = evaluate(options, state);
				const overflow$1 = await detectOverflow$1(state, detectOverflowOptions);
				const side = getSide(placement);
				const alignment = getAlignment(placement);
				const isYAxis = getSideAxis(placement) === "y";
				const { width, height } = rects.floating;
				let heightSide;
				let widthSide;
				if (side === "top" || side === "bottom") {
					heightSide = side;
					widthSide = alignment === (await (platform$1.isRTL == null ? void 0 : platform$1.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
				} else {
					widthSide = side;
					heightSide = alignment === "end" ? "top" : "bottom";
				}
				const maximumClippingHeight = height - overflow$1.top - overflow$1.bottom;
				const maximumClippingWidth = width - overflow$1.left - overflow$1.right;
				const overflowAvailableHeight = min(height - overflow$1[heightSide], maximumClippingHeight);
				const overflowAvailableWidth = min(width - overflow$1[widthSide], maximumClippingWidth);
				const noShift = !state.middlewareData.shift;
				let availableHeight = overflowAvailableHeight;
				let availableWidth = overflowAvailableWidth;
				if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) availableWidth = maximumClippingWidth;
				if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) availableHeight = maximumClippingHeight;
				if (noShift && !alignment) {
					const xMin = max(overflow$1.left, 0);
					const xMax = max(overflow$1.right, 0);
					const yMin = max(overflow$1.top, 0);
					const yMax = max(overflow$1.bottom, 0);
					if (isYAxis) availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow$1.left, overflow$1.right));
					else availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow$1.top, overflow$1.bottom));
				}
				await apply({
					...state,
					availableWidth,
					availableHeight
				});
				const nextDimensions = await platform$1.getDimensions(elements.floating);
				if (width !== nextDimensions.width || height !== nextDimensions.height) return { reset: { rects: true } };
				return {};
			}
		};
	};

//#endregion
//#region node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
	function hasWindow() {
		return typeof window !== "undefined";
	}
	function getNodeName(node$1) {
		if (isNode(node$1)) return (node$1.nodeName || "").toLowerCase();
		return "#document";
	}
	function getWindow(node$1) {
		var _node$ownerDocument;
		return (node$1 == null || (_node$ownerDocument = node$1.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
	}
	function getDocumentElement(node$1) {
		var _ref;
		return (_ref = (isNode(node$1) ? node$1.ownerDocument : node$1.document) || window.document) == null ? void 0 : _ref.documentElement;
	}
	function isNode(value) {
		if (!hasWindow()) return false;
		return value instanceof Node || value instanceof getWindow(value).Node;
	}
	function isElement(value) {
		if (!hasWindow()) return false;
		return value instanceof Element || value instanceof getWindow(value).Element;
	}
	function isHTMLElement$2(value) {
		if (!hasWindow()) return false;
		return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
	}
	function isShadowRoot(value) {
		if (!hasWindow() || typeof ShadowRoot === "undefined") return false;
		return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
	}
	const invalidOverflowDisplayValues = /* @__PURE__ */ new Set(["inline", "contents"]);
	function isOverflowElement(element) {
		const { overflow: overflow$1, overflowX, overflowY, display } = getComputedStyle$1(element);
		return /auto|scroll|overlay|hidden|clip/.test(overflow$1 + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);
	}
	const tableElements = /* @__PURE__ */ new Set([
		"table",
		"td",
		"th"
	]);
	function isTableElement(element) {
		return tableElements.has(getNodeName(element));
	}
	const topLayerSelectors = [":popover-open", ":modal"];
	function isTopLayer(element) {
		return topLayerSelectors.some((selector) => {
			try {
				return element.matches(selector);
			} catch (_e) {
				return false;
			}
		});
	}
	const transformProperties = [
		"transform",
		"translate",
		"scale",
		"rotate",
		"perspective"
	];
	const willChangeValues = [
		"transform",
		"translate",
		"scale",
		"rotate",
		"perspective",
		"filter"
	];
	const containValues = [
		"paint",
		"layout",
		"strict",
		"content"
	];
	function isContainingBlock(elementOrCss) {
		const webkit = isWebKit();
		const css = isElement(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;
		return transformProperties.some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || willChangeValues.some((value) => (css.willChange || "").includes(value)) || containValues.some((value) => (css.contain || "").includes(value));
	}
	function getContainingBlock(element) {
		let currentNode = getParentNode$1(element);
		while (isHTMLElement$2(currentNode) && !isLastTraversableNode(currentNode)) {
			if (isContainingBlock(currentNode)) return currentNode;
			else if (isTopLayer(currentNode)) return null;
			currentNode = getParentNode$1(currentNode);
		}
		return null;
	}
	function isWebKit() {
		if (typeof CSS === "undefined" || !CSS.supports) return false;
		return CSS.supports("-webkit-backdrop-filter", "none");
	}
	const lastTraversableNodeNames = /* @__PURE__ */ new Set([
		"html",
		"body",
		"#document"
	]);
	function isLastTraversableNode(node$1) {
		return lastTraversableNodeNames.has(getNodeName(node$1));
	}
	function getComputedStyle$1(element) {
		return getWindow(element).getComputedStyle(element);
	}
	function getNodeScroll(element) {
		if (isElement(element)) return {
			scrollLeft: element.scrollLeft,
			scrollTop: element.scrollTop
		};
		return {
			scrollLeft: element.scrollX,
			scrollTop: element.scrollY
		};
	}
	function getParentNode$1(node$1) {
		if (getNodeName(node$1) === "html") return node$1;
		const result = node$1.assignedSlot || node$1.parentNode || isShadowRoot(node$1) && node$1.host || getDocumentElement(node$1);
		return isShadowRoot(result) ? result.host : result;
	}
	function getNearestOverflowAncestor(node$1) {
		const parentNode = getParentNode$1(node$1);
		if (isLastTraversableNode(parentNode)) return node$1.ownerDocument ? node$1.ownerDocument.body : node$1.body;
		if (isHTMLElement$2(parentNode) && isOverflowElement(parentNode)) return parentNode;
		return getNearestOverflowAncestor(parentNode);
	}
	function getOverflowAncestors(node$1, list, traverseIframes) {
		var _node$ownerDocument2;
		if (list === void 0) list = [];
		if (traverseIframes === void 0) traverseIframes = true;
		const scrollableAncestor = getNearestOverflowAncestor(node$1);
		const isBody = scrollableAncestor === ((_node$ownerDocument2 = node$1.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
		const win = getWindow(scrollableAncestor);
		if (isBody) {
			const frameElement = getFrameElement(win);
			return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
		}
		return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
	}
	function getFrameElement(win) {
		return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
	}

//#endregion
//#region node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
	function getCssDimensions(element) {
		const css = getComputedStyle$1(element);
		let width = parseFloat(css.width) || 0;
		let height = parseFloat(css.height) || 0;
		const hasOffset = isHTMLElement$2(element);
		const offsetWidth = hasOffset ? element.offsetWidth : width;
		const offsetHeight = hasOffset ? element.offsetHeight : height;
		const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
		if (shouldFallback) {
			width = offsetWidth;
			height = offsetHeight;
		}
		return {
			width,
			height,
			$: shouldFallback
		};
	}
	function unwrapElement(element) {
		return !isElement(element) ? element.contextElement : element;
	}
	function getScale(element) {
		const domElement = unwrapElement(element);
		if (!isHTMLElement$2(domElement)) return createCoords(1);
		const rect = domElement.getBoundingClientRect();
		const { width, height, $ } = getCssDimensions(domElement);
		let x = ($ ? round(rect.width) : rect.width) / width;
		let y = ($ ? round(rect.height) : rect.height) / height;
		if (!x || !Number.isFinite(x)) x = 1;
		if (!y || !Number.isFinite(y)) y = 1;
		return {
			x,
			y
		};
	}
	const noOffsets = /* @__PURE__ */ createCoords(0);
	function getVisualOffsets(element) {
		const win = getWindow(element);
		if (!isWebKit() || !win.visualViewport) return noOffsets;
		return {
			x: win.visualViewport.offsetLeft,
			y: win.visualViewport.offsetTop
		};
	}
	function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
		if (isFixed === void 0) isFixed = false;
		if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) return false;
		return isFixed;
	}
	function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
		if (includeScale === void 0) includeScale = false;
		if (isFixedStrategy === void 0) isFixedStrategy = false;
		const clientRect = element.getBoundingClientRect();
		const domElement = unwrapElement(element);
		let scale = createCoords(1);
		if (includeScale) if (offsetParent) {
			if (isElement(offsetParent)) scale = getScale(offsetParent);
		} else scale = getScale(element);
		const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
		let x = (clientRect.left + visualOffsets.x) / scale.x;
		let y = (clientRect.top + visualOffsets.y) / scale.y;
		let width = clientRect.width / scale.x;
		let height = clientRect.height / scale.y;
		if (domElement) {
			const win = getWindow(domElement);
			const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
			let currentWin = win;
			let currentIFrame = getFrameElement(currentWin);
			while (currentIFrame && offsetParent && offsetWin !== currentWin) {
				const iframeScale = getScale(currentIFrame);
				const iframeRect = currentIFrame.getBoundingClientRect();
				const css = getComputedStyle$1(currentIFrame);
				const left$1 = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
				const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
				x *= iframeScale.x;
				y *= iframeScale.y;
				width *= iframeScale.x;
				height *= iframeScale.y;
				x += left$1;
				y += top;
				currentWin = getWindow(currentIFrame);
				currentIFrame = getFrameElement(currentWin);
			}
		}
		return rectToClientRect({
			width,
			height,
			x,
			y
		});
	}
	function getWindowScrollBarX(element, rect) {
		const leftScroll = getNodeScroll(element).scrollLeft;
		if (!rect) return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
		return rect.left + leftScroll;
	}
	function getHTMLOffset(documentElement, scroll) {
		const htmlRect = documentElement.getBoundingClientRect();
		return {
			x: htmlRect.left + scroll.scrollLeft - getWindowScrollBarX(documentElement, htmlRect),
			y: htmlRect.top + scroll.scrollTop
		};
	}
	function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
		let { elements, rect, offsetParent, strategy } = _ref;
		const isFixed = strategy === "fixed";
		const documentElement = getDocumentElement(offsetParent);
		const topLayer = elements ? isTopLayer(elements.floating) : false;
		if (offsetParent === documentElement || topLayer && isFixed) return rect;
		let scroll = {
			scrollLeft: 0,
			scrollTop: 0
		};
		let scale = createCoords(1);
		const offsets = createCoords(0);
		const isOffsetParentAnElement = isHTMLElement$2(offsetParent);
		if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
			if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) scroll = getNodeScroll(offsetParent);
			if (isHTMLElement$2(offsetParent)) {
				const offsetRect = getBoundingClientRect(offsetParent);
				scale = getScale(offsetParent);
				offsets.x = offsetRect.x + offsetParent.clientLeft;
				offsets.y = offsetRect.y + offsetParent.clientTop;
			}
		}
		const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
		return {
			width: rect.width * scale.x,
			height: rect.height * scale.y,
			x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
			y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
		};
	}
	function getClientRects(element) {
		return Array.from(element.getClientRects());
	}
	function getDocumentRect(element) {
		const html = getDocumentElement(element);
		const scroll = getNodeScroll(element);
		const body = element.ownerDocument.body;
		const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
		const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
		let x = -scroll.scrollLeft + getWindowScrollBarX(element);
		const y = -scroll.scrollTop;
		if (getComputedStyle$1(body).direction === "rtl") x += max(html.clientWidth, body.clientWidth) - width;
		return {
			width,
			height,
			x,
			y
		};
	}
	const SCROLLBAR_MAX = 25;
	function getViewportRect(element, strategy) {
		const win = getWindow(element);
		const html = getDocumentElement(element);
		const visualViewport = win.visualViewport;
		let width = html.clientWidth;
		let height = html.clientHeight;
		let x = 0;
		let y = 0;
		if (visualViewport) {
			width = visualViewport.width;
			height = visualViewport.height;
			const visualViewportBased = isWebKit();
			if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
				x = visualViewport.offsetLeft;
				y = visualViewport.offsetTop;
			}
		}
		const windowScrollbarX = getWindowScrollBarX(html);
		if (windowScrollbarX <= 0) {
			const doc = html.ownerDocument;
			const body = doc.body;
			const bodyStyles = getComputedStyle(body);
			const bodyMarginInline = doc.compatMode === "CSS1Compat" ? parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight) || 0 : 0;
			const clippingStableScrollbarWidth = Math.abs(html.clientWidth - body.clientWidth - bodyMarginInline);
			if (clippingStableScrollbarWidth <= SCROLLBAR_MAX) width -= clippingStableScrollbarWidth;
		} else if (windowScrollbarX <= SCROLLBAR_MAX) width += windowScrollbarX;
		return {
			width,
			height,
			x,
			y
		};
	}
	const absoluteOrFixed = /* @__PURE__ */ new Set(["absolute", "fixed"]);
	function getInnerBoundingClientRect(element, strategy) {
		const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
		const top = clientRect.top + element.clientTop;
		const left$1 = clientRect.left + element.clientLeft;
		const scale = isHTMLElement$2(element) ? getScale(element) : createCoords(1);
		return {
			width: element.clientWidth * scale.x,
			height: element.clientHeight * scale.y,
			x: left$1 * scale.x,
			y: top * scale.y
		};
	}
	function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
		let rect;
		if (clippingAncestor === "viewport") rect = getViewportRect(element, strategy);
		else if (clippingAncestor === "document") rect = getDocumentRect(getDocumentElement(element));
		else if (isElement(clippingAncestor)) rect = getInnerBoundingClientRect(clippingAncestor, strategy);
		else {
			const visualOffsets = getVisualOffsets(element);
			rect = {
				x: clippingAncestor.x - visualOffsets.x,
				y: clippingAncestor.y - visualOffsets.y,
				width: clippingAncestor.width,
				height: clippingAncestor.height
			};
		}
		return rectToClientRect(rect);
	}
	function hasFixedPositionAncestor(element, stopNode) {
		const parentNode = getParentNode$1(element);
		if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) return false;
		return getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
	}
	function getClippingElementAncestors(element, cache$3) {
		const cachedResult = cache$3.get(element);
		if (cachedResult) return cachedResult;
		let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
		let currentContainingBlockComputedStyle = null;
		const elementIsFixed = getComputedStyle$1(element).position === "fixed";
		let currentNode = elementIsFixed ? getParentNode$1(element) : element;
		while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
			const computedStyle = getComputedStyle$1(currentNode);
			const currentNodeIsContaining = isContainingBlock(currentNode);
			if (!currentNodeIsContaining && computedStyle.position === "fixed") currentContainingBlockComputedStyle = null;
			if (elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode)) result = result.filter((ancestor) => ancestor !== currentNode);
			else currentContainingBlockComputedStyle = computedStyle;
			currentNode = getParentNode$1(currentNode);
		}
		cache$3.set(element, result);
		return result;
	}
	function getClippingRect(_ref) {
		let { element, boundary, rootBoundary, strategy } = _ref;
		const clippingAncestors = [...boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary), rootBoundary];
		const firstClippingAncestor = clippingAncestors[0];
		const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
			const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
			accRect.top = max(rect.top, accRect.top);
			accRect.right = min(rect.right, accRect.right);
			accRect.bottom = min(rect.bottom, accRect.bottom);
			accRect.left = max(rect.left, accRect.left);
			return accRect;
		}, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
		return {
			width: clippingRect.right - clippingRect.left,
			height: clippingRect.bottom - clippingRect.top,
			x: clippingRect.left,
			y: clippingRect.top
		};
	}
	function getDimensions(element) {
		const { width, height } = getCssDimensions(element);
		return {
			width,
			height
		};
	}
	function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
		const isOffsetParentAnElement = isHTMLElement$2(offsetParent);
		const documentElement = getDocumentElement(offsetParent);
		const isFixed = strategy === "fixed";
		const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
		let scroll = {
			scrollLeft: 0,
			scrollTop: 0
		};
		const offsets = createCoords(0);
		function setLeftRTLScrollbarOffset() {
			offsets.x = getWindowScrollBarX(documentElement);
		}
		if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
			if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) scroll = getNodeScroll(offsetParent);
			if (isOffsetParentAnElement) {
				const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
				offsets.x = offsetRect.x + offsetParent.clientLeft;
				offsets.y = offsetRect.y + offsetParent.clientTop;
			} else if (documentElement) setLeftRTLScrollbarOffset();
		}
		if (isFixed && !isOffsetParentAnElement && documentElement) setLeftRTLScrollbarOffset();
		const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
		return {
			x: rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x,
			y: rect.top + scroll.scrollTop - offsets.y - htmlOffset.y,
			width: rect.width,
			height: rect.height
		};
	}
	function isStaticPositioned(element) {
		return getComputedStyle$1(element).position === "static";
	}
	function getTrueOffsetParent(element, polyfill) {
		if (!isHTMLElement$2(element) || getComputedStyle$1(element).position === "fixed") return null;
		if (polyfill) return polyfill(element);
		let rawOffsetParent = element.offsetParent;
		if (getDocumentElement(element) === rawOffsetParent) rawOffsetParent = rawOffsetParent.ownerDocument.body;
		return rawOffsetParent;
	}
	function getOffsetParent(element, polyfill) {
		const win = getWindow(element);
		if (isTopLayer(element)) return win;
		if (!isHTMLElement$2(element)) {
			let svgOffsetParent = getParentNode$1(element);
			while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
				if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) return svgOffsetParent;
				svgOffsetParent = getParentNode$1(svgOffsetParent);
			}
			return win;
		}
		let offsetParent = getTrueOffsetParent(element, polyfill);
		while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) offsetParent = getTrueOffsetParent(offsetParent, polyfill);
		if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) return win;
		return offsetParent || getContainingBlock(element) || win;
	}
	const getElementRects = async function(data) {
		const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
		const getDimensionsFn = this.getDimensions;
		const floatingDimensions = await getDimensionsFn(data.floating);
		return {
			reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
			floating: {
				x: 0,
				y: 0,
				width: floatingDimensions.width,
				height: floatingDimensions.height
			}
		};
	};
	function isRTL(element) {
		return getComputedStyle$1(element).direction === "rtl";
	}
	const platform = {
		convertOffsetParentRelativeRectToViewportRelativeRect,
		getDocumentElement,
		getClippingRect,
		getOffsetParent,
		getElementRects,
		getClientRects,
		getDimensions,
		getScale,
		isElement,
		isRTL
	};
	/**
	* Resolves with an object of overflow side offsets that determine how much the
	* element is overflowing a given clipping boundary on each side.
	* - positive = overflowing the boundary by that number of pixels
	* - negative = how many pixels left before it will overflow
	* - 0 = lies flush with the boundary
	* @see https://floating-ui.com/docs/detectOverflow
	*/
	const detectOverflow = detectOverflow$1;
	/**
	* Modifies the placement by translating the floating element along the
	* specified axes.
	* A number (shorthand for `mainAxis` or distance), or an axes configuration
	* object may be passed.
	* @see https://floating-ui.com/docs/offset
	*/
	const offset$1 = offset$2;
	/**
	* Optimizes the visibility of the floating element by shifting it in order to
	* keep it in view when it will overflow the clipping boundary.
	* @see https://floating-ui.com/docs/shift
	*/
	const shift$1 = shift$2;
	/**
	* Optimizes the visibility of the floating element by flipping the `placement`
	* in order to keep it in view when the preferred placement(s) will overflow the
	* clipping boundary. Alternative to `autoPlacement`.
	* @see https://floating-ui.com/docs/flip
	*/
	const flip$1 = flip$2;
	/**
	* Provides data that allows you to change the size of the floating element 
	* for instance, prevent it from overflowing the clipping boundary or match the
	* width of the reference element.
	* @see https://floating-ui.com/docs/size
	*/
	const size = size$1;
	/**
	* Provides data to hide the floating element in applicable situations, such as
	* when it is not in the same clipping context as the reference element.
	* @see https://floating-ui.com/docs/hide
	*/
	const hide = hide$1;
	/**
	* Provides data to position an inner element of the floating element so that it
	* appears centered to the reference element.
	* @see https://floating-ui.com/docs/arrow
	*/
	const arrow = arrow$1;
	/**
	* Built-in `limiter` that will stop `shift()` at a certain point.
	*/
	const limitShift = limitShift$1;
	/**
	* Computes the `x` and `y` coordinates that will place the floating element
	* next to a given reference element.
	*/
	const computePosition = (reference, floating, options) => {
		const cache$3 = /* @__PURE__ */ new Map();
		const mergedOptions = {
			platform,
			...options
		};
		const platformWithCache = {
			...mergedOptions.platform,
			_c: cache$3
		};
		return computePosition$1(reference, floating, {
			...mergedOptions,
			platform: platformWithCache
		});
	};

//#endregion
//#region node_modules/@fluentui/react-positioning/lib/utils/parseFloatingUIPlacement.js
/**
	* Parses Floating UI placement and returns the different components
	* @param placement - the floating ui placement (i.e. bottom-start)
	*
	* @returns side and alignment components of the placement
	*/ function parseFloatingUIPlacement(placement) {
		const tokens$1 = placement.split("-");
		return {
			side: tokens$1[0],
			alignment: tokens$1[1]
		};
	}

//#endregion
//#region node_modules/@fluentui/react-positioning/lib/utils/getScrollParent.js
/**
	* Returns the parent node or the host of the node argument.
	* @param node - DOM node.
	* @returns - parent DOM node.
	*/ const getParentNode = (node$1) => {
		if (node$1.nodeName === "HTML") return node$1;
		return node$1.parentNode || node$1.host;
	};
	/**
	* Returns CSS styles of the given node.
	* @param node - DOM node.
	* @returns - CSS styles.
	*/ const getStyleComputedProperty = (node$1) => {
		var _node_ownerDocument;
		if (node$1.nodeType !== 1) return {};
		const targetWindow = (_node_ownerDocument = node$1.ownerDocument) === null || _node_ownerDocument === void 0 ? void 0 : _node_ownerDocument.defaultView;
		if (targetWindow) return targetWindow.getComputedStyle(node$1, null);
		return {};
	};
	/**
	* Returns the first scrollable parent of the given element.
	* @param node - DOM node.
	* @returns - the first scrollable parent.
	*/ const getScrollParent = (node$1) => {
		const parentNode = node$1 && getParentNode(node$1);
		if (!parentNode) return document.body;
		switch (parentNode.nodeName) {
			case "HTML":
			case "BODY": return parentNode.ownerDocument.body;
			case "#document": return parentNode.body;
		}
		const { overflow: overflow$1, overflowX, overflowY } = getStyleComputedProperty(parentNode);
		if (/(auto|scroll|overlay)/.test(overflow$1 + overflowY + overflowX)) return parentNode;
		return getScrollParent(parentNode);
	};
	const hasScrollParent = (node$1) => {
		var _scrollParentElement_ownerDocument;
		const scrollParentElement = getScrollParent(node$1);
		return scrollParentElement ? scrollParentElement !== ((_scrollParentElement_ownerDocument = scrollParentElement.ownerDocument) === null || _scrollParentElement_ownerDocument === void 0 ? void 0 : _scrollParentElement_ownerDocument.body) : false;
	};

//#endregion
//#region node_modules/@fluentui/react-positioning/lib/utils/getBoundary.js
/**
	* Allows to mimic a behavior from V1 of Popper and accept `window` and `scrollParent` as strings.
	*/ function getBoundary(element, boundary) {
		if (boundary === "window") return element === null || element === void 0 ? void 0 : element.ownerDocument.documentElement;
		if (boundary === "clippingParents") return "clippingAncestors";
		if (boundary === "scrollParent") {
			let boundariesNode = getScrollParent(element);
			if (boundariesNode.nodeName === "BODY") boundariesNode = element === null || element === void 0 ? void 0 : element.ownerDocument.documentElement;
			return boundariesNode;
		}
		return boundary;
	}

//#endregion
//#region node_modules/@fluentui/react-positioning/lib/utils/getReactFiberFromNode.js
	function getReactFiberFromNode(elm) {
		if (!elm) return null;
		for (const k in elm) if (k.indexOf("__reactInternalInstance$") === 0 || k.indexOf("__reactFiber$") === 0) return elm[k];
		throw new Error("getReactFiber(): Failed to find a React Fiber on a node");
	}

//#endregion
//#region node_modules/@fluentui/react-positioning/lib/utils/mergeArrowOffset.js
/**
	* Generally when adding an arrow to popper, it's necessary to offset the position of the popper by the
	* height of the arrow. A simple utility to merge a provided offset with an arrow height to return the final offset
	*
	* @internal
	* @param userOffset - The offset provided by the user
	* @param arrowHeight - The height of the arrow in px
	* @returns User offset augmented with arrow height
	*/ function mergeArrowOffset(userOffset, arrowHeight$1) {
		if (typeof userOffset === "number") return addArrowOffset(userOffset, arrowHeight$1);
		if (typeof userOffset === "object" && userOffset !== null) return addArrowOffset(userOffset, arrowHeight$1);
		if (typeof userOffset === "function") return (offsetParams) => {
			return addArrowOffset(userOffset(offsetParams), arrowHeight$1);
		};
		return { mainAxis: arrowHeight$1 };
	}
	const addArrowOffset = (offset$3, arrowHeight$1) => {
		if (typeof offset$3 === "number") return { mainAxis: offset$3 + arrowHeight$1 };
		var _offset_mainAxis;
		return {
			...offset$3,
			mainAxis: ((_offset_mainAxis = offset$3.mainAxis) !== null && _offset_mainAxis !== void 0 ? _offset_mainAxis : 0) + arrowHeight$1
		};
	};

//#endregion
//#region node_modules/@fluentui/react-positioning/lib/utils/toFloatingUIPadding.js
	function toFloatingUIPadding(padding$1, isRtl) {
		if (typeof padding$1 === "number") return padding$1;
		const { start, end, ...verticalPadding } = padding$1;
		const paddingObject = verticalPadding;
		const left$1 = isRtl ? "end" : "start";
		const right$1 = isRtl ? "start" : "end";
		if (padding$1[left$1]) paddingObject.left = padding$1[left$1];
		if (padding$1[right$1]) paddingObject.right = padding$1[right$1];
		return paddingObject;
	}

//#endregion
//#region node_modules/@fluentui/react-positioning/lib/utils/toFloatingUIPlacement.js
	const getPositionMap$1 = (rtl) => ({
		above: "top",
		below: "bottom",
		before: rtl ? "right" : "left",
		after: rtl ? "left" : "right"
	});
	const getAlignmentMap$1 = () => ({
		start: "start",
		end: "end",
		top: "start",
		bottom: "end",
		center: void 0
	});
	const shouldAlignToCenter = (p, a) => {
		const positionedVertically = p === "above" || p === "below";
		const alignedVertically = a === "top" || a === "bottom";
		return positionedVertically && alignedVertically || !positionedVertically && !alignedVertically;
	};
	/**
	* Maps internal positioning values to Floating UI placement
	* @see positioningHelper.test.ts for expected placement values
	*/ const toFloatingUIPlacement = (align, position$1, rtl) => {
		const alignment = shouldAlignToCenter(position$1, align) ? "center" : align;
		const computedPosition = position$1 && getPositionMap$1(rtl)[position$1];
		const computedAlignment = alignment && getAlignmentMap$1()[alignment];
		if (computedPosition && computedAlignment) return `${computedPosition}-${computedAlignment}`;
		return computedPosition;
	};

//#endregion
//#region node_modules/@fluentui/react-positioning/lib/utils/fromFloatingUIPlacement.js
	const getPositionMap = () => ({
		top: "above",
		bottom: "below",
		right: "after",
		left: "before"
	});
	const getAlignmentMap = (position$1) => {
		if (position$1 === "above" || position$1 === "below") return {
			start: "start",
			end: "end"
		};
		return {
			start: "top",
			end: "bottom"
		};
	};
	/**
	* Maps Floating UI placement to positioning values
	* @see positioningHelper.test.ts for expected placement values
	*/ const fromFloatingUIPlacement = (placement) => {
		const { side, alignment: floatingUIAlignment } = parseFloatingUIPlacement(placement);
		const position$1 = getPositionMap()[side];
		return {
			position: position$1,
			alignment: floatingUIAlignment && getAlignmentMap(position$1)[floatingUIAlignment]
		};
	};

//#endregion
//#region node_modules/@fluentui/react-positioning/lib/utils/resolvePositioningShorthand.js
	const shorthandLookup = {
		above: {
			position: "above",
			align: "center"
		},
		"above-start": {
			position: "above",
			align: "start"
		},
		"above-end": {
			position: "above",
			align: "end"
		},
		below: {
			position: "below",
			align: "center"
		},
		"below-start": {
			position: "below",
			align: "start"
		},
		"below-end": {
			position: "below",
			align: "end"
		},
		before: {
			position: "before",
			align: "center"
		},
		"before-top": {
			position: "before",
			align: "top"
		},
		"before-bottom": {
			position: "before",
			align: "bottom"
		},
		after: {
			position: "after",
			align: "center"
		},
		"after-top": {
			position: "after",
			align: "top"
		},
		"after-bottom": {
			position: "after",
			align: "bottom"
		}
	};
	function resolvePositioningShorthand(shorthand) {
		if (shorthand === void 0 || shorthand === null) return {};
		if (typeof shorthand === "string") return shorthandLookup[shorthand];
		return shorthand;
	}

//#endregion
//#region node_modules/@fluentui/react-positioning/lib/utils/useCallbackRef.js
/**
	* Creates a MutableRef with ref change callback. Is useful as React.useRef() doesn't notify you when its content
	* changes and mutating the .current property doesn't cause a re-render. An opt-out will be use a callback ref via
	* React.useState(), but it will cause re-renders always.
	*
	* https://reactjs.org/docs/hooks-reference.html#useref
	* https://github.com/theKashey/use-callback-ref#usecallbackref---to-replace-reactuseref
	*
	* @param initialValue - initial ref value
	* @param callback - a callback to run when value changes
	* @param skipInitialResolve - a flag to skip an initial ref report
	*
	* @example
	* const ref = useCallbackRef(0, (newValue, oldValue) => console.log(oldValue, '->', newValue);
	* ref.current = 1;
	* // prints 0 -> 1
	*/ function useCallbackRef(initialValue, callback, skipInitialResolve) {
		const isFirst = react.useRef(true);
		const [ref] = react.useState(() => ({
			value: initialValue,
			callback,
			facade: {
				get current() {
					return ref.value;
				},
				set current(value) {
					const last = ref.value;
					if (last !== value) {
						ref.value = value;
						if (skipInitialResolve && isFirst.current) return;
						ref.callback(value, last);
					}
				}
			}
		}));
		useIsomorphicLayoutEffect(() => {
			isFirst.current = false;
		}, []);
		ref.callback = callback;
		return ref.facade;
	}

//#endregion
//#region node_modules/@fluentui/react-positioning/lib/utils/debounce.js
/**
	* Promise microtask debouncer used by Popper.js v2
	* This is no longer exported in Floating UI (Popper.js v3)
	* https://github.com/floating-ui/floating-ui/blob/v2.x/src/utils/debounce.js
	* @param fn function that will be debounced
	*/ function debounce$1(fn) {
		let pending;
		return () => {
			if (!pending) pending = new Promise((resolve) => {
				Promise.resolve().then(() => {
					pending = void 0;
					resolve(fn());
				});
			});
			return pending;
		};
	}

//#endregion
//#region node_modules/@fluentui/react-positioning/lib/utils/hasAutoFocusFilter.js
/**
	* Detects if a passed HTML node has "autoFocus" prop on a React's fiber. Is needed as React handles autofocus behavior
	* in React DOM and will not pass "autoFocus" to an actual HTML.
	*
	* @param node
	*/ function hasAutofocusProp(node$1) {
		if (node$1.nodeName === "BUTTON" || node$1.nodeName === "INPUT" || node$1.nodeName === "SELECT" || node$1.nodeName === "TEXTAREA") {
			var _getReactFiberFromNode;
			return !!((_getReactFiberFromNode = getReactFiberFromNode(node$1)) === null || _getReactFiberFromNode === void 0 ? void 0 : _getReactFiberFromNode.pendingProps.autoFocus);
		}
		return false;
	}
	function hasAutofocusFilter(node$1) {
		return hasAutofocusProp(node$1) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
	}

//#endregion
//#region node_modules/@fluentui/react-positioning/lib/utils/writeArrowUpdates.js
/**
	* Writes all DOM element updates after position is computed
	*/ function writeArrowUpdates(options) {
		const { arrow: arrow$2, middlewareData } = options;
		if (!middlewareData.arrow || !arrow$2) return;
		const { x: arrowX, y: arrowY } = middlewareData.arrow;
		Object.assign(arrow$2.style, {
			left: arrowX !== null && arrowX !== void 0 ? `${arrowX}px` : "",
			top: arrowY !== null && arrowY !== void 0 ? `${arrowY}px` : ""
		});
	}

//#endregion
//#region node_modules/@fluentui/react-positioning/lib/utils/writeContainerupdates.js
/**
	* Writes all container element position updates after the position is computed
	*/ function writeContainerUpdates(options) {
		var _middlewareData_hide, _middlewareData_hide1, _container_ownerDocument_defaultView;
		const { container, placement, middlewareData, strategy, lowPPI, coordinates, useTransform = true } = options;
		if (!container) return;
		container.setAttribute(DATA_POSITIONING_PLACEMENT, placement);
		container.removeAttribute(DATA_POSITIONING_INTERSECTING);
		if (middlewareData.intersectionObserver.intersecting) container.setAttribute(DATA_POSITIONING_INTERSECTING, "");
		container.removeAttribute(DATA_POSITIONING_ESCAPED);
		if ((_middlewareData_hide = middlewareData.hide) === null || _middlewareData_hide === void 0 ? void 0 : _middlewareData_hide.escaped) container.setAttribute(DATA_POSITIONING_ESCAPED, "");
		container.removeAttribute(DATA_POSITIONING_HIDDEN);
		if ((_middlewareData_hide1 = middlewareData.hide) === null || _middlewareData_hide1 === void 0 ? void 0 : _middlewareData_hide1.referenceHidden) container.setAttribute(DATA_POSITIONING_HIDDEN, "");
		const devicePixelRatio = ((_container_ownerDocument_defaultView = container.ownerDocument.defaultView) === null || _container_ownerDocument_defaultView === void 0 ? void 0 : _container_ownerDocument_defaultView.devicePixelRatio) || 1;
		const x = Math.round(coordinates.x * devicePixelRatio) / devicePixelRatio;
		const y = Math.round(coordinates.y * devicePixelRatio) / devicePixelRatio;
		Object.assign(container.style, { position: strategy });
		if (useTransform) {
			Object.assign(container.style, { transform: lowPPI ? `translate(${x}px, ${y}px)` : `translate3d(${x}px, ${y}px, 0)` });
			return;
		}
		Object.assign(container.style, {
			left: `${x}px`,
			top: `${y}px`
		});
	}

//#endregion
//#region node_modules/@fluentui/react-positioning/lib/utils/normalizeAutoSize.js
/**
	* AutoSizes contains many options from historic implementation.
	* Now options 'always'/'height-always'/'width-always' are obsolete.
	* This function maps them to true/'height'/'width'
	*/ const normalizeAutoSize = (autoSize) => {
		switch (autoSize) {
			case "always":
			case true: return {
				applyMaxWidth: true,
				applyMaxHeight: true
			};
			case "width-always":
			case "width": return {
				applyMaxWidth: true,
				applyMaxHeight: false
			};
			case "height-always":
			case "height": return {
				applyMaxWidth: false,
				applyMaxHeight: true
			};
			default: return false;
		}
	};

//#endregion
//#region node_modules/@fluentui/react-positioning/lib/utils/listScrollParents.js
	function listScrollParents(node$1) {
		const scrollParents = [];
		let cur = node$1;
		while (cur) {
			const scrollParent = getScrollParent(cur);
			if (node$1.ownerDocument.body === scrollParent) {
				scrollParents.push(scrollParent);
				break;
			}
			if (scrollParent.nodeName === "BODY" && scrollParent !== node$1.ownerDocument.body) {
				console.error("@fluentui/react-positioning: You are comparing two different documents! This is an unexpected error, please report this as a bug to the Fluent UI team ");
				break;
			}
			scrollParents.push(scrollParent);
			cur = scrollParent;
		}
		return scrollParents;
	}

//#endregion
//#region node_modules/@fluentui/react-positioning/lib/utils/createResizeObserver.js
	function createResizeObserver(targetWindow, callback) {
		return new targetWindow.ResizeObserver(callback);
	}

//#endregion
//#region node_modules/@fluentui/react-positioning/lib/createPositionManager.js
/**
	* @internal
	* @returns manager that handles positioning out of the react lifecycle
	*/ function createPositionManager(options) {
		let isDestroyed = false;
		const { container, target, arrow: arrow$2, strategy, middleware: middleware$1, placement, useTransform = true, disableUpdateOnResize = false } = options;
		const targetWindow = container.ownerDocument.defaultView;
		if (!target || !container || !targetWindow) return {
			updatePosition: () => void 0,
			dispose: () => void 0
		};
		const resizeObserver = disableUpdateOnResize ? null : createResizeObserver(targetWindow, (entries) => {
			if (entries.every((entry) => {
				return entry.contentRect.width > 0 && entry.contentRect.height > 0;
			})) updatePosition();
		});
		let isFirstUpdate = true;
		const scrollParents = /* @__PURE__ */ new Set();
		Object.assign(container.style, {
			position: "fixed",
			left: 0,
			top: 0,
			margin: 0
		});
		const forceUpdate = () => {
			if (isDestroyed) return;
			if (isFirstUpdate) {
				listScrollParents(container).forEach((scrollParent) => scrollParents.add(scrollParent));
				if (isHTMLElement(target)) listScrollParents(target).forEach((scrollParent) => scrollParents.add(scrollParent));
				scrollParents.forEach((scrollParent) => {
					scrollParent.addEventListener("scroll", updatePosition, { passive: true });
				});
				resizeObserver === null || resizeObserver === void 0 || resizeObserver.observe(container);
				if (isHTMLElement(target)) resizeObserver === null || resizeObserver === void 0 || resizeObserver.observe(target);
				isFirstUpdate = false;
			}
			Object.assign(container.style, { position: strategy });
			computePosition(target, container, {
				placement,
				middleware: middleware$1,
				strategy
			}).then(({ x, y, middlewareData, placement: computedPlacement }) => {
				if (isDestroyed) return;
				writeArrowUpdates({
					arrow: arrow$2,
					middlewareData
				});
				writeContainerUpdates({
					container,
					middlewareData,
					placement: computedPlacement,
					coordinates: {
						x,
						y
					},
					lowPPI: ((targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.devicePixelRatio) || 1) <= 1,
					strategy,
					useTransform
				});
				container.dispatchEvent(new CustomEvent(POSITIONING_END_EVENT));
			}).catch((err) => {
				console.error("[usePositioning]: Failed to calculate position", err);
			});
		};
		const updatePosition = debounce$1(() => forceUpdate());
		const dispose = () => {
			isDestroyed = true;
			if (targetWindow) {
				targetWindow.removeEventListener("scroll", updatePosition);
				targetWindow.removeEventListener("resize", updatePosition);
			}
			scrollParents.forEach((scrollParent) => {
				scrollParent.removeEventListener("scroll", updatePosition);
			});
			scrollParents.clear();
			resizeObserver === null || resizeObserver === void 0 || resizeObserver.disconnect();
		};
		if (targetWindow) {
			targetWindow.addEventListener("scroll", updatePosition, { passive: true });
			targetWindow.addEventListener("resize", updatePosition);
		}
		updatePosition();
		return {
			updatePosition,
			dispose
		};
	}

//#endregion
//#region node_modules/@floating-ui/devtools/dist/floating-ui.devtools.mjs
/**
	* @internal
	*/
	const CONTROLLER = "__FUIDT_CONTROLLER__";
	/**
	* @internal
	*/
	const ELEMENT_METADATA = "__FUIDT_ELEMENT_METADATA__";
	/**
	* @internal
	*/
	const HTML_ELEMENT_REFERENCE = "__FUIDT_HTML_ELEMENT_REFERENCE__";
	/**
	* @internal
	*/
	const SERIALIZED_DATA_CHANGE = "__FUIDT_SERIALIZED_DATA_CHANGE__";
	/**
	* Verifies if a given node is an HTMLElement,
	* this method works seamlessly with frames and elements from different documents
	*
	* This is preferred over simply using `instanceof`.
	* Since `instanceof` might be problematic while operating with [multiple realms](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof#instanceof_and_multiple_realms)
	*
	* @example
	* ```ts
	* isHTMLElement(event.target) && event.target.focus()
	* isHTMLElement(event.target, {constructorName: 'HTMLInputElement'}) && event.target.value // some value
	* ```
	*
	*/
	function isHTMLElement$1(element, options) {
		var _typedElement$ownerDo, _options$constructorN;
		const typedElement = element;
		return Boolean((typedElement == null || (_typedElement$ownerDo = typedElement.ownerDocument) == null ? void 0 : _typedElement$ownerDo.defaultView) && typedElement instanceof typedElement.ownerDocument.defaultView[(_options$constructorN = void 0) != null ? _options$constructorN : "HTMLElement"]);
	}
	/**
	* @internal
	*/
	const isHTMLElementWithMetadata = (element) => Boolean(isHTMLElement$1(element) && ELEMENT_METADATA in element && element.parentElement !== null);
	const createController = (defaultView) => {
		let selectedElement = null;
		const observer = new MutationObserver((mutations) => {
			if (!selectedElement) return;
			for (const mutation of mutations) if (mutation.type === "childList" && Array.from(mutation.removedNodes).includes(selectedElement)) controller.withdraw();
		});
		const controller = {
			get selectedElement() {
				return selectedElement;
			},
			select: (nextSelectedElement) => {
				if (isHTMLElementWithMetadata(nextSelectedElement)) {
					selectedElement = nextSelectedElement;
					observer.observe(nextSelectedElement.parentElement, {
						childList: true,
						subtree: false
					});
				}
				if (selectedElement && nextSelectedElement) {
					if (selectedElement[ELEMENT_METADATA].references.has(nextSelectedElement)) return selectedElement;
				}
				controller.withdraw();
				return selectedElement;
			},
			withdraw: () => {
				selectedElement = null;
				observer.disconnect();
				defaultView.postMessage(SERIALIZED_DATA_CHANGE);
			}
		};
		return controller;
	};
	const injectController = (_ref) => {
		let { defaultView } = _ref;
		if (!defaultView) return;
		if (!defaultView[CONTROLLER]) defaultView[CONTROLLER] = createController(defaultView);
	};
	const getController = (targetDocument) => {
		var _targetDocument$defau, _targetDocument$defau2;
		injectController(targetDocument);
		return (_targetDocument$defau = (_targetDocument$defau2 = targetDocument.defaultView) == null ? void 0 : _targetDocument$defau2[CONTROLLER]) != null ? _targetDocument$defau : null;
	};
	const serialize = (data, references) => {
		return JSON.parse(JSON.stringify(data, (_, value) => {
			if (isHTMLElement$1(value)) return references.add(value);
			if (typeof value === "object" && value && Object.getPrototypeOf(value) !== Object.prototype && Object.getPrototypeOf(value) !== Array.prototype) {
				if ("toString" in value) return value.toString();
				return;
			}
			return value;
		}));
	};
	let counter$2 = 0;
	const generateReferenceId = () => HTML_ELEMENT_REFERENCE + ":" + counter$2++;
	const createReferences = () => {
		const map = /* @__PURE__ */ new Map();
		const weakMap = /* @__PURE__ */ new WeakMap();
		return {
			add: (element) => {
				if (weakMap.has(element)) return weakMap.get(element);
				const id = generateReferenceId();
				map.set(id, element);
				weakMap.set(element, id);
				return id;
			},
			get: (id) => {
				const element = map.get(id);
				if (element && weakMap.has(element)) return element;
			},
			has: (element) => {
				return weakMap.has(element);
			}
		};
	};
	/**
	* devtools middleware
	* @public
	*/
	const devtools = function(targetDocument, middlewareDataCallback) {
		if (targetDocument === void 0) targetDocument = document;
		if (middlewareDataCallback === void 0) middlewareDataCallback = floatingUIMiddlewareDataCallback;
		return {
			name: "@floating-ui/devtools",
			fn: (state) => {
				const { [ELEMENT_METADATA]: metadata } = isHTMLElementWithMetadata(state.elements.floating) ? state.elements.floating : Object.assign(state.elements.floating, { [ELEMENT_METADATA]: {
					references: createReferences(),
					serializedData: []
				} });
				const serializedData = serialize(middlewareDataCallback(state), metadata.references);
				metadata.serializedData.unshift(serializedData);
				const controller = getController(targetDocument);
				if (metadata.serializedData.length > 1 && state.elements.floating === (controller == null ? void 0 : controller.selectedElement)) {
					var _targetDocument$defau;
					(_targetDocument$defau = targetDocument.defaultView) == null || _targetDocument$defau.postMessage(SERIALIZED_DATA_CHANGE);
				}
				return {};
			}
		};
	};
	const floatingUIMiddlewareDataCallback = (state) => ({
		...state,
		type: "FloatingUIMiddleware"
	});

//#endregion
//#region node_modules/@fluentui/react-positioning/lib/middleware/coverTarget.js
	function coverTarget() {
		return {
			name: "coverTarget",
			fn: (middlewareArguments) => {
				const { placement, rects, x, y } = middlewareArguments;
				const basePlacement = parseFloatingUIPlacement(placement).side;
				const newCoords = {
					x,
					y
				};
				switch (basePlacement) {
					case "bottom":
						newCoords.y -= rects.reference.height;
						break;
					case "top":
						newCoords.y += rects.reference.height;
						break;
					case "left":
						newCoords.x += rects.reference.width;
						break;
					case "right":
						newCoords.x -= rects.reference.width;
						break;
				}
				return newCoords;
			}
		};
	}

//#endregion
//#region node_modules/@fluentui/react-positioning/lib/middleware/flip.js
	function flip(options) {
		const { hasScrollableElement, flipBoundary, container, fallbackPositions: fallbackPositions$1 = [], isRtl } = options;
		const fallbackPlacements = fallbackPositions$1.reduce((acc, shorthand) => {
			const { position: position$1, align } = resolvePositioningShorthand(shorthand);
			const placement = toFloatingUIPlacement(align, position$1, isRtl);
			if (placement) acc.push(placement);
			return acc;
		}, []);
		return flip$1({
			...hasScrollableElement && { boundary: "clippingAncestors" },
			...flipBoundary && {
				altBoundary: true,
				boundary: getBoundary(container, flipBoundary)
			},
			fallbackStrategy: "bestFit",
			...fallbackPlacements.length && { fallbackPlacements }
		});
	}

//#endregion
//#region node_modules/@fluentui/react-positioning/lib/middleware/intersecting.js
	function intersecting() {
		return {
			name: "intersectionObserver",
			fn: async (middlewareArguments) => {
				const floatingRect = middlewareArguments.rects.floating;
				const altOverflow = await detectOverflow(middlewareArguments, { altBoundary: true });
				const isIntersectingTop = altOverflow.top < floatingRect.height && altOverflow.top > 0;
				const isIntersectingBottom = altOverflow.bottom < floatingRect.height && altOverflow.bottom > 0;
				return { data: { intersecting: isIntersectingTop || isIntersectingBottom } };
			}
		};
	}

//#endregion
//#region node_modules/@fluentui/react-positioning/lib/middleware/maxSize.js
/**
	* floating-ui `size` middleware uses floating element's height/width to calculate available height/width.
	* This middleware only runs once per lifecycle, resetting styles applied by maxSize from previous lifecycle.
	* Then floating element's original size is restored and `size` middleware can calculate available height/width correctly.
	*/ const resetMaxSize = (autoSize) => ({
		name: "resetMaxSize",
		fn({ middlewareData, elements }) {
			var _middlewareData_resetMaxSize;
			if ((_middlewareData_resetMaxSize = middlewareData.resetMaxSize) === null || _middlewareData_resetMaxSize === void 0 ? void 0 : _middlewareData_resetMaxSize.maxSizeAlreadyReset) return {};
			const { applyMaxWidth, applyMaxHeight } = autoSize;
			if (applyMaxWidth) {
				elements.floating.style.removeProperty("box-sizing");
				elements.floating.style.removeProperty("max-width");
				elements.floating.style.removeProperty("width");
			}
			if (applyMaxHeight) {
				elements.floating.style.removeProperty("box-sizing");
				elements.floating.style.removeProperty("max-height");
				elements.floating.style.removeProperty("height");
			}
			return {
				data: { maxSizeAlreadyReset: true },
				reset: { rects: true }
			};
		}
	});
	function maxSize(autoSize, options) {
		const { container, overflowBoundary, overflowBoundaryPadding, isRtl } = options;
		return size({
			...overflowBoundaryPadding && { padding: toFloatingUIPadding(overflowBoundaryPadding, isRtl) },
			...overflowBoundary && {
				altBoundary: true,
				boundary: getBoundary(container, overflowBoundary)
			},
			apply({ availableHeight, availableWidth, elements, rects }) {
				const applyMaxSizeStyles = (apply, dimension, availableSize) => {
					if (!apply) return;
					elements.floating.style.setProperty("box-sizing", "border-box");
					elements.floating.style.setProperty(`max-${dimension}`, `${availableSize}px`);
					if (rects.floating[dimension] > availableSize) {
						elements.floating.style.setProperty(dimension, `${availableSize}px`);
						const axis = dimension === "width" ? "x" : "y";
						if (!elements.floating.style.getPropertyValue(`overflow-${axis}`)) elements.floating.style.setProperty(`overflow-${axis}`, "auto");
					}
				};
				const { applyMaxWidth, applyMaxHeight } = autoSize;
				applyMaxSizeStyles(applyMaxWidth, "width", availableWidth);
				applyMaxSizeStyles(applyMaxHeight, "height", availableHeight);
			}
		});
	}

//#endregion
//#region node_modules/@fluentui/react-positioning/lib/utils/getFloatingUIOffset.js
/**
	* Shim to transform offset values from this library to Floating UI
	* @param rawOffset Offset from this library
	* @returns An offset value compatible with Floating UI
	*/ function getFloatingUIOffset(rawOffset) {
		if (!rawOffset) return rawOffset;
		if (typeof rawOffset === "number" || typeof rawOffset === "object") return rawOffset;
		return ({ rects: { floating, reference }, placement }) => {
			const { position: position$1, alignment } = fromFloatingUIPlacement(placement);
			return rawOffset({
				positionedRect: floating,
				targetRect: reference,
				position: position$1,
				alignment
			});
		};
	}

//#endregion
//#region node_modules/@fluentui/react-positioning/lib/middleware/offset.js
/**
	* Wraps floating UI offset middleware to transform offset value.
	*/ function offset(offsetValue) {
		return offset$1(getFloatingUIOffset(offsetValue));
	}

//#endregion
//#region node_modules/@fluentui/react-positioning/lib/middleware/shift.js
/**
	* Wraps the floating UI shift middleware for easier usage of our options
	*/ function shift(options) {
		const { hasScrollableElement, shiftToCoverTarget, disableTether, overflowBoundary, container, overflowBoundaryPadding, isRtl } = options;
		return shift$1({
			...hasScrollableElement && { boundary: "clippingAncestors" },
			...shiftToCoverTarget && {
				crossAxis: true,
				limiter: limitShift({
					crossAxis: true,
					mainAxis: false
				})
			},
			...disableTether && {
				crossAxis: disableTether === "all",
				limiter: limitShift({
					crossAxis: disableTether !== "all",
					mainAxis: false
				})
			},
			...overflowBoundaryPadding && { padding: toFloatingUIPadding(overflowBoundaryPadding, isRtl) },
			...overflowBoundary && {
				altBoundary: true,
				boundary: getBoundary(container, overflowBoundary)
			}
		});
	}

//#endregion
//#region node_modules/@fluentui/react-positioning/lib/middleware/matchTargetSize.js
	const matchTargetSizeCssVar = "--fui-match-target-size";
	function matchTargetSize() {
		return {
			name: "matchTargetSize",
			fn: async (middlewareArguments) => {
				const { rects: { reference: referenceRect, floating: floatingRect }, elements: { floating: floatingElement }, middlewareData: { matchTargetSize: { matchTargetSizeAttempt = false } = {} } } = middlewareArguments;
				if (referenceRect.width === floatingRect.width || matchTargetSizeAttempt) return {};
				const { width } = referenceRect;
				floatingElement.style.setProperty(matchTargetSizeCssVar, `${width}px`);
				if (!floatingElement.style.width) floatingElement.style.width = `var(${matchTargetSizeCssVar})`;
				return {
					data: { matchTargetSizeAttempt: true },
					reset: { rects: true }
				};
			}
		};
	}

//#endregion
//#region node_modules/@fluentui/react-positioning/lib/utils/devtools.js
	const devtoolsCallback = (options) => (middlewareState) => {
		const { elements: { floating, reference } } = middlewareState;
		const scrollParentsSet = /* @__PURE__ */ new Set();
		if (isHTMLElement(reference)) listScrollParents(reference).forEach((scrollParent) => scrollParentsSet.add(scrollParent));
		listScrollParents(floating).forEach((scrollParent) => scrollParentsSet.add(scrollParent));
		const flipBoundaries = Array.isArray(options.flipBoundary) ? options.flipBoundary : isHTMLElement(options.flipBoundary) ? [options.flipBoundary] : [];
		const overflowBoundaries = Array.isArray(options.overflowBoundary) ? options.overflowBoundary : isHTMLElement(options.overflowBoundary) ? [options.overflowBoundary] : [];
		return {
			type: "FluentUIMiddleware",
			middlewareState,
			options,
			initialPlacement: fromFloatingUIPlacement(middlewareState.initialPlacement),
			placement: fromFloatingUIPlacement(middlewareState.placement),
			flipBoundaries,
			overflowBoundaries,
			scrollParents: Array.from(scrollParentsSet)
		};
	};

//#endregion
//#region node_modules/@fluentui/react-positioning/lib/usePositioningOptions.js
/**
	* @internal
	*
	* This is redundant and exists only to manage React dependencies properly & avoid leaking individual options to the
	* scope of `usePositioningOptions`.
	*/ function usePositioningConfigFn(configFn, options) {
		const { align, arrowPadding, autoSize, coverTarget: coverTarget$1, disableUpdateOnResize, flipBoundary, offset: offset$3, overflowBoundary, pinned, position: position$1, unstable_disableTether, strategy, overflowBoundaryPadding, fallbackPositions: fallbackPositions$1, useTransform, matchTargetSize: matchTargetSize$1, shiftToCoverTarget } = options;
		return react.useCallback((container, arrow$2) => {
			return configFn({
				container,
				arrow: arrow$2,
				options: {
					autoSize,
					disableUpdateOnResize,
					matchTargetSize: matchTargetSize$1,
					offset: offset$3,
					strategy,
					coverTarget: coverTarget$1,
					flipBoundary,
					overflowBoundary,
					useTransform,
					overflowBoundaryPadding,
					pinned,
					arrowPadding,
					align,
					fallbackPositions: fallbackPositions$1,
					shiftToCoverTarget,
					position: position$1,
					unstable_disableTether
				}
			});
		}, [
			autoSize,
			disableUpdateOnResize,
			matchTargetSize$1,
			offset$3,
			strategy,
			coverTarget$1,
			flipBoundary,
			overflowBoundary,
			useTransform,
			overflowBoundaryPadding,
			pinned,
			arrowPadding,
			align,
			fallbackPositions$1,
			shiftToCoverTarget,
			position$1,
			unstable_disableTether,
			configFn
		]);
	}
	/**
	* @internal
	*/ function usePositioningOptions(options) {
		const { dir, targetDocument } = useFluent();
		const isRtl = dir === "rtl";
		const configFn = usePositioningConfigFn(usePositioningConfiguration(), options);
		const { positionFixed } = options;
		return react.useCallback((container, arrow$2) => {
			const hasScrollableElement = hasScrollParent(container);
			const optionsAfterEnhancement = configFn(container, arrow$2);
			const { autoSize, disableUpdateOnResize, matchTargetSize: matchTargetSize$1, offset: offset$3, coverTarget: coverTarget$1, flipBoundary, overflowBoundary, useTransform, overflowBoundaryPadding, pinned, position: position$1, arrowPadding, strategy, align, fallbackPositions: fallbackPositions$1, shiftToCoverTarget, unstable_disableTether } = optionsAfterEnhancement;
			const normalizedAutoSize = normalizeAutoSize(autoSize);
			const middleware$1 = [
				normalizedAutoSize && resetMaxSize(normalizedAutoSize),
				matchTargetSize$1 && matchTargetSize(),
				offset$3 && offset(offset$3),
				coverTarget$1 && coverTarget(),
				!pinned && flip({
					container,
					flipBoundary,
					hasScrollableElement,
					isRtl,
					fallbackPositions: fallbackPositions$1
				}),
				shift({
					container,
					hasScrollableElement,
					overflowBoundary,
					disableTether: unstable_disableTether,
					overflowBoundaryPadding,
					isRtl,
					shiftToCoverTarget
				}),
				normalizedAutoSize && maxSize(normalizedAutoSize, {
					container,
					overflowBoundary,
					overflowBoundaryPadding,
					isRtl
				}),
				intersecting(),
				arrow$2 && arrow({
					element: arrow$2,
					padding: arrowPadding
				}),
				hide({ strategy: "referenceHidden" }),
				hide({ strategy: "escaped" }),
				targetDocument && devtools(targetDocument, devtoolsCallback(optionsAfterEnhancement))
			].filter(Boolean);
			return {
				placement: toFloatingUIPlacement(align, position$1, isRtl),
				middleware: middleware$1,
				strategy: (strategy !== null && strategy !== void 0 ? strategy : positionFixed) ? "fixed" : "absolute",
				disableUpdateOnResize,
				useTransform
			};
		}, [
			configFn,
			isRtl,
			targetDocument,
			positionFixed
		]);
	}

//#endregion
//#region node_modules/@fluentui/react-positioning/lib/usePositioning.js
/**
	* @internal
	*/ function usePositioning(options) {
		"use no memo";
		const managerRef = react.useRef(null);
		const targetRef = react.useRef(null);
		const overrideTargetRef = react.useRef(null);
		const containerRef = react.useRef(null);
		const arrowRef = react.useRef(null);
		const { enabled = true } = options;
		const resolvePositioningOptions = usePositioningOptions(options);
		const updatePositionManager = react.useCallback(() => {
			if (managerRef.current) managerRef.current.dispose();
			managerRef.current = null;
			var _overrideTargetRef_current;
			const target = (_overrideTargetRef_current = overrideTargetRef.current) !== null && _overrideTargetRef_current !== void 0 ? _overrideTargetRef_current : targetRef.current;
			if (enabled && canUseDOM() && target && containerRef.current) managerRef.current = createPositionManager({
				container: containerRef.current,
				target,
				arrow: arrowRef.current,
				...resolvePositioningOptions(containerRef.current, arrowRef.current)
			});
		}, [enabled, resolvePositioningOptions]);
		const setOverrideTarget = useEventCallback((target) => {
			overrideTargetRef.current = target;
			updatePositionManager();
		});
		react.useImperativeHandle(options.positioningRef, () => ({
			updatePosition: () => {
				var _managerRef_current;
				return (_managerRef_current = managerRef.current) === null || _managerRef_current === void 0 ? void 0 : _managerRef_current.updatePosition();
			},
			setTarget: (target) => {
				if (options.target && true) {
					const err = /* @__PURE__ */ new Error();
					console.warn("Imperative setTarget should not be used at the same time as target option");
					console.warn(err.stack);
				}
				setOverrideTarget(target);
			}
		}), [options.target, setOverrideTarget]);
		useIsomorphicLayoutEffect(() => {
			var _options_target;
			setOverrideTarget((_options_target = options.target) !== null && _options_target !== void 0 ? _options_target : null);
		}, [options.target, setOverrideTarget]);
		useIsomorphicLayoutEffect(() => {
			updatePositionManager();
		}, [updatePositionManager]);
		react.useEffect(() => {
			if (containerRef.current) {
				var _contentNode_ownerDocument;
				const contentNode = containerRef.current;
				const treeWalker = (_contentNode_ownerDocument = contentNode.ownerDocument) === null || _contentNode_ownerDocument === void 0 ? void 0 : _contentNode_ownerDocument.createTreeWalker(contentNode, NodeFilter.SHOW_ELEMENT, { acceptNode: hasAutofocusFilter });
				while (treeWalker.nextNode()) {
					const node$1 = treeWalker.currentNode;
					console.warn("usePositioning():", node$1);
					console.warn([
						"usePositioning(): ^ this node contains \"autoFocus\" prop on a React element. This can break the initial",
						"positioning of an element and cause a window jump effect. This issue occurs because React polyfills",
						"\"autoFocus\" behavior to solve inconsistencies between different browsers:",
						"https://github.com/facebook/react/issues/11851#issuecomment-351787078",
						"\n",
						"However, \".focus()\" in this case occurs before any other React effects will be executed",
						"(React.useEffect(), componentDidMount(), etc.) and we can not prevent this behavior. If you really",
						"want to use \"autoFocus\" please add \"position: fixed\" to styles of the element that is wrapped by",
						"\"Popper\".",
						`In general, it's not recommended to use "autoFocus" as it may break accessibility aspects:`,
						"https://github.com/jsx-eslint/eslint-plugin-jsx-a11y/blob/master/docs/rules/no-autofocus.md",
						"\n",
						"We suggest to use the \"trapFocus\" prop on Fluent components or a catch \"ref\" and then use",
						"\"ref.current.focus\" in React.useEffect():",
						"https://reactjs.org/docs/refs-and-the-dom.html#adding-a-ref-to-a-dom-element"
					].join(" "));
				}
			}
		}, []);
		const setTarget = useCallbackRef(null, (target) => {
			if (targetRef.current !== target) {
				targetRef.current = target;
				updatePositionManager();
			}
		});
		const onPositioningEnd = useEventCallback(() => {
			var _options_onPositioningEnd;
			return (_options_onPositioningEnd = options.onPositioningEnd) === null || _options_onPositioningEnd === void 0 ? void 0 : _options_onPositioningEnd.call(options);
		});
		return {
			targetRef: setTarget,
			containerRef: useCallbackRef(null, (container) => {
				if (containerRef.current !== container) {
					var _containerRef_current;
					(_containerRef_current = containerRef.current) === null || _containerRef_current === void 0 || _containerRef_current.removeEventListener(POSITIONING_END_EVENT, onPositioningEnd);
					container === null || container === void 0 || container.addEventListener(POSITIONING_END_EVENT, onPositioningEnd);
					containerRef.current = container;
					updatePositionManager();
				}
			}),
			arrowRef: useCallbackRef(null, (arrow$2) => {
				if (arrowRef.current !== arrow$2) {
					arrowRef.current = arrow$2;
					updatePositionManager();
				}
			})
		};
	}

//#endregion
//#region node_modules/@fluentui/react-positioning/lib/usePositioningMouseTarget.js
/**
	* @internal
	* A state hook that manages a popper virtual element from mouseevents.
	* Useful for scenarios where a component needs to be positioned by mouse click (e.g. contextmenu)
	* React synthetic events are not persisted by this hook
	*
	* @param initialState - initializes a user provided state similare to useState
	* @returns state and dispatcher for a Popper virtual element that uses native/synthetic mouse events
	*/ const usePositioningMouseTarget = (initialState) => {
		const [virtualElement, setVirtualElement] = react.useState(initialState);
		const setVirtualMouseTarget = (event) => {
			if (event === void 0 || event === null) {
				setVirtualElement(void 0);
				return;
			}
			let mouseevent;
			if (!(event instanceof MouseEvent)) mouseevent = event.nativeEvent;
			else mouseevent = event;
			if (!(mouseevent instanceof MouseEvent) && true) console.error("usePositioningMouseTarget should only be used with MouseEvent");
			setVirtualElement(createVirtualElementFromClick(mouseevent));
		};
		return [virtualElement, setVirtualMouseTarget];
	};

//#endregion
//#region node_modules/@fluentui/react-positioning/lib/hooks/useSafeZoneArea/createSafeZoneAreaStateStore.js
	function createSafeZoneAreaStateStore() {
		let isActive = false;
		const listeners = [];
		return {
			isActive() {
				return isActive;
			},
			toggleActive(newIsActive) {
				if (isActive === newIsActive) return;
				isActive = newIsActive;
				listeners.forEach((listener) => listener(isActive));
			},
			subscribe(listener) {
				listeners.push(listener);
				return () => {
					const index = listeners.indexOf(listener);
					if (index > -1) listeners.splice(index, 1);
				};
			}
		};
	}

//#endregion
//#region node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
/**
	* @license React
	* use-sync-external-store-shim.development.js
	*
	* Copyright (c) Meta Platforms, Inc. and affiliates.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*/
	var require_use_sync_external_store_shim_development = /* @__PURE__ */ __commonJSMin(((exports) => {
		(function() {
			function is(x, y) {
				return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
			}
			function useSyncExternalStore$2(subscribe, getSnapshot) {
				didWarnOld18Alpha || void 0 === React.startTransition || (didWarnOld18Alpha = !0, console.error("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
				var value = getSnapshot();
				if (!didWarnUncachedGetSnapshot) {
					var cachedValue = getSnapshot();
					objectIs(value, cachedValue) || (console.error("The result of getSnapshot should be cached to avoid an infinite loop"), didWarnUncachedGetSnapshot = !0);
				}
				cachedValue = useState({ inst: {
					value,
					getSnapshot
				} });
				var inst = cachedValue[0].inst, forceUpdate = cachedValue[1];
				useLayoutEffect(function() {
					inst.value = value;
					inst.getSnapshot = getSnapshot;
					checkIfSnapshotChanged(inst) && forceUpdate({ inst });
				}, [
					subscribe,
					value,
					getSnapshot
				]);
				useEffect(function() {
					checkIfSnapshotChanged(inst) && forceUpdate({ inst });
					return subscribe(function() {
						checkIfSnapshotChanged(inst) && forceUpdate({ inst });
					});
				}, [subscribe]);
				useDebugValue(value);
				return value;
			}
			function checkIfSnapshotChanged(inst) {
				var latestGetSnapshot = inst.getSnapshot;
				inst = inst.value;
				try {
					var nextValue = latestGetSnapshot();
					return !objectIs(inst, nextValue);
				} catch (error) {
					return !0;
				}
			}
			function useSyncExternalStore$1$1(subscribe, getSnapshot) {
				return getSnapshot();
			}
			"undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
			var React = require("react"), objectIs = "function" === typeof Object.is ? Object.is : is, useState = React.useState, useEffect = React.useEffect, useLayoutEffect = React.useLayoutEffect, useDebugValue = React.useDebugValue, didWarnOld18Alpha = !1, didWarnUncachedGetSnapshot = !1, shim = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$1$1 : useSyncExternalStore$2;
			exports.useSyncExternalStore = void 0 !== React.useSyncExternalStore ? React.useSyncExternalStore : shim;
			"undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
		})();
	}));

//#endregion
//#region node_modules/use-sync-external-store/shim/index.js
	var require_shim = /* @__PURE__ */ __commonJSMin(((exports, module) => {
		module.exports = require_use_sync_external_store_shim_development();
	}));

//#endregion
//#region node_modules/@fluentui/react-positioning/lib/hooks/useSafeZoneArea/getRectCorners.js
/**
	* Calculates the corners of a rectangle based on its DOMRect and an offset.
	*
	* @internal
	*/ function getRectCorners(rect, offset$3) {
		return {
			topLeft: [rect.left - offset$3[0], rect.top - offset$3[1]],
			topRight: [rect.right - offset$3[0], rect.top - offset$3[1]],
			bottomRight: [rect.right - offset$3[0], rect.bottom - offset$3[1]],
			bottomLeft: [rect.left - offset$3[0], rect.bottom - offset$3[1]]
		};
	}

//#endregion
//#region node_modules/@fluentui/react-positioning/lib/hooks/useSafeZoneArea/getMouseAnchor.js
	const OFFSET_DISTANCE = 20;
	/**
	* Measures the distance between two points in a 2D space.
	*/ function measureDistance(a, b) {
		return Math.sqrt((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2);
	}
	/**
	* Returns a unit vector pointing from point `b` to point `a`.
	* If the distance is zero, returns a zero vector.
	*/ function getUnitVector(a, b) {
		const distance = measureDistance(a, b);
		if (distance === 0) return [0, 0];
		return [(a[0] - b[0]) / distance, (a[1] - b[1]) / distance];
	}
	/**
	* Calculates the anchor point for a mouse position within a container defined by its top-left and bottom-right corners.
	* The anchor point is calculated as an offset from the center of the container in the direction of the mouse position.
	*
	* @internal
	*/ function getMouseAnchor(topLeftCorner, bottomRightCorner, mouseCoordinates) {
		const containerCenter = [(topLeftCorner[0] + bottomRightCorner[0]) / 2, (topLeftCorner[1] + bottomRightCorner[1]) / 2];
		const unitVector = getUnitVector([mouseCoordinates[0], mouseCoordinates[1]], [containerCenter[0], containerCenter[1]]);
		const distance = measureDistance([containerCenter[0], containerCenter[1]], [mouseCoordinates[0], mouseCoordinates[1]]);
		return [containerCenter[0] + unitVector[0] * (distance + OFFSET_DISTANCE), containerCenter[1] + unitVector[1] * (distance + OFFSET_DISTANCE)];
	}

//#endregion
//#region node_modules/@fluentui/react-positioning/lib/hooks/useSafeZoneArea/pointsToSvgPath.js
/**
	* Calculates the corners of a rectangle based on its DOMRect and an offset.
	*
	* @internal
	*/ function pointsToSvgPath(points) {
		return `M ${points} z`;
	}

//#endregion
//#region node_modules/@fluentui/react-positioning/lib/hooks/useSafeZoneArea/SafeZoneArea.styles.js
	const useStyles$99 = /* @__PURE__ */ __styles({
		wrapper: {
			mc9l5x: "fjseox",
			Bqenvij: "fniina8",
			a9b677: "f3tsq5r",
			Bkecrkj: "f1aehjj5"
		},
		wrapperActive: { mc9l5x: "ftgm304" },
		svg: {
			Bkfmm31: "f1au8mb3",
			Bkecrkj: "f1aehjj5",
			qhf8xq: "f19dog8a",
			Bhzewxz: "f15twtuk",
			oyh7mz: ["f1vgc2s3", "f1e31b4d"]
		},
		triangle: { Bkecrkj: "f1cguypg" },
		triangleDebug: {
			Bceei9c: "f7116n6",
			Bkfmm31: "f1xab38x"
		},
		rectDebug: { Bkfmm31: "fyegryc" }
	}, { d: [
		".fjseox{display:none;}",
		".fniina8{height:0;}",
		".f3tsq5r{width:0;}",
		".f1aehjj5{pointer-events:none;}",
		".ftgm304{display:block;}",
		".f1au8mb3{fill:transparent;}",
		".f19dog8a{position:fixed;}",
		".f15twtuk{top:0;}",
		".f1vgc2s3{left:0;}",
		".f1e31b4d{right:0;}",
		".f1cguypg{pointer-events:auto;}",
		".f7116n6{cursor:crosshair;}",
		".f1xab38x{fill:color-mix(in srgb, var(--colorPaletteGreenBackground3) 20%, transparent);}",
		".fyegryc{fill:color-mix(in srgb, var(--colorPaletteRedBackground3) 20%, transparent);}"
	] });

//#endregion
//#region node_modules/@fluentui/react-positioning/lib/hooks/useSafeZoneArea/computeOutsideClipPath.js
	function drawRectangle(rect) {
		if (rect.width <= 0 || rect.height <= 0) return "";
		let pathData = "";
		pathData += `M ${rect.x},${rect.y} `;
		pathData += `V ${rect.y + rect.height} `;
		pathData += `H ${rect.x + rect.width} `;
		pathData += `V ${rect.y} `;
		pathData += `H ${rect.x} `;
		pathData += `Z `;
		return pathData;
	}
	/**
	* Computes a clip path that covers the area outside multiple rectangles.
	*
	* @internal
	*/ function computeOutsideClipPath(svgWidth, svgHeight, targetRect, containerRect) {
		let pathData = `M 0,0 H ${svgWidth} V ${svgHeight} H 0 Z `;
		pathData += drawRectangle(targetRect);
		pathData += drawRectangle(containerRect);
		return pathData;
	}

//#endregion
//#region node_modules/@fluentui/react-positioning/lib/hooks/useSafeZoneArea/SafeZoneArea.js
	var import_shim = require_shim();
	const EMPTY_RECT = {
		top: 0,
		right: 0,
		bottom: 0,
		left: 0,
		width: 0,
		height: 0,
		x: 0,
		y: 0,
		toJSON() {
			return "";
		}
	};
	function isSameRect(a, b) {
		return a.top === b.top && a.right === b.right && a.bottom === b.bottom && a.left === b.left && a.width === b.width && a.height === b.height;
	}
	function isSameCoordinates(a, b) {
		return a[0] === b[0] && a[1] === b[1];
	}
	/**
	* A component that renders a safe zone area with SVG shapes. Uses `useSyncExternalStore` to manage its active state
	* to avoid causing re-renders in `useSafeZoneArea()` as the hook might be used in host components like `Menu`.
	*
	* Draws two shapes:
	* - a triangle that points to the target element which is an actual safe zone
	* - a rectangle for a clip path that clips out the target element
	*
	* @internal
	*/ const SafeZoneArea = /* @__PURE__ */ react.memo((props) => {
		const { debug, onMouseEnter, onMouseMove, onMouseLeave, stateStore } = props;
		const clipPathId = useId();
		const styles = useStyles$99();
		const active = (0, import_shim.useSyncExternalStore)(stateStore.subscribe, stateStore.isActive);
		const svgRef = react.useRef(null);
		const [state, setState] = react.useState(() => ({
			containerRect: EMPTY_RECT,
			targetRect: EMPTY_RECT,
			mouseCoordinates: [0, 0]
		}));
		react.useImperativeHandle(props.imperativeRef, () => ({ updateSVG(newState) {
			setState((prevState) => {
				if (isSameRect(prevState.containerRect, newState.containerRect) && isSameRect(prevState.targetRect, newState.targetRect) && isSameCoordinates(prevState.mouseCoordinates, newState.mouseCoordinates)) return prevState;
				return newState;
			});
		} }), []);
		const { containerRect, targetRect, mouseCoordinates } = state;
		const topOffset = Math.min(targetRect.top, containerRect.top);
		const leftOffset = Math.min(targetRect.left, containerRect.left);
		const bottomOffset = Math.max(targetRect.bottom, containerRect.bottom);
		const rightOffset = Math.max(targetRect.right, containerRect.right);
		const containerCorners = getRectCorners(containerRect, [leftOffset, topOffset]);
		const targetCorners = getRectCorners(targetRect, [leftOffset, topOffset]);
		const relativeMouseCoordinates = [mouseCoordinates[0] - leftOffset, mouseCoordinates[1] - topOffset];
		const mouseAnchor = getMouseAnchor(containerCorners.topLeft, containerCorners.bottomRight, relativeMouseCoordinates);
		const triangleA = [
			mouseAnchor,
			containerCorners.topLeft,
			containerCorners.topRight
		];
		const triangleB = [
			mouseAnchor,
			containerCorners.topRight,
			containerCorners.bottomRight
		];
		const triangleC = [
			mouseAnchor,
			containerCorners.bottomRight,
			containerCorners.bottomLeft
		];
		const triangleD = [
			mouseAnchor,
			containerCorners.bottomLeft,
			containerCorners.topLeft
		];
		const svgWidth = rightOffset - leftOffset;
		const svgHeight = bottomOffset - topOffset;
		const clipPath = computeOutsideClipPath(svgWidth, svgHeight, {
			x: targetCorners.topLeft[0],
			y: targetCorners.topLeft[1],
			width: targetRect.width,
			height: targetRect.height
		}, {
			x: containerCorners.topLeft[0],
			y: containerCorners.topLeft[1],
			width: containerRect.width,
			height: containerRect.height
		});
		return /* @__PURE__ */ react.createElement("div", {
			className: mergeClasses(styles.wrapper, active && styles.wrapperActive),
			"data-safe-zone": ""
		}, active ? /* @__PURE__ */ react.createElement("svg", {
			"aria-hidden": true,
			className: styles.svg,
			xmlns: "http://www.w3.org/2000/svg",
			ref: svgRef,
			style: {
				width: `${svgWidth}px`,
				height: `${svgHeight}px`,
				transform: `translate(${leftOffset}px, ${topOffset}px)`
			}
		}, /* @__PURE__ */ react.createElement("g", {
			className: mergeClasses(styles.triangle, debug && styles.triangleDebug),
			clipPath: `url(#${clipPathId})`,
			onMouseEnter,
			onMouseMove,
			onMouseLeave
		}, /* @__PURE__ */ react.createElement("path", { d: pointsToSvgPath(triangleA) }), /* @__PURE__ */ react.createElement("path", { d: pointsToSvgPath(triangleB) }), /* @__PURE__ */ react.createElement("path", { d: pointsToSvgPath(triangleC) }), /* @__PURE__ */ react.createElement("path", { d: pointsToSvgPath(triangleD) })), /* @__PURE__ */ react.createElement("clipPath", { id: clipPathId }, /* @__PURE__ */ react.createElement("path", { d: clipPath })), debug && /* @__PURE__ */ react.createElement("path", {
			className: styles.rectDebug,
			d: clipPath
		})) : null);
	});

//#endregion
//#region node_modules/@fluentui/react-positioning/lib/hooks/useSafeZoneArea/useSafeZoneArea.js
/**
	* Time in milliseconds after which the safe zone area will be cleared if no mouse movement is detected.
	*
	* Only affects the target element, not the safe zone area itself.
	*/ const MOUSE_MOVE_TARGET_POLLING_TIMEOUT = 2e3;
	function useSafeZoneArea({ debug = false, disabled = false, onSafeZoneEnter, onSafeZoneMove, onSafeZoneLeave, onSafeZoneTimeout, timeout = 1500 } = {}) {
		const [stateStore] = react.useState(createSafeZoneAreaStateStore);
		const safeZoneAreaRef = react.useRef(null);
		const containerRef = react.useRef(null);
		const targetRef = react.useRef(null);
		const [setSafeZoneCloseTimeout, clearSafeZoneCloseTimeout] = useTimeout();
		const [requestUpdateFrame, clearUpdateFrame] = useAnimationFrame();
		const mouseCoordinatesRef = react.useRef({
			x: 0,
			y: 0
		});
		const containerListenerRef = react.useMemo(() => {
			if (disabled) return () => {};
			let containerEl = null;
			function onContainerMouseEnter() {
				clearSafeZoneCloseTimeout();
				stateStore.toggleActive(false);
			}
			return (el) => {
				if (el === null) containerEl === null || containerEl === void 0 || containerEl.removeEventListener("mouseenter", onContainerMouseEnter);
				containerEl = el;
				el === null || el === void 0 || el.addEventListener("mouseenter", onContainerMouseEnter);
			};
		}, [
			clearSafeZoneCloseTimeout,
			disabled,
			stateStore
		]);
		const targetListenerRef = react.useMemo(() => {
			if (disabled) return () => {};
			let targetEl = null;
			function onTargetMouseMove(e) {
				mouseCoordinatesRef.current = {
					x: e.clientX,
					y: e.clientY
				};
				if (!stateStore.isActive()) stateStore.toggleActive(true);
				setSafeZoneCloseTimeout(() => {
					stateStore.toggleActive(false);
				}, MOUSE_MOVE_TARGET_POLLING_TIMEOUT);
			}
			return (el) => {
				if (el === null) {
					clearUpdateFrame();
					clearSafeZoneCloseTimeout();
					targetEl === null || targetEl === void 0 || targetEl.removeEventListener("mousemove", onTargetMouseMove);
				}
				targetEl = el;
				el === null || el === void 0 || el.addEventListener("mousemove", onTargetMouseMove);
			};
		}, [
			clearUpdateFrame,
			clearSafeZoneCloseTimeout,
			disabled,
			stateStore,
			setSafeZoneCloseTimeout
		]);
		const onSvgMouseEnter = useEventCallback((e) => {
			onSafeZoneEnter === null || onSafeZoneEnter === void 0 || onSafeZoneEnter(e);
			setSafeZoneCloseTimeout(() => {
				stateStore.toggleActive(false);
				onSafeZoneTimeout === null || onSafeZoneTimeout === void 0 || onSafeZoneTimeout();
			}, timeout);
		});
		const onSvgMouseMove = useEventCallback((e) => {
			setSafeZoneCloseTimeout(() => {
				stateStore.toggleActive(false);
				onSafeZoneTimeout === null || onSafeZoneTimeout === void 0 || onSafeZoneTimeout();
			}, timeout);
			onSafeZoneMove === null || onSafeZoneMove === void 0 || onSafeZoneMove(e);
		});
		const onSvgMouseLeave = useEventCallback((e) => {
			onSafeZoneLeave === null || onSafeZoneLeave === void 0 || onSafeZoneLeave(e);
		});
		react.useEffect(() => {
			return stateStore.subscribe((isActive) => {
				if (isActive) {
					function updateSVGs() {
						const containerEl = containerRef.current;
						const targetEl = targetRef.current;
						if (containerEl && targetEl) {
							var _safeZoneAreaRef_current;
							(_safeZoneAreaRef_current = safeZoneAreaRef.current) === null || _safeZoneAreaRef_current === void 0 || _safeZoneAreaRef_current.updateSVG({
								containerRect: containerEl.getBoundingClientRect(),
								mouseCoordinates: [mouseCoordinatesRef.current.x, mouseCoordinatesRef.current.y],
								targetRect: targetEl.getBoundingClientRect()
							});
						}
						requestUpdateFrame(updateSVGs);
					}
					updateSVGs();
					return;
				}
				clearUpdateFrame();
			});
		}, [
			clearUpdateFrame,
			requestUpdateFrame,
			stateStore
		]);
		return {
			containerRef: useMergedRefs(containerRef, containerListenerRef),
			targetRef: useMergedRefs(targetRef, targetListenerRef),
			elementToRender: react.useMemo(() => disabled ? null : /* @__PURE__ */ react.createElement(SafeZoneArea, {
				debug,
				onMouseEnter: onSvgMouseEnter,
				onMouseMove: onSvgMouseMove,
				onMouseLeave: onSvgMouseLeave,
				imperativeRef: safeZoneAreaRef,
				stateStore
			}), [
				disabled,
				debug,
				onSvgMouseEnter,
				onSvgMouseMove,
				onSvgMouseLeave,
				stateStore
			])
		};
	}

//#endregion
//#region node_modules/@fluentui/react-popover/lib/popoverContext.js
	const PopoverContext = createContext(void 0);
	const popoverContextDefaultValue = {
		open: false,
		setOpen: () => null,
		toggleOpen: () => null,
		triggerRef: { current: null },
		contentRef: { current: null },
		arrowRef: { current: null },
		openOnContext: false,
		openOnHover: false,
		size: "medium",
		trapFocus: false,
		inline: false
	};
	const PopoverProvider = PopoverContext.Provider;
	const usePopoverContext_unstable = (selector) => useContextSelector(PopoverContext, (ctx = popoverContextDefaultValue) => selector(ctx));

//#endregion
//#region node_modules/@fluentui/react-popover/lib/components/PopoverSurface/usePopoverSurface.js
/**
	* Create the state required to render PopoverSurface.
	*
	* The returned state can be modified with hooks such as usePopoverSurfaceStyles_unstable,
	* before being passed to renderPopoverSurface_unstable.
	*
	* @param props - props from this instance of PopoverSurface
	* @param ref - reference to root HTMLDivElement of PopoverSurface
	*/ const usePopoverSurface_unstable = (props, ref) => {
		const contentRef = usePopoverContext_unstable((context) => context.contentRef);
		const openOnHover = usePopoverContext_unstable((context) => context.openOnHover);
		const setOpen = usePopoverContext_unstable((context) => context.setOpen);
		const mountNode = usePopoverContext_unstable((context) => context.mountNode);
		const arrowRef = usePopoverContext_unstable((context) => context.arrowRef);
		const size$2 = usePopoverContext_unstable((context) => context.size);
		const withArrow = usePopoverContext_unstable((context) => context.withArrow);
		const appearance = usePopoverContext_unstable((context) => context.appearance);
		const trapFocus = usePopoverContext_unstable((context) => context.trapFocus);
		const inertTrapFocus = usePopoverContext_unstable((context) => context.inertTrapFocus);
		const inline = usePopoverContext_unstable((context) => context.inline);
		const { modalAttributes } = useModalAttributes({
			trapFocus,
			legacyTrapFocus: !inertTrapFocus,
			alwaysFocusable: !trapFocus
		});
		const state = {
			inline,
			appearance,
			withArrow,
			size: size$2,
			arrowRef,
			mountNode,
			components: { root: "div" },
			root: always(getIntrinsicElementProps("div", {
				ref: useMergedRefs(ref, contentRef),
				role: trapFocus ? "dialog" : "group",
				"aria-modal": trapFocus ? true : void 0,
				...modalAttributes,
				...props
			}), { elementType: "div" })
		};
		const { onMouseEnter: onMouseEnterOriginal, onMouseLeave: onMouseLeaveOriginal, onKeyDown: onKeyDownOriginal } = state.root;
		state.root.onMouseEnter = (e) => {
			if (openOnHover) setOpen(e, true);
			onMouseEnterOriginal === null || onMouseEnterOriginal === void 0 || onMouseEnterOriginal(e);
		};
		state.root.onMouseLeave = (e) => {
			if (openOnHover) setOpen(e, false);
			onMouseLeaveOriginal === null || onMouseLeaveOriginal === void 0 || onMouseLeaveOriginal(e);
		};
		state.root.onKeyDown = (e) => {
			var _contentRef_current;
			if (e.key === "Escape" && ((_contentRef_current = contentRef.current) === null || _contentRef_current === void 0 ? void 0 : _contentRef_current.contains(e.target))) {
				e.preventDefault();
				setOpen(e, false);
			}
			onKeyDownOriginal === null || onKeyDownOriginal === void 0 || onKeyDownOriginal(e);
		};
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-portal/lib/utils/toMountNodeProps.js
/**
	* The function that normalizes the `mountNode` prop into an object with element and className props.
	*
	* @param mountNode - an HTML element or an object with props
	*/ function toMountNodeProps(mountNode) {
		if (isHTMLElement(mountNode)) return { element: mountNode };
		if (typeof mountNode === "object") {
			if (mountNode === null) return { element: null };
			return mountNode;
		}
		return {};
	}

//#endregion
//#region node_modules/@fluentui/react-portal/lib/components/Portal/usePortalMountNodeStyles.styles.js
	const usePortalMountNodeStylesStyles = /* @__PURE__ */ __styles({ root: {
		qhf8xq: "f1euv43f",
		Bhzewxz: "f15twtuk",
		oyh7mz: ["f1vgc2s3", "f1e31b4d"],
		j35jbq: ["f1e31b4d", "f1vgc2s3"],
		Bj3rh1h: "f494woh"
	} }, { d: [
		".f1euv43f{position:absolute;}",
		".f15twtuk{top:0;}",
		".f1vgc2s3{left:0;}",
		".f1e31b4d{right:0;}",
		".f494woh{z-index:1000000;}"
	] });

//#endregion
//#region node_modules/@fluentui/react-portal/lib/components/Portal/usePortalMountNode.js
	const useInsertionEffect = react["useInsertionEffect"];
	/**
	* Legacy element factory for React 17 and below. It's not safe for concurrent rendering.
	*
	* Creates a new element on a "document.body" to mount portals.
	*/ const useLegacyElementFactory = (options) => {
		"use no memo";
		const { className, dir, focusVisibleRef, targetNode } = options;
		const targetElement = react.useMemo(() => {
			if (targetNode === void 0 || options.disabled) return null;
			const element = targetNode.ownerDocument.createElement("div");
			targetNode.appendChild(element);
			return element;
		}, [targetNode, options.disabled]);
		react.useMemo(() => {
			if (!targetElement) return;
			targetElement.className = className;
			targetElement.setAttribute("dir", dir);
			targetElement.setAttribute("data-portal-node", "true");
			focusVisibleRef.current = targetElement;
		}, [
			className,
			dir,
			targetElement,
			focusVisibleRef
		]);
		react.useEffect(() => {
			return () => {
				targetElement === null || targetElement === void 0 || targetElement.remove();
			};
		}, [targetElement]);
		return targetElement;
	};
	const initializeElementFactory = () => {
		let currentElement = void 0;
		function get(targetRoot, forceCreation) {
			if (currentElement) return currentElement;
			if (forceCreation) {
				currentElement = targetRoot.ownerDocument.createElement("div");
				targetRoot.appendChild(currentElement);
			}
			return currentElement;
		}
		function dispose() {
			if (currentElement) {
				currentElement.remove();
				currentElement = void 0;
			}
		}
		return {
			get,
			dispose
		};
	};
	/**
	* This is a modern element factory for React 18 and above. It is safe for concurrent rendering.
	*
	* It abuses the fact that React will mount DOM once (unlike hooks), so by using a proxy we can intercept:
	* - the `remove()` method (we call it in `useEffect()`) and remove the element only when the portal is unmounted
	* - all other methods (and properties) will be called by React once a portal is mounted
	*/ const useModernElementFactory = (options) => {
		"use no memo";
		const { className, dir, focusVisibleRef, targetNode } = options;
		const [elementFactory] = react.useState(initializeElementFactory);
		const elementProxy = react.useMemo(() => {
			if (targetNode === void 0 || options.disabled) return null;
			return new Proxy({}, {
				get(_, property) {
					if (property === "nodeType") return 1;
					if (property === "remove") {
						const targetElement$1 = elementFactory.get(targetNode, false);
						if (targetElement$1) {
							if (targetElement$1.childNodes.length === 0) elementFactory.dispose();
						}
						return () => {};
					}
					const targetElement = elementFactory.get(targetNode, true);
					const targetProperty = targetElement ? targetElement[property] : void 0;
					if (typeof targetProperty === "function") return targetProperty.bind(targetElement);
					return targetProperty;
				},
				set(_, property, value) {
					const ignoredProperty = property === "_virtual" || property === "focusVisible";
					const targetElement = ignoredProperty ? elementFactory.get(targetNode, false) : elementFactory.get(targetNode, true);
					if (ignoredProperty && !targetElement) return true;
					if (targetElement) {
						Object.assign(targetElement, { [property]: value });
						return true;
					}
					return false;
				}
			});
		}, [
			elementFactory,
			targetNode,
			options.disabled
		]);
		useInsertionEffect(() => {
			if (!elementProxy) return;
			const classesToApply = className.split(" ").filter(Boolean);
			elementProxy.classList.add(...classesToApply);
			elementProxy.setAttribute("dir", dir);
			elementProxy.setAttribute("data-portal-node", "true");
			focusVisibleRef.current = elementProxy;
			return () => {
				elementProxy.classList.remove(...classesToApply);
				elementProxy.removeAttribute("dir");
			};
		}, [
			className,
			dir,
			elementProxy,
			focusVisibleRef
		]);
		react.useEffect(() => {
			return () => {
				elementProxy === null || elementProxy === void 0 || elementProxy.remove();
			};
		}, [elementProxy]);
		return elementProxy;
	};
	/**
	* Element factory based on the React version.
	*
	* React 17 and below:
	* - useLegacyElementFactory
	*
	* React 18 and above:
	* - useModernElementFactory
	*/ const useElementFactory = useInsertionEffect ? useModernElementFactory : useLegacyElementFactory;
	/**
	* Creates a new element on a "document.body" to mount portals.
	*/ const usePortalMountNode$1 = (options) => {
		"use no memo";
		const { targetDocument, dir } = useFluent();
		const mountNode = usePortalMountNode();
		const focusVisibleRef = useFocusVisible();
		const classes = usePortalMountNodeStylesStyles();
		const themeClassName = useThemeClassName();
		return useElementFactory({
			dir,
			disabled: options.disabled,
			focusVisibleRef,
			className: mergeClasses(themeClassName, classes.root, options.className),
			targetNode: mountNode !== null && mountNode !== void 0 ? mountNode : targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.body
		});
	};

//#endregion
//#region node_modules/@fluentui/react-portal/lib/components/Portal/usePortal.js
/**
	* Create the state required to render Portal.
	*
	* The returned state can be modified with hooks such as usePortalStyles, before being passed to renderPortal_unstable.
	*
	* @param props - props from this instance of Portal
	*/ const usePortal_unstable = (props) => {
		const { element, className } = toMountNodeProps(props.mountNode);
		const virtualParentRootRef = react.useRef(null);
		const fallbackElement = usePortalMountNode$1({
			disabled: !!element,
			className
		});
		const mountNode = element !== null && element !== void 0 ? element : fallbackElement;
		const state = {
			children: props.children,
			mountNode,
			virtualParentRootRef
		};
		react.useEffect(() => {
			if (!mountNode) return;
			const virtualParent = virtualParentRootRef.current;
			const isVirtualParentInsideChild = mountNode.contains(virtualParent);
			if (virtualParent && !isVirtualParentInsideChild) {
				setVirtualParent(mountNode, virtualParent);
				return () => {
					setVirtualParent(mountNode, void 0);
				};
			}
		}, [virtualParentRootRef, mountNode]);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-portal/lib/components/Portal/renderPortal.js
/**
	* Render the final JSX of Portal
	*/ const renderPortal_unstable = (state) => {
		return /* @__PURE__ */ react.createElement("span", {
			hidden: true,
			ref: state.virtualParentRootRef
		}, state.mountNode && /* @__PURE__ */ react_dom.createPortal(/* @__PURE__ */ react.createElement(react.Fragment, null, state.children, /* @__PURE__ */ react.createElement("span", { hidden: true })), state.mountNode));
	};

//#endregion
//#region node_modules/@fluentui/react-portal/lib/components/Portal/Portal.js
/**
	* A portal provides a way to render children into a DOM node
	* that exists outside the DOM hierarchy of the parent component.
	*/ const Portal = (props) => {
		return renderPortal_unstable(usePortal_unstable(props));
	};
	Portal.displayName = "Portal";

//#endregion
//#region node_modules/@fluentui/react-popover/lib/components/PopoverSurface/renderPopoverSurface.js
/**
	* Render the final JSX of PopoverSurface
	*/ const renderPopoverSurface_unstable = (state) => {
		assertSlots(state);
		const surface = /* @__PURE__ */ jsxs(state.root, { children: [state.withArrow && /* @__PURE__ */ jsx("div", {
			ref: state.arrowRef,
			className: state.arrowClassName
		}), state.root.children] });
		if (state.inline) return surface;
		return /* @__PURE__ */ jsx(Portal, {
			mountNode: state.mountNode,
			children: surface
		});
	};

//#endregion
//#region node_modules/@fluentui/react-popover/lib/components/PopoverSurface/usePopoverSurfaceStyles.styles.js
	const popoverSurfaceClassNames = { root: "fui-PopoverSurface" };
	const arrowHeights = {
		small: 6,
		medium: 8,
		large: 8
	};
	/**
	* Styles for the root slot
	*/
	const useStyles$98 = /* @__PURE__ */ __styles({
		root: {
			sj55zd: "f19n0e5",
			De3pzq: "fxugw4r",
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "ft85np5",
			Bgfg5da: 0,
			B9xav0g: 0,
			oivjwe: 0,
			Bn0qgzm: 0,
			B4g9neb: 0,
			zhjwy3: 0,
			wvpqe5: 0,
			ibv6hh: 0,
			u1mtju: 0,
			h3c5rm: 0,
			vrafjx: 0,
			Bekrc4i: 0,
			i8vvqc: 0,
			g2u3we: 0,
			icvyot: 0,
			B4j52fo: 0,
			irswps: "f9ggezi",
			Bahqtrf: "fk6fouc",
			Be2twd7: "fkhj508",
			Bhrd7zp: "figsok6",
			Bg96gwp: "f1i3iumi",
			B93otf3: "f18k4bn6",
			vin17d: "fo1kyvf",
			Ezkn3b: "fetxo7e",
			nyiy2g: "f8x1vz1",
			swvrvq: "f8g0anz",
			Bkovbt3: "fezwn9i",
			hgjdhn: "fz5efge",
			fsy9dk: "f1ydixl4",
			B3ogreh: "f8dgqj5",
			jv49x5: "fnyfnr8",
			Bk7o48c: "fgw77r4",
			Bv12yb3: "f1noc5he",
			i09l9u: "f1k46bua",
			Bcrj8ia: "f1lhuzxm",
			Bmmhre5: "f1f9qikc",
			Bhu2qc9: "fymb6k8"
		},
		inline: { Bj3rh1h: "f19g0ac" },
		inverted: {
			De3pzq: "fg3r6xk",
			sj55zd: "fonrgv7"
		},
		brand: {
			De3pzq: "ffp7eso",
			sj55zd: "f1phragk"
		},
		smallPadding: {
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f1sy4kr4"
		},
		mediumPadding: {
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f4zyqsv"
		},
		largePadding: {
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "fop8ug2"
		},
		smallArrow: {
			rhnwrx: "f1s3jn22",
			Bdy53xb: "fv40uqz"
		},
		mediumLargeArrow: {
			rhnwrx: "f1f72gjr",
			Bdy53xb: "f69yoe5"
		},
		arrow: {
			B7ck84d: "f1ewtqcl",
			qhf8xq: "f1euv43f",
			Bj3rh1h: "f1bsuimh",
			De3pzq: "f1u2r49w",
			B2eet1l: "fqhgnl",
			Beyfa6y: "f17bz04i",
			Bz10aip: "f36o3x3",
			Bqenvij: "fzofk8q",
			a9b677: "f1wbx1ie",
			Ftih45: "f1wl9k8s",
			Br0sdwz: "f1aocrix",
			cmx5o7: "f1ljr5q2",
			susq4k: 0,
			Biibvgv: 0,
			Bicfajf: 0,
			qehafq: 0,
			Brs5u8j: "f155f1qt",
			Ccq8qp: "f9mhzq7",
			Baz25je: "fr6rhvx",
			Bcgcnre: 0,
			Bqjgrrk: 0,
			qa3bma: 0,
			y0oebl: 0,
			Biqmznv: 0,
			Bm6vgfq: 0,
			Bbv0w2i: 0,
			uvfttm: 0,
			eqrjj: 0,
			Bk5zm6e: 0,
			m598lv: 0,
			B4f6apu: 0,
			ydt019: 0,
			Bq4z7u6: 0,
			Bdkvgpv: 0,
			B0qfbqy: 0,
			kj8mxx: "f1kc0wz4",
			r59vdv: "fgq90dz",
			Bkw5xw4: "fq0y47f",
			hl6cv3: "f1pwrbz6",
			aea9ga: "f1hxxcvm",
			yayu3t: "fw8rgyo",
			Bhsv975: "f1wnzycx",
			rhl9o9: "f1730wal",
			B7gxrvb: "f1fy4ixr",
			B6q6orb: "fobkauc",
			B0lu1f8: "f16bqv1l"
		}
	}, {
		d: [
			".f19n0e5{color:var(--colorNeutralForeground1);}",
			".fxugw4r{background-color:var(--colorNeutralBackground1);}",
			[".ft85np5{border-radius:var(--borderRadiusMedium);}", { p: -1 }],
			[".f9ggezi{border:1px solid var(--colorTransparentStroke);}", { p: -2 }],
			".fk6fouc{font-family:var(--fontFamilyBase);}",
			".fkhj508{font-size:var(--fontSizeBase300);}",
			".figsok6{font-weight:var(--fontWeightRegular);}",
			".f1i3iumi{line-height:var(--lineHeightBase300);}",
			".f18k4bn6{animation-composition:accumulate;}",
			".fo1kyvf{animation-duration:var(--durationSlower);}",
			".fetxo7e{animation-timing-function:var(--curveDecelerateMid);}",
			".f8x1vz1{--fui-positioning-slide-distance-x:0px;}",
			".f8g0anz{--fui-positioning-slide-distance-y:10px;}",
			".fezwn9i[data-popper-placement^=right]{--fui-positioning-slide-distance-x:-10px;}",
			".fz5efge[data-popper-placement^=right]{--fui-positioning-slide-distance-y:0px;}",
			".f1ydixl4[data-popper-placement^=bottom]{--fui-positioning-slide-distance-x:0px;}",
			".f8dgqj5[data-popper-placement^=bottom]{--fui-positioning-slide-distance-y:-10px;}",
			".fnyfnr8[data-popper-placement^=left]{--fui-positioning-slide-distance-x:10px;}",
			".fgw77r4[data-popper-placement^=left]{--fui-positioning-slide-distance-y:0px;}",
			".f1noc5he{animation-name:f1m0q9mo,f79suad;}",
			".fymb6k8{filter:drop-shadow(0 0 2px var(--colorNeutralShadowAmbient)) drop-shadow(0 8px 16px var(--colorNeutralShadowKey));}",
			".f19g0ac{z-index:1;}",
			".fg3r6xk{background-color:var(--colorNeutralBackgroundStatic);}",
			".fonrgv7{color:var(--colorNeutralForegroundStaticInverted);}",
			".ffp7eso{background-color:var(--colorBrandBackground);}",
			".f1phragk{color:var(--colorNeutralForegroundOnBrand);}",
			[".f1sy4kr4{padding:12px;}", { p: -1 }],
			[".f4zyqsv{padding:16px;}", { p: -1 }],
			[".fop8ug2{padding:20px;}", { p: -1 }],
			".f1s3jn22{--fui-positioning-arrow-height:8.484px;}",
			".fv40uqz{--fui-positioning-arrow-offset:-4.242px;}",
			".f1f72gjr{--fui-positioning-arrow-height:11.312px;}",
			".f69yoe5{--fui-positioning-arrow-offset:-5.656px;}",
			".f1ewtqcl{box-sizing:border-box;}",
			".f1euv43f{position:absolute;}",
			".f1bsuimh{z-index:-1;}",
			".f1u2r49w{background-color:inherit;}",
			".fqhgnl{background-clip:content-box;}",
			".f17bz04i{border-bottom-left-radius:var(--borderRadiusSmall);}",
			".f36o3x3{transform:rotate(var(--fui-positioning-arrow-angle));}",
			".fzofk8q{height:var(--fui-positioning-arrow-height);}",
			".f1wbx1ie{width:var(--fui-positioning-arrow-height);}",
			".f1wl9k8s::before{content:\"\";}",
			".f1aocrix::before{display:block;}",
			".f1ljr5q2::before{background-color:inherit;}",
			[".f155f1qt::before{margin:-1px;}", { p: -1 }],
			".f9mhzq7::before{width:100%;}",
			".fr6rhvx::before{height:100%;}",
			[".f1kc0wz4::before{border:1px solid var(--colorTransparentStroke);}", { p: -2 }],
			".fgq90dz::before{border-bottom-left-radius:var(--borderRadiusSmall);}",
			".fq0y47f::before{clip-path:polygon(0% 0%, 100% 100%, 0% 100%);}",
			"[data-popper-placement^=\"top\"] .f1pwrbz6{bottom:var(--fui-positioning-arrow-offset);}",
			"[data-popper-placement^=\"top\"] .f1hxxcvm{--fui-positioning-arrow-angle:-45deg;}",
			"[data-popper-placement^=\"right\"] .fw8rgyo{left:var(--fui-positioning-arrow-offset);}",
			"[data-popper-placement^=\"right\"] .f1wnzycx{--fui-positioning-arrow-angle:45deg;}",
			"[data-popper-placement^=\"bottom\"] .f1730wal{top:var(--fui-positioning-arrow-offset);}",
			"[data-popper-placement^=\"bottom\"] .f1fy4ixr{--fui-positioning-arrow-angle:135deg;}",
			"[data-popper-placement^=\"left\"] .fobkauc{right:var(--fui-positioning-arrow-offset);}",
			"[data-popper-placement^=\"left\"] .f16bqv1l{--fui-positioning-arrow-angle:225deg;}"
		],
		k: ["@keyframes f1m0q9mo{from{opacity:-1;}to{opacity:0;}}", "@keyframes f79suad{from{transform:translate(var(--fui-positioning-slide-distance-x), var(--fui-positioning-slide-distance-y));}}"],
		m: [["@media (prefers-reduced-motion){.f1k46bua[data-popper-placement]{animation-duration:1ms;}}", { m: "(prefers-reduced-motion)" }], ["@media (prefers-reduced-motion){.f1lhuzxm[data-popper-placement]{animation-name:f1m0q9mo;}}", { m: "(prefers-reduced-motion)" }]],
		t: ["@supports not (animation-composition: accumulate){.f1f9qikc[data-popper-placement]{animation-name:f1m0q9mo;}}"]
	});
	/**
	* Apply styling to the PopoverSurface slots based on the state
	*/
	const usePopoverSurfaceStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$98();
		state.root.className = mergeClasses(popoverSurfaceClassNames.root, styles.root, state.inline && styles.inline, state.size === "small" && styles.smallPadding, state.size === "medium" && styles.mediumPadding, state.size === "large" && styles.largePadding, state.appearance === "inverted" && styles.inverted, state.appearance === "brand" && styles.brand, state.root.className);
		state.arrowClassName = mergeClasses(styles.arrow, state.size === "small" ? styles.smallArrow : styles.mediumLargeArrow);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-popover/lib/components/PopoverSurface/PopoverSurface.js
/**
	* PopoverSurface component renders react children in a positioned box
	*/ const PopoverSurface = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = usePopoverSurface_unstable(props, ref);
		usePopoverSurfaceStyles_unstable(state);
		useCustomStyleHook("usePopoverSurfaceStyles_unstable")(state);
		return renderPopoverSurface_unstable(state);
	});
	PopoverSurface.displayName = "PopoverSurface";

//#endregion
//#region node_modules/@fluentui/react-popover/lib/components/Popover/constants.js
/**
	* @internal
	* The default value of the tooltip's border radius (borderRadiusMedium).
	*
	* Unfortunately, Popper requires it to be specified as a variable instead of using CSS.
	* While we could use getComputedStyle, that adds a performance penalty for something that
	* will likely never change.
	*/ const popoverSurfaceBorderRadius = 4;

//#endregion
//#region node_modules/@fluentui/react-popover/lib/components/Popover/usePopover.js
/**
	* Create the state required to render Popover.
	*
	* The returned state can be modified with hooks such as usePopoverStyles,
	* before being passed to renderPopover_unstable.
	*
	* @param props - props from this instance of Popover
	*/ const usePopover_unstable = (props) => {
		const [contextTarget, setContextTarget] = usePositioningMouseTarget();
		const initialState = {
			size: "medium",
			contextTarget,
			setContextTarget,
			...props
		};
		const children = react.Children.toArray(props.children);
		if (children.length === 0) console.warn("Popover must contain at least one child");
		if (children.length > 2) console.warn("Popover must contain at most two children");
		let popoverTrigger = void 0;
		let popoverSurface = void 0;
		if (children.length === 2) {
			popoverTrigger = children[0];
			popoverSurface = children[1];
		} else if (children.length === 1) popoverSurface = children[0];
		const [open, setOpenState] = useOpenState(initialState);
		const [setOpenTimeout, clearOpenTimeout] = useTimeout();
		const setOpen = useEventCallback((e, shouldOpen) => {
			clearOpenTimeout();
			if (!(e instanceof Event) && e.persist) e.persist();
			if (e.type === "mouseleave") {
				var _props_mouseLeaveDelay;
				setOpenTimeout(() => {
					setOpenState(e, shouldOpen);
				}, (_props_mouseLeaveDelay = props.mouseLeaveDelay) !== null && _props_mouseLeaveDelay !== void 0 ? _props_mouseLeaveDelay : 500);
			} else setOpenState(e, shouldOpen);
		});
		const toggleOpen = react.useCallback((e) => {
			setOpen(e, !open);
		}, [setOpen, open]);
		const positioningRefs = usePopoverRefs(initialState);
		const { targetDocument } = useFluent();
		var _props_closeOnIframeFocus;
		useOnClickOutside({
			contains: elementContains,
			element: targetDocument,
			callback: (ev) => setOpen(ev, false),
			refs: [positioningRefs.triggerRef, positioningRefs.contentRef],
			disabled: !open,
			disabledFocusOnIframe: !((_props_closeOnIframeFocus = props.closeOnIframeFocus) !== null && _props_closeOnIframeFocus !== void 0 ? _props_closeOnIframeFocus : true)
		});
		const closeOnScroll = initialState.openOnContext || initialState.closeOnScroll;
		useOnScrollOutside({
			contains: elementContains,
			element: targetDocument,
			callback: (ev) => setOpen(ev, false),
			refs: [positioningRefs.triggerRef, positioningRefs.contentRef],
			disabled: !open || !closeOnScroll
		});
		const { findFirstFocusable } = useFocusFinders();
		const activateModal = useActivateModal();
		react.useEffect(() => {
			if (props.unstable_disableAutoFocus) return;
			const contentElement = positioningRefs.contentRef.current;
			if (open && contentElement) {
				var _contentElement_getAttribute;
				const shouldFocusContainer = !isNaN((_contentElement_getAttribute = contentElement.getAttribute("tabIndex")) !== null && _contentElement_getAttribute !== void 0 ? _contentElement_getAttribute : void 0);
				const firstFocusable = shouldFocusContainer ? contentElement : findFirstFocusable(contentElement);
				firstFocusable === null || firstFocusable === void 0 || firstFocusable.focus();
				if (shouldFocusContainer) activateModal(contentElement);
			}
		}, [
			findFirstFocusable,
			activateModal,
			open,
			positioningRefs.contentRef,
			props.unstable_disableAutoFocus
		]);
		var _props_inertTrapFocus, _props_inline;
		return {
			...initialState,
			...positioningRefs,
			inertTrapFocus: (_props_inertTrapFocus = props.inertTrapFocus) !== null && _props_inertTrapFocus !== void 0 ? _props_inertTrapFocus : props.legacyTrapFocus === void 0 ? false : !props.legacyTrapFocus,
			popoverTrigger,
			popoverSurface,
			open,
			setOpen,
			toggleOpen,
			setContextTarget,
			contextTarget,
			inline: (_props_inline = props.inline) !== null && _props_inline !== void 0 ? _props_inline : false
		};
	};
	/**
	* Creates and manages the Popover open state
	*/ function useOpenState(state) {
		"use no memo";
		const onOpenChange = useEventCallback((e, data) => {
			var _state_onOpenChange;
			return (_state_onOpenChange = state.onOpenChange) === null || _state_onOpenChange === void 0 ? void 0 : _state_onOpenChange.call(state, e, data);
		});
		const [open, setOpenState] = useControllableState({
			state: state.open,
			defaultState: state.defaultOpen,
			initialState: false
		});
		state.open = open !== void 0 ? open : state.open;
		const setContextTarget = state.setContextTarget;
		return [open, react.useCallback((e, shouldOpen) => {
			if (shouldOpen && e.type === "contextmenu") setContextTarget(e);
			if (!shouldOpen) setContextTarget(void 0);
			setOpenState(shouldOpen);
			onOpenChange === null || onOpenChange === void 0 || onOpenChange(e, { open: shouldOpen });
		}, [
			setOpenState,
			onOpenChange,
			setContextTarget
		])];
	}
	/**
	* Creates and sets the necessary trigger, target and content refs used by Popover
	*/ function usePopoverRefs(state) {
		"use no memo";
		const positioningOptions = {
			position: "above",
			align: "center",
			arrowPadding: 2 * popoverSurfaceBorderRadius,
			target: state.openOnContext ? state.contextTarget : void 0,
			...resolvePositioningShorthand(state.positioning)
		};
		if (positioningOptions.coverTarget) state.withArrow = false;
		if (state.withArrow) positioningOptions.offset = mergeArrowOffset(positioningOptions.offset, arrowHeights[state.size]);
		const { targetRef: triggerRef, containerRef: contentRef, arrowRef } = usePositioning(positioningOptions);
		return {
			triggerRef,
			contentRef,
			arrowRef
		};
	}

//#endregion
//#region node_modules/@fluentui/react-popover/lib/components/Popover/renderPopover.js
/**
	* Render the final JSX of Popover
	*/ const renderPopover_unstable = (state) => {
		const { appearance, arrowRef, contentRef, inline, mountNode, open, openOnContext, openOnHover, setOpen, size: size$2, toggleOpen, trapFocus, triggerRef, withArrow, inertTrapFocus } = state;
		return /* @__PURE__ */ react.createElement(PopoverContext.Provider, { value: {
			appearance,
			arrowRef,
			contentRef,
			inline,
			mountNode,
			open,
			openOnContext,
			openOnHover,
			setOpen,
			toggleOpen,
			triggerRef,
			size: size$2,
			trapFocus,
			inertTrapFocus,
			withArrow
		} }, state.popoverTrigger, state.open && state.popoverSurface);
	};

//#endregion
//#region node_modules/@fluentui/react-popover/lib/components/Popover/Popover.js
/**
	* Wrapper component that manages state for a PopoverTrigger and a PopoverSurface components.
	*/ const Popover = (props) => {
		return renderPopover_unstable(usePopover_unstable(props));
	};
	Popover.displayName = "Popover";

//#endregion
//#region node_modules/@fluentui/react-popover/lib/components/PopoverTrigger/usePopoverTrigger.js
/**
	* Create the state required to render PopoverTrigger.
	*
	* The returned state can be modified with hooks such as usePopoverTriggerStyles,
	* before being passed to renderPopoverTrigger_unstable.
	*
	* @param props - props from this instance of PopoverTrigger
	*/ const usePopoverTrigger_unstable = (props) => {
		const { children, disableButtonEnhancement = false } = props;
		const child = getTriggerChild(children);
		const open = usePopoverContext_unstable((context) => context.open);
		const setOpen = usePopoverContext_unstable((context) => context.setOpen);
		const toggleOpen = usePopoverContext_unstable((context) => context.toggleOpen);
		const triggerRef = usePopoverContext_unstable((context) => context.triggerRef);
		const openOnHover = usePopoverContext_unstable((context) => context.openOnHover);
		const openOnContext = usePopoverContext_unstable((context) => context.openOnContext);
		const { triggerAttributes } = useModalAttributes();
		const onContextMenu = (e) => {
			if (openOnContext) {
				e.preventDefault();
				setOpen(e, true);
			}
		};
		const onClick = (e) => {
			if (!openOnContext) toggleOpen(e);
		};
		const onKeyDown = (e) => {
			if (e.key === Escape && open && !e.isDefaultPrevented()) {
				setOpen(e, false);
				e.preventDefault();
			}
		};
		const onMouseEnter = (e) => {
			if (openOnHover) setOpen(e, true);
		};
		const onMouseLeave = (e) => {
			if (openOnHover) setOpen(e, false);
		};
		const contextMenuProps = {
			...triggerAttributes,
			"aria-expanded": `${open}`,
			...child === null || child === void 0 ? void 0 : child.props,
			onMouseEnter: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onMouseEnter, onMouseEnter)),
			onMouseLeave: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onMouseLeave, onMouseLeave)),
			onContextMenu: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onContextMenu, onContextMenu)),
			ref: useMergedRefs(triggerRef, getReactElementRef(child))
		};
		const triggerChildProps = {
			...contextMenuProps,
			onClick: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onClick, onClick)),
			onKeyDown: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onKeyDown, onKeyDown))
		};
		const ariaButtonTriggerChildProps = useARIAButtonProps((child === null || child === void 0 ? void 0 : child.type) === "button" || (child === null || child === void 0 ? void 0 : child.type) === "a" ? child.type : "div", triggerChildProps);
		return { children: applyTriggerPropsToChildren(props.children, useARIAButtonProps((child === null || child === void 0 ? void 0 : child.type) === "button" || (child === null || child === void 0 ? void 0 : child.type) === "a" ? child.type : "div", openOnContext ? contextMenuProps : disableButtonEnhancement ? triggerChildProps : ariaButtonTriggerChildProps)) };
	};

//#endregion
//#region node_modules/@fluentui/react-popover/lib/components/PopoverTrigger/renderPopoverTrigger.js
/**
	* Render the final JSX of PopoverTrigger
	*/ const renderPopoverTrigger_unstable = (state) => {
		return state.children;
	};

//#endregion
//#region node_modules/@fluentui/react-popover/lib/components/PopoverTrigger/PopoverTrigger.js
/**
	* Wraps a trigger element as an only child and adds the necessary event handling to open a popover.
	*/ const PopoverTrigger = (props) => {
		return renderPopoverTrigger_unstable(usePopoverTrigger_unstable(props));
	};
	PopoverTrigger.displayName = "PopoverTrigger";
	PopoverTrigger.isFluentTriggerComponent = true;

//#endregion
//#region node_modules/@fluentui/react-avatar/lib/components/AvatarGroupPopover/renderAvatarGroupPopover.js
/**
	* Render the final JSX of AvatarGroupPopover
	*/ const renderAvatarGroupPopover_unstable = (state, contextValues) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(state.root, { children: [/* @__PURE__ */ jsx(PopoverTrigger, {
			disableButtonEnhancement: true,
			children: /* @__PURE__ */ jsx(state.tooltip, { children: /* @__PURE__ */ jsx(state.triggerButton, {}) })
		}), /* @__PURE__ */ jsx(state.popoverSurface, { children: /* @__PURE__ */ jsx(AvatarGroupProvider, {
			value: contextValues.avatarGroup,
			children: /* @__PURE__ */ jsx(state.content, {})
		}) })] });
	};

//#endregion
//#region node_modules/@fluentui/react-avatar/lib/components/AvatarGroupPopover/useAvatarGroupPopoverContextValues.js
	const useAvatarGroupPopoverContextValues_unstable = (state) => {
		return { avatarGroup: {
			isOverflow: true,
			size: 24
		} };
	};

//#endregion
//#region node_modules/@fluentui/react-tooltip/lib/components/Tooltip/private/constants.js
/**
	* The height of the tooltip's arrow in pixels.
	*/ const arrowHeight = 6;
	/**
	* The default value of the tooltip's border radius (borderRadiusMedium).
	*
	* Unfortunately, Popper requires it to be specified as a variable instead of using CSS.
	* While we could use getComputedStyle, that adds a performance penalty for something that
	* will likely never change.
	*/ const tooltipBorderRadius = 4;

//#endregion
//#region node_modules/@fluentui/react-tooltip/lib/components/Tooltip/private/useTooltipTimeout.js
	const setTimeoutNoop = (_callback) => -1;
	const clearTimeoutNoop = (_handle) => void 0;
	/**
	* @internal
	* @param triggerElementRef - Reference to the trigger element
	* @returns A pair of [setTimeout, clearTimeout] that are stable between renders.
	*/ function useTooltipTimeout(triggerElementRef) {
		const { targetDocument } = useFluent();
		const win = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView;
		const setTimerFn = win ? win.setTimeout : setTimeoutNoop;
		const clearTimerFn = win ? win.clearTimeout : clearTimeoutNoop;
		const id = react.useRef(void 0);
		const set = react.useCallback((fn, delay) => {
			if (id.current !== void 0) clearTimerFn(id.current);
			id.current = setTimerFn(fn, delay !== null && delay !== void 0 ? delay : 0);
			return id.current;
		}, [clearTimerFn, setTimerFn]);
		const cancel = react.useCallback(() => {
			if (id.current !== void 0) {
				clearTimerFn(id.current);
				id.current = void 0;
			}
		}, [clearTimerFn]);
		react.useEffect(() => {
			const el = triggerElementRef.current;
			return () => {
				if (!el || !el.isConnected) cancel();
			};
		}, [cancel, triggerElementRef]);
		return [set, cancel];
	}

//#endregion
//#region node_modules/@fluentui/react-tooltip/lib/components/Tooltip/useTooltip.js
/**
	* Create the state required to render Tooltip.
	*
	* The returned state can be modified with hooks such as useTooltipStyles_unstable,
	* before being passed to renderTooltip_unstable.
	*
	* @param props - props from this instance of Tooltip
	*/ const useTooltip_unstable = (props) => {
		"use no memo";
		var _child_props, _child_props1, _child_props2, _child_props3, _child_props4, _child_props5, _child_props6;
		const context = useTooltipVisibility();
		const isServerSideRender = useIsSSR();
		const { targetDocument } = useFluent();
		const [visible, setVisibleInternal] = useControllableState({
			state: props.visible,
			initialState: false
		});
		const { appearance = "normal", children, content, withArrow = false, positioning = "above", onVisibleChange, relationship, showDelay = 250, hideDelay = 250, mountNode } = props;
		const state = {
			withArrow,
			positioning,
			showDelay,
			hideDelay,
			relationship,
			visible,
			shouldRenderTooltip: visible,
			appearance,
			mountNode,
			components: { content: "div" },
			content: always(content, {
				defaultProps: { role: "tooltip" },
				elementType: "div"
			})
		};
		state.content.id = useId("tooltip-", state.content.id);
		const positioningOptions = {
			enabled: state.visible,
			arrowPadding: 2 * tooltipBorderRadius,
			position: "above",
			align: "center",
			offset: 4,
			...resolvePositioningShorthand(state.positioning)
		};
		if (state.withArrow) positioningOptions.offset = mergeArrowOffset(positioningOptions.offset, arrowHeight);
		const { targetRef, containerRef, arrowRef } = usePositioning(positioningOptions);
		const [setDelayTimeout, clearDelayTimeout] = useTooltipTimeout(containerRef);
		const setVisible = react.useCallback((ev, data) => {
			clearDelayTimeout();
			setVisibleInternal((oldVisible) => {
				if (data.visible !== oldVisible) onVisibleChange === null || onVisibleChange === void 0 || onVisibleChange(ev, data);
				return data.visible;
			});
		}, [
			clearDelayTimeout,
			setVisibleInternal,
			onVisibleChange
		]);
		state.content.ref = useMergedRefs(state.content.ref, containerRef);
		state.arrowRef = arrowRef;
		useIsomorphicLayoutEffect(() => {
			if (visible) {
				var _context_visibleTooltip;
				const thisTooltip = { hide: (ev) => setVisible(void 0, {
					visible: false,
					documentKeyboardEvent: ev
				}) };
				(_context_visibleTooltip = context.visibleTooltip) === null || _context_visibleTooltip === void 0 || _context_visibleTooltip.hide();
				context.visibleTooltip = thisTooltip;
				const onDocumentKeyDown = (ev) => {
					if (ev.key === Escape && !ev.defaultPrevented) {
						thisTooltip.hide(ev);
						ev.preventDefault();
					}
				};
				targetDocument === null || targetDocument === void 0 || targetDocument.addEventListener("keydown", onDocumentKeyDown, { capture: true });
				return () => {
					if (context.visibleTooltip === thisTooltip) context.visibleTooltip = void 0;
					targetDocument === null || targetDocument === void 0 || targetDocument.removeEventListener("keydown", onDocumentKeyDown, { capture: true });
				};
			}
		}, [
			context,
			targetDocument,
			visible,
			setVisible
		]);
		const ignoreNextFocusEventRef = react.useRef(false);
		const onEnterTrigger = react.useCallback((ev) => {
			if (ev.type === "focus" && ignoreNextFocusEventRef.current) {
				ignoreNextFocusEventRef.current = false;
				return;
			}
			setDelayTimeout(() => {
				setVisible(ev, { visible: true });
			}, context.visibleTooltip ? 0 : state.showDelay);
			ev.persist();
		}, [
			setDelayTimeout,
			setVisible,
			state.showDelay,
			context
		]);
		const isNavigatingWithKeyboard = useIsNavigatingWithKeyboard();
		const [keyborgListenerCallbackRef] = react.useState(() => {
			const onKeyborgFocusIn = (ev) => {
				var _ev_detail;
				if (((_ev_detail = ev.detail) === null || _ev_detail === void 0 ? void 0 : _ev_detail.isFocusedProgrammatically) && !isNavigatingWithKeyboard()) ignoreNextFocusEventRef.current = true;
			};
			let current = null;
			return (element) => {
				current === null || current === void 0 || current.removeEventListener(KEYBORG_FOCUSIN, onKeyborgFocusIn);
				element === null || element === void 0 || element.addEventListener(KEYBORG_FOCUSIN, onKeyborgFocusIn);
				current = element;
			};
		});
		const onLeaveTrigger = react.useCallback((ev) => {
			let delay = state.hideDelay;
			if (ev.type === "blur") {
				delay = 0;
				ignoreNextFocusEventRef.current = (targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.activeElement) === ev.target;
			}
			setDelayTimeout(() => {
				setVisible(ev, { visible: false });
			}, delay);
			ev.persist();
		}, [
			setDelayTimeout,
			setVisible,
			state.hideDelay,
			targetDocument
		]);
		state.content.onPointerEnter = mergeCallbacks(state.content.onPointerEnter, clearDelayTimeout);
		state.content.onPointerLeave = mergeCallbacks(state.content.onPointerLeave, onLeaveTrigger);
		state.content.onFocus = mergeCallbacks(state.content.onFocus, clearDelayTimeout);
		state.content.onBlur = mergeCallbacks(state.content.onBlur, onLeaveTrigger);
		const child = getTriggerChild(children);
		const triggerAriaProps = {};
		const isPopupExpanded = (child === null || child === void 0 ? void 0 : (_child_props = child.props) === null || _child_props === void 0 ? void 0 : _child_props["aria-haspopup"]) && ((child === null || child === void 0 ? void 0 : (_child_props1 = child.props) === null || _child_props1 === void 0 ? void 0 : _child_props1["aria-expanded"]) === true || (child === null || child === void 0 ? void 0 : (_child_props2 = child.props) === null || _child_props2 === void 0 ? void 0 : _child_props2["aria-expanded"]) === "true");
		if (relationship === "label") if (typeof state.content.children === "string") triggerAriaProps["aria-label"] = state.content.children;
		else {
			triggerAriaProps["aria-labelledby"] = state.content.id;
			state.shouldRenderTooltip = true;
		}
		else if (relationship === "description") {
			triggerAriaProps["aria-describedby"] = state.content.id;
			state.shouldRenderTooltip = true;
		}
		if (isServerSideRender || isPopupExpanded) state.shouldRenderTooltip = false;
		state.children = applyTriggerPropsToChildren(children, {
			...triggerAriaProps,
			...child === null || child === void 0 ? void 0 : child.props,
			ref: useMergedRefs(getReactElementRef(child), keyborgListenerCallbackRef, positioningOptions.target === void 0 ? targetRef : void 0),
			onPointerEnter: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : (_child_props3 = child.props) === null || _child_props3 === void 0 ? void 0 : _child_props3.onPointerEnter, onEnterTrigger)),
			onPointerLeave: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : (_child_props4 = child.props) === null || _child_props4 === void 0 ? void 0 : _child_props4.onPointerLeave, onLeaveTrigger)),
			onFocus: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : (_child_props5 = child.props) === null || _child_props5 === void 0 ? void 0 : _child_props5.onFocus, onEnterTrigger)),
			onBlur: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : (_child_props6 = child.props) === null || _child_props6 === void 0 ? void 0 : _child_props6.onBlur, onLeaveTrigger))
		});
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-tooltip/lib/components/Tooltip/renderTooltip.js
/**
	* Render the final JSX of Tooltip
	*/ const renderTooltip_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(react.Fragment, { children: [state.children, state.shouldRenderTooltip && /* @__PURE__ */ jsx(Portal, {
			mountNode: state.mountNode,
			children: /* @__PURE__ */ jsxs(state.content, { children: [state.withArrow && /* @__PURE__ */ jsx("div", {
				ref: state.arrowRef,
				className: state.arrowClassName
			}), state.content.children] })
		})] });
	};

//#endregion
//#region node_modules/@fluentui/react-tooltip/lib/components/Tooltip/useTooltipStyles.styles.js
	const tooltipClassNames = { content: "fui-Tooltip__content" };
	/**
	* Styles for the tooltip
	*/
	const useStyles$97 = /* @__PURE__ */ __styles({
		root: {
			mc9l5x: "fjseox",
			B7ck84d: "f1ewtqcl",
			B2u0y6b: "f132xexn",
			Bceei9c: "f158kwzp",
			Bahqtrf: "fk6fouc",
			Be2twd7: "fy9rknc",
			Bg96gwp: "fwrc4pm",
			Btd35i7: "fokg9q4",
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "ft85np5",
			Bgfg5da: 0,
			B9xav0g: 0,
			oivjwe: 0,
			Bn0qgzm: 0,
			B4g9neb: 0,
			zhjwy3: 0,
			wvpqe5: 0,
			ibv6hh: 0,
			u1mtju: 0,
			h3c5rm: 0,
			vrafjx: 0,
			Bekrc4i: 0,
			i8vvqc: 0,
			g2u3we: 0,
			icvyot: 0,
			B4j52fo: 0,
			irswps: "f9ggezi",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f1bzqsji",
			De3pzq: "fxugw4r",
			sj55zd: "f19n0e5",
			Bhu2qc9: "fxeb0a7"
		},
		visible: { mc9l5x: "ftgm304" },
		inverted: {
			De3pzq: "fg3r6xk",
			sj55zd: "fonrgv7"
		},
		arrow: {
			B7ck84d: "f1ewtqcl",
			qhf8xq: "f1euv43f",
			Bj3rh1h: "f1bsuimh",
			rhnwrx: "f1s3jn22",
			Bdy53xb: "fv40uqz",
			De3pzq: "f1u2r49w",
			B2eet1l: "fqhgnl",
			Beyfa6y: "f17bz04i",
			Bz10aip: "f36o3x3",
			Bqenvij: "fzofk8q",
			a9b677: "f1wbx1ie",
			Ftih45: "f1wl9k8s",
			Br0sdwz: "f1aocrix",
			cmx5o7: "f1ljr5q2",
			susq4k: 0,
			Biibvgv: 0,
			Bicfajf: 0,
			qehafq: 0,
			Brs5u8j: "f155f1qt",
			Ccq8qp: "f9mhzq7",
			Baz25je: "fr6rhvx",
			Bcgcnre: 0,
			Bqjgrrk: 0,
			qa3bma: 0,
			y0oebl: 0,
			Biqmznv: 0,
			Bm6vgfq: 0,
			Bbv0w2i: 0,
			uvfttm: 0,
			eqrjj: 0,
			Bk5zm6e: 0,
			m598lv: 0,
			B4f6apu: 0,
			ydt019: 0,
			Bq4z7u6: 0,
			Bdkvgpv: 0,
			B0qfbqy: 0,
			kj8mxx: "f1kc0wz4",
			r59vdv: "fgq90dz",
			Bkw5xw4: "fq0y47f",
			hl6cv3: "f1pwrbz6",
			aea9ga: "f1hxxcvm",
			yayu3t: "fw8rgyo",
			Bhsv975: "f1wnzycx",
			rhl9o9: "f1730wal",
			B7gxrvb: "f1fy4ixr",
			B6q6orb: "fobkauc",
			B0lu1f8: "f16bqv1l"
		}
	}, { d: [
		".fjseox{display:none;}",
		".f1ewtqcl{box-sizing:border-box;}",
		".f132xexn{max-width:240px;}",
		".f158kwzp{cursor:default;}",
		".fk6fouc{font-family:var(--fontFamilyBase);}",
		".fy9rknc{font-size:var(--fontSizeBase200);}",
		".fwrc4pm{line-height:var(--lineHeightBase200);}",
		".fokg9q4{overflow-wrap:break-word;}",
		[".ft85np5{border-radius:var(--borderRadiusMedium);}", { p: -1 }],
		[".f9ggezi{border:1px solid var(--colorTransparentStroke);}", { p: -2 }],
		[".f1bzqsji{padding:4px 11px 6px 11px;}", { p: -1 }],
		".fxugw4r{background-color:var(--colorNeutralBackground1);}",
		".f19n0e5{color:var(--colorNeutralForeground1);}",
		".fxeb0a7{filter:drop-shadow(0 0 2px var(--colorNeutralShadowAmbient)) drop-shadow(0 4px 8px var(--colorNeutralShadowKey));}",
		".ftgm304{display:block;}",
		".fg3r6xk{background-color:var(--colorNeutralBackgroundStatic);}",
		".fonrgv7{color:var(--colorNeutralForegroundStaticInverted);}",
		".f1euv43f{position:absolute;}",
		".f1bsuimh{z-index:-1;}",
		".f1s3jn22{--fui-positioning-arrow-height:8.484px;}",
		".fv40uqz{--fui-positioning-arrow-offset:-4.242px;}",
		".f1u2r49w{background-color:inherit;}",
		".fqhgnl{background-clip:content-box;}",
		".f17bz04i{border-bottom-left-radius:var(--borderRadiusSmall);}",
		".f36o3x3{transform:rotate(var(--fui-positioning-arrow-angle));}",
		".fzofk8q{height:var(--fui-positioning-arrow-height);}",
		".f1wbx1ie{width:var(--fui-positioning-arrow-height);}",
		".f1wl9k8s::before{content:\"\";}",
		".f1aocrix::before{display:block;}",
		".f1ljr5q2::before{background-color:inherit;}",
		[".f155f1qt::before{margin:-1px;}", { p: -1 }],
		".f9mhzq7::before{width:100%;}",
		".fr6rhvx::before{height:100%;}",
		[".f1kc0wz4::before{border:1px solid var(--colorTransparentStroke);}", { p: -2 }],
		".fgq90dz::before{border-bottom-left-radius:var(--borderRadiusSmall);}",
		".fq0y47f::before{clip-path:polygon(0% 0%, 100% 100%, 0% 100%);}",
		"[data-popper-placement^=\"top\"] .f1pwrbz6{bottom:var(--fui-positioning-arrow-offset);}",
		"[data-popper-placement^=\"top\"] .f1hxxcvm{--fui-positioning-arrow-angle:-45deg;}",
		"[data-popper-placement^=\"right\"] .fw8rgyo{left:var(--fui-positioning-arrow-offset);}",
		"[data-popper-placement^=\"right\"] .f1wnzycx{--fui-positioning-arrow-angle:45deg;}",
		"[data-popper-placement^=\"bottom\"] .f1730wal{top:var(--fui-positioning-arrow-offset);}",
		"[data-popper-placement^=\"bottom\"] .f1fy4ixr{--fui-positioning-arrow-angle:135deg;}",
		"[data-popper-placement^=\"left\"] .fobkauc{right:var(--fui-positioning-arrow-offset);}",
		"[data-popper-placement^=\"left\"] .f16bqv1l{--fui-positioning-arrow-angle:225deg;}"
	] });
	/**
	* Apply styling to the Tooltip slots based on the state
	*/
	const useTooltipStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$97();
		state.content.className = mergeClasses(tooltipClassNames.content, styles.root, state.appearance === "inverted" && styles.inverted, state.visible && styles.visible, state.content.className);
		state.arrowClassName = styles.arrow;
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-tooltip/lib/components/Tooltip/Tooltip.js
/**
	* A tooltip provides light weight contextual information on top of its target element.
	*/ const Tooltip = (props) => {
		const state = useTooltip_unstable(props);
		useTooltipStyles_unstable(state);
		useCustomStyleHook("useTooltipStyles_unstable")(state);
		return renderTooltip_unstable(state);
	};
	Tooltip.displayName = "Tooltip";
	Tooltip.isFluentTriggerComponent = true;

//#endregion
//#region node_modules/@fluentui/react-avatar/lib/components/AvatarGroupPopover/useAvatarGroupPopover.js
/**
	* Create the state required to render AvatarGroupPopover.
	*
	* The returned state can be modified with hooks such as useAvatarGroupPopoverStyles_unstable,
	* before being passed to renderAvatarGroupPopover_unstable.
	*
	* @param props - props from this instance of AvatarGroupPopover
	*/ const useAvatarGroupPopover_unstable = (props) => {
		var _useAvatarGroupContext_unstable;
		const size$2 = (_useAvatarGroupContext_unstable = useAvatarGroupContext_unstable((ctx) => ctx.size)) !== null && _useAvatarGroupContext_unstable !== void 0 ? _useAvatarGroupContext_unstable : defaultAvatarGroupSize;
		const layout = useAvatarGroupContext_unstable((ctx) => ctx.layout);
		const { indicator = size$2 < 24 ? "icon" : "count", count = react.Children.count(props.children), children, ...restOfProps } = props;
		const [popoverOpen, setPopoverOpen] = useControllableState({
			state: props.open,
			defaultState: props.defaultOpen,
			initialState: false
		});
		const handleOnPopoverChange = (e, data) => {
			var _restOfProps_onOpenChange;
			(_restOfProps_onOpenChange = restOfProps.onOpenChange) === null || _restOfProps_onOpenChange === void 0 || _restOfProps_onOpenChange.call(restOfProps, e, data);
			setPopoverOpen(data.open);
		};
		let triggerButtonChildren;
		if (layout === "pie") triggerButtonChildren = null;
		else if (indicator === "icon") triggerButtonChildren = /* @__PURE__ */ react.createElement(MoreHorizontalRegular, null);
		else triggerButtonChildren = count > 99 ? "99+" : `+${count}`;
		return {
			count,
			indicator,
			layout,
			popoverOpen,
			size: size$2,
			components: {
				root: Popover,
				triggerButton: "button",
				content: "ul",
				popoverSurface: PopoverSurface,
				tooltip: Tooltip
			},
			root: always({
				children: /* @__PURE__ */ react.createElement(react.Fragment, null),
				size: "small",
				trapFocus: true,
				...restOfProps,
				open: popoverOpen,
				onOpenChange: handleOnPopoverChange
			}, { elementType: Popover }),
			triggerButton: always(props.triggerButton, {
				defaultProps: {
					children: triggerButtonChildren,
					type: "button"
				},
				elementType: "button"
			}),
			content: always(props.content, {
				defaultProps: {
					children,
					role: "list"
				},
				elementType: "ul"
			}),
			popoverSurface: always(props.popoverSurface, {
				defaultProps: {
					"aria-label": "Overflow",
					tabIndex: 0
				},
				elementType: PopoverSurface
			}),
			tooltip: always(props.tooltip, {
				defaultProps: {
					content: "View more people.",
					relationship: "label"
				},
				elementType: Tooltip
			})
		};
	};

//#endregion
//#region node_modules/@fluentui/react-avatar/lib/components/AvatarGroupPopover/useAvatarGroupPopoverStyles.styles.js
	const avatarGroupPopoverClassNames = {
		root: "fui-AvatarGroupPopover",
		content: "fui-AvatarGroupPopover__content",
		popoverSurface: "fui-AvatarGroupPopover__popoverSurface",
		tooltip: "fui-AvatarGroupPopover__tooltip",
		triggerButton: "fui-AvatarGroupPopover__triggerButton"
	};
	/**
	* Styles for the content slot.
	*/
	const useContentStyles$3 = /* @__PURE__ */ __styles({ base: {
		dclx09: "ftrb29c",
		jrapky: 0,
		Frg6f3: 0,
		t21cq0: 0,
		B6of3ja: 0,
		B74szlk: "f1s184ao",
		Byoj8tv: 0,
		uwmqm3: 0,
		z189sj: 0,
		z8tnut: 0,
		B0ocmuz: "f1mk8lai",
		mc9l5x: "f22iagw",
		Beiy3e4: "f1vx9l62"
	} }, { d: [
		".ftrb29c{list-style-type:none;}",
		[".f1s184ao{margin:0;}", { p: -1 }],
		[".f1mk8lai{padding:0;}", { p: -1 }],
		".f22iagw{display:flex;}",
		".f1vx9l62{flex-direction:column;}"
	] });
	/**
	* Styles for the popoverSurface slot.
	*/
	const usePopoverSurfaceStyles$1 = /* @__PURE__ */ __styles({ base: {
		Bxyxcbc: "fopcw2o",
		sshi5w: "f1n5o1gx",
		B68tc82: 0,
		Bmxbyg5: 0,
		Bpg54ce: "f19r5mr9",
		Byoj8tv: 0,
		uwmqm3: 0,
		z189sj: 0,
		z8tnut: 0,
		B0ocmuz: "f1f5q0n8",
		a9b677: "f13dwy2t"
	} }, { d: [
		".fopcw2o{max-height:220px;}",
		".f1n5o1gx{min-height:80px;}",
		[".f19r5mr9{overflow:hidden scroll;}", { p: -1 }],
		[".f1f5q0n8{padding:var(--spacingVerticalS) var(--spacingHorizontalS);}", { p: -1 }],
		".f13dwy2t{width:220px;}"
	] });
	/**
	* Styles for the triggerButton slot.
	*/
	const useTriggerButtonStyles = /* @__PURE__ */ __styles({
		base: {
			mc9l5x: "ftuwxu6",
			qhf8xq: "f10pi13n",
			Bnnss6s: "fi64zpg",
			Brf1p80: "f4d9j23",
			Bt984gj: "f122n59",
			sj55zd: "f19n0e5",
			De3pzq: "fxugw4r",
			g2u3we: "fj3muxo",
			h3c5rm: ["f1akhkt", "f1lxtadh"],
			B9xav0g: "f1aperda",
			zhjwy3: ["f1lxtadh", "f1akhkt"],
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "f44lkw9",
			icvyot: "fzkkow9",
			vrafjx: ["fcdblym", "fjik90z"],
			oivjwe: "fg706s2",
			wvpqe5: ["fjik90z", "fcdblym"],
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f1mk8lai",
			Bcq6wej: "fx5js7k",
			Jcjdmf: ["f17aelzi", "f2tn0l4"],
			sc4o1m: "f14ood81",
			Bosien3: ["f2tn0l4", "f17aelzi"]
		},
		pie: {
			De3pzq: "f1c21dwh",
			g2u3we: "fghlq4f",
			h3c5rm: ["f1gn591s", "fjscplz"],
			B9xav0g: "fb073pr",
			zhjwy3: ["fjscplz", "f1gn591s"],
			sj55zd: "f44pa96"
		},
		focusIndicator: {
			Byu6kyc: 0,
			n8qw10: 0,
			Bbjhlyh: 0,
			i2cumq: 0,
			Bunx835: 0,
			Bdrgwmp: 0,
			mqozju: 0,
			lbo84a: 0,
			Bksnhdo: 0,
			Bci5o5g: 0,
			u5e7qz: 0,
			Bn40d3w: 0,
			B7b6zxw: 0,
			B8q5s1w: 0,
			B5gfjzb: 0,
			Bbcte9g: 0,
			Bqz3imu: "f1j9b7x8",
			g9k6zt: "f1nev41a"
		},
		states: {
			Bi91k9c: "feu1g3u",
			Jwef8y: "f1knas48",
			Bgoe8wy: "fvcxoqz",
			Bwzppfd: ["f1ub3y4t", "f1m52nbi"],
			oetu4i: "f1xlaoq0",
			gg5e9n: ["f1m52nbi", "f1ub3y4t"],
			lj723h: "f1g4hkjv",
			ecr2s2: "fb40n2d",
			B6oc9vd: "fvs00aa",
			ak43y8: ["f1assf6x", "f4ruux4"],
			wmxk5l: "fumykes",
			B50zh58: ["f4ruux4", "f1assf6x"]
		},
		selected: {
			sj55zd: "f14nttnl",
			De3pzq: "f1nfm20t",
			g2u3we: "f1ly1fcm",
			h3c5rm: ["fi8bssc", "fj6btzu"],
			B9xav0g: "f1s9tnsa",
			zhjwy3: ["fj6btzu", "fi8bssc"]
		},
		icon12: { Be2twd7: "f1ugzwwg" },
		icon16: { Be2twd7: "f4ybsrx" },
		icon20: { Be2twd7: "fe5j1ua" },
		icon24: { Be2twd7: "f1rt2boy" },
		icon28: { Be2twd7: "f24l1pt" },
		icon32: { Be2twd7: "ffl51b" },
		icon48: { Be2twd7: "f18m8u13" },
		caption2Strong: {
			Bahqtrf: "fk6fouc",
			Be2twd7: "f13mqy1h",
			Bhrd7zp: "fl43uef",
			Bg96gwp: "fcpl73t"
		},
		caption1Strong: {
			Bahqtrf: "fk6fouc",
			Be2twd7: "fy9rknc",
			Bhrd7zp: "fl43uef",
			Bg96gwp: "fwrc4pm"
		},
		body1Strong: {
			Bahqtrf: "fk6fouc",
			Be2twd7: "fkhj508",
			Bhrd7zp: "fl43uef",
			Bg96gwp: "f1i3iumi"
		},
		subtitle2: {
			Bahqtrf: "fk6fouc",
			Be2twd7: "fod5ikn",
			Bhrd7zp: "fl43uef",
			Bg96gwp: "faaz57k"
		},
		subtitle1: {
			Bahqtrf: "fk6fouc",
			Be2twd7: "f1pp30po",
			Bhrd7zp: "fl43uef",
			Bg96gwp: "f106mvju"
		},
		title3: {
			Bahqtrf: "fk6fouc",
			Be2twd7: "f1x0m3f5",
			Bhrd7zp: "fl43uef",
			Bg96gwp: "fb86gi6"
		},
		borderThin: {
			B4j52fo: "f192inf7",
			Bekrc4i: ["f5tn483", "f1ojsxk5"],
			Bn0qgzm: "f1vxd6vx",
			ibv6hh: ["f1ojsxk5", "f5tn483"]
		},
		borderThick: {
			B4j52fo: "f18zi460",
			Bekrc4i: ["f1wpluaz", "fsfsuhs"],
			Bn0qgzm: "fmklw6v",
			ibv6hh: ["fsfsuhs", "f1wpluaz"]
		},
		borderThicker: {
			B4j52fo: "fgx37oo",
			Bekrc4i: ["f130t4y6", "f1efpmoh"],
			Bn0qgzm: "fv51ejd",
			ibv6hh: ["f1efpmoh", "f130t4y6"]
		},
		borderThickest: {
			B4j52fo: "fwn6jck",
			Bekrc4i: ["figl7jc", "f1g0iy8l"],
			Bn0qgzm: "f1b8shu7",
			ibv6hh: ["f1g0iy8l", "figl7jc"]
		}
	}, {
		d: [
			".ftuwxu6{display:inline-flex;}",
			".f10pi13n{position:relative;}",
			".fi64zpg{flex-shrink:0;}",
			".f4d9j23{justify-content:center;}",
			".f122n59{align-items:center;}",
			".f19n0e5{color:var(--colorNeutralForeground1);}",
			".fxugw4r{background-color:var(--colorNeutralBackground1);}",
			".fj3muxo{border-top-color:var(--colorNeutralStroke1);}",
			".f1akhkt{border-right-color:var(--colorNeutralStroke1);}",
			".f1lxtadh{border-left-color:var(--colorNeutralStroke1);}",
			".f1aperda{border-bottom-color:var(--colorNeutralStroke1);}",
			[".f44lkw9{border-radius:var(--borderRadiusCircular);}", { p: -1 }],
			".fzkkow9{border-top-style:solid;}",
			".fcdblym{border-right-style:solid;}",
			".fjik90z{border-left-style:solid;}",
			".fg706s2{border-bottom-style:solid;}",
			[".f1mk8lai{padding:0;}", { p: -1 }],
			".f1c21dwh{background-color:var(--colorTransparentBackground);}",
			".fghlq4f{border-top-color:var(--colorTransparentStroke);}",
			".f1gn591s{border-right-color:var(--colorTransparentStroke);}",
			".fjscplz{border-left-color:var(--colorTransparentStroke);}",
			".fb073pr{border-bottom-color:var(--colorTransparentStroke);}",
			".f44pa96{color:transparent;}",
			[".f1j9b7x8[data-fui-focus-visible]{border:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}", { p: -2 }],
			".f1nev41a[data-fui-focus-visible]{outline-style:none;}",
			".f14nttnl{color:var(--colorNeutralForeground1Selected);}",
			".f1nfm20t{background-color:var(--colorNeutralBackground1Selected);}",
			".f1ly1fcm{border-top-color:var(--colorNeutralStroke1Selected);}",
			".fi8bssc{border-right-color:var(--colorNeutralStroke1Selected);}",
			".fj6btzu{border-left-color:var(--colorNeutralStroke1Selected);}",
			".f1s9tnsa{border-bottom-color:var(--colorNeutralStroke1Selected);}",
			".f1ugzwwg{font-size:12px;}",
			".f4ybsrx{font-size:16px;}",
			".fe5j1ua{font-size:20px;}",
			".f1rt2boy{font-size:24px;}",
			".f24l1pt{font-size:28px;}",
			".ffl51b{font-size:32px;}",
			".f18m8u13{font-size:48px;}",
			".fk6fouc{font-family:var(--fontFamilyBase);}",
			".f13mqy1h{font-size:var(--fontSizeBase100);}",
			".fl43uef{font-weight:var(--fontWeightSemibold);}",
			".fcpl73t{line-height:var(--lineHeightBase100);}",
			".fy9rknc{font-size:var(--fontSizeBase200);}",
			".fwrc4pm{line-height:var(--lineHeightBase200);}",
			".fkhj508{font-size:var(--fontSizeBase300);}",
			".f1i3iumi{line-height:var(--lineHeightBase300);}",
			".fod5ikn{font-size:var(--fontSizeBase400);}",
			".faaz57k{line-height:var(--lineHeightBase400);}",
			".f1pp30po{font-size:var(--fontSizeBase500);}",
			".f106mvju{line-height:var(--lineHeightBase500);}",
			".f1x0m3f5{font-size:var(--fontSizeBase600);}",
			".fb86gi6{line-height:var(--lineHeightBase600);}",
			".f192inf7{border-top-width:var(--strokeWidthThin);}",
			".f5tn483{border-right-width:var(--strokeWidthThin);}",
			".f1ojsxk5{border-left-width:var(--strokeWidthThin);}",
			".f1vxd6vx{border-bottom-width:var(--strokeWidthThin);}",
			".f18zi460{border-top-width:var(--strokeWidthThick);}",
			".f1wpluaz{border-right-width:var(--strokeWidthThick);}",
			".fsfsuhs{border-left-width:var(--strokeWidthThick);}",
			".fmklw6v{border-bottom-width:var(--strokeWidthThick);}",
			".fgx37oo{border-top-width:var(--strokeWidthThicker);}",
			".f130t4y6{border-right-width:var(--strokeWidthThicker);}",
			".f1efpmoh{border-left-width:var(--strokeWidthThicker);}",
			".fv51ejd{border-bottom-width:var(--strokeWidthThicker);}",
			".fwn6jck{border-top-width:var(--strokeWidthThickest);}",
			".figl7jc{border-right-width:var(--strokeWidthThickest);}",
			".f1g0iy8l{border-left-width:var(--strokeWidthThickest);}",
			".f1b8shu7{border-bottom-width:var(--strokeWidthThickest);}"
		],
		m: [
			["@media (forced-colors: active){.fx5js7k{border-top-color:CanvasText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f17aelzi{border-right-color:CanvasText;}.f2tn0l4{border-left-color:CanvasText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f14ood81{border-bottom-color:CanvasText;}}", { m: "(forced-colors: active)" }]
		],
		h: [
			".feu1g3u:hover{color:var(--colorNeutralForeground1Hover);}",
			".f1knas48:hover{background-color:var(--colorNeutralBackground1Hover);}",
			".fvcxoqz:hover{border-top-color:var(--colorNeutralStroke1Hover);}",
			".f1ub3y4t:hover{border-right-color:var(--colorNeutralStroke1Hover);}",
			".f1m52nbi:hover{border-left-color:var(--colorNeutralStroke1Hover);}",
			".f1xlaoq0:hover{border-bottom-color:var(--colorNeutralStroke1Hover);}"
		],
		a: [
			".f1g4hkjv:active{color:var(--colorNeutralForeground1Pressed);}",
			".fb40n2d:active{background-color:var(--colorNeutralBackground1Pressed);}",
			".fvs00aa:active{border-top-color:var(--colorNeutralStroke1Pressed);}",
			".f1assf6x:active{border-right-color:var(--colorNeutralStroke1Pressed);}",
			".f4ruux4:active{border-left-color:var(--colorNeutralStroke1Pressed);}",
			".fumykes:active{border-bottom-color:var(--colorNeutralStroke1Pressed);}"
		]
	});
	/**
	* Apply styling to the AvatarGroupPopover slots based on the state
	*/
	const useAvatarGroupPopoverStyles_unstable = (state) => {
		"use no memo";
		const { indicator, size: size$2, layout, popoverOpen } = state;
		const sizeStyles = useSizeStyles$4();
		const triggerButtonStyles = useTriggerButtonStyles();
		const contentStyles = useContentStyles$3();
		const popoverSurfaceStyles = usePopoverSurfaceStyles$1();
		const groupChildClassName = useGroupChildClassName(layout, size$2);
		const triggerButtonClasses = [];
		if (size$2 < 36) triggerButtonClasses.push(triggerButtonStyles.borderThin);
		else if (size$2 < 56) triggerButtonClasses.push(triggerButtonStyles.borderThick);
		else if (size$2 < 72) triggerButtonClasses.push(triggerButtonStyles.borderThicker);
		else triggerButtonClasses.push(triggerButtonStyles.borderThickest);
		if (indicator === "count") if (size$2 <= 24) triggerButtonClasses.push(triggerButtonStyles.caption2Strong);
		else if (size$2 <= 28) triggerButtonClasses.push(triggerButtonStyles.caption1Strong);
		else if (size$2 <= 40) triggerButtonClasses.push(triggerButtonStyles.body1Strong);
		else if (size$2 <= 56) triggerButtonClasses.push(triggerButtonStyles.subtitle2);
		else if (size$2 <= 96) triggerButtonClasses.push(triggerButtonStyles.subtitle1);
		else triggerButtonClasses.push(triggerButtonStyles.title3);
		else if (size$2 <= 16) triggerButtonClasses.push(triggerButtonStyles.icon12);
		else if (size$2 <= 24) triggerButtonClasses.push(triggerButtonStyles.icon16);
		else if (size$2 <= 40) triggerButtonClasses.push(triggerButtonStyles.icon20);
		else if (size$2 <= 48) triggerButtonClasses.push(triggerButtonStyles.icon24);
		else if (size$2 <= 56) triggerButtonClasses.push(triggerButtonStyles.icon28);
		else if (size$2 <= 72) triggerButtonClasses.push(triggerButtonStyles.icon32);
		else triggerButtonClasses.push(triggerButtonStyles.icon48);
		state.triggerButton.className = mergeClasses(avatarGroupPopoverClassNames.triggerButton, groupChildClassName, sizeStyles[size$2], triggerButtonStyles.base, layout === "pie" && triggerButtonStyles.pie, triggerButtonStyles.focusIndicator, layout !== "pie" && triggerButtonStyles.states, layout !== "pie" && popoverOpen && triggerButtonStyles.selected, ...triggerButtonClasses, state.triggerButton.className);
		state.content.className = mergeClasses(avatarGroupPopoverClassNames.content, contentStyles.base, state.content.className);
		state.popoverSurface.className = mergeClasses(avatarGroupPopoverClassNames.popoverSurface, popoverSurfaceStyles.base, state.popoverSurface.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-avatar/lib/components/AvatarGroupPopover/AvatarGroupPopover.js
/**
	* The AvatarGroupPopover component provides a button with a Popover containing the children provided.
	*/ const AvatarGroupPopover = (props) => {
		const state = useAvatarGroupPopover_unstable(props);
		const contextValues = useAvatarGroupPopoverContextValues_unstable(state);
		useAvatarGroupPopoverStyles_unstable(state);
		useCustomStyleHook("useAvatarGroupPopoverStyles_unstable")(state);
		return renderAvatarGroupPopover_unstable(state, contextValues);
	};
	AvatarGroupPopover.displayName = "AvatarGroupPopover";

//#endregion
//#region node_modules/@fluentui/react-button/lib/components/Button/renderButton.js
/**
	* Renders a Button component by passing the state defined props to the appropriate slots.
	*/ const renderButton_unstable = (state) => {
		assertSlots(state);
		const { iconOnly, iconPosition } = state;
		return /* @__PURE__ */ jsxs(state.root, { children: [
			iconPosition !== "after" && state.icon && /* @__PURE__ */ jsx(state.icon, {}),
			!iconOnly && state.root.children,
			iconPosition === "after" && state.icon && /* @__PURE__ */ jsx(state.icon, {})
		] });
	};

//#endregion
//#region node_modules/@fluentui/react-button/lib/contexts/ButtonContext.js
	const buttonContext = react.createContext(void 0);
	const buttonContextDefaultValue = {};
	/**
	* @internal
	* Internal context provider used to update default values between internal components
	*/ const ButtonContextProvider = buttonContext.Provider;
	/**
	* @internal
	* Internal context hook used to update default values between internal components
	*/ const useButtonContext = () => {
		var _React_useContext;
		return (_React_useContext = react.useContext(buttonContext)) !== null && _React_useContext !== void 0 ? _React_useContext : buttonContextDefaultValue;
	};

//#endregion
//#region node_modules/@fluentui/react-button/lib/components/Button/useButton.js
/**
	* Given user props, defines default props for the Button, calls useButtonState, and returns processed state.
	* @param props - User provided props to the Button component.
	* @param ref - User provided ref to be passed to the Button component.
	*/ const useButton_unstable = (props, ref) => {
		const { size: contextSize } = useButtonContext();
		const { appearance = "secondary", as = "button", disabled = false, disabledFocusable = false, icon, iconPosition = "before", shape = "rounded", size: size$2 = contextSize !== null && contextSize !== void 0 ? contextSize : "medium" } = props;
		const iconShorthand = optional(icon, { elementType: "span" });
		return {
			appearance,
			disabled,
			disabledFocusable,
			iconPosition,
			shape,
			size: size$2,
			iconOnly: Boolean((iconShorthand === null || iconShorthand === void 0 ? void 0 : iconShorthand.children) && !props.children),
			components: {
				root: "button",
				icon: "span"
			},
			root: always(getIntrinsicElementProps(as, useARIAButtonProps(props.as, props)), {
				elementType: "button",
				defaultProps: {
					ref,
					type: as === "button" ? "button" : void 0
				}
			}),
			icon: iconShorthand
		};
	};

//#endregion
//#region node_modules/@fluentui/react-button/lib/components/Button/useButtonStyles.styles.js
	const buttonClassNames = {
		root: "fui-Button",
		icon: "fui-Button__icon"
	};
	`${tokens.strokeWidthThin}`;
	const useRootBaseClassName$12 = /* @__PURE__ */ __resetStyles("r1f29ykk", null, {
		r: [
			".r1f29ykk{align-items:center;box-sizing:border-box;display:inline-flex;justify-content:center;text-decoration-line:none;vertical-align:middle;margin:0;overflow:hidden;background-color:var(--colorNeutralBackground1);color:var(--colorNeutralForeground1);border:var(--strokeWidthThin) solid var(--colorNeutralStroke1);font-family:var(--fontFamilyBase);outline-style:none;padding:5px var(--spacingHorizontalM);min-width:96px;border-radius:var(--borderRadiusMedium);font-size:var(--fontSizeBase300);font-weight:var(--fontWeightSemibold);line-height:var(--lineHeightBase300);transition-duration:var(--durationFaster);transition-property:background,border,color;transition-timing-function:var(--curveEasyEase);}",
			".r1f29ykk:hover{background-color:var(--colorNeutralBackground1Hover);border-color:var(--colorNeutralStroke1Hover);color:var(--colorNeutralForeground1Hover);cursor:pointer;}",
			".r1f29ykk:hover:active,.r1f29ykk:active:focus-visible{background-color:var(--colorNeutralBackground1Pressed);border-color:var(--colorNeutralStroke1Pressed);color:var(--colorNeutralForeground1Pressed);outline-style:none;}",
			".r1f29ykk[data-fui-focus-visible]{border-color:var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);border-width:1px;outline:var(--strokeWidthThick) solid var(--colorTransparentStroke);box-shadow:0 0 0 var(--strokeWidthThin) var(--colorStrokeFocus2) inset;z-index:1;}"
		],
		s: [
			"@media screen and (prefers-reduced-motion: reduce){.r1f29ykk{transition-duration:0.01ms;}}",
			"@media (forced-colors: active){.r1f29ykk:focus{border-color:ButtonText;}.r1f29ykk:hover{background-color:HighlightText;border-color:Highlight;color:Highlight;forced-color-adjust:none;}.r1f29ykk:hover:active,.r1f29ykk:active:focus-visible{background-color:HighlightText;border-color:Highlight;color:Highlight;forced-color-adjust:none;}}",
			"@supports (-moz-appearance:button){.r1f29ykk[data-fui-focus-visible]{box-shadow:0 0 0 calc(var(--strokeWidthThin) + 0.25px) var(--colorStrokeFocus2) inset;}}"
		]
	});
	const useIconBaseClassName = /* @__PURE__ */ __resetStyles("rywnvv2", null, [".rywnvv2{align-items:center;display:inline-flex;justify-content:center;font-size:20px;height:20px;width:20px;--fui-Button__icon--spacing:var(--spacingHorizontalSNudge);}"]);
	const useRootStyles$26 = /* @__PURE__ */ __styles({
		outline: {
			De3pzq: "f1c21dwh",
			Jwef8y: "fjxutwb",
			Bpjbzib: "fkoldzo"
		},
		primary: {
			De3pzq: "ffp7eso",
			g2u3we: "f1p3nwhy",
			h3c5rm: ["f11589ue", "f1pdflbu"],
			B9xav0g: "f1q5o8ev",
			zhjwy3: ["f1pdflbu", "f11589ue"],
			sj55zd: "f1phragk",
			Jwef8y: "f15wkkf3",
			Bgoe8wy: "f1s2uweq",
			Bwzppfd: ["fr80ssc", "fecsdlb"],
			oetu4i: "f1ukrpxl",
			gg5e9n: ["fecsdlb", "fr80ssc"],
			Bi91k9c: "f1rq72xc",
			Bpjbzib: "f1ksv2xa",
			im15vp: "fhvnf4x",
			Hjvxdg: ["fb6swo4", "f232fm2"],
			Gpfmf1: "f1klyf7k",
			ustxxc: ["f232fm2", "fb6swo4"],
			Brsut9c: "f1d6mv4x",
			By8wz76: "f1nz3ub2",
			Bcq6wej: "fag2qd2",
			Jcjdmf: ["fmvhcg7", "f14bpyus"],
			sc4o1m: "f1o3dhpw",
			Bosien3: ["f14bpyus", "fmvhcg7"],
			B7iucu3: "fqc85l4",
			B8gzw0y: "f1h3a8gf",
			Bbkh6qg: "fkiggi6",
			F230oe: "f8gmj8i",
			Bdw8ktp: ["f1ap8nzx", "fjag8bx"],
			Bj1xduy: "f1igan7k",
			Bhh2cfd: ["fjag8bx", "f1ap8nzx"],
			Bahaeuw: "f1v3eptx",
			Bv2bamp: "f1ysmecq",
			vxuvv6: "faulsx",
			Bli9q98: ["f79t15f", "f8qmx7k"],
			Bx2tt8t: "fbtzoaq",
			yad0b3: ["f8qmx7k", "f79t15f"],
			j2fop7: "fd4bjan"
		},
		secondary: {},
		subtle: {
			De3pzq: "fhovq9v",
			g2u3we: "f1p3nwhy",
			h3c5rm: ["f11589ue", "f1pdflbu"],
			B9xav0g: "f1q5o8ev",
			zhjwy3: ["f1pdflbu", "f11589ue"],
			sj55zd: "fkfq4zb",
			Jwef8y: "f1t94bn6",
			Bgoe8wy: "f1s2uweq",
			Bwzppfd: ["fr80ssc", "fecsdlb"],
			oetu4i: "f1ukrpxl",
			gg5e9n: ["fecsdlb", "fr80ssc"],
			Bi91k9c: "fnwyq0v",
			Bk3fhr4: "ft1hn21",
			Bmfj8id: "fuxngvv",
			Bbdnnc7: "fy5bs14",
			Bpjbzib: "f1q1yqic",
			im15vp: "fhvnf4x",
			Hjvxdg: ["fb6swo4", "f232fm2"],
			Gpfmf1: "f1klyf7k",
			ustxxc: ["f232fm2", "fb6swo4"],
			Brsut9c: "fwga7ee",
			Bqou3pl: "f1nhwcv0",
			Bsnehw8: "f1gm6xmp",
			wsxvnf: "f1xxsver",
			Bahaeuw: "f1v3eptx",
			Buhizc3: "fivsta0",
			j2fop7: "fd4bjan",
			Bqabnb4: "f3m6zum"
		},
		transparent: {
			De3pzq: "f1c21dwh",
			g2u3we: "f1p3nwhy",
			h3c5rm: ["f11589ue", "f1pdflbu"],
			B9xav0g: "f1q5o8ev",
			zhjwy3: ["f1pdflbu", "f11589ue"],
			sj55zd: "fkfq4zb",
			Jwef8y: "fjxutwb",
			Bgoe8wy: "f1s2uweq",
			Bwzppfd: ["fr80ssc", "fecsdlb"],
			oetu4i: "f1ukrpxl",
			gg5e9n: ["fecsdlb", "fr80ssc"],
			Bi91k9c: "f139oj5f",
			Bk3fhr4: "ft1hn21",
			Bmfj8id: "fuxngvv",
			Bpjbzib: "fkoldzo",
			im15vp: "fhvnf4x",
			Hjvxdg: ["fb6swo4", "f232fm2"],
			Gpfmf1: "f1klyf7k",
			ustxxc: ["f232fm2", "fb6swo4"],
			Brsut9c: "f1l983o9",
			Bqou3pl: "f1nhwcv0",
			Bsnehw8: "f1gm6xmp",
			Bbkh6qg: "fxoo9op",
			Bahaeuw: "f1v3eptx",
			Bv2bamp: "f1i0gk12",
			j2fop7: "fd4bjan"
		},
		circular: {
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "f44lkw9"
		},
		rounded: {},
		square: {
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "f1fabniw"
		},
		small: {
			Bf4jedk: "fh7ncta",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "fneth5b",
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "ft85np5",
			Be2twd7: "fy9rknc",
			Bhrd7zp: "figsok6",
			Bg96gwp: "fwrc4pm"
		},
		smallWithIcon: {
			Byoj8tv: "f1brlhvm",
			z8tnut: "f1sl3k7w"
		},
		medium: {},
		large: {
			Bf4jedk: "f14es27b",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f4db1ww",
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "ft85np5",
			Be2twd7: "fod5ikn",
			Bhrd7zp: "fl43uef",
			Bg96gwp: "faaz57k"
		},
		largeWithIcon: {
			Byoj8tv: "fy7v416",
			z8tnut: "f1a1bwwz"
		}
	}, {
		d: [
			".f1c21dwh{background-color:var(--colorTransparentBackground);}",
			".ffp7eso{background-color:var(--colorBrandBackground);}",
			".f1p3nwhy{border-top-color:transparent;}",
			".f11589ue{border-right-color:transparent;}",
			".f1pdflbu{border-left-color:transparent;}",
			".f1q5o8ev{border-bottom-color:transparent;}",
			".f1phragk{color:var(--colorNeutralForegroundOnBrand);}",
			".fhovq9v{background-color:var(--colorSubtleBackground);}",
			".fkfq4zb{color:var(--colorNeutralForeground2);}",
			[".f44lkw9{border-radius:var(--borderRadiusCircular);}", { p: -1 }],
			[".f1fabniw{border-radius:var(--borderRadiusNone);}", { p: -1 }],
			".fh7ncta{min-width:64px;}",
			[".fneth5b{padding:3px var(--spacingHorizontalS);}", { p: -1 }],
			[".ft85np5{border-radius:var(--borderRadiusMedium);}", { p: -1 }],
			".fy9rknc{font-size:var(--fontSizeBase200);}",
			".figsok6{font-weight:var(--fontWeightRegular);}",
			".fwrc4pm{line-height:var(--lineHeightBase200);}",
			".f1brlhvm{padding-bottom:1px;}",
			".f1sl3k7w{padding-top:1px;}",
			".f14es27b{min-width:96px;}",
			[".f4db1ww{padding:8px var(--spacingHorizontalL);}", { p: -1 }],
			[".ft85np5{border-radius:var(--borderRadiusMedium);}", { p: -1 }],
			".fod5ikn{font-size:var(--fontSizeBase400);}",
			".fl43uef{font-weight:var(--fontWeightSemibold);}",
			".faaz57k{line-height:var(--lineHeightBase400);}",
			".fy7v416{padding-bottom:7px;}",
			".f1a1bwwz{padding-top:7px;}"
		],
		h: [
			".fjxutwb:hover{background-color:var(--colorTransparentBackgroundHover);}",
			".fkoldzo:hover:active,.fkoldzo:active:focus-visible{background-color:var(--colorTransparentBackgroundPressed);}",
			".f15wkkf3:hover{background-color:var(--colorBrandBackgroundHover);}",
			".f1s2uweq:hover{border-top-color:transparent;}",
			".fr80ssc:hover{border-right-color:transparent;}",
			".fecsdlb:hover{border-left-color:transparent;}",
			".f1ukrpxl:hover{border-bottom-color:transparent;}",
			".f1rq72xc:hover{color:var(--colorNeutralForegroundOnBrand);}",
			".f1ksv2xa:hover:active,.f1ksv2xa:active:focus-visible{background-color:var(--colorBrandBackgroundPressed);}",
			".fhvnf4x:hover:active,.fhvnf4x:active:focus-visible{border-top-color:transparent;}",
			".fb6swo4:hover:active,.fb6swo4:active:focus-visible{border-right-color:transparent;}",
			".f232fm2:hover:active,.f232fm2:active:focus-visible{border-left-color:transparent;}",
			".f1klyf7k:hover:active,.f1klyf7k:active:focus-visible{border-bottom-color:transparent;}",
			".f1d6mv4x:hover:active,.f1d6mv4x:active:focus-visible{color:var(--colorNeutralForegroundOnBrand);}",
			".f1t94bn6:hover{background-color:var(--colorSubtleBackgroundHover);}",
			".fnwyq0v:hover{color:var(--colorNeutralForeground2Hover);}",
			".ft1hn21:hover .fui-Icon-filled{display:inline;}",
			".fuxngvv:hover .fui-Icon-regular{display:none;}",
			".fy5bs14:hover .fui-Button__icon{color:var(--colorNeutralForeground2BrandHover);}",
			".f1q1yqic:hover:active,.f1q1yqic:active:focus-visible{background-color:var(--colorSubtleBackgroundPressed);}",
			".fwga7ee:hover:active,.fwga7ee:active:focus-visible{color:var(--colorNeutralForeground2Pressed);}",
			".f1nhwcv0:hover:active .fui-Icon-filled,.f1nhwcv0:active:focus-visible .fui-Icon-filled{display:inline;}",
			".f1gm6xmp:hover:active .fui-Icon-regular,.f1gm6xmp:active:focus-visible .fui-Icon-regular{display:none;}",
			".f1xxsver:hover:active .fui-Button__icon,.f1xxsver:active:focus-visible .fui-Button__icon{color:var(--colorNeutralForeground2BrandPressed);}",
			".f139oj5f:hover{color:var(--colorNeutralForeground2BrandHover);}",
			".f1l983o9:hover:active,.f1l983o9:active:focus-visible{color:var(--colorNeutralForeground2BrandPressed);}"
		],
		m: [
			["@media (forced-colors: active){.f1nz3ub2{background-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fag2qd2{border-top-color:HighlightText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f14bpyus{border-left-color:HighlightText;}.fmvhcg7{border-right-color:HighlightText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1o3dhpw{border-bottom-color:HighlightText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fqc85l4{color:HighlightText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1h3a8gf{forced-color-adjust:none;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fkiggi6:hover{background-color:HighlightText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f8gmj8i:hover{border-top-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1ap8nzx:hover{border-right-color:Highlight;}.fjag8bx:hover{border-left-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1igan7k:hover{border-bottom-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1v3eptx:hover{color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1ysmecq:hover:active,.f1ysmecq:active:focus-visible{background-color:HighlightText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.faulsx:hover:active,.faulsx:active:focus-visible{border-top-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f79t15f:hover:active,.f79t15f:active:focus-visible{border-right-color:Highlight;}.f8qmx7k:hover:active,.f8qmx7k:active:focus-visible{border-left-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fbtzoaq:hover:active,.fbtzoaq:active:focus-visible{border-bottom-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fd4bjan:hover:active,.fd4bjan:active:focus-visible{color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fivsta0:hover .fui-Button__icon{color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f3m6zum:hover:active .fui-Button__icon,.f3m6zum:active:focus-visible .fui-Button__icon{color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fxoo9op:hover{background-color:var(--colorTransparentBackground);}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1i0gk12:hover:active,.f1i0gk12:active:focus-visible{background-color:var(--colorTransparentBackground);}}", { m: "(forced-colors: active)" }]
		]
	});
	const useRootDisabledStyles$3 = /* @__PURE__ */ __styles({
		base: {
			De3pzq: "f1bg9a2p",
			g2u3we: "f1jj8ep1",
			h3c5rm: ["f15xbau", "fy0fskl"],
			B9xav0g: "f4ikngz",
			zhjwy3: ["fy0fskl", "f15xbau"],
			sj55zd: "f1s2aq7o",
			Bceei9c: "fdrzuqr",
			Bfinmwp: "f15x8b5r",
			Jwef8y: "f1falr9n",
			Bgoe8wy: "f12mpcsy",
			Bwzppfd: ["f1gwvigk", "f18rmfxp"],
			oetu4i: "f1jnshp0",
			gg5e9n: ["f18rmfxp", "f1gwvigk"],
			Bi91k9c: "fvgxktp",
			eoavqd: "fphbwmw",
			Bk3fhr4: "f19vpps7",
			Bmfj8id: "fv5swzo",
			Bbdnnc7: "f1al02dq",
			Bpjbzib: "f1jct5ie",
			im15vp: "f13txml0",
			Hjvxdg: ["f1ncddno", "f1axfvow"],
			Gpfmf1: "f1z04ada",
			ustxxc: ["f1axfvow", "f1ncddno"],
			Brsut9c: "f1uhomfy",
			Bses4qk: "fy9mucy",
			Bqou3pl: "f1g9va8i",
			Bsnehw8: "fwgvudy",
			wsxvnf: "fom6jww"
		},
		highContrast: {
			By8wz76: "f14ptb23",
			Bcq6wej: "f9dbb4x",
			Jcjdmf: ["f3qs60o", "f5u9ap2"],
			sc4o1m: "fwd1oij",
			Bosien3: ["f5u9ap2", "f3qs60o"],
			B7iucu3: "f1cyfu5x",
			Grqk0h: "f127ot8j",
			h3ptyc: "f19etb0b",
			Buw724y: ["f4f984j", "fw441p0"],
			Buk7464: "f3d22hf",
			Hwei09: ["fw441p0", "f4f984j"],
			Bbkh6qg: "fj8k9ua",
			F230oe: "fifrq0d",
			Bdw8ktp: ["f196mwp7", "fnekfq"],
			Bj1xduy: "f1l6uprw",
			Bhh2cfd: ["fnekfq", "f196mwp7"],
			Bahaeuw: "fa9u7a5",
			Buhizc3: "f1m71e0y",
			Bv2bamp: "fw24f3",
			vxuvv6: "f1nznrny",
			Bli9q98: ["fq8nxuu", "f1ao3jkc"],
			Bx2tt8t: "ftoixeo",
			yad0b3: ["f1ao3jkc", "fq8nxuu"],
			j2fop7: "fpmuzpx",
			Bqabnb4: "f168odog"
		},
		outline: {
			De3pzq: "f1c21dwh",
			Jwef8y: "f9ql6rf",
			Bpjbzib: "f9r0db0"
		},
		primary: {
			g2u3we: "f1p3nwhy",
			h3c5rm: ["f11589ue", "f1pdflbu"],
			B9xav0g: "f1q5o8ev",
			zhjwy3: ["f1pdflbu", "f11589ue"],
			Bgoe8wy: "f1s2uweq",
			Bwzppfd: ["fr80ssc", "fecsdlb"],
			oetu4i: "f1ukrpxl",
			gg5e9n: ["fecsdlb", "fr80ssc"],
			im15vp: "fhvnf4x",
			Hjvxdg: ["fb6swo4", "f232fm2"],
			Gpfmf1: "f1klyf7k",
			ustxxc: ["f232fm2", "fb6swo4"]
		},
		secondary: {},
		subtle: {
			De3pzq: "f1c21dwh",
			g2u3we: "f1p3nwhy",
			h3c5rm: ["f11589ue", "f1pdflbu"],
			B9xav0g: "f1q5o8ev",
			zhjwy3: ["f1pdflbu", "f11589ue"],
			Jwef8y: "f9ql6rf",
			Bgoe8wy: "f1s2uweq",
			Bwzppfd: ["fr80ssc", "fecsdlb"],
			oetu4i: "f1ukrpxl",
			gg5e9n: ["fecsdlb", "fr80ssc"],
			Bpjbzib: "f9r0db0",
			im15vp: "fhvnf4x",
			Hjvxdg: ["fb6swo4", "f232fm2"],
			Gpfmf1: "f1klyf7k",
			ustxxc: ["f232fm2", "fb6swo4"]
		},
		transparent: {
			De3pzq: "f1c21dwh",
			g2u3we: "f1p3nwhy",
			h3c5rm: ["f11589ue", "f1pdflbu"],
			B9xav0g: "f1q5o8ev",
			zhjwy3: ["f1pdflbu", "f11589ue"],
			Jwef8y: "f9ql6rf",
			Bgoe8wy: "f1s2uweq",
			Bwzppfd: ["fr80ssc", "fecsdlb"],
			oetu4i: "f1ukrpxl",
			gg5e9n: ["fecsdlb", "fr80ssc"],
			Bpjbzib: "f9r0db0",
			im15vp: "fhvnf4x",
			Hjvxdg: ["fb6swo4", "f232fm2"],
			Gpfmf1: "f1klyf7k",
			ustxxc: ["f232fm2", "fb6swo4"]
		}
	}, {
		d: [
			".f1bg9a2p{background-color:var(--colorNeutralBackgroundDisabled);}",
			".f1jj8ep1{border-top-color:var(--colorNeutralStrokeDisabled);}",
			".f15xbau{border-right-color:var(--colorNeutralStrokeDisabled);}",
			".fy0fskl{border-left-color:var(--colorNeutralStrokeDisabled);}",
			".f4ikngz{border-bottom-color:var(--colorNeutralStrokeDisabled);}",
			".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}",
			".fdrzuqr{cursor:not-allowed;}",
			".f15x8b5r .fui-Button__icon{color:var(--colorNeutralForegroundDisabled);}",
			".f1c21dwh{background-color:var(--colorTransparentBackground);}",
			".f1p3nwhy{border-top-color:transparent;}",
			".f11589ue{border-right-color:transparent;}",
			".f1pdflbu{border-left-color:transparent;}",
			".f1q5o8ev{border-bottom-color:transparent;}"
		],
		h: [
			".f1falr9n:hover{background-color:var(--colorNeutralBackgroundDisabled);}",
			".f12mpcsy:hover{border-top-color:var(--colorNeutralStrokeDisabled);}",
			".f1gwvigk:hover{border-right-color:var(--colorNeutralStrokeDisabled);}",
			".f18rmfxp:hover{border-left-color:var(--colorNeutralStrokeDisabled);}",
			".f1jnshp0:hover{border-bottom-color:var(--colorNeutralStrokeDisabled);}",
			".fvgxktp:hover{color:var(--colorNeutralForegroundDisabled);}",
			".fphbwmw:hover{cursor:not-allowed;}",
			".f19vpps7:hover .fui-Icon-filled{display:none;}",
			".fv5swzo:hover .fui-Icon-regular{display:inline;}",
			".f1al02dq:hover .fui-Button__icon{color:var(--colorNeutralForegroundDisabled);}",
			".f1jct5ie:hover:active,.f1jct5ie:active:focus-visible{background-color:var(--colorNeutralBackgroundDisabled);}",
			".f13txml0:hover:active,.f13txml0:active:focus-visible{border-top-color:var(--colorNeutralStrokeDisabled);}",
			".f1ncddno:hover:active,.f1ncddno:active:focus-visible{border-right-color:var(--colorNeutralStrokeDisabled);}",
			".f1axfvow:hover:active,.f1axfvow:active:focus-visible{border-left-color:var(--colorNeutralStrokeDisabled);}",
			".f1z04ada:hover:active,.f1z04ada:active:focus-visible{border-bottom-color:var(--colorNeutralStrokeDisabled);}",
			".f1uhomfy:hover:active,.f1uhomfy:active:focus-visible{color:var(--colorNeutralForegroundDisabled);}",
			".fy9mucy:hover:active,.fy9mucy:active:focus-visible{cursor:not-allowed;}",
			".f1g9va8i:hover:active .fui-Icon-filled,.f1g9va8i:active:focus-visible .fui-Icon-filled{display:none;}",
			".fwgvudy:hover:active .fui-Icon-regular,.fwgvudy:active:focus-visible .fui-Icon-regular{display:inline;}",
			".fom6jww:hover:active .fui-Button__icon,.fom6jww:active:focus-visible .fui-Button__icon{color:var(--colorNeutralForegroundDisabled);}",
			".f9ql6rf:hover{background-color:var(--colorTransparentBackground);}",
			".f9r0db0:hover:active,.f9r0db0:active:focus-visible{background-color:var(--colorTransparentBackground);}",
			".f1s2uweq:hover{border-top-color:transparent;}",
			".fr80ssc:hover{border-right-color:transparent;}",
			".fecsdlb:hover{border-left-color:transparent;}",
			".f1ukrpxl:hover{border-bottom-color:transparent;}",
			".fhvnf4x:hover:active,.fhvnf4x:active:focus-visible{border-top-color:transparent;}",
			".fb6swo4:hover:active,.fb6swo4:active:focus-visible{border-right-color:transparent;}",
			".f232fm2:hover:active,.f232fm2:active:focus-visible{border-left-color:transparent;}",
			".f1klyf7k:hover:active,.f1klyf7k:active:focus-visible{border-bottom-color:transparent;}"
		],
		m: [
			["@media (forced-colors: active){.f14ptb23{background-color:ButtonFace;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f9dbb4x{border-top-color:GrayText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f3qs60o{border-right-color:GrayText;}.f5u9ap2{border-left-color:GrayText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fwd1oij{border-bottom-color:GrayText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1cyfu5x{color:GrayText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f127ot8j .fui-Button__icon{color:GrayText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f19etb0b:focus{border-top-color:GrayText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f4f984j:focus{border-right-color:GrayText;}.fw441p0:focus{border-left-color:GrayText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f3d22hf:focus{border-bottom-color:GrayText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fj8k9ua:hover{background-color:ButtonFace;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fifrq0d:hover{border-top-color:GrayText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f196mwp7:hover{border-right-color:GrayText;}.fnekfq:hover{border-left-color:GrayText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1l6uprw:hover{border-bottom-color:GrayText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fa9u7a5:hover{color:GrayText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1m71e0y:hover .fui-Button__icon{color:GrayText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fw24f3:hover:active,.fw24f3:active:focus-visible{background-color:ButtonFace;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1nznrny:hover:active,.f1nznrny:active:focus-visible{border-top-color:GrayText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1ao3jkc:hover:active,.f1ao3jkc:active:focus-visible{border-left-color:GrayText;}.fq8nxuu:hover:active,.fq8nxuu:active:focus-visible{border-right-color:GrayText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.ftoixeo:hover:active,.ftoixeo:active:focus-visible{border-bottom-color:GrayText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fpmuzpx:hover:active,.fpmuzpx:active:focus-visible{color:GrayText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f168odog:hover:active .fui-Button__icon,.f168odog:active:focus-visible .fui-Button__icon{color:GrayText;}}", { m: "(forced-colors: active)" }]
		]
	});
	const useRootFocusStyles = /* @__PURE__ */ __styles({
		circular: {
			Bw81rd7: 0,
			kdpuga: 0,
			dm238s: 0,
			B6xbmo0: 0,
			B3whbx2: "f1062rbf"
		},
		rounded: {},
		square: {
			Bw81rd7: 0,
			kdpuga: 0,
			dm238s: 0,
			B6xbmo0: 0,
			B3whbx2: "fj0ryk1"
		},
		primary: {
			B8q5s1w: "f17t0x8g",
			Bci5o5g: ["f194v5ow", "fk7jm04"],
			n8qw10: "f1qgg65p",
			Bdrgwmp: ["fk7jm04", "f194v5ow"],
			j6ew2k: ["fhgccpy", "fjo7pq6"],
			he4mth: "f32wu9k",
			Byr4aka: "fu5nqqq",
			lks7q5: ["f13prjl2", "f1nl83rv"],
			Bnan3qt: "f1czftr5",
			k1dn9: ["f1nl83rv", "f13prjl2"],
			Bqsb82s: ["fixhny3", "f18mfu3r"],
			jg1oma: "feygou5"
		},
		small: {
			Bw81rd7: 0,
			kdpuga: 0,
			dm238s: 0,
			B6xbmo0: 0,
			B3whbx2: "fazmxh"
		},
		medium: {},
		large: {
			Bw81rd7: 0,
			kdpuga: 0,
			dm238s: 0,
			B6xbmo0: 0,
			B3whbx2: "f1b6alqh"
		}
	}, {
		d: [
			[".f1062rbf[data-fui-focus-visible]{border-radius:var(--borderRadiusCircular);}", { p: -1 }],
			[".fj0ryk1[data-fui-focus-visible]{border-radius:var(--borderRadiusNone);}", { p: -1 }],
			".f17t0x8g[data-fui-focus-visible]{border-top-color:var(--colorStrokeFocus2);}",
			".f194v5ow[data-fui-focus-visible]{border-right-color:var(--colorStrokeFocus2);}",
			".fk7jm04[data-fui-focus-visible]{border-left-color:var(--colorStrokeFocus2);}",
			".f1qgg65p[data-fui-focus-visible]{border-bottom-color:var(--colorStrokeFocus2);}",
			".fhgccpy[data-fui-focus-visible]{box-shadow:var(--shadow2),0 0 0 var(--strokeWidthThin) var(--colorStrokeFocus2) inset,0 0 0 var(--strokeWidthThick) var(--colorNeutralForegroundOnBrand) inset;}",
			".fjo7pq6[data-fui-focus-visible]{box-shadow:var(--shadow2),0 0 0 var(--strokeWidthThin) var(--colorStrokeFocus2) inset,0 0 0 var(--strokeWidthThick) var(--colorNeutralForegroundOnBrand) inset;}",
			".f32wu9k[data-fui-focus-visible]:hover{box-shadow:var(--shadow2),0 0 0 var(--strokeWidthThin) var(--colorStrokeFocus2) inset;}",
			".fu5nqqq[data-fui-focus-visible]:hover{border-top-color:var(--colorStrokeFocus2);}",
			".f13prjl2[data-fui-focus-visible]:hover{border-right-color:var(--colorStrokeFocus2);}",
			".f1nl83rv[data-fui-focus-visible]:hover{border-left-color:var(--colorStrokeFocus2);}",
			".f1czftr5[data-fui-focus-visible]:hover{border-bottom-color:var(--colorStrokeFocus2);}",
			[".fazmxh[data-fui-focus-visible]{border-radius:var(--borderRadiusSmall);}", { p: -1 }],
			[".f1b6alqh[data-fui-focus-visible]{border-radius:var(--borderRadiusLarge);}", { p: -1 }]
		],
		t: ["@supports (-moz-appearance:button){.f18mfu3r[data-fui-focus-visible]{box-shadow:var(--shadow2),0 0 0 calc(var(--strokeWidthThin) + 0.25px) var(--colorStrokeFocus2) inset,0 0 0 var(--strokeWidthThick) var(--colorNeutralForegroundOnBrand) inset;}.fixhny3[data-fui-focus-visible]{box-shadow:var(--shadow2),0 0 0 calc(var(--strokeWidthThin) + 0.25px) var(--colorStrokeFocus2) inset,0 0 0 var(--strokeWidthThick) var(--colorNeutralForegroundOnBrand) inset;}}", "@supports (-moz-appearance:button){.feygou5[data-fui-focus-visible]:hover{box-shadow:var(--shadow2),0 0 0 calc(var(--strokeWidthThin) + 0.25px) var(--colorStrokeFocus2) inset;}}"]
	});
	const useRootIconOnlyStyles$1 = /* @__PURE__ */ __styles({
		small: {
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "fu97m5z",
			Bf4jedk: "f17fgpbq",
			B2u0y6b: "f1jt17bm"
		},
		medium: {
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f18ktai2",
			Bf4jedk: "fwbmr0d",
			B2u0y6b: "f44c6la"
		},
		large: {
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f1hbd1aw",
			Bf4jedk: "f12clzc2",
			B2u0y6b: "fjy1crr"
		}
	}, { d: [
		[".fu97m5z{padding:1px;}", { p: -1 }],
		".f17fgpbq{min-width:24px;}",
		".f1jt17bm{max-width:24px;}",
		[".f18ktai2{padding:5px;}", { p: -1 }],
		".fwbmr0d{min-width:32px;}",
		".f44c6la{max-width:32px;}",
		[".f1hbd1aw{padding:7px;}", { p: -1 }],
		".f12clzc2{min-width:40px;}",
		".fjy1crr{max-width:40px;}"
	] });
	const useIconStyles$11 = /* @__PURE__ */ __styles({
		small: {
			Be2twd7: "fe5j1ua",
			Bqenvij: "fjamq6b",
			a9b677: "f64fuq3",
			Bqrlyyl: "fbaiahx"
		},
		medium: {},
		large: {
			Be2twd7: "f1rt2boy",
			Bqenvij: "frvgh55",
			a9b677: "fq4mcun",
			Bqrlyyl: "f1exjqw5"
		},
		before: { t21cq0: ["f1nizpg2", "f1a695kz"] },
		after: { Frg6f3: ["f1a695kz", "f1nizpg2"] }
	}, { d: [
		".fe5j1ua{font-size:20px;}",
		".fjamq6b{height:20px;}",
		".f64fuq3{width:20px;}",
		".fbaiahx{--fui-Button__icon--spacing:var(--spacingHorizontalXS);}",
		".f1rt2boy{font-size:24px;}",
		".frvgh55{height:24px;}",
		".fq4mcun{width:24px;}",
		".f1exjqw5{--fui-Button__icon--spacing:var(--spacingHorizontalSNudge);}",
		".f1nizpg2{margin-right:var(--fui-Button__icon--spacing);}",
		".f1a695kz{margin-left:var(--fui-Button__icon--spacing);}"
	] });
	const useButtonStyles_unstable = (state) => {
		"use no memo";
		const rootBaseClassName = useRootBaseClassName$12();
		const iconBaseClassName = useIconBaseClassName();
		const rootStyles = useRootStyles$26();
		const rootDisabledStyles = useRootDisabledStyles$3();
		const rootFocusStyles = useRootFocusStyles();
		const rootIconOnlyStyles = useRootIconOnlyStyles$1();
		const iconStyles = useIconStyles$11();
		const { appearance, disabled, disabledFocusable, icon, iconOnly, iconPosition, shape, size: size$2 } = state;
		state.root.className = mergeClasses(buttonClassNames.root, rootBaseClassName, appearance && rootStyles[appearance], rootStyles[size$2], icon && size$2 === "small" && rootStyles.smallWithIcon, icon && size$2 === "large" && rootStyles.largeWithIcon, rootStyles[shape], (disabled || disabledFocusable) && rootDisabledStyles.base, (disabled || disabledFocusable) && rootDisabledStyles.highContrast, appearance && (disabled || disabledFocusable) && rootDisabledStyles[appearance], appearance === "primary" && rootFocusStyles.primary, rootFocusStyles[size$2], rootFocusStyles[shape], iconOnly && rootIconOnlyStyles[size$2], state.root.className);
		if (state.icon) state.icon.className = mergeClasses(buttonClassNames.icon, iconBaseClassName, !!state.root.children && iconStyles[iconPosition], iconStyles[size$2], state.icon.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-button/lib/components/Button/Button.js
/**
	* Buttons give people a way to trigger an action.
	*/ const Button = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useButton_unstable(props, ref);
		useButtonStyles_unstable(state);
		useCustomStyleHook("useButtonStyles_unstable")(state);
		return renderButton_unstable(state);
	});
	Button.displayName = "Button";

//#endregion
//#region node_modules/@fluentui/react-button/lib/components/CompoundButton/renderCompoundButton.js
/**
	* Renders a CompoundButton component by passing the state defined props to the appropriate slots.
	*/ const renderCompoundButton_unstable = (state) => {
		assertSlots(state);
		const { iconOnly, iconPosition } = state;
		return /* @__PURE__ */ jsxs(state.root, { children: [
			iconPosition !== "after" && state.icon && /* @__PURE__ */ jsx(state.icon, {}),
			!iconOnly && /* @__PURE__ */ jsxs(state.contentContainer, { children: [state.root.children, state.secondaryContent && /* @__PURE__ */ jsx(state.secondaryContent, {})] }),
			iconPosition === "after" && state.icon && /* @__PURE__ */ jsx(state.icon, {})
		] });
	};

//#endregion
//#region node_modules/@fluentui/react-button/lib/components/CompoundButton/useCompoundButton.js
/**
	* Given user props, defines default props for the CompoundButton, calls useButtonState, and returns processed state.
	* @param props - User provided props to the CompoundButton component.
	* @param ref - User provided ref to be passed to the CompoundButton component.
	*/ const useCompoundButton_unstable = ({ contentContainer, secondaryContent, ...props }, ref) => {
		var _state_icon, _state_secondaryContent;
		const state = {
			...useButton_unstable(props, ref),
			components: {
				root: "button",
				icon: "span",
				contentContainer: "span",
				secondaryContent: "span"
			},
			contentContainer: always(contentContainer, { elementType: "span" }),
			secondaryContent: optional(secondaryContent, { elementType: "span" })
		};
		state.iconOnly = Boolean(((_state_icon = state.icon) === null || _state_icon === void 0 ? void 0 : _state_icon.children) && !props.children && !((_state_secondaryContent = state.secondaryContent) === null || _state_secondaryContent === void 0 ? void 0 : _state_secondaryContent.children));
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-button/lib/components/CompoundButton/useCompoundButtonStyles.styles.js
	const compoundButtonClassNames = {
		root: "fui-CompoundButton",
		icon: "fui-CompoundButton__icon",
		contentContainer: "fui-CompoundButton__contentContainer",
		secondaryContent: "fui-CompoundButton__secondaryContent"
	};
	const useRootStyles$25 = /* @__PURE__ */ __styles({
		base: {
			Bqenvij: "f11ysow2",
			J657lq: "f1um431h",
			Jlnjib: "fte7hqw",
			Bo7webf: "frw79jk"
		},
		highContrast: {
			m3fafd: "ffcivv0",
			pus4l6: "f1wchxtt"
		},
		outline: {},
		primary: {
			J657lq: "foe7gw6",
			Jlnjib: "fvxlz81",
			Bo7webf: "f16twlsn",
			D126e9: "fsglouz"
		},
		secondary: {},
		subtle: {
			J657lq: "f1um431h",
			Jlnjib: "fte7hqw",
			Bo7webf: "frw79jk",
			m3fafd: "f13lnigs",
			pus4l6: "f1ba77l5"
		},
		transparent: {
			J657lq: "f1um431h",
			Jlnjib: "f1wn9xqz",
			Bo7webf: "f1juxwb4"
		},
		small: {
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f1ge6w2w",
			Be2twd7: "fkhj508",
			Bg96gwp: "f1i3iumi"
		},
		medium: {
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "fnnf4v2",
			Be2twd7: "fkhj508",
			Bg96gwp: "f1i3iumi"
		},
		large: {
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f14s4sho",
			Be2twd7: "fod5ikn",
			Bg96gwp: "faaz57k"
		},
		disabled: {
			J657lq: "f1rlv8bf",
			Jlnjib: "fd1dbtm",
			Bo7webf: "f1x3eb98"
		},
		disabledHighContrast: {
			D126e9: "fbqh1p7",
			m3fafd: "fu2tbix",
			pus4l6: "f1g2tosm"
		}
	}, {
		d: [
			".f11ysow2{height:auto;}",
			".f1um431h .fui-CompoundButton__secondaryContent{color:var(--colorNeutralForeground2);}",
			".foe7gw6 .fui-CompoundButton__secondaryContent{color:var(--colorNeutralForegroundOnBrand);}",
			[".f1ge6w2w{padding:var(--spacingHorizontalS) var(--spacingHorizontalS) var(--spacingHorizontalMNudge) var(--spacingHorizontalS);}", { p: -1 }],
			".fkhj508{font-size:var(--fontSizeBase300);}",
			".f1i3iumi{line-height:var(--lineHeightBase300);}",
			[".fnnf4v2{padding:14px var(--spacingHorizontalM) var(--spacingHorizontalL) var(--spacingHorizontalM);}", { p: -1 }],
			[".f14s4sho{padding:18px var(--spacingHorizontalL) var(--spacingHorizontalXL) var(--spacingHorizontalL);}", { p: -1 }],
			".fod5ikn{font-size:var(--fontSizeBase400);}",
			".faaz57k{line-height:var(--lineHeightBase400);}",
			".f1rlv8bf .fui-CompoundButton__secondaryContent{color:var(--colorNeutralForegroundDisabled);}"
		],
		h: [
			".fte7hqw:hover .fui-CompoundButton__secondaryContent{color:var(--colorNeutralForeground2Hover);}",
			".frw79jk:hover:active .fui-CompoundButton__secondaryContent,.frw79jk:active:focus-visible .fui-CompoundButton__secondaryContent{color:var(--colorNeutralForeground2Pressed);}",
			".fvxlz81:hover .fui-CompoundButton__secondaryContent{color:var(--colorNeutralForegroundOnBrand);}",
			".f16twlsn:hover:active .fui-CompoundButton__secondaryContent,.f16twlsn:active:focus-visible .fui-CompoundButton__secondaryContent{color:var(--colorNeutralForegroundOnBrand);}",
			".f1wn9xqz:hover .fui-CompoundButton__secondaryContent{color:var(--colorNeutralForeground2BrandHover);}",
			".f1juxwb4:hover:active .fui-CompoundButton__secondaryContent,.f1juxwb4:active:focus-visible .fui-CompoundButton__secondaryContent{color:var(--colorNeutralForeground2BrandPressed);}",
			".fd1dbtm:hover .fui-CompoundButton__secondaryContent{color:var(--colorNeutralForegroundDisabled);}",
			".f1x3eb98:hover:active .fui-CompoundButton__secondaryContent,.f1x3eb98:active:focus-visible .fui-CompoundButton__secondaryContent{color:var(--colorNeutralForegroundDisabled);}"
		],
		m: [
			["@media (forced-colors: active){.ffcivv0:hover .fui-CompoundButton__secondaryContent{color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1wchxtt:hover:active .fui-CompoundButton__secondaryContent,.f1wchxtt:active:focus-visible .fui-CompoundButton__secondaryContent{color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fsglouz .fui-CompoundButton__secondaryContent{color:HighlightText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f13lnigs:hover .fui-CompoundButton__secondaryContent{color:Canvas;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1ba77l5:hover:active .fui-CompoundButton__secondaryContent,.f1ba77l5:active:focus-visible .fui-CompoundButton__secondaryContent{color:Canvas;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fbqh1p7 .fui-CompoundButton__secondaryContent{color:GrayText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fu2tbix:hover .fui-CompoundButton__secondaryContent{color:GrayText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1g2tosm:hover:active .fui-CompoundButton__secondaryContent,.f1g2tosm:active:focus-visible .fui-CompoundButton__secondaryContent{color:GrayText;}}", { m: "(forced-colors: active)" }]
		]
	});
	const useRootIconOnlyStyles = /* @__PURE__ */ __styles({
		small: {
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f1t35pdg",
			B2u0y6b: "ft5vyj6",
			Bf4jedk: "f17suaiq"
		},
		medium: {
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f1r1wyb6",
			B2u0y6b: "fdczgix",
			Bf4jedk: "fjdcg9m"
		},
		large: {
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f1bnz8pu",
			B2u0y6b: "fww51uw",
			Bf4jedk: "f1qhsl2h"
		}
	}, { d: [
		[".f1t35pdg{padding:var(--spacingHorizontalXS);}", { p: -1 }],
		".ft5vyj6{max-width:48px;}",
		".f17suaiq{min-width:48px;}",
		[".f1r1wyb6{padding:var(--spacingHorizontalSNudge);}", { p: -1 }],
		".fdczgix{max-width:52px;}",
		".fjdcg9m{min-width:52px;}",
		[".f1bnz8pu{padding:var(--spacingHorizontalS);}", { p: -1 }],
		".fww51uw{max-width:56px;}",
		".f1qhsl2h{min-width:56px;}"
	] });
	const useIconStyles$10 = /* @__PURE__ */ __styles({
		base: {
			Be2twd7: "fndrnj9",
			Bqenvij: "fbhnoac",
			a9b677: "feqmc2u"
		},
		before: { t21cq0: ["fkujibs", "f199hnxi"] },
		after: { Frg6f3: ["f199hnxi", "fkujibs"] }
	}, { d: [
		".fndrnj9{font-size:40px;}",
		".fbhnoac{height:40px;}",
		".feqmc2u{width:40px;}",
		".fkujibs{margin-right:var(--spacingHorizontalM);}",
		".f199hnxi{margin-left:var(--spacingHorizontalM);}"
	] });
	const useContentContainerStyles = /* @__PURE__ */ __styles({ base: {
		mc9l5x: "f22iagw",
		Beiy3e4: "f1vx9l62",
		fsow6f: ["f1o700av", "fes3tcz"]
	} }, { d: [
		".f22iagw{display:flex;}",
		".f1vx9l62{flex-direction:column;}",
		".f1o700av{text-align:left;}",
		".fes3tcz{text-align:right;}"
	] });
	const useSecondaryContentStyles = /* @__PURE__ */ __styles({
		base: {
			Bg96gwp: "flkuc6h",
			Bhrd7zp: "figsok6"
		},
		small: { Be2twd7: "fy9rknc" },
		medium: { Be2twd7: "fy9rknc" },
		large: { Be2twd7: "fkhj508" }
	}, { d: [
		".flkuc6h{line-height:100%;}",
		".figsok6{font-weight:var(--fontWeightRegular);}",
		".fy9rknc{font-size:var(--fontSizeBase200);}",
		".fkhj508{font-size:var(--fontSizeBase300);}"
	] });
	const useCompoundButtonStyles_unstable = (state) => {
		"use no memo";
		const rootStyles = useRootStyles$25();
		const rootIconOnlyStyles = useRootIconOnlyStyles();
		const iconStyles = useIconStyles$10();
		const contentContainerStyles = useContentContainerStyles();
		const secondaryContentStyles = useSecondaryContentStyles();
		const { appearance, disabled, disabledFocusable, iconOnly, iconPosition, size: size$2 } = state;
		state.root.className = mergeClasses(compoundButtonClassNames.root, rootStyles.base, rootStyles.highContrast, appearance && rootStyles[appearance], rootStyles[size$2], (disabled || disabledFocusable) && rootStyles.disabled, (disabled || disabledFocusable) && rootStyles.disabledHighContrast, iconOnly && rootIconOnlyStyles[size$2], state.root.className);
		state.contentContainer.className = mergeClasses(compoundButtonClassNames.contentContainer, contentContainerStyles.base, state.contentContainer.className);
		if (state.icon) state.icon.className = mergeClasses(compoundButtonClassNames.icon, iconStyles.base, state.root.children !== void 0 && state.root.children !== null && iconStyles[iconPosition], state.icon.className);
		if (state.secondaryContent) state.secondaryContent.className = mergeClasses(compoundButtonClassNames.secondaryContent, secondaryContentStyles.base, secondaryContentStyles[size$2], state.secondaryContent.className);
		useButtonStyles_unstable(state);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-button/lib/components/CompoundButton/CompoundButton.js
/**
	* CompoundButtons are buttons that can have secondary content that adds extra information to the user.
	*/ const CompoundButton = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useCompoundButton_unstable(props, ref);
		useCompoundButtonStyles_unstable(state);
		useCustomStyleHook("useCompoundButtonStyles_unstable")(state);
		return renderCompoundButton_unstable(state);
	});
	CompoundButton.displayName = "CompoundButton";

//#endregion
//#region node_modules/@fluentui/react-button/lib/components/MenuButton/renderMenuButton.js
/**
	* Renders a MenuButton component by passing the state defined props to the appropriate slots.
	*/ const renderMenuButton_unstable = (state) => {
		assertSlots(state);
		const { icon, iconOnly } = state;
		return /* @__PURE__ */ jsxs(state.root, { children: [
			state.icon && /* @__PURE__ */ jsx(state.icon, {}),
			!iconOnly && state.root.children,
			(!iconOnly || !(icon === null || icon === void 0 ? void 0 : icon.children)) && state.menuIcon && /* @__PURE__ */ jsx(state.menuIcon, {})
		] });
	};

//#endregion
//#region node_modules/@fluentui/react-button/lib/components/MenuButton/useMenuButton.js
/**
	* Given user props, returns the final state for a MenuButton.
	*/ const useMenuButton_unstable = ({ menuIcon, ...props }, ref) => {
		"use no memo";
		const buttonState = useButton_unstable(props, ref);
		buttonState.root["aria-expanded"] = props["aria-expanded"] ? props["aria-expanded"] === "true" || props["aria-expanded"] === true : false;
		return {
			...buttonState,
			iconOnly: Boolean(!props.children),
			components: {
				root: "button",
				icon: "span",
				menuIcon: "span"
			},
			menuIcon: optional(menuIcon, {
				defaultProps: { children: /* @__PURE__ */ react.createElement(ChevronDownRegular, null) },
				renderByDefault: true,
				elementType: "span"
			})
		};
	};

//#endregion
//#region node_modules/@fluentui/react-button/lib/components/MenuButton/useMenuButtonStyles.styles.js
	const menuButtonClassNames = {
		root: "fui-MenuButton",
		icon: "fui-MenuButton__icon",
		menuIcon: "fui-MenuButton__menuIcon"
	};
	const useRootExpandedStyles = /* @__PURE__ */ __styles({
		base: {
			D0sxk3: "fxoiby5",
			t6yez3: "f15q0o9g"
		},
		outline: {
			g2u3we: "f1ly1fcm",
			h3c5rm: ["fi8bssc", "fj6btzu"],
			B9xav0g: "f1s9tnsa",
			zhjwy3: ["fj6btzu", "fi8bssc"],
			B4j52fo: "fgx37oo",
			Bekrc4i: ["f130t4y6", "f1efpmoh"],
			Bn0qgzm: "fv51ejd",
			ibv6hh: ["f1efpmoh", "f130t4y6"],
			sj55zd: "f14nttnl"
		},
		primary: { De3pzq: "f8w4g0q" },
		secondary: {
			De3pzq: "f1nfm20t",
			g2u3we: "f1ly1fcm",
			h3c5rm: ["fi8bssc", "fj6btzu"],
			B9xav0g: "f1s9tnsa",
			zhjwy3: ["fj6btzu", "fi8bssc"],
			sj55zd: "f14nttnl"
		},
		subtle: {
			De3pzq: "fq5gl1p",
			sj55zd: "f1eryozh"
		},
		transparent: {
			De3pzq: "f1q9pm1r",
			sj55zd: "f1qj7y59"
		}
	}, { d: [
		".fxoiby5 .fui-Icon-filled{display:inline;}",
		".f15q0o9g .fui-Icon-regular{display:none;}",
		".f1ly1fcm{border-top-color:var(--colorNeutralStroke1Selected);}",
		".fi8bssc{border-right-color:var(--colorNeutralStroke1Selected);}",
		".fj6btzu{border-left-color:var(--colorNeutralStroke1Selected);}",
		".f1s9tnsa{border-bottom-color:var(--colorNeutralStroke1Selected);}",
		".fgx37oo{border-top-width:var(--strokeWidthThicker);}",
		".f130t4y6{border-right-width:var(--strokeWidthThicker);}",
		".f1efpmoh{border-left-width:var(--strokeWidthThicker);}",
		".fv51ejd{border-bottom-width:var(--strokeWidthThicker);}",
		".f14nttnl{color:var(--colorNeutralForeground1Selected);}",
		".f8w4g0q{background-color:var(--colorBrandBackgroundSelected);}",
		".f1nfm20t{background-color:var(--colorNeutralBackground1Selected);}",
		".fq5gl1p{background-color:var(--colorSubtleBackgroundSelected);}",
		".f1eryozh{color:var(--colorNeutralForeground2Selected);}",
		".f1q9pm1r{background-color:var(--colorTransparentBackgroundSelected);}",
		".f1qj7y59{color:var(--colorNeutralForeground2BrandSelected);}"
	] });
	const useIconExpandedStyles = /* @__PURE__ */ __styles({
		outline: { sj55zd: "f14nttnl" },
		primary: {},
		secondary: { sj55zd: "f14nttnl" },
		subtle: { sj55zd: "f1qj7y59" },
		transparent: { sj55zd: "f1qj7y59" },
		highContrast: { Bahaeuw: "f1v3eptx" }
	}, {
		d: [".f14nttnl{color:var(--colorNeutralForeground1Selected);}", ".f1qj7y59{color:var(--colorNeutralForeground2BrandSelected);}"],
		m: [["@media (forced-colors: active){.f1v3eptx:hover{color:Highlight;}}", { m: "(forced-colors: active)" }]]
	});
	const useMenuIconStyles = /* @__PURE__ */ __styles({
		base: { Bg96gwp: "fez10in" },
		small: {
			Be2twd7: "f1ugzwwg",
			Bqenvij: "fvblgha",
			Bg96gwp: "fwrc4pm",
			a9b677: "frx94fk"
		},
		medium: {
			Be2twd7: "f1ugzwwg",
			Bqenvij: "fvblgha",
			Bg96gwp: "fwrc4pm",
			a9b677: "frx94fk"
		},
		large: {
			Be2twd7: "f4ybsrx",
			Bqenvij: "fd461yt",
			Bg96gwp: "faaz57k",
			a9b677: "fjw5fx7"
		},
		notIconOnly: { Frg6f3: ["fbyavb5", "fm0x6gh"] }
	}, { d: [
		".fez10in{line-height:0;}",
		".f1ugzwwg{font-size:12px;}",
		".fvblgha{height:12px;}",
		".fwrc4pm{line-height:var(--lineHeightBase200);}",
		".frx94fk{width:12px;}",
		".f4ybsrx{font-size:16px;}",
		".fd461yt{height:16px;}",
		".faaz57k{line-height:var(--lineHeightBase400);}",
		".fjw5fx7{width:16px;}",
		".fbyavb5{margin-left:var(--spacingHorizontalXS);}",
		".fm0x6gh{margin-right:var(--spacingHorizontalXS);}"
	] });
	const useMenuButtonStyles_unstable = (state) => {
		"use no memo";
		const rootExpandedStyles = useRootExpandedStyles();
		const iconExpandedStyles = useIconExpandedStyles();
		const menuIconStyles = useMenuIconStyles();
		state.root.className = mergeClasses(menuButtonClassNames.root, state.root["aria-expanded"] && rootExpandedStyles.base, state.root["aria-expanded"] && rootExpandedStyles[state.appearance], state.root.className);
		if (state.icon) state.icon.className = mergeClasses(menuButtonClassNames.icon, state.root["aria-expanded"] && iconExpandedStyles[state.appearance] && iconExpandedStyles.highContrast, state.icon.className);
		if (state.menuIcon) state.menuIcon.className = mergeClasses(menuButtonClassNames.menuIcon, menuIconStyles.base, menuIconStyles[state.size], !state.iconOnly && menuIconStyles.notIconOnly, state.menuIcon.className);
		useButtonStyles_unstable({
			...state,
			iconPosition: "before"
		});
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-button/lib/components/MenuButton/MenuButton.js
/**
	* MenuButtons are buttons that have a chevron icon after the button contents and are usually clicked to open/close
	* menus.
	*/ const MenuButton = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useMenuButton_unstable(props, ref);
		useMenuButtonStyles_unstable(state);
		useCustomStyleHook("useMenuButtonStyles_unstable")(state);
		return renderMenuButton_unstable(state);
	});
	MenuButton.displayName = "MenuButton";

//#endregion
//#region node_modules/@fluentui/react-button/lib/components/SplitButton/renderSplitButton.js
/**
	* Renders a SplitButton component by passing the state defined props to the appropriate slots.
	*/ const renderSplitButton_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(state.root, { children: [state.primaryActionButton && /* @__PURE__ */ jsx(state.primaryActionButton, {}), state.menuButton && /* @__PURE__ */ jsx(state.menuButton, {})] });
	};

//#endregion
//#region node_modules/@fluentui/react-button/lib/components/SplitButton/useSplitButton.js
/**
	* Given user props, defines default props for the SplitButton and returns processed state.
	* @param props - User provided props to the SplitButton component.
	* @param ref - User provided ref to be passed to the SplitButton component.
	*/ const useSplitButton_unstable = (props, ref) => {
		const { appearance = "secondary", children, disabled = false, disabledFocusable = false, icon, iconPosition = "before", menuButton: menuButton$1, menuIcon, primaryActionButton, shape = "rounded", size: size$2 = "medium" } = props;
		const baseId = useId("splitButton-");
		const menuButtonShorthand = optional(menuButton$1, {
			defaultProps: {
				appearance,
				disabled,
				disabledFocusable,
				menuIcon,
				shape,
				size: size$2
			},
			renderByDefault: true,
			elementType: MenuButton
		});
		const primaryActionButtonShorthand = optional(primaryActionButton, {
			defaultProps: {
				appearance,
				children,
				disabled,
				disabledFocusable,
				icon,
				iconPosition,
				id: baseId + "__primaryActionButton",
				shape,
				size: size$2
			},
			renderByDefault: true,
			elementType: Button
		});
		if (menuButtonShorthand && primaryActionButtonShorthand && !menuButtonShorthand["aria-label"] && !menuButtonShorthand["aria-labelledby"]) menuButtonShorthand["aria-labelledby"] = primaryActionButtonShorthand.id;
		return {
			appearance,
			disabled,
			disabledFocusable,
			iconPosition,
			shape,
			size: size$2,
			components: {
				root: "div",
				menuButton: MenuButton,
				primaryActionButton: Button
			},
			root: always(getIntrinsicElementProps("div", {
				ref,
				...props
			}), { elementType: "div" }),
			menuButton: menuButtonShorthand,
			primaryActionButton: primaryActionButtonShorthand
		};
	};

//#endregion
//#region node_modules/@fluentui/react-button/lib/components/SplitButton/useSplitButtonStyles.styles.js
	const splitButtonClassNames = {
		root: "fui-SplitButton",
		menuButton: "fui-SplitButton__menuButton",
		primaryActionButton: "fui-SplitButton__primaryActionButton"
	};
	const useFocusStyles$1 = /* @__PURE__ */ __styles({
		primaryActionButton: {
			B6xbmo0: ["f1x37qnr", "f1um7c6d"],
			kdpuga: ["fn4c73s", "f6pwzcr"]
		},
		menuButton: {
			lbo84a: ["frrbwxo", "f1rgcpbv"],
			dm238s: ["f1um7c6d", "f1x37qnr"],
			Bw81rd7: ["f6pwzcr", "fn4c73s"]
		}
	}, { d: [
		".f1x37qnr[data-fui-focus-visible]{border-top-right-radius:0;}",
		".f1um7c6d[data-fui-focus-visible]{border-top-left-radius:0;}",
		".fn4c73s[data-fui-focus-visible]{border-bottom-right-radius:0;}",
		".f6pwzcr[data-fui-focus-visible]{border-bottom-left-radius:0;}",
		".frrbwxo[data-fui-focus-visible]{border-left-width:0;}",
		".f1rgcpbv[data-fui-focus-visible]{border-right-width:0;}"
	] });
	const useRootStyles$24 = /* @__PURE__ */ __styles({
		base: {
			mc9l5x: "ftuwxu6",
			Brf1p80: "fsxf2b5",
			qhf8xq: "f10pi13n",
			ha4doy: "fmrv4ls",
			kn2xc0: ["f14uur2j", "fc1btbj"],
			Bs76p8a: ["fye5tvs", "fc597qq"],
			cuxpm9: ["f1e8brtx", "fr36rk3"],
			Biffepf: ["fxp12j1", "f1m6nt2y"],
			Defnvf: ["fr7y8no", "f1dn0c6m"],
			z0pv9t: "f1b65x5h"
		},
		outline: {},
		primary: {
			B1l9wao: ["f4rm5b0", "f1tuwo13"],
			lcnrd8: ["fdwdeeo", "f1ezdslh"],
			vlshuh: ["f1ju2vgk", "f1r6p88l"],
			B3s9tpx: ["f2z0mmn", "f12iqdwp"],
			rfylfo: ["f1btorfl", "fxofj4p"],
			k5lds2: ["f161sdhp", "f10m3pjc"]
		},
		secondary: {},
		subtle: {
			B1l9wao: ["f16kf41h", "fxiafvi"],
			lcnrd8: ["ffl6mx9", "f1t5sw6t"],
			vlshuh: ["f1mww3cx", "f1wtv0vd"]
		},
		transparent: {
			B1l9wao: ["f16kf41h", "fxiafvi"],
			lcnrd8: ["ffl6mx9", "f1t5sw6t"],
			vlshuh: ["f1mww3cx", "f1wtv0vd"]
		},
		circular: {},
		rounded: {},
		square: {},
		disabled: {
			B1l9wao: ["f10xrnr8", "f15nylwb"],
			lcnrd8: ["f11fwhjz", "f18vtcsx"],
			vlshuh: ["f12kx9re", "f1hyxdqk"]
		},
		disabledHighContrast: {
			B3s9tpx: ["fslo9ob", "ftovg2z"],
			rfylfo: ["f1fuq5cn", "f168zpha"],
			k5lds2: ["f1t6bo0o", "f1dnwhli"]
		}
	}, {
		d: [
			".ftuwxu6{display:inline-flex;}",
			".fsxf2b5{justify-content:stretch;}",
			".f10pi13n{position:relative;}",
			".fmrv4ls{vertical-align:middle;}",
			".f14uur2j .fui-SplitButton__primaryActionButton{border-top-right-radius:0;}",
			".fc1btbj .fui-SplitButton__primaryActionButton{border-top-left-radius:0;}",
			".fye5tvs .fui-SplitButton__primaryActionButton{border-bottom-right-radius:0;}",
			".fc597qq .fui-SplitButton__primaryActionButton{border-bottom-left-radius:0;}",
			".f1e8brtx .fui-SplitButton__menuButton{border-left-width:0;}",
			".fr36rk3 .fui-SplitButton__menuButton{border-right-width:0;}",
			".fxp12j1 .fui-SplitButton__menuButton{border-top-left-radius:0;}",
			".f1m6nt2y .fui-SplitButton__menuButton{border-top-right-radius:0;}",
			".fr7y8no .fui-SplitButton__menuButton{border-bottom-left-radius:0;}",
			".f1dn0c6m .fui-SplitButton__menuButton{border-bottom-right-radius:0;}",
			".f1b65x5h .fui-SplitButton__menuButton{min-width:24px;}",
			".f4rm5b0 .fui-SplitButton__primaryActionButton{border-right-color:var(--colorNeutralStrokeOnBrand);}",
			".f1tuwo13 .fui-SplitButton__primaryActionButton{border-left-color:var(--colorNeutralStrokeOnBrand);}",
			".f16kf41h .fui-SplitButton__primaryActionButton{border-right-color:var(--colorTransparentBackground);}",
			".fxiafvi .fui-SplitButton__primaryActionButton{border-left-color:var(--colorTransparentBackground);}",
			".f10xrnr8 .fui-SplitButton__primaryActionButton{border-right-color:var(--colorNeutralStrokeDisabled);}",
			".f15nylwb .fui-SplitButton__primaryActionButton{border-left-color:var(--colorNeutralStrokeDisabled);}"
		],
		h: [
			".fdwdeeo:hover .fui-SplitButton__primaryActionButton{border-right-color:var(--colorNeutralStrokeOnBrand);}",
			".f1ezdslh:hover .fui-SplitButton__primaryActionButton{border-left-color:var(--colorNeutralStrokeOnBrand);}",
			".f1ju2vgk:hover:active .fui-SplitButton__primaryActionButton,.f1ju2vgk:active:focus-visible .fui-SplitButton__primaryActionButton{border-right-color:var(--colorNeutralStrokeOnBrand);}",
			".f1r6p88l:hover:active .fui-SplitButton__primaryActionButton,.f1r6p88l:active:focus-visible .fui-SplitButton__primaryActionButton{border-left-color:var(--colorNeutralStrokeOnBrand);}",
			".ffl6mx9:hover .fui-SplitButton__primaryActionButton{border-right-color:var(--colorTransparentBackgroundHover);}",
			".f1t5sw6t:hover .fui-SplitButton__primaryActionButton{border-left-color:var(--colorTransparentBackgroundHover);}",
			".f1mww3cx:hover:active .fui-SplitButton__primaryActionButton,.f1mww3cx:active:focus-visible .fui-SplitButton__primaryActionButton{border-right-color:var(--colorTransparentBackgroundPressed);}",
			".f1wtv0vd:hover:active .fui-SplitButton__primaryActionButton,.f1wtv0vd:active:focus-visible .fui-SplitButton__primaryActionButton{border-left-color:var(--colorTransparentBackgroundPressed);}",
			".f11fwhjz:hover .fui-SplitButton__primaryActionButton{border-right-color:var(--colorNeutralStrokeDisabled);}",
			".f18vtcsx:hover .fui-SplitButton__primaryActionButton{border-left-color:var(--colorNeutralStrokeDisabled);}",
			".f12kx9re:hover:active .fui-SplitButton__primaryActionButton,.f12kx9re:active:focus-visible .fui-SplitButton__primaryActionButton{border-right-color:var(--colorNeutralStrokeDisabled);}",
			".f1hyxdqk:hover:active .fui-SplitButton__primaryActionButton,.f1hyxdqk:active:focus-visible .fui-SplitButton__primaryActionButton{border-left-color:var(--colorNeutralStrokeDisabled);}"
		],
		m: [
			["@media (forced-colors: active){.f12iqdwp .fui-SplitButton__primaryActionButton{border-left-color:HighlightText;}.f2z0mmn .fui-SplitButton__primaryActionButton{border-right-color:HighlightText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1btorfl:hover .fui-SplitButton__primaryActionButton{border-right-color:Highlight;}.fxofj4p:hover .fui-SplitButton__primaryActionButton{border-left-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f10m3pjc:hover:active .fui-SplitButton__primaryActionButton,.f10m3pjc:active:focus-visible .fui-SplitButton__primaryActionButton{border-left-color:Highlight;}.f161sdhp:hover:active .fui-SplitButton__primaryActionButton,.f161sdhp:active:focus-visible .fui-SplitButton__primaryActionButton{border-right-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fslo9ob .fui-SplitButton__primaryActionButton{border-right-color:GrayText;}.ftovg2z .fui-SplitButton__primaryActionButton{border-left-color:GrayText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f168zpha:hover .fui-SplitButton__primaryActionButton{border-left-color:GrayText;}.f1fuq5cn:hover .fui-SplitButton__primaryActionButton{border-right-color:GrayText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1dnwhli:hover:active .fui-SplitButton__primaryActionButton,.f1dnwhli:active:focus-visible .fui-SplitButton__primaryActionButton{border-left-color:GrayText;}.f1t6bo0o:hover:active .fui-SplitButton__primaryActionButton,.f1t6bo0o:active:focus-visible .fui-SplitButton__primaryActionButton{border-right-color:GrayText;}}", { m: "(forced-colors: active)" }]
		]
	});
	const useSplitButtonStyles_unstable = (state) => {
		"use no memo";
		const rootStyles = useRootStyles$24();
		const focusStyles = useFocusStyles$1();
		const { appearance, disabled, disabledFocusable } = state;
		state.root.className = mergeClasses(splitButtonClassNames.root, rootStyles.base, appearance && rootStyles[appearance], (disabled || disabledFocusable) && rootStyles.disabled, (disabled || disabledFocusable) && rootStyles.disabledHighContrast, state.root.className);
		if (state.menuButton) state.menuButton.className = mergeClasses(splitButtonClassNames.menuButton, focusStyles.menuButton, state.menuButton.className);
		if (state.primaryActionButton) state.primaryActionButton.className = mergeClasses(splitButtonClassNames.primaryActionButton, focusStyles.primaryActionButton, state.primaryActionButton.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-button/lib/components/SplitButton/SplitButton.js
/**
	* SplitButtons are a grouping of two interactive surfaces where interacting with the first one triggers a primary
	* action, while interacting with the second one opens a menu with secondary actions.
	*/ const SplitButton = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useSplitButton_unstable(props, ref);
		useSplitButtonStyles_unstable(state);
		useCustomStyleHook("useSplitButtonStyles_unstable")(state);
		return renderSplitButton_unstable(state);
	});
	SplitButton.displayName = "SplitButton";

//#endregion
//#region node_modules/@fluentui/react-button/lib/utils/useToggleState.js
	function useToggleState(props, state) {
		const { checked, defaultChecked, disabled, disabledFocusable } = props;
		const { onClick, role } = state.root;
		const [checkedValue, setCheckedValue] = useControllableState({
			state: checked,
			defaultState: defaultChecked,
			initialState: false
		});
		const isCheckboxTypeRole = role === "menuitemcheckbox" || role === "checkbox";
		const onToggleClick = react.useCallback((ev) => {
			if (!disabled && !disabledFocusable) {
				if (ev.defaultPrevented) return;
				setCheckedValue(!checkedValue);
			}
		}, [
			checkedValue,
			disabled,
			disabledFocusable,
			setCheckedValue
		]);
		return {
			...state,
			checked: checkedValue,
			root: {
				...state.root,
				[isCheckboxTypeRole ? "aria-checked" : "aria-pressed"]: checkedValue,
				onClick: useEventCallback(mergeCallbacks(onClick, onToggleClick))
			}
		};
	}

//#endregion
//#region node_modules/@fluentui/react-button/lib/components/ToggleButton/useToggleButton.js
/**
	* Given user props, defines default props for the ToggleButton, calls useButtonState and useChecked, and returns
	* processed state.
	* @param props - User provided props to the ToggleButton component.
	* @param ref - User provided ref to be passed to the ToggleButton component.
	*/ const useToggleButton_unstable = (props, ref) => {
		return useToggleState(props, useButton_unstable(props, ref));
	};

//#endregion
//#region node_modules/@fluentui/react-button/lib/components/ToggleButton/useToggleButtonStyles.styles.js
	const toggleButtonClassNames = {
		root: "fui-ToggleButton",
		icon: "fui-ToggleButton__icon"
	};
	const useRootCheckedStyles = /* @__PURE__ */ __styles({
		base: {
			De3pzq: "f1nfm20t",
			g2u3we: "fj3muxo",
			h3c5rm: ["f1akhkt", "f1lxtadh"],
			B9xav0g: "f1aperda",
			zhjwy3: ["f1lxtadh", "f1akhkt"],
			sj55zd: "f14nttnl",
			B4j52fo: "f192inf7",
			Bekrc4i: ["f5tn483", "f1ojsxk5"],
			Bn0qgzm: "f1vxd6vx",
			ibv6hh: ["f1ojsxk5", "f5tn483"],
			D0sxk3: "fxoiby5",
			t6yez3: "f15q0o9g",
			Jwef8y: "f1knas48",
			Bgoe8wy: "fvcxoqz",
			Bwzppfd: ["f1ub3y4t", "f1m52nbi"],
			oetu4i: "f1xlaoq0",
			gg5e9n: ["f1m52nbi", "f1ub3y4t"],
			Bi91k9c: "feu1g3u",
			Bpjbzib: "f128kf1x",
			im15vp: "f1a38rnh",
			Hjvxdg: ["f1wvuwkr", "fbu0tau"],
			Gpfmf1: "f132k7zb",
			ustxxc: ["fbu0tau", "f1wvuwkr"],
			Brsut9c: "fggfoek"
		},
		highContrast: {
			By8wz76: "f1nz3ub2",
			Bcq6wej: "fjq791v",
			Jcjdmf: ["fkq2p2y", "f1sehlss"],
			sc4o1m: "f11odvng",
			Bosien3: ["f1sehlss", "fkq2p2y"],
			B7iucu3: "fqc85l4",
			B8gzw0y: "f1h3a8gf",
			Bbkh6qg: "fkiggi6",
			F230oe: "f8gmj8i",
			Bdw8ktp: ["f1ap8nzx", "fjag8bx"],
			Bj1xduy: "f1igan7k",
			Bhh2cfd: ["fjag8bx", "f1ap8nzx"],
			Bahaeuw: "f1v3eptx",
			Bv2bamp: "f1ysmecq",
			vxuvv6: "faulsx",
			Bli9q98: ["f79t15f", "f8qmx7k"],
			Bx2tt8t: "fbtzoaq",
			yad0b3: ["f8qmx7k", "f79t15f"],
			j2fop7: "fd4bjan",
			B6rz4yo: 0,
			Buk7464: 0,
			Bqg8rp8: 0,
			pjr8j7: 0,
			Bgs2klq: 0,
			Hwei09: 0,
			Bi9aqk7: 0,
			Fihjvf: 0,
			nhyz0p: 0,
			Buw724y: 0,
			Bn7qjfh: 0,
			B0u7xl9: 0,
			md97jv: 0,
			h3ptyc: 0,
			s1kvfj: 0,
			kogrdj: 0,
			dqx2i2: "fdmpsdn",
			o0nolc: "fgjsukj"
		},
		outline: {
			De3pzq: "f1q9pm1r",
			g2u3we: "fj3muxo",
			h3c5rm: ["f1akhkt", "f1lxtadh"],
			B9xav0g: "f1aperda",
			zhjwy3: ["f1lxtadh", "f1akhkt"],
			B4j52fo: "fgx37oo",
			Bekrc4i: ["f130t4y6", "f1efpmoh"],
			Bn0qgzm: "fv51ejd",
			ibv6hh: ["f1efpmoh", "f130t4y6"],
			Jwef8y: "fjxutwb",
			Bpjbzib: "fkoldzo",
			B8q5s1w: "fcaw57c",
			Bci5o5g: ["fpwd27e", "f1999bjr"],
			n8qw10: "f1hi52o4",
			Bdrgwmp: ["f1999bjr", "fpwd27e"]
		},
		primary: {
			De3pzq: "f8w4g0q",
			g2u3we: "f1p3nwhy",
			h3c5rm: ["f11589ue", "f1pdflbu"],
			B9xav0g: "f1q5o8ev",
			zhjwy3: ["f1pdflbu", "f11589ue"],
			sj55zd: "f1phragk",
			Jwef8y: "f15wkkf3",
			Bgoe8wy: "f1s2uweq",
			Bwzppfd: ["fr80ssc", "fecsdlb"],
			oetu4i: "f1ukrpxl",
			gg5e9n: ["fecsdlb", "fr80ssc"],
			Bi91k9c: "f1rq72xc",
			Bpjbzib: "f1ksv2xa",
			im15vp: "fhvnf4x",
			Hjvxdg: ["fb6swo4", "f232fm2"],
			Gpfmf1: "f1klyf7k",
			ustxxc: ["f232fm2", "fb6swo4"],
			Brsut9c: "f1d6mv4x"
		},
		secondary: {},
		subtle: {
			De3pzq: "fq5gl1p",
			g2u3we: "f1p3nwhy",
			h3c5rm: ["f11589ue", "f1pdflbu"],
			B9xav0g: "f1q5o8ev",
			zhjwy3: ["f1pdflbu", "f11589ue"],
			sj55zd: "f1eryozh",
			Jwef8y: "f1t94bn6",
			Bgoe8wy: "f1s2uweq",
			Bwzppfd: ["fr80ssc", "fecsdlb"],
			oetu4i: "f1ukrpxl",
			gg5e9n: ["fecsdlb", "fr80ssc"],
			Bi91k9c: "fnwyq0v",
			Bpjbzib: "f1q1yqic",
			im15vp: "fhvnf4x",
			Hjvxdg: ["fb6swo4", "f232fm2"],
			Gpfmf1: "f1klyf7k",
			ustxxc: ["f232fm2", "fb6swo4"],
			Brsut9c: "fwga7ee"
		},
		transparent: {
			De3pzq: "f1q9pm1r",
			g2u3we: "f1p3nwhy",
			h3c5rm: ["f11589ue", "f1pdflbu"],
			B9xav0g: "f1q5o8ev",
			zhjwy3: ["f1pdflbu", "f11589ue"],
			sj55zd: "f1qj7y59",
			Jwef8y: "fjxutwb",
			Bgoe8wy: "f1s2uweq",
			Bwzppfd: ["fr80ssc", "fecsdlb"],
			oetu4i: "f1ukrpxl",
			gg5e9n: ["fecsdlb", "fr80ssc"],
			Bi91k9c: "f139oj5f",
			Bpjbzib: "fkoldzo",
			im15vp: "fhvnf4x",
			Hjvxdg: ["fb6swo4", "f232fm2"],
			Gpfmf1: "f1klyf7k",
			ustxxc: ["f232fm2", "fb6swo4"],
			Brsut9c: "f1l983o9"
		}
	}, {
		d: [
			".f1nfm20t{background-color:var(--colorNeutralBackground1Selected);}",
			".fj3muxo{border-top-color:var(--colorNeutralStroke1);}",
			".f1akhkt{border-right-color:var(--colorNeutralStroke1);}",
			".f1lxtadh{border-left-color:var(--colorNeutralStroke1);}",
			".f1aperda{border-bottom-color:var(--colorNeutralStroke1);}",
			".f14nttnl{color:var(--colorNeutralForeground1Selected);}",
			".f192inf7{border-top-width:var(--strokeWidthThin);}",
			".f5tn483{border-right-width:var(--strokeWidthThin);}",
			".f1ojsxk5{border-left-width:var(--strokeWidthThin);}",
			".f1vxd6vx{border-bottom-width:var(--strokeWidthThin);}",
			".fxoiby5 .fui-Icon-filled{display:inline;}",
			".f15q0o9g .fui-Icon-regular{display:none;}",
			".f1q9pm1r{background-color:var(--colorTransparentBackgroundSelected);}",
			".fgx37oo{border-top-width:var(--strokeWidthThicker);}",
			".f130t4y6{border-right-width:var(--strokeWidthThicker);}",
			".f1efpmoh{border-left-width:var(--strokeWidthThicker);}",
			".fv51ejd{border-bottom-width:var(--strokeWidthThicker);}",
			".fcaw57c[data-fui-focus-visible]{border-top-color:var(--colorNeutralStroke1);}",
			".fpwd27e[data-fui-focus-visible]{border-right-color:var(--colorNeutralStroke1);}",
			".f1999bjr[data-fui-focus-visible]{border-left-color:var(--colorNeutralStroke1);}",
			".f1hi52o4[data-fui-focus-visible]{border-bottom-color:var(--colorNeutralStroke1);}",
			".f8w4g0q{background-color:var(--colorBrandBackgroundSelected);}",
			".f1p3nwhy{border-top-color:transparent;}",
			".f11589ue{border-right-color:transparent;}",
			".f1pdflbu{border-left-color:transparent;}",
			".f1q5o8ev{border-bottom-color:transparent;}",
			".f1phragk{color:var(--colorNeutralForegroundOnBrand);}",
			".fq5gl1p{background-color:var(--colorSubtleBackgroundSelected);}",
			".f1eryozh{color:var(--colorNeutralForeground2Selected);}",
			".f1qj7y59{color:var(--colorNeutralForeground2BrandSelected);}"
		],
		h: [
			".f1knas48:hover{background-color:var(--colorNeutralBackground1Hover);}",
			".fvcxoqz:hover{border-top-color:var(--colorNeutralStroke1Hover);}",
			".f1ub3y4t:hover{border-right-color:var(--colorNeutralStroke1Hover);}",
			".f1m52nbi:hover{border-left-color:var(--colorNeutralStroke1Hover);}",
			".f1xlaoq0:hover{border-bottom-color:var(--colorNeutralStroke1Hover);}",
			".feu1g3u:hover{color:var(--colorNeutralForeground1Hover);}",
			".f128kf1x:hover:active,.f128kf1x:active:focus-visible{background-color:var(--colorNeutralBackground1Pressed);}",
			".f1a38rnh:hover:active,.f1a38rnh:active:focus-visible{border-top-color:var(--colorNeutralStroke1Pressed);}",
			".f1wvuwkr:hover:active,.f1wvuwkr:active:focus-visible{border-right-color:var(--colorNeutralStroke1Pressed);}",
			".fbu0tau:hover:active,.fbu0tau:active:focus-visible{border-left-color:var(--colorNeutralStroke1Pressed);}",
			".f132k7zb:hover:active,.f132k7zb:active:focus-visible{border-bottom-color:var(--colorNeutralStroke1Pressed);}",
			".fggfoek:hover:active,.fggfoek:active:focus-visible{color:var(--colorNeutralForeground1Pressed);}",
			".fjxutwb:hover{background-color:var(--colorTransparentBackgroundHover);}",
			".fkoldzo:hover:active,.fkoldzo:active:focus-visible{background-color:var(--colorTransparentBackgroundPressed);}",
			".f15wkkf3:hover{background-color:var(--colorBrandBackgroundHover);}",
			".f1s2uweq:hover{border-top-color:transparent;}",
			".fr80ssc:hover{border-right-color:transparent;}",
			".fecsdlb:hover{border-left-color:transparent;}",
			".f1ukrpxl:hover{border-bottom-color:transparent;}",
			".f1rq72xc:hover{color:var(--colorNeutralForegroundOnBrand);}",
			".f1ksv2xa:hover:active,.f1ksv2xa:active:focus-visible{background-color:var(--colorBrandBackgroundPressed);}",
			".fhvnf4x:hover:active,.fhvnf4x:active:focus-visible{border-top-color:transparent;}",
			".fb6swo4:hover:active,.fb6swo4:active:focus-visible{border-right-color:transparent;}",
			".f232fm2:hover:active,.f232fm2:active:focus-visible{border-left-color:transparent;}",
			".f1klyf7k:hover:active,.f1klyf7k:active:focus-visible{border-bottom-color:transparent;}",
			".f1d6mv4x:hover:active,.f1d6mv4x:active:focus-visible{color:var(--colorNeutralForegroundOnBrand);}",
			".f1t94bn6:hover{background-color:var(--colorSubtleBackgroundHover);}",
			".fnwyq0v:hover{color:var(--colorNeutralForeground2Hover);}",
			".f1q1yqic:hover:active,.f1q1yqic:active:focus-visible{background-color:var(--colorSubtleBackgroundPressed);}",
			".fwga7ee:hover:active,.fwga7ee:active:focus-visible{color:var(--colorNeutralForeground2Pressed);}",
			".f139oj5f:hover{color:var(--colorNeutralForeground2BrandHover);}",
			".f1l983o9:hover:active,.f1l983o9:active:focus-visible{color:var(--colorNeutralForeground2BrandPressed);}"
		],
		m: [
			["@media (forced-colors: active){.f1nz3ub2{background-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fjq791v{border-top-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1sehlss{border-left-color:Highlight;}.fkq2p2y{border-right-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f11odvng{border-bottom-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fqc85l4{color:HighlightText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1h3a8gf{forced-color-adjust:none;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fkiggi6:hover{background-color:HighlightText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f8gmj8i:hover{border-top-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1ap8nzx:hover{border-right-color:Highlight;}.fjag8bx:hover{border-left-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1igan7k:hover{border-bottom-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1v3eptx:hover{color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1ysmecq:hover:active,.f1ysmecq:active:focus-visible{background-color:HighlightText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.faulsx:hover:active,.faulsx:active:focus-visible{border-top-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f79t15f:hover:active,.f79t15f:active:focus-visible{border-right-color:Highlight;}.f8qmx7k:hover:active,.f8qmx7k:active:focus-visible{border-left-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fbtzoaq:hover:active,.fbtzoaq:active:focus-visible{border-bottom-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fd4bjan:hover:active,.fd4bjan:active:focus-visible{color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fdmpsdn:focus{border:1px solid HighlightText;}}", {
				p: -2,
				m: "(forced-colors: active)"
			}],
			["@media (forced-colors: active){.fgjsukj:focus{outline-color:Highlight;}}", { m: "(forced-colors: active)" }]
		]
	});
	const useRootDisabledStyles$2 = /* @__PURE__ */ __styles({
		base: {
			De3pzq: "f1bg9a2p",
			g2u3we: "f1jj8ep1",
			h3c5rm: ["f15xbau", "fy0fskl"],
			B9xav0g: "f4ikngz",
			zhjwy3: ["fy0fskl", "f15xbau"],
			sj55zd: "f1s2aq7o",
			Jwef8y: "f1falr9n",
			Bgoe8wy: "f12mpcsy",
			Bwzppfd: ["f1gwvigk", "f18rmfxp"],
			oetu4i: "f1jnshp0",
			gg5e9n: ["f18rmfxp", "f1gwvigk"],
			Bi91k9c: "fvgxktp",
			Bpjbzib: "f1jct5ie",
			im15vp: "f13txml0",
			Hjvxdg: ["f1ncddno", "f1axfvow"],
			Gpfmf1: "f1z04ada",
			ustxxc: ["f1axfvow", "f1ncddno"],
			Brsut9c: "f1uhomfy"
		},
		outline: {},
		primary: {
			g2u3we: "f1p3nwhy",
			h3c5rm: ["f11589ue", "f1pdflbu"],
			B9xav0g: "f1q5o8ev",
			zhjwy3: ["f1pdflbu", "f11589ue"],
			Bgoe8wy: "f1s2uweq",
			Bwzppfd: ["fr80ssc", "fecsdlb"],
			oetu4i: "f1ukrpxl",
			gg5e9n: ["fecsdlb", "fr80ssc"],
			im15vp: "fhvnf4x",
			Hjvxdg: ["fb6swo4", "f232fm2"],
			Gpfmf1: "f1klyf7k",
			ustxxc: ["f232fm2", "fb6swo4"]
		},
		secondary: {},
		subtle: {
			De3pzq: "f1c21dwh",
			g2u3we: "f1p3nwhy",
			h3c5rm: ["f11589ue", "f1pdflbu"],
			B9xav0g: "f1q5o8ev",
			zhjwy3: ["f1pdflbu", "f11589ue"],
			Jwef8y: "fjxutwb",
			Bgoe8wy: "f1s2uweq",
			Bwzppfd: ["fr80ssc", "fecsdlb"],
			oetu4i: "f1ukrpxl",
			gg5e9n: ["fecsdlb", "fr80ssc"],
			Bpjbzib: "fkoldzo",
			im15vp: "fhvnf4x",
			Hjvxdg: ["fb6swo4", "f232fm2"],
			Gpfmf1: "f1klyf7k",
			ustxxc: ["f232fm2", "fb6swo4"]
		},
		transparent: {
			De3pzq: "f1c21dwh",
			g2u3we: "f1p3nwhy",
			h3c5rm: ["f11589ue", "f1pdflbu"],
			B9xav0g: "f1q5o8ev",
			zhjwy3: ["f1pdflbu", "f11589ue"],
			Jwef8y: "fjxutwb",
			Bgoe8wy: "f1s2uweq",
			Bwzppfd: ["fr80ssc", "fecsdlb"],
			oetu4i: "f1ukrpxl",
			gg5e9n: ["fecsdlb", "fr80ssc"],
			Bpjbzib: "fkoldzo",
			im15vp: "fhvnf4x",
			Hjvxdg: ["fb6swo4", "f232fm2"],
			Gpfmf1: "f1klyf7k",
			ustxxc: ["f232fm2", "fb6swo4"]
		}
	}, {
		d: [
			".f1bg9a2p{background-color:var(--colorNeutralBackgroundDisabled);}",
			".f1jj8ep1{border-top-color:var(--colorNeutralStrokeDisabled);}",
			".f15xbau{border-right-color:var(--colorNeutralStrokeDisabled);}",
			".fy0fskl{border-left-color:var(--colorNeutralStrokeDisabled);}",
			".f4ikngz{border-bottom-color:var(--colorNeutralStrokeDisabled);}",
			".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}",
			".f1p3nwhy{border-top-color:transparent;}",
			".f11589ue{border-right-color:transparent;}",
			".f1pdflbu{border-left-color:transparent;}",
			".f1q5o8ev{border-bottom-color:transparent;}",
			".f1c21dwh{background-color:var(--colorTransparentBackground);}"
		],
		h: [
			".f1falr9n:hover{background-color:var(--colorNeutralBackgroundDisabled);}",
			".f12mpcsy:hover{border-top-color:var(--colorNeutralStrokeDisabled);}",
			".f1gwvigk:hover{border-right-color:var(--colorNeutralStrokeDisabled);}",
			".f18rmfxp:hover{border-left-color:var(--colorNeutralStrokeDisabled);}",
			".f1jnshp0:hover{border-bottom-color:var(--colorNeutralStrokeDisabled);}",
			".fvgxktp:hover{color:var(--colorNeutralForegroundDisabled);}",
			".f1jct5ie:hover:active,.f1jct5ie:active:focus-visible{background-color:var(--colorNeutralBackgroundDisabled);}",
			".f13txml0:hover:active,.f13txml0:active:focus-visible{border-top-color:var(--colorNeutralStrokeDisabled);}",
			".f1ncddno:hover:active,.f1ncddno:active:focus-visible{border-right-color:var(--colorNeutralStrokeDisabled);}",
			".f1axfvow:hover:active,.f1axfvow:active:focus-visible{border-left-color:var(--colorNeutralStrokeDisabled);}",
			".f1z04ada:hover:active,.f1z04ada:active:focus-visible{border-bottom-color:var(--colorNeutralStrokeDisabled);}",
			".f1uhomfy:hover:active,.f1uhomfy:active:focus-visible{color:var(--colorNeutralForegroundDisabled);}",
			".f1s2uweq:hover{border-top-color:transparent;}",
			".fr80ssc:hover{border-right-color:transparent;}",
			".fecsdlb:hover{border-left-color:transparent;}",
			".f1ukrpxl:hover{border-bottom-color:transparent;}",
			".fhvnf4x:hover:active,.fhvnf4x:active:focus-visible{border-top-color:transparent;}",
			".fb6swo4:hover:active,.fb6swo4:active:focus-visible{border-right-color:transparent;}",
			".f232fm2:hover:active,.f232fm2:active:focus-visible{border-left-color:transparent;}",
			".f1klyf7k:hover:active,.f1klyf7k:active:focus-visible{border-bottom-color:transparent;}",
			".fjxutwb:hover{background-color:var(--colorTransparentBackgroundHover);}",
			".fkoldzo:hover:active,.fkoldzo:active:focus-visible{background-color:var(--colorTransparentBackgroundPressed);}"
		]
	});
	const useIconCheckedStyles = /* @__PURE__ */ __styles({
		subtleOrTransparent: { sj55zd: "f1qj7y59" },
		highContrast: { B8gzw0y: "f1dd5bof" }
	}, {
		d: [".f1qj7y59{color:var(--colorNeutralForeground2BrandSelected);}"],
		m: [["@media (forced-colors: active){.f1dd5bof{forced-color-adjust:auto;}}", { m: "(forced-colors: active)" }]]
	});
	const usePrimaryHighContrastStyles = /* @__PURE__ */ __styles({
		base: {
			By8wz76: "f14ptb23",
			Bcq6wej: "fd7znuh",
			Jcjdmf: ["f1wh4a04", "f15h7fac"],
			sc4o1m: "f1f064oi",
			Bosien3: ["f15h7fac", "f1wh4a04"],
			B7iucu3: "f3ggph1",
			B8gzw0y: "f1dd5bof"
		},
		disabled: {
			Bcq6wej: "f9dbb4x",
			Jcjdmf: ["f3qs60o", "f5u9ap2"],
			sc4o1m: "fwd1oij",
			Bosien3: ["f5u9ap2", "f3qs60o"],
			B7iucu3: "f1cyfu5x",
			h3ptyc: "f19etb0b",
			Buw724y: ["f4f984j", "fw441p0"],
			Buk7464: "f3d22hf",
			Hwei09: ["fw441p0", "f4f984j"]
		}
	}, { m: [
		["@media (forced-colors: active){.f14ptb23{background-color:ButtonFace;}}", { m: "(forced-colors: active)" }],
		["@media (forced-colors: active){.fd7znuh{border-top-color:ButtonBorder;}}", { m: "(forced-colors: active)" }],
		["@media (forced-colors: active){.f15h7fac{border-left-color:ButtonBorder;}.f1wh4a04{border-right-color:ButtonBorder;}}", { m: "(forced-colors: active)" }],
		["@media (forced-colors: active){.f1f064oi{border-bottom-color:ButtonBorder;}}", { m: "(forced-colors: active)" }],
		["@media (forced-colors: active){.f3ggph1{color:ButtonText;}}", { m: "(forced-colors: active)" }],
		["@media (forced-colors: active){.f1dd5bof{forced-color-adjust:auto;}}", { m: "(forced-colors: active)" }],
		["@media (forced-colors: active){.f9dbb4x{border-top-color:GrayText;}}", { m: "(forced-colors: active)" }],
		["@media (forced-colors: active){.f3qs60o{border-right-color:GrayText;}.f5u9ap2{border-left-color:GrayText;}}", { m: "(forced-colors: active)" }],
		["@media (forced-colors: active){.fwd1oij{border-bottom-color:GrayText;}}", { m: "(forced-colors: active)" }],
		["@media (forced-colors: active){.f1cyfu5x{color:GrayText;}}", { m: "(forced-colors: active)" }],
		["@media (forced-colors: active){.f19etb0b:focus{border-top-color:GrayText;}}", { m: "(forced-colors: active)" }],
		["@media (forced-colors: active){.f4f984j:focus{border-right-color:GrayText;}.fw441p0:focus{border-left-color:GrayText;}}", { m: "(forced-colors: active)" }],
		["@media (forced-colors: active){.f3d22hf:focus{border-bottom-color:GrayText;}}", { m: "(forced-colors: active)" }]
	] });
	const useToggleButtonStyles_unstable = (state) => {
		"use no memo";
		const rootCheckedStyles = useRootCheckedStyles();
		const rootDisabledStyles = useRootDisabledStyles$2();
		const iconCheckedStyles = useIconCheckedStyles();
		const primaryHighContrastStyles = usePrimaryHighContrastStyles();
		const { appearance, checked, disabled, disabledFocusable } = state;
		state.root.className = mergeClasses(toggleButtonClassNames.root, appearance === "primary" && primaryHighContrastStyles.base, appearance === "primary" && (disabled || disabledFocusable) && primaryHighContrastStyles.disabled, checked && rootCheckedStyles.base, checked && rootCheckedStyles.highContrast, appearance && checked && rootCheckedStyles[appearance], (disabled || disabledFocusable) && rootDisabledStyles.base, appearance && (disabled || disabledFocusable) && rootDisabledStyles[appearance], state.root.className);
		if (state.icon) state.icon.className = mergeClasses(toggleButtonClassNames.icon, checked && (appearance === "subtle" || appearance === "transparent") && iconCheckedStyles.subtleOrTransparent, iconCheckedStyles.highContrast, state.icon.className);
		useButtonStyles_unstable(state);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-button/lib/components/ToggleButton/ToggleButton.js
/**
	* ToggleButtons are buttons that toggle between two defined states when triggered.
	*/ const ToggleButton = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useToggleButton_unstable(props, ref);
		useToggleButtonStyles_unstable(state);
		useCustomStyleHook("useToggleButtonStyles_unstable")(state);
		return renderButton_unstable(state);
	});
	ToggleButton.displayName = "ToggleButton";

//#endregion
//#region node_modules/@fluentui/react-field/lib/contexts/FieldContext.js
	const FieldContext = react.createContext(void 0);
	const FieldContextProvider = FieldContext.Provider;
	const useFieldContext_unstable = () => react.useContext(FieldContext);

//#endregion
//#region node_modules/@fluentui/react-field/lib/contexts/useFieldContextValues.js
/**
	* Get the context values used when rendering Field.
	*/ const useFieldContextValues_unstable = (state) => {
		var _state_label, _state_label1, _state_validationMessage, _state_hint;
		const { generatedControlId, orientation, required, size: size$2, validationState } = state;
		const labelFor = (_state_label = state.label) === null || _state_label === void 0 ? void 0 : _state_label.htmlFor;
		const labelId = (_state_label1 = state.label) === null || _state_label1 === void 0 ? void 0 : _state_label1.id;
		const validationMessageId = (_state_validationMessage = state.validationMessage) === null || _state_validationMessage === void 0 ? void 0 : _state_validationMessage.id;
		const hintId = (_state_hint = state.hint) === null || _state_hint === void 0 ? void 0 : _state_hint.id;
		return { field: react.useMemo(() => ({
			generatedControlId,
			hintId,
			labelFor,
			labelId,
			orientation,
			required,
			size: size$2,
			validationMessageId,
			validationState
		}), [
			generatedControlId,
			hintId,
			labelFor,
			labelId,
			orientation,
			required,
			size$2,
			validationMessageId,
			validationState
		]) };
	};

//#endregion
//#region node_modules/@fluentui/react-field/lib/contexts/useFieldControlProps.js
	function useFieldControlProps_unstable(props, options) {
		return getFieldControlProps(useFieldContext_unstable(), props, options);
	}
	/**
	* @internal
	* Implementation of useFieldControlProps_unstable.
	* Split out so it can be used directly in renderField_unstable.
	*/ function getFieldControlProps(context, props, options) {
		if (!context) return props;
		props = { ...props };
		const { generatedControlId, hintId, labelFor, labelId, required, validationMessageId, validationState } = context;
		if (generatedControlId) {
			var _props;
			var _id;
			(_id = (_props = props).id) !== null && _id !== void 0 || (_props.id = generatedControlId);
		}
		if (labelId && (!(options === null || options === void 0 ? void 0 : options.supportsLabelFor) || labelFor !== props.id)) {
			var _props1, _arialabelledby;
			var _;
			(_ = (_props1 = props)[_arialabelledby = "aria-labelledby"]) !== null && _ !== void 0 || (_props1[_arialabelledby] = labelId);
		}
		if (validationMessageId || hintId) props["aria-describedby"] = [
			validationMessageId,
			hintId,
			props === null || props === void 0 ? void 0 : props["aria-describedby"]
		].filter(Boolean).join(" ");
		if (validationState === "error") {
			var _props2, _ariainvalid;
			var _1;
			(_1 = (_props2 = props)[_ariainvalid = "aria-invalid"]) !== null && _1 !== void 0 || (_props2[_ariainvalid] = true);
		}
		if (required) if (options === null || options === void 0 ? void 0 : options.supportsRequired) {
			var _props3;
			var _required;
			(_required = (_props3 = props).required) !== null && _required !== void 0 || (_props3.required = true);
		} else {
			var _props4, _ariarequired;
			var _2;
			(_2 = (_props4 = props)[_ariarequired = "aria-required"]) !== null && _2 !== void 0 || (_props4[_ariarequired] = true);
		}
		if (options === null || options === void 0 ? void 0 : options.supportsSize) {
			var _props5;
			var _size;
			(_size = (_props5 = props).size) !== null && _size !== void 0 || (_props5.size = context.size);
		}
		return props;
	}

//#endregion
//#region node_modules/@fluentui/react-field/lib/components/Field/renderField.js
/**
	* Render the final JSX of Field
	*/ const renderField_unstable = (state, contextValues) => {
		assertSlots(state);
		let { children } = state;
		if (typeof children === "function") children = children(getFieldControlProps(contextValues.field) || {});
		return /* @__PURE__ */ jsx(FieldContextProvider, {
			value: contextValues === null || contextValues === void 0 ? void 0 : contextValues.field,
			children: /* @__PURE__ */ jsxs(state.root, { children: [
				state.label && /* @__PURE__ */ jsx(state.label, {}),
				children,
				state.validationMessage && /* @__PURE__ */ jsxs(state.validationMessage, { children: [state.validationMessageIcon && /* @__PURE__ */ jsx(state.validationMessageIcon, {}), state.validationMessage.children] }),
				state.hint && /* @__PURE__ */ jsx(state.hint, {})
			] })
		});
	};

//#endregion
//#region node_modules/@fluentui/react-label/lib/components/Label/useLabel.js
/**
	* Create the state required to render Label.
	*
	* The returned state can be modified with hooks such as useLabelStyles_unstable,
	* before being passed to renderLabel_unstable.
	*
	* @param props - props from this instance of Label
	* @param ref - reference to root HTMLElement of Label
	*/ const useLabel_unstable = (props, ref) => {
		const { disabled = false, required = false, weight = "regular", size: size$2 = "medium" } = props;
		return {
			disabled,
			required: optional(required === true ? "*" : required || void 0, {
				defaultProps: { "aria-hidden": "true" },
				elementType: "span"
			}),
			weight,
			size: size$2,
			components: {
				root: "label",
				required: "span"
			},
			root: always(getIntrinsicElementProps("label", {
				ref,
				...props
			}), { elementType: "label" })
		};
	};

//#endregion
//#region node_modules/@fluentui/react-label/lib/components/Label/renderLabel.js
/**
	* Render the final JSX of Label
	*/ const renderLabel_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(state.root, { children: [state.root.children, state.required && /* @__PURE__ */ jsx(state.required, {})] });
	};

//#endregion
//#region node_modules/@fluentui/react-label/lib/components/Label/useLabelStyles.styles.js
	const labelClassNames = {
		root: "fui-Label",
		required: "fui-Label__required"
	};
	/**
	* Styles for the label
	*/
	const useStyles$96 = /* @__PURE__ */ __styles({
		root: {
			Bahqtrf: "fk6fouc",
			sj55zd: "f19n0e5"
		},
		disabled: {
			sj55zd: "f1s2aq7o",
			B7iucu3: "f1cyfu5x"
		},
		required: {
			sj55zd: "f1whyuy6",
			uwmqm3: ["fruq291", "f7x41pl"]
		},
		small: {
			Be2twd7: "fy9rknc",
			Bg96gwp: "fwrc4pm"
		},
		medium: {
			Be2twd7: "fkhj508",
			Bg96gwp: "f1i3iumi"
		},
		large: {
			Be2twd7: "fod5ikn",
			Bg96gwp: "faaz57k",
			Bhrd7zp: "fl43uef"
		},
		semibold: { Bhrd7zp: "fl43uef" }
	}, {
		d: [
			".fk6fouc{font-family:var(--fontFamilyBase);}",
			".f19n0e5{color:var(--colorNeutralForeground1);}",
			".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}",
			".f1whyuy6{color:var(--colorPaletteRedForeground3);}",
			".fruq291{padding-left:var(--spacingHorizontalXS);}",
			".f7x41pl{padding-right:var(--spacingHorizontalXS);}",
			".fy9rknc{font-size:var(--fontSizeBase200);}",
			".fwrc4pm{line-height:var(--lineHeightBase200);}",
			".fkhj508{font-size:var(--fontSizeBase300);}",
			".f1i3iumi{line-height:var(--lineHeightBase300);}",
			".fod5ikn{font-size:var(--fontSizeBase400);}",
			".faaz57k{line-height:var(--lineHeightBase400);}",
			".fl43uef{font-weight:var(--fontWeightSemibold);}"
		],
		m: [["@media (forced-colors: active){.f1cyfu5x{color:GrayText;}}", { m: "(forced-colors: active)" }]]
	});
	/**
	* Apply styling to the Label slots based on the state
	*/
	const useLabelStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$96();
		state.root.className = mergeClasses(labelClassNames.root, styles.root, state.disabled && styles.disabled, styles[state.size], state.weight === "semibold" && styles.semibold, state.root.className);
		if (state.required) state.required.className = mergeClasses(labelClassNames.required, styles.required, state.disabled && styles.disabled, state.required.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-label/lib/components/Label/Label.js
/**
	* A label component provides a title or name to a component.
	*/ const Label = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useLabel_unstable(props, ref);
		useLabelStyles_unstable(state);
		useCustomStyleHook("useLabelStyles_unstable")(state);
		return renderLabel_unstable(state);
	});
	Label.displayName = "Label";

//#endregion
//#region node_modules/@fluentui/react-field/lib/components/Field/useField.js
	const validationMessageIcons = {
		error: /* @__PURE__ */ react.createElement(ErrorCircle12Filled, null),
		warning: /* @__PURE__ */ react.createElement(Warning12Filled, null),
		success: /* @__PURE__ */ react.createElement(CheckmarkCircle12Filled, null),
		none: void 0
	};
	/**
	* Create the state required to render Field.
	*
	* The returned state can be modified with hooks such as useFieldStyles_unstable,
	* before being passed to renderField_unstable.
	*
	* @param props - Props passed to this field
	* @param ref - Ref to the root
	*/ const useField_unstable = (props, ref) => {
		const { children, orientation = "vertical", required = false, validationState = props.validationMessage ? "error" : "none", size: size$2 = "medium" } = props;
		const baseId = useId("field-");
		const generatedControlId = baseId + "__control";
		const root = always(getIntrinsicElementProps("div", {
			...props,
			ref
		}, ["children"]), { elementType: "div" });
		const label = optional(props.label, {
			defaultProps: {
				htmlFor: generatedControlId,
				id: baseId + "__label",
				required,
				size: size$2
			},
			elementType: Label
		});
		const validationMessage = optional(props.validationMessage, {
			defaultProps: {
				id: baseId + "__validationMessage",
				role: validationState === "error" || validationState === "warning" ? "alert" : void 0
			},
			elementType: "div"
		});
		const hint = optional(props.hint, {
			defaultProps: { id: baseId + "__hint" },
			elementType: "div"
		});
		const defaultIcon = validationMessageIcons[validationState];
		const validationMessageIcon = optional(props.validationMessageIcon, {
			renderByDefault: !!defaultIcon,
			defaultProps: { children: defaultIcon },
			elementType: "span"
		});
		return {
			children,
			generatedControlId,
			orientation,
			required,
			size: size$2,
			validationState,
			components: {
				root: "div",
				label: Label,
				validationMessage: "div",
				validationMessageIcon: "span",
				hint: "div"
			},
			root,
			label,
			validationMessageIcon,
			validationMessage,
			hint
		};
	};

//#endregion
//#region node_modules/@fluentui/react-field/lib/components/Field/useFieldStyles.styles.js
	const fieldClassNames = {
		root: `fui-Field`,
		label: `fui-Field__label`,
		validationMessage: `fui-Field__validationMessage`,
		validationMessageIcon: `fui-Field__validationMessageIcon`,
		hint: `fui-Field__hint`
	};
	/**
	* Styles for the root slot
	*/
	const useRootStyles$23 = /* @__PURE__ */ __styles({
		base: { mc9l5x: "f13qh94s" },
		horizontal: {
			Budl1dq: "f2wwaib",
			wkccdc: "f1645dqt"
		},
		horizontalNoLabel: {
			uwmqm3: ["f15jqgz8", "fggqkej"],
			Budl1dq: "f1c2z91y"
		}
	}, { d: [
		".f13qh94s{display:grid;}",
		".f2wwaib{grid-template-columns:33% 1fr;}",
		".f1645dqt{grid-template-rows:auto auto auto 1fr;}",
		".f15jqgz8{padding-left:33%;}",
		".fggqkej{padding-right:33%;}",
		".f1c2z91y{grid-template-columns:1fr;}"
	] });
	const useLabelStyles$6 = /* @__PURE__ */ __styles({
		base: {
			B2u0y6b: "f6nezus",
			Bxyxcbc: "f1iqmcbn"
		},
		vertical: {
			z8tnut: "fclwglc",
			Byoj8tv: "fywfov9",
			jrapky: "fyacil5"
		},
		verticalLarge: {
			z8tnut: "f1sl3k7w",
			Byoj8tv: "f1brlhvm",
			jrapky: "f8l5zjj"
		},
		horizontal: {
			z8tnut: "fp2oml8",
			Byoj8tv: "f1tdddsa",
			t21cq0: ["fkujibs", "f199hnxi"],
			Ijaq50: "f16hsg94",
			nk6f5a: "f1nzqi2z"
		},
		horizontalSmall: {
			z8tnut: "f1ywm7hm",
			Byoj8tv: "f14wxoun"
		},
		horizontalLarge: {
			z8tnut: "f1hqyr95",
			Byoj8tv: "fm4hlj0"
		}
	}, { d: [
		".f6nezus{max-width:max-content;}",
		".f1iqmcbn{max-height:max-content;}",
		".fclwglc{padding-top:var(--spacingVerticalXXS);}",
		".fywfov9{padding-bottom:var(--spacingVerticalXXS);}",
		".fyacil5{margin-bottom:var(--spacingVerticalXXS);}",
		".f1sl3k7w{padding-top:1px;}",
		".f1brlhvm{padding-bottom:1px;}",
		".f8l5zjj{margin-bottom:var(--spacingVerticalXS);}",
		".fp2oml8{padding-top:var(--spacingVerticalSNudge);}",
		".f1tdddsa{padding-bottom:var(--spacingVerticalSNudge);}",
		".fkujibs{margin-right:var(--spacingHorizontalM);}",
		".f199hnxi{margin-left:var(--spacingHorizontalM);}",
		".f16hsg94{grid-row-start:1;}",
		".f1nzqi2z{grid-row-end:-1;}",
		".f1ywm7hm{padding-top:var(--spacingVerticalXS);}",
		".f14wxoun{padding-bottom:var(--spacingVerticalXS);}",
		".f1hqyr95{padding-top:9px;}",
		".fm4hlj0{padding-bottom:9px;}"
	] });
	const useSecondaryTextBaseClassName$1 = /* @__PURE__ */ __resetStyles("r5c4z9l", null, [".r5c4z9l{margin-top:var(--spacingVerticalXXS);color:var(--colorNeutralForeground3);font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase200);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase200);}"]);
	const useSecondaryTextStyles = /* @__PURE__ */ __styles({
		error: { sj55zd: "f1hcrxcs" },
		withIcon: { uwmqm3: ["frawy03", "fg4c52"] }
	}, { d: [
		".f1hcrxcs{color:var(--colorPaletteRedForeground1);}",
		".frawy03{padding-left:calc(12px + var(--spacingHorizontalXS));}",
		".fg4c52{padding-right:calc(12px + var(--spacingHorizontalXS));}"
	] });
	const useValidationMessageIconBaseClassName = /* @__PURE__ */ __resetStyles("ra7h1uk", "r1rh6bd7", [".ra7h1uk{display:inline-block;font-size:12px;margin-left:calc(-12px - var(--spacingHorizontalXS));margin-right:var(--spacingHorizontalXS);line-height:0;vertical-align:-1px;}", ".r1rh6bd7{display:inline-block;font-size:12px;margin-right:calc(-12px - var(--spacingHorizontalXS));margin-left:var(--spacingHorizontalXS);line-height:0;vertical-align:-1px;}"]);
	const useValidationMessageIconStyles = /* @__PURE__ */ __styles({
		error: { sj55zd: "f1hcrxcs" },
		warning: { sj55zd: "f1k5f75o" },
		success: { sj55zd: "ffmvakt" }
	}, { d: [
		".f1hcrxcs{color:var(--colorPaletteRedForeground1);}",
		".f1k5f75o{color:var(--colorPaletteDarkOrangeForeground1);}",
		".ffmvakt{color:var(--colorPaletteGreenForeground1);}"
	] });
	/**
	* Apply styling to the Field slots based on the state
	*/
	const useFieldStyles_unstable = (state) => {
		"use no memo";
		const { validationState, size: size$2 } = state;
		const horizontal = state.orientation === "horizontal";
		const rootStyles = useRootStyles$23();
		state.root.className = mergeClasses(fieldClassNames.root, rootStyles.base, horizontal && rootStyles.horizontal, horizontal && !state.label && rootStyles.horizontalNoLabel, state.root.className);
		const labelStyles = useLabelStyles$6();
		if (state.label) state.label.className = mergeClasses(fieldClassNames.label, labelStyles.base, horizontal && labelStyles.horizontal, horizontal && size$2 === "small" && labelStyles.horizontalSmall, horizontal && size$2 === "large" && labelStyles.horizontalLarge, !horizontal && labelStyles.vertical, !horizontal && size$2 === "large" && labelStyles.verticalLarge, state.label.className);
		const validationMessageIconBaseClassName = useValidationMessageIconBaseClassName();
		const validationMessageIconStyles = useValidationMessageIconStyles();
		if (state.validationMessageIcon) state.validationMessageIcon.className = mergeClasses(fieldClassNames.validationMessageIcon, validationMessageIconBaseClassName, validationState !== "none" && validationMessageIconStyles[validationState], state.validationMessageIcon.className);
		const secondaryTextBaseClassName = useSecondaryTextBaseClassName$1();
		const secondaryTextStyles = useSecondaryTextStyles();
		if (state.validationMessage) state.validationMessage.className = mergeClasses(fieldClassNames.validationMessage, secondaryTextBaseClassName, validationState === "error" && secondaryTextStyles.error, !!state.validationMessageIcon && secondaryTextStyles.withIcon, state.validationMessage.className);
		if (state.hint) state.hint.className = mergeClasses(fieldClassNames.hint, secondaryTextBaseClassName, state.hint.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-field/lib/components/Field/Field.js
	const Field = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useField_unstable(props, ref);
		useFieldStyles_unstable(state);
		useCustomStyleHook("useFieldStyles_unstable")(state);
		return renderField_unstable(state, useFieldContextValues_unstable(state));
	});
	Field.displayName = "Field";

//#endregion
//#region node_modules/@fluentui/react-checkbox/lib/components/Checkbox/useCheckbox.js
/**
	* Create the state required to render Checkbox.
	*
	* The returned state can be modified with hooks such as useCheckboxStyles_unstable,
	* before being passed to renderCheckbox_unstable.
	*
	* @param props - props from this instance of Checkbox
	* @param ref - reference to `<input>` element of Checkbox
	*/ const useCheckbox_unstable = (props, ref) => {
		"use no memo";
		props = useFieldControlProps_unstable(props, {
			supportsLabelFor: true,
			supportsRequired: true
		});
		const { disabled = false, required, shape = "square", size: size$2 = "medium", labelPosition = "after", onChange } = props;
		const [checked, setChecked] = useControllableState({
			defaultState: props.defaultChecked,
			state: props.checked,
			initialState: false
		});
		const nativeProps = getPartitionedNativeProps({
			props,
			primarySlotTagName: "input",
			excludedPropNames: [
				"checked",
				"defaultChecked",
				"size",
				"onChange"
			]
		});
		const mixed = checked === "mixed";
		const id = useId("checkbox-", nativeProps.primary.id);
		let checkmarkIcon;
		if (mixed) if (shape === "circular") checkmarkIcon = /* @__PURE__ */ react.createElement(CircleFilled, null);
		else checkmarkIcon = size$2 === "large" ? /* @__PURE__ */ react.createElement(Square16Filled, null) : /* @__PURE__ */ react.createElement(Square12Filled, null);
		else if (checked) checkmarkIcon = size$2 === "large" ? /* @__PURE__ */ react.createElement(Checkmark16Filled, null) : /* @__PURE__ */ react.createElement(Checkmark12Filled, null);
		const state = {
			shape,
			checked,
			disabled,
			size: size$2,
			labelPosition,
			components: {
				root: "span",
				input: "input",
				indicator: "div",
				label: Label
			},
			root: always(props.root, {
				defaultProps: {
					ref: useFocusWithin(),
					...nativeProps.root
				},
				elementType: "span"
			}),
			input: always(props.input, {
				defaultProps: {
					type: "checkbox",
					id,
					ref,
					checked: checked === true,
					...nativeProps.primary
				},
				elementType: "input"
			}),
			label: optional(props.label, {
				defaultProps: {
					htmlFor: id,
					disabled,
					required,
					size: "medium"
				},
				elementType: Label
			}),
			indicator: optional(props.indicator, {
				renderByDefault: true,
				defaultProps: {
					"aria-hidden": true,
					children: checkmarkIcon
				},
				elementType: "div"
			})
		};
		state.input.onChange = useEventCallback((ev) => {
			const val = ev.currentTarget.indeterminate ? "mixed" : ev.currentTarget.checked;
			onChange === null || onChange === void 0 || onChange(ev, { checked: val });
			setChecked(val);
		});
		const inputRef = useMergedRefs(state.input.ref);
		state.input.ref = inputRef;
		useIsomorphicLayoutEffect(() => {
			if (inputRef.current) inputRef.current.indeterminate = mixed;
		}, [inputRef, mixed]);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-checkbox/lib/components/Checkbox/renderCheckbox.js
	const renderCheckbox_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(state.root, { children: [
			/* @__PURE__ */ jsx(state.input, {}),
			state.labelPosition === "before" && state.label && /* @__PURE__ */ jsx(state.label, {}),
			state.indicator && /* @__PURE__ */ jsx(state.indicator, {}),
			state.labelPosition === "after" && state.label && /* @__PURE__ */ jsx(state.label, {})
		] });
	};

//#endregion
//#region node_modules/@fluentui/react-checkbox/lib/components/Checkbox/useCheckboxStyles.styles.js
	const checkboxClassNames = {
		root: "fui-Checkbox",
		label: "fui-Checkbox__label",
		input: "fui-Checkbox__input",
		indicator: "fui-Checkbox__indicator"
	};
	const useRootBaseClassName$11 = /* @__PURE__ */ __resetStyles("r1nzur1d", "r128arqq", {
		r: [
			".r1nzur1d{position:relative;display:inline-flex;cursor:pointer;max-width:fit-content;vertical-align:middle;color:var(--colorNeutralForeground3);}",
			".r1nzur1d:focus{outline-style:none;}",
			".r1nzur1d:focus-visible{outline-style:none;}",
			".r1nzur1d[data-fui-focus-within]:focus-within{border-top-color:transparent;border-right-color:transparent;border-bottom-color:transparent;border-left-color:transparent;}",
			".r1nzur1d[data-fui-focus-within]:focus-within::after{content:\"\";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);right:calc(2px * -1);bottom:calc(2px * -1);left:calc(2px * -1);}",
			".r128arqq{position:relative;display:inline-flex;cursor:pointer;max-width:fit-content;vertical-align:middle;color:var(--colorNeutralForeground3);}",
			".r128arqq:focus{outline-style:none;}",
			".r128arqq:focus-visible{outline-style:none;}",
			".r128arqq[data-fui-focus-within]:focus-within{border-top-color:transparent;border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent;}",
			".r128arqq[data-fui-focus-within]:focus-within::after{content:\"\";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);left:calc(2px * -1);bottom:calc(2px * -1);right:calc(2px * -1);}"
		],
		s: ["@media (forced-colors: active){.r1nzur1d[data-fui-focus-within]:focus-within::after{border-top-color:Highlight;border-right-color:Highlight;border-bottom-color:Highlight;border-left-color:Highlight;}}", "@media (forced-colors: active){.r128arqq[data-fui-focus-within]:focus-within::after{border-top-color:Highlight;border-left-color:Highlight;border-bottom-color:Highlight;border-right-color:Highlight;}}"]
	});
	const useRootStyles$22 = /* @__PURE__ */ __styles({
		unchecked: {
			Bi91k9c: "f3p8bqa",
			pv5h1i: "fium13f",
			lj723h: "f1r2dosr",
			Hnthvo: "f1729es6"
		},
		checked: {
			sj55zd: "f19n0e5",
			wkncrt: "f35ds98",
			zxk7z7: "f12mnkne",
			Hmsnfy: "fei9a8h",
			e6czan: "fix56y3",
			pv5h1i: "f1bcv2js",
			qbydtz: "f7dr4go",
			Hnthvo: "f1r5cpua"
		},
		mixed: {
			sj55zd: "f19n0e5",
			Hmsnfy: "f1l27tf0",
			zxk7z7: "fcilktj",
			pv5h1i: "f1lphd54",
			Bunfa6h: "f1obkvq7",
			Hnthvo: "f2gmbuh",
			B15ykmv: "f1oy4fa1"
		},
		disabled: {
			Bceei9c: "f158kwzp",
			sj55zd: "f1s2aq7o",
			Hmsnfy: "f1w7mfl5",
			zxk7z7: "fcoafq6",
			B7iucu3: "f1cyfu5x",
			Bptavk6: "f1lwde8o"
		}
	}, {
		h: [
			".f3p8bqa:hover{color:var(--colorNeutralForeground2);}",
			".fium13f:hover{--fui-Checkbox__indicator--borderColor:var(--colorNeutralStrokeAccessibleHover);}",
			".fix56y3:hover{--fui-Checkbox__indicator--backgroundColor:var(--colorCompoundBrandBackgroundHover);}",
			".f1bcv2js:hover{--fui-Checkbox__indicator--borderColor:var(--colorCompoundBrandBackgroundHover);}",
			".f1lphd54:hover{--fui-Checkbox__indicator--borderColor:var(--colorCompoundBrandStrokeHover);}",
			".f1obkvq7:hover{--fui-Checkbox__indicator--color:var(--colorCompoundBrandForeground1Hover);}"
		],
		a: [
			".f1r2dosr:active{color:var(--colorNeutralForeground1);}",
			".f1729es6:active{--fui-Checkbox__indicator--borderColor:var(--colorNeutralStrokeAccessiblePressed);}",
			".f7dr4go:active{--fui-Checkbox__indicator--backgroundColor:var(--colorCompoundBrandBackgroundPressed);}",
			".f1r5cpua:active{--fui-Checkbox__indicator--borderColor:var(--colorCompoundBrandBackgroundPressed);}",
			".f2gmbuh:active{--fui-Checkbox__indicator--borderColor:var(--colorCompoundBrandStrokePressed);}",
			".f1oy4fa1:active{--fui-Checkbox__indicator--color:var(--colorCompoundBrandForeground1Pressed);}"
		],
		d: [
			".f19n0e5{color:var(--colorNeutralForeground1);}",
			".f35ds98{--fui-Checkbox__indicator--backgroundColor:var(--colorCompoundBrandBackground);}",
			".f12mnkne{--fui-Checkbox__indicator--color:var(--colorNeutralForegroundInverted);}",
			".fei9a8h{--fui-Checkbox__indicator--borderColor:var(--colorCompoundBrandBackground);}",
			".f1l27tf0{--fui-Checkbox__indicator--borderColor:var(--colorCompoundBrandStroke);}",
			".fcilktj{--fui-Checkbox__indicator--color:var(--colorCompoundBrandForeground1);}",
			".f158kwzp{cursor:default;}",
			".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}",
			".f1w7mfl5{--fui-Checkbox__indicator--borderColor:var(--colorNeutralStrokeDisabled);}",
			".fcoafq6{--fui-Checkbox__indicator--color:var(--colorNeutralForegroundDisabled);}"
		],
		m: [["@media (forced-colors: active){.f1cyfu5x{color:GrayText;}}", { m: "(forced-colors: active)" }], ["@media (forced-colors: active){.f1lwde8o{--fui-Checkbox__indicator--color:GrayText;}}", { m: "(forced-colors: active)" }]]
	});
	const useInputBaseClassName$3 = /* @__PURE__ */ __resetStyles("ruo9svu", null, [".ruo9svu{box-sizing:border-box;cursor:inherit;height:100%;margin:0;opacity:0;position:absolute;top:0;width:calc(16px + 2 * var(--spacingHorizontalS));}"]);
	const useInputStyles$9 = /* @__PURE__ */ __styles({
		before: { j35jbq: ["f1e31b4d", "f1vgc2s3"] },
		after: { oyh7mz: ["f1vgc2s3", "f1e31b4d"] },
		large: { a9b677: "f1mq5jt6" }
	}, { d: [
		".f1e31b4d{right:0;}",
		".f1vgc2s3{left:0;}",
		".f1mq5jt6{width:calc(20px + 2 * var(--spacingHorizontalS));}"
	] });
	const useIndicatorBaseClassName$3 = /* @__PURE__ */ __resetStyles("rl7ci6d", null, [".rl7ci6d{align-self:flex-start;box-sizing:border-box;flex-shrink:0;display:flex;align-items:center;justify-content:center;overflow:hidden;color:var(--fui-Checkbox__indicator--color);background-color:var(--fui-Checkbox__indicator--backgroundColor);border-color:var(--fui-Checkbox__indicator--borderColor, var(--colorNeutralStrokeAccessible));border-style:solid;border-width:var(--strokeWidthThin);border-radius:var(--borderRadiusSmall);margin:var(--spacingVerticalS) var(--spacingHorizontalS);fill:currentColor;pointer-events:none;font-size:12px;height:16px;width:16px;}"]);
	const useIndicatorStyles$3 = /* @__PURE__ */ __styles({
		large: {
			Be2twd7: "f4ybsrx",
			Bqenvij: "fjamq6b",
			a9b677: "f64fuq3"
		},
		circular: {
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "f44lkw9"
		}
	}, { d: [
		".f4ybsrx{font-size:16px;}",
		".fjamq6b{height:20px;}",
		".f64fuq3{width:20px;}",
		[".f44lkw9{border-radius:var(--borderRadiusCircular);}", { p: -1 }]
	] });
	const useLabelStyles$5 = /* @__PURE__ */ __styles({
		base: {
			qb2dma: "f7nlbp4",
			sj55zd: "f1ym3bx4",
			Bceei9c: "fpo1scq",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f1f5q0n8"
		},
		before: { z189sj: ["f7x41pl", "fruq291"] },
		after: { uwmqm3: ["fruq291", "f7x41pl"] },
		medium: {
			B6of3ja: "fjzwpt6",
			jrapky: "fh6j2fo"
		},
		large: {
			B6of3ja: "f1xlvstr",
			jrapky: "f49ad5g"
		}
	}, { d: [
		".f7nlbp4{align-self:center;}",
		".f1ym3bx4{color:inherit;}",
		".fpo1scq{cursor:inherit;}",
		[".f1f5q0n8{padding:var(--spacingVerticalS) var(--spacingHorizontalS);}", { p: -1 }],
		".f7x41pl{padding-right:var(--spacingHorizontalXS);}",
		".fruq291{padding-left:var(--spacingHorizontalXS);}",
		".fjzwpt6{margin-top:calc((16px - var(--lineHeightBase300)) / 2);}",
		".fh6j2fo{margin-bottom:calc((16px - var(--lineHeightBase300)) / 2);}",
		".f1xlvstr{margin-top:calc((20px - var(--lineHeightBase300)) / 2);}",
		".f49ad5g{margin-bottom:calc((20px - var(--lineHeightBase300)) / 2);}"
	] });
	/**
	* Apply styling to the Checkbox slots based on the state
	*/
	const useCheckboxStyles_unstable = (state) => {
		"use no memo";
		const { checked, disabled, labelPosition, shape, size: size$2 } = state;
		const rootBaseClassName = useRootBaseClassName$11();
		const rootStyles = useRootStyles$22();
		state.root.className = mergeClasses(checkboxClassNames.root, rootBaseClassName, disabled ? rootStyles.disabled : checked === "mixed" ? rootStyles.mixed : checked ? rootStyles.checked : rootStyles.unchecked, state.root.className);
		const inputBaseClassName = useInputBaseClassName$3();
		const inputStyles = useInputStyles$9();
		state.input.className = mergeClasses(checkboxClassNames.input, inputBaseClassName, size$2 === "large" && inputStyles.large, inputStyles[labelPosition], state.input.className);
		const indicatorBaseClassName = useIndicatorBaseClassName$3();
		const indicatorStyles = useIndicatorStyles$3();
		if (state.indicator) state.indicator.className = mergeClasses(checkboxClassNames.indicator, indicatorBaseClassName, size$2 === "large" && indicatorStyles.large, shape === "circular" && indicatorStyles.circular, state.indicator.className);
		const labelStyles = useLabelStyles$5();
		if (state.label) state.label.className = mergeClasses(checkboxClassNames.label, labelStyles.base, labelStyles[size$2], labelStyles[labelPosition], state.label.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-checkbox/lib/components/Checkbox/Checkbox.js
/**
	* Checkboxes give people a way to select one or more items from a group,
	* or switch between two mutually exclusive options (checked or unchecked).
	*/ const Checkbox = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useCheckbox_unstable(props, ref);
		useCheckboxStyles_unstable(state);
		useCustomStyleHook("useCheckboxStyles_unstable")(state);
		return renderCheckbox_unstable(state);
	});
	Checkbox.displayName = "Checkbox";

//#endregion
//#region node_modules/@fluentui/react-combobox/lib/contexts/ComboboxContext.js
/**
	* @deprecated - use ListboxContext instead
	* @see ListboxContext
	*/ const ComboboxContext = createContext({
		activeOption: void 0,
		appearance: "outline",
		focusVisible: false,
		open: false,
		registerOption() {
			return () => void 0;
		},
		selectedOptions: [],
		selectOption() {},
		setActiveOption() {},
		setOpen() {},
		size: "medium"
	});
	/**
	* @deprecated - render ListboxProvider instead
	* @see ListboxProvider
	* @see useListboxContext_unstable
	*/ const ComboboxProvider = ComboboxContext.Provider;

//#endregion
//#region node_modules/@fluentui/react-combobox/lib/contexts/ListboxContext.js
	const listboxContextDefaultValue = {
		activeOption: void 0,
		focusVisible: false,
		multiselect: false,
		getOptionById() {},
		getOptionsMatchingValue() {
			return [];
		},
		registerOption() {
			return () => void 0;
		},
		selectedOptions: [],
		onOptionClick() {},
		onActiveDescendantChange() {},
		selectOption() {},
		setActiveOption() {}
	};
	const ListboxContext = createContext(void 0);
	const useListboxContext_unstable = (selector) => useContextSelector(ListboxContext, (ctx = listboxContextDefaultValue) => selector(ctx));
	const ListboxProvider = ListboxContext.Provider;

//#endregion
//#region node_modules/@fluentui/react-combobox/lib/contexts/useComboboxContextValues.js
	function useComboboxContextValues(state) {
		const { appearance, open, getOptionById, getOptionsMatchingValue, registerOption, selectedOptions, selectOption, setOpen, size: size$2, activeDescendantController, onOptionClick, onActiveDescendantChange } = state;
		const combobox = {
			activeOption: void 0,
			appearance,
			focusVisible: false,
			open,
			registerOption,
			selectedOptions,
			selectOption,
			setActiveOption: () => null,
			setOpen,
			size: size$2
		};
		const listbox = {
			activeOption: void 0,
			focusVisible: false,
			getOptionById,
			getOptionsMatchingValue,
			registerOption,
			selectedOptions,
			selectOption,
			setActiveOption: () => null,
			onOptionClick,
			onActiveDescendantChange
		};
		return {
			combobox,
			activeDescendant: react.useMemo(() => ({ controller: activeDescendantController }), [activeDescendantController]),
			listbox
		};
	}

//#endregion
//#region node_modules/@fluentui/react-combobox/lib/contexts/useListboxContextValues.js
	function useListboxContextValues(state) {
		const hasListboxContext = useHasParentContext(ListboxContext);
		const { getOptionById, getOptionsMatchingValue, multiselect, registerOption, selectedOptions, selectOption, activeDescendantController } = state;
		const parentRegisterOption = useListboxContext_unstable((ctx) => ctx.registerOption);
		const onOptionClick = useListboxContext_unstable((ctx) => ctx.onOptionClick);
		const onActiveDescendantChange = useListboxContext_unstable((ctx) => ctx.onActiveDescendantChange);
		return {
			listbox: {
				activeOption: void 0,
				focusVisible: false,
				getOptionById,
				getOptionsMatchingValue,
				multiselect,
				registerOption: hasListboxContext ? parentRegisterOption : registerOption,
				selectedOptions,
				selectOption,
				setActiveOption: () => void 0,
				onOptionClick,
				onActiveDescendantChange
			},
			activeDescendant: react.useMemo(() => ({ controller: activeDescendantController }), [activeDescendantController])
		};
	}

//#endregion
//#region node_modules/@fluentui/react-combobox/lib/utils/dropdownKeyActions.js
/**
	* Converts a keyboard interaction into a defined action
	*/ function getDropdownActionFromKey(e, options = {}) {
		const { open = true, multiselect = false } = options;
		const code = e.key;
		const { altKey, ctrlKey, key, metaKey } = e;
		if (key.length === 1 && code !== Space && !altKey && !ctrlKey && !metaKey) return "Type";
		if (!open) {
			if (code === ArrowDown || code === ArrowUp || code === Enter || code === Space) return "Open";
			return "None";
		}
		if (code === ArrowUp && altKey || code === Enter || !multiselect && code === Space) return "CloseSelect";
		if (multiselect && code === Space) return "Select";
		if (code === Escape) return "Close";
		if (code === ArrowDown) return "Next";
		if (code === ArrowUp) return "Previous";
		if (code === Home) return "First";
		if (code === End) return "Last";
		if (code === PageUp) return "PageUp";
		if (code === PageDown) return "PageDown";
		if (code === Tab$1) return "Tab";
		return "None";
	}

//#endregion
//#region node_modules/@fluentui/react-combobox/lib/utils/useOptionCollection.js
/**
	* A hook for managing a collection of child Options
	*/ const useOptionCollection = () => {
		const optionsById = react.useRef(/* @__PURE__ */ new Map());
		const collectionAPI = react.useMemo(() => {
			const getCount = () => optionsById.current.size;
			const getOptionAtIndex = () => void 0;
			const getIndexOfId = () => -1;
			const getOptionById = (id) => {
				return optionsById.current.get(id);
			};
			const getOptionsMatchingText = (matcher) => {
				return Array.from(optionsById.current.values()).filter(({ text }) => matcher(text));
			};
			const getOptionsMatchingValue = (matcher) => {
				const matches = [];
				for (const option of optionsById.current.values()) if (matcher(option.value)) matches.push(option);
				return matches;
			};
			return {
				getCount,
				getOptionAtIndex,
				getIndexOfId,
				getOptionById,
				getOptionsMatchingText,
				getOptionsMatchingValue
			};
		}, []);
		const registerOption = react.useCallback((option) => {
			optionsById.current.set(option.id, option);
			return () => optionsById.current.delete(option.id);
		}, []);
		return {
			...collectionAPI,
			options: Array.from(optionsById.current.values()),
			registerOption
		};
	};

//#endregion
//#region node_modules/@fluentui/react-combobox/lib/utils/useSelection.js
	const useSelection$1 = (props) => {
		const { defaultSelectedOptions, multiselect, onOptionSelect } = props;
		const [selectedOptions, setSelectedOptions] = useControllableState({
			state: props.selectedOptions,
			defaultState: defaultSelectedOptions,
			initialState: []
		});
		const selectOption = react.useCallback((event, option) => {
			if (option.disabled) return;
			let newSelection = [option.value];
			if (multiselect) {
				const selectedIndex = selectedOptions.findIndex((o) => o === option.value);
				if (selectedIndex > -1) newSelection = [...selectedOptions.slice(0, selectedIndex), ...selectedOptions.slice(selectedIndex + 1)];
				else newSelection = [...selectedOptions, option.value];
			}
			setSelectedOptions(newSelection);
			onOptionSelect === null || onOptionSelect === void 0 || onOptionSelect(event, {
				optionValue: option.value,
				optionText: option.text,
				selectedOptions: newSelection
			});
		}, [
			onOptionSelect,
			multiselect,
			selectedOptions,
			setSelectedOptions
		]);
		const clearSelection = (event) => {
			setSelectedOptions([]);
			onOptionSelect === null || onOptionSelect === void 0 || onOptionSelect(event, {
				optionValue: void 0,
				optionText: void 0,
				selectedOptions: []
			});
		};
		return {
			clearSelection,
			selectOption,
			selectedOptions
		};
	};

//#endregion
//#region node_modules/@fluentui/react-combobox/lib/components/Option/useOptionStyles.styles.js
	const optionClassNames = {
		root: "fui-Option",
		checkIcon: "fui-Option__checkIcon"
	};
	/**
	* Styles for the root slot
	*/
	const useStyles$95 = /* @__PURE__ */ __styles({
		root: {
			Bt984gj: "f122n59",
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "ft85np5",
			sj55zd: "f19n0e5",
			i8kkvl: "f1ufnopg",
			Bceei9c: "f1k6fduh",
			mc9l5x: "f22iagw",
			Bahqtrf: "fk6fouc",
			Be2twd7: "fkhj508",
			Bg96gwp: "f1i3iumi",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "fm5eomj",
			qhf8xq: "f10pi13n",
			Jwef8y: "f1knas48",
			Bi91k9c: "feu1g3u",
			zqbkvg: "fo79ri9",
			h82x05: ["f1osiabc", "f1e8le25"],
			cqj998: "f1yusjty",
			j3hlsh: ["f1e8le25", "f1osiabc"],
			ecr2s2: "fb40n2d",
			lj723h: "f1g4hkjv",
			Btxx2vb: "f1lnr2zp",
			sltcwy: ["f1ogfk9z", "f1g7j8ec"],
			dnwvvm: "fiuf46r",
			Blyvkvs: ["f1g7j8ec", "f1ogfk9z"]
		},
		active: {
			Bowz1zl: "f11vrvdw",
			oxogb1: "f17hxjb7",
			Ix2sn8: "f1dha69c",
			q7v32p: "f1lm7500",
			B7cbj04: 0,
			Bewtojm: 0,
			b50fsz: 0,
			B1wzb3v: 0,
			Bqwk70n: 0,
			B37u8z8: 0,
			avt0cx: 0,
			f0sref: 0,
			B9fkznv: 0,
			Be3o27t: 0,
			Bertapg: 0,
			B53xpsf: 0,
			Bsv72rj: 0,
			B39dzdd: 0,
			Btq9bd3: 0,
			Bqfxd14: 0,
			atup0s: "fo7xqb",
			Fffuxt: 0,
			Bttcd12: 0,
			Beitzug: 0,
			Bqougee: 0,
			B86i8pi: "f1kurthe",
			Bhijsxg: "fwq15dy",
			kktds4: "f1pb3wry",
			Bmau3bo: ["ftjv2f4", "f1flhb1f"],
			npektv: ["f1flhb1f", "ftjv2f4"]
		},
		disabled: {
			sj55zd: "f1s2aq7o",
			Jwef8y: "f9ql6rf",
			Bi91k9c: "fvgxktp",
			zqbkvg: "f185j3qj",
			h82x05: ["f1dligi3", "f1vydzie"],
			cqj998: "fjw1di3",
			j3hlsh: ["f1vydzie", "f1dligi3"],
			ecr2s2: "fgj9um3",
			lj723h: "f19wldhg",
			Btxx2vb: "f1ss0kt2",
			sltcwy: ["f1t6oli3", "fjy9ci8"],
			dnwvvm: "fresaxk",
			Blyvkvs: ["fjy9ci8", "f1t6oli3"],
			B7iucu3: "f1cyfu5x"
		},
		selected: {},
		checkIcon: {
			Bnnss6s: "fi64zpg",
			Be2twd7: "fod5ikn",
			Frg6f3: ["f18b9hdq", "fn6qj8t"],
			t21cq0: ["f1xk557c", "f1h9en5y"],
			Bcdw1i0: "fd7fpy0",
			Bo70h7d: "fvc9v3g"
		},
		selectedCheck: { Bcdw1i0: "f1022m68" },
		multiselectCheck: {
			Bgfg5da: 0,
			B9xav0g: 0,
			oivjwe: 0,
			Bn0qgzm: 0,
			B4g9neb: 0,
			zhjwy3: 0,
			wvpqe5: 0,
			ibv6hh: 0,
			u1mtju: 0,
			h3c5rm: 0,
			vrafjx: 0,
			Bekrc4i: 0,
			i8vvqc: 0,
			g2u3we: 0,
			icvyot: 0,
			B4j52fo: 0,
			irswps: "f1l3cf7o",
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "fq9zq91",
			B7ck84d: "f1ewtqcl",
			mc9l5x: "f22iagw",
			Bt984gj: "f122n59",
			Brf1p80: "f4d9j23",
			Bkfmm31: "f1w9h62z",
			Be2twd7: "f1ugzwwg",
			Bqenvij: "fd461yt",
			a9b677: "fjw5fx7",
			Bcdw1i0: "f1022m68"
		},
		selectedMultiselectCheck: {
			De3pzq: "ftywsgz",
			sj55zd: "fqpbvvt",
			g2u3we: "f3xi7mh",
			h3c5rm: ["ftovhe4", "f1wczvin"],
			B9xav0g: "f68vbr6",
			zhjwy3: ["f1wczvin", "ftovhe4"]
		},
		checkDisabled: {
			sj55zd: "f1s2aq7o",
			B7iucu3: "f1cyfu5x"
		},
		multiselectCheckDisabled: {
			g2u3we: "f1r1t4y1",
			h3c5rm: ["fmj8ijw", "figx54m"],
			B9xav0g: "f360ss8",
			zhjwy3: ["figx54m", "fmj8ijw"]
		}
	}, {
		d: [
			".f122n59{align-items:center;}",
			[".ft85np5{border-radius:var(--borderRadiusMedium);}", { p: -1 }],
			".f19n0e5{color:var(--colorNeutralForeground1);}",
			".f1ufnopg{column-gap:var(--spacingHorizontalXS);}",
			".f1k6fduh{cursor:pointer;}",
			".f22iagw{display:flex;}",
			".fk6fouc{font-family:var(--fontFamilyBase);}",
			".fkhj508{font-size:var(--fontSizeBase300);}",
			".f1i3iumi{line-height:var(--lineHeightBase300);}",
			[".fm5eomj{padding:var(--spacingVerticalSNudge) var(--spacingHorizontalS);}", { p: -1 }],
			".f10pi13n{position:relative;}",
			".f11vrvdw[data-activedescendant-focusvisible]::after{content:\"\";}",
			".f17hxjb7[data-activedescendant-focusvisible]::after{position:absolute;}",
			".f1dha69c[data-activedescendant-focusvisible]::after{pointer-events:none;}",
			".f1lm7500[data-activedescendant-focusvisible]::after{z-index:1;}",
			[".fo7xqb[data-activedescendant-focusvisible]::after{border:2px solid var(--colorStrokeFocus2);}", { p: -2 }],
			[".f1kurthe[data-activedescendant-focusvisible]::after{border-radius:var(--borderRadiusMedium);}", { p: -1 }],
			".fwq15dy[data-activedescendant-focusvisible]::after{top:-2px;}",
			".f1pb3wry[data-activedescendant-focusvisible]::after{bottom:-2px;}",
			".ftjv2f4[data-activedescendant-focusvisible]::after{left:-2px;}",
			".f1flhb1f[data-activedescendant-focusvisible]::after{right:-2px;}",
			".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}",
			".fi64zpg{flex-shrink:0;}",
			".fod5ikn{font-size:var(--fontSizeBase400);}",
			".f18b9hdq{margin-left:calc(var(--spacingHorizontalXXS) * -1);}",
			".fn6qj8t{margin-right:calc(var(--spacingHorizontalXXS) * -1);}",
			".f1xk557c{margin-right:var(--spacingHorizontalXXS);}",
			".f1h9en5y{margin-left:var(--spacingHorizontalXXS);}",
			".fd7fpy0{visibility:hidden;}",
			".fvc9v3g svg{display:block;}",
			".f1022m68{visibility:visible;}",
			[".f1l3cf7o{border:var(--strokeWidthThin) solid var(--colorNeutralStrokeAccessible);}", { p: -2 }],
			[".fq9zq91{border-radius:var(--borderRadiusSmall);}", { p: -1 }],
			".f1ewtqcl{box-sizing:border-box;}",
			".f4d9j23{justify-content:center;}",
			".f1w9h62z{fill:currentColor;}",
			".f1ugzwwg{font-size:12px;}",
			".fd461yt{height:16px;}",
			".fjw5fx7{width:16px;}",
			".ftywsgz{background-color:var(--colorCompoundBrandBackground);}",
			".fqpbvvt{color:var(--colorNeutralForegroundInverted);}",
			".f3xi7mh{border-top-color:var(--colorCompoundBrandBackground);}",
			".ftovhe4{border-right-color:var(--colorCompoundBrandBackground);}",
			".f1wczvin{border-left-color:var(--colorCompoundBrandBackground);}",
			".f68vbr6{border-bottom-color:var(--colorCompoundBrandBackground);}",
			".f1r1t4y1{border-top-color:var(--colorNeutralForegroundDisabled);}",
			".fmj8ijw{border-right-color:var(--colorNeutralForegroundDisabled);}",
			".figx54m{border-left-color:var(--colorNeutralForegroundDisabled);}",
			".f360ss8{border-bottom-color:var(--colorNeutralForegroundDisabled);}"
		],
		h: [
			".f1knas48:hover{background-color:var(--colorNeutralBackground1Hover);}",
			".feu1g3u:hover{color:var(--colorNeutralForeground1Hover);}",
			".fo79ri9:hover .fui-Option__checkIcon{border-top-color:var(--colorNeutralForeground1Hover);}",
			".f1osiabc:hover .fui-Option__checkIcon{border-right-color:var(--colorNeutralForeground1Hover);}",
			".f1e8le25:hover .fui-Option__checkIcon{border-left-color:var(--colorNeutralForeground1Hover);}",
			".f1yusjty:hover .fui-Option__checkIcon{border-bottom-color:var(--colorNeutralForeground1Hover);}",
			".f9ql6rf:hover{background-color:var(--colorTransparentBackground);}",
			".fvgxktp:hover{color:var(--colorNeutralForegroundDisabled);}",
			".f185j3qj:hover .fui-Option__checkIcon{border-top-color:var(--colorNeutralForegroundDisabled);}",
			".f1dligi3:hover .fui-Option__checkIcon{border-right-color:var(--colorNeutralForegroundDisabled);}",
			".f1vydzie:hover .fui-Option__checkIcon{border-left-color:var(--colorNeutralForegroundDisabled);}",
			".fjw1di3:hover .fui-Option__checkIcon{border-bottom-color:var(--colorNeutralForegroundDisabled);}"
		],
		a: [
			".fb40n2d:active{background-color:var(--colorNeutralBackground1Pressed);}",
			".f1g4hkjv:active{color:var(--colorNeutralForeground1Pressed);}",
			".f1lnr2zp:active .fui-Option__checkIcon{border-top-color:var(--colorNeutralForeground1Hover);}",
			".f1ogfk9z:active .fui-Option__checkIcon{border-right-color:var(--colorNeutralForeground1Hover);}",
			".f1g7j8ec:active .fui-Option__checkIcon{border-left-color:var(--colorNeutralForeground1Hover);}",
			".fiuf46r:active .fui-Option__checkIcon{border-bottom-color:var(--colorNeutralForeground1Hover);}",
			".fgj9um3:active{background-color:var(--colorTransparentBackground);}",
			".f19wldhg:active{color:var(--colorNeutralForegroundDisabled);}",
			".f1ss0kt2:active .fui-Option__checkIcon{border-top-color:var(--colorNeutralForegroundDisabled);}",
			".f1t6oli3:active .fui-Option__checkIcon{border-right-color:var(--colorNeutralForegroundDisabled);}",
			".fjy9ci8:active .fui-Option__checkIcon{border-left-color:var(--colorNeutralForegroundDisabled);}",
			".fresaxk:active .fui-Option__checkIcon{border-bottom-color:var(--colorNeutralForegroundDisabled);}"
		],
		m: [["@media (forced-colors: active){.f1cyfu5x{color:GrayText;}}", { m: "(forced-colors: active)" }]]
	});
	/**
	* Apply styling to the Option slots based on the state
	*/
	const useOptionStyles_unstable = (state) => {
		"use no memo";
		const { disabled, multiselect, selected } = state;
		const styles = useStyles$95();
		state.root.className = mergeClasses(optionClassNames.root, styles.root, styles.active, disabled && styles.disabled, selected && styles.selected, state.root.className);
		if (state.checkIcon) state.checkIcon.className = mergeClasses(optionClassNames.checkIcon, styles.checkIcon, multiselect && styles.multiselectCheck, selected && styles.selectedCheck, selected && multiselect && styles.selectedMultiselectCheck, disabled && styles.checkDisabled, disabled && multiselect && styles.multiselectCheckDisabled, state.checkIcon.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-combobox/lib/components/Listbox/useListbox.js
	const UNSAFE_noLongerUsed = {
		activeOption: void 0,
		focusVisible: false,
		setActiveOption: () => null
	};
	/**
	* Create the state required to render Listbox.
	*
	* The returned state can be modified with hooks such as useListboxStyles_unstable,
	* before being passed to renderListbox_unstable.
	*
	* @param props - props from this instance of Listbox
	* @param ref - reference to root HTMLElement of Listbox
	*/ const useListbox_unstable = (props, ref) => {
		"use no memo";
		const { multiselect, disableAutoFocus = false } = props;
		const optionCollection = useOptionCollection();
		const { listboxRef: activeDescendantListboxRef, activeParentRef, controller } = useActiveDescendant({ matchOption: (el) => el.classList.contains(optionClassNames.root) });
		const hasListboxContext = useHasParentContext(ListboxContext);
		const onActiveDescendantChange = useListboxContext_unstable((ctx) => ctx.onActiveDescendantChange);
		const contextGetOptionById = useListboxContext_unstable((ctx) => ctx.getOptionById);
		const contextGetOptionsMatchingValue = useListboxContext_unstable((ctx) => ctx.getOptionsMatchingValue);
		const getOptionById = hasListboxContext ? contextGetOptionById : optionCollection.getOptionById;
		const getOptionsMatchingValue = hasListboxContext ? contextGetOptionsMatchingValue : optionCollection.getOptionsMatchingValue;
		const listenerRef = react.useMemo(() => {
			let element = null;
			const listener = (untypedEvent) => {
				onActiveDescendantChange === null || onActiveDescendantChange === void 0 || onActiveDescendantChange(untypedEvent);
			};
			return (el) => {
				if (!el) {
					element === null || element === void 0 || element.removeEventListener("activedescendantchange", listener);
					return;
				}
				element = el;
				element.addEventListener("activedescendantchange", listener);
			};
		}, [onActiveDescendantChange]);
		const [isNavigatingWithKeyboard, setIsNavigatingWithKeyboard] = react.useState(false);
		useOnKeyboardNavigationChange(setIsNavigatingWithKeyboard);
		const activeDescendantContext = useActiveDescendantContext();
		const hasParentActiveDescendantContext = useHasParentActiveDescendantContext();
		const activeDescendantController = hasParentActiveDescendantContext ? activeDescendantContext.controller : controller;
		const { clearSelection, selectedOptions, selectOption } = useSelection$1(props);
		const onKeyDown = (event) => {
			const action = getDropdownActionFromKey(event, { open: true });
			const activeOptionId = activeDescendantController.active();
			const activeOption = activeOptionId ? getOptionById(activeOptionId) : null;
			switch (action) {
				case "First":
				case "Last":
				case "Next":
				case "Previous":
				case "PageDown":
				case "PageUp":
				case "CloseSelect":
				case "Select":
					event.preventDefault();
					break;
			}
			switch (action) {
				case "Next":
					if (activeOption) activeDescendantController.next();
					else activeDescendantController.first();
					break;
				case "Previous":
					if (activeOption) activeDescendantController.prev();
					else activeDescendantController.first();
					break;
				case "PageUp":
				case "First":
					activeDescendantController.first();
					break;
				case "PageDown":
				case "Last":
					activeDescendantController.last();
					break;
				case "Select":
				case "CloseSelect":
					activeOption && selectOption(event, activeOption);
					break;
			}
		};
		const contextSelectedOptions = useListboxContext_unstable((ctx) => ctx.selectedOptions);
		const contextSelectOption = useListboxContext_unstable((ctx) => ctx.selectOption);
		const optionContextValues = hasListboxContext ? {
			selectedOptions: contextSelectedOptions,
			selectOption: contextSelectOption,
			...UNSAFE_noLongerUsed
		} : {
			selectedOptions,
			selectOption,
			...UNSAFE_noLongerUsed
		};
		react.useEffect(() => {
			if (hasParentActiveDescendantContext) return;
			activeDescendantController.hideFocusVisibleAttributes();
			if (!disableAutoFocus) if (!multiselect && optionContextValues.selectedOptions.length > 0) {
				const selectedOption = getOptionsMatchingValue((v) => v === optionContextValues.selectedOptions[0]).pop();
				if (selectedOption === null || selectedOption === void 0 ? void 0 : selectedOption.id) activeDescendantController.focus(selectedOption.id);
			} else activeDescendantController.first();
			return () => {
				activeDescendantController.blur();
			};
		}, []);
		const onFocus = react.useCallback(() => {
			if (hasParentActiveDescendantContext) return;
			activeDescendantController.showFocusVisibleAttributes();
			if (isNavigatingWithKeyboard) activeDescendantController.scrollActiveIntoView();
		}, [
			activeDescendantController,
			hasParentActiveDescendantContext,
			isNavigatingWithKeyboard
		]);
		const onBlur = react.useCallback(() => {
			if (hasParentActiveDescendantContext) return;
			activeDescendantController.hideFocusVisibleAttributes();
		}, [activeDescendantController, hasParentActiveDescendantContext]);
		const state = {
			components: { root: "div" },
			root: always(getIntrinsicElementProps("div", {
				ref: useMergedRefs(ref, activeParentRef, activeDescendantListboxRef, listenerRef),
				role: multiselect ? "menu" : "listbox",
				tabIndex: 0,
				...props
			}), { elementType: "div" }),
			standalone: !hasListboxContext,
			multiselect,
			clearSelection,
			activeDescendantController,
			onActiveDescendantChange,
			...optionCollection,
			...optionContextValues
		};
		state.root.onKeyDown = useEventCallback(mergeCallbacks(state.root.onKeyDown, onKeyDown));
		state.root.onFocus = useEventCallback(mergeCallbacks(state.root.onFocus, onFocus));
		state.root.onBlur = useEventCallback(mergeCallbacks(state.root.onBlur, onBlur));
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-combobox/lib/components/Listbox/renderListbox.js
/**
	* Render the final JSX of Listbox
	*/ const renderListbox_unstable = (state, contextValues) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(ActiveDescendantContextProvider, {
			value: contextValues.activeDescendant,
			children: /* @__PURE__ */ jsx(ListboxContext.Provider, {
				value: contextValues.listbox,
				children: /* @__PURE__ */ jsx(state.root, {})
			})
		});
	};

//#endregion
//#region node_modules/@fluentui/react-combobox/lib/components/Listbox/useListboxStyles.styles.js
	const listboxClassNames = { root: "fui-Listbox" };
	/**
	* Styles for the root slot
	*/
	const useStyles$94 = /* @__PURE__ */ __styles({ root: {
		De3pzq: "fxugw4r",
		B7ck84d: "f1ewtqcl",
		mc9l5x: "f22iagw",
		Beiy3e4: "f1vx9l62",
		Bf4jedk: "f3hsy1e",
		Bmxbyg5: "f5zp4f",
		Bw0xxkn: 0,
		oeaueh: 0,
		Bpd4iqm: 0,
		Befb4lg: "f1iepc6i",
		Byoj8tv: 0,
		uwmqm3: 0,
		z189sj: 0,
		z8tnut: 0,
		B0ocmuz: "f1t35pdg",
		Belr9w4: "fiut8dr"
	} }, { d: [
		".fxugw4r{background-color:var(--colorNeutralBackground1);}",
		".f1ewtqcl{box-sizing:border-box;}",
		".f22iagw{display:flex;}",
		".f1vx9l62{flex-direction:column;}",
		".f3hsy1e{min-width:160px;}",
		".f5zp4f{overflow-y:auto;}",
		[".f1iepc6i{outline:1px solid var(--colorTransparentStroke);}", { p: -1 }],
		[".f1t35pdg{padding:var(--spacingHorizontalXS);}", { p: -1 }],
		".fiut8dr{row-gap:var(--spacingHorizontalXXS);}"
	] });
	/**
	* Apply styling to the Listbox slots based on the state
	*/
	const useListboxStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$94();
		state.root.className = mergeClasses(listboxClassNames.root, styles.root, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-combobox/lib/components/Listbox/Listbox.js
/**
	* Listbox component: a standalone selection control, or the popup in a Combobox
	*/ const Listbox = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useListbox_unstable(props, ref);
		const contextValues = useListboxContextValues(state);
		useListboxStyles_unstable(state);
		useCustomStyleHook("useListboxStyles_unstable")(state);
		return renderListbox_unstable(state, contextValues);
	});
	Listbox.displayName = "Listbox";

//#endregion
//#region node_modules/@fluentui/react-combobox/lib/components/Option/useOption.js
	function getTextString(text, children) {
		if (text !== void 0) return text;
		let textString = "";
		let hasNonStringChild = false;
		react.Children.forEach(children, (child) => {
			if (typeof child === "string") textString += child;
			else hasNonStringChild = true;
		});
		if (hasNonStringChild) console.warn("Provide a `text` prop to Option components when they contain non-string children.");
		return textString;
	}
	/**
	* Create the state required to render Option.
	*
	* The returned state can be modified with hooks such as useOptionStyles_unstable,
	* before being passed to renderOption_unstable.
	*
	* @param props - props from this instance of Option
	* @param ref - reference to root HTMLElement of Option
	*/ const useOption_unstable = (props, ref) => {
		const { children, disabled, text, value } = props;
		const optionRef = react.useRef(null);
		const optionText = getTextString(text, children);
		const optionValue = value !== null && value !== void 0 ? value : optionText;
		const id = useId("fluent-option", props.id);
		const optionData = react.useMemo(() => ({
			id,
			disabled,
			text: optionText,
			value: optionValue
		}), [
			id,
			disabled,
			optionText,
			optionValue
		]);
		const { controller: activeDescendantController } = useActiveDescendantContext();
		const multiselect = useListboxContext_unstable((ctx) => ctx.multiselect);
		const registerOption = useListboxContext_unstable((ctx) => ctx.registerOption);
		const selected = useListboxContext_unstable((ctx) => {
			const selectedOptions = ctx.selectedOptions;
			return optionValue !== void 0 && selectedOptions.find((o) => o === optionValue) !== void 0;
		});
		const selectOption = useListboxContext_unstable((ctx) => ctx.selectOption);
		const onOptionClick = useListboxContext_unstable((ctx) => ctx.onOptionClick);
		let CheckIcon = /* @__PURE__ */ react.createElement(CheckmarkFilled, null);
		if (multiselect) CheckIcon = selected ? /* @__PURE__ */ react.createElement(Checkmark12Filled, null) : "";
		const onClick = (event) => {
			var _props_onClick;
			if (disabled) {
				event.preventDefault();
				return;
			}
			activeDescendantController.focus(id);
			selectOption(event, optionData);
			onOptionClick(event);
			(_props_onClick = props.onClick) === null || _props_onClick === void 0 || _props_onClick.call(props, event);
		};
		react.useEffect(() => {
			if (id && optionRef.current) return registerOption(optionData, optionRef.current);
		}, [
			id,
			optionData,
			registerOption
		]);
		const semanticProps = multiselect ? {
			role: "menuitemcheckbox",
			"aria-checked": selected
		} : {
			role: "option",
			"aria-selected": selected
		};
		return {
			components: {
				root: "div",
				checkIcon: "span"
			},
			root: always(getIntrinsicElementProps("div", {
				ref: useMergedRefs(ref, optionRef),
				"aria-disabled": disabled ? "true" : void 0,
				id,
				...semanticProps,
				...props,
				onClick
			}), { elementType: "div" }),
			checkIcon: optional(props.checkIcon, {
				renderByDefault: true,
				defaultProps: {
					"aria-hidden": "true",
					children: CheckIcon
				},
				elementType: "span"
			}),
			disabled,
			multiselect,
			selected,
			focusVisible: false,
			active: false
		};
	};

//#endregion
//#region node_modules/@fluentui/react-combobox/lib/components/Option/renderOption.js
/**
	* Render the final JSX of Option
	*/ const renderOption_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(state.root, { children: [state.checkIcon && /* @__PURE__ */ jsx(state.checkIcon, {}), state.root.children] });
	};

//#endregion
//#region node_modules/@fluentui/react-combobox/lib/components/Option/Option.js
/**
	* Option component: a styled child option of a Combobox
	*/ const Option = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useOption_unstable(props, ref);
		useOptionStyles_unstable(state);
		useCustomStyleHook("useOptionStyles_unstable")(state);
		return renderOption_unstable(state);
	});
	Option.displayName = "Option";

//#endregion
//#region node_modules/@fluentui/react-combobox/lib/utils/useComboboxBaseState.js
/**
	* @internal
	* State shared between Combobox and Dropdown components
	*/ const useComboboxBaseState = (props) => {
		"use no memo";
		const { appearance = "outline", disableAutoFocus, children, clearable = false, editable = false, inlinePopup = false, mountNode = void 0, multiselect, onOpenChange, size: size$2 = "medium", activeDescendantController, freeform = false, disabled = false, onActiveOptionChange = null } = props;
		const optionCollection = useOptionCollection();
		const { getOptionsMatchingValue } = optionCollection;
		const { getOptionById } = optionCollection;
		const getActiveOption = react.useCallback(() => {
			const activeOptionId = activeDescendantController.active();
			return activeOptionId ? getOptionById(activeOptionId) : void 0;
		}, [activeDescendantController, getOptionById]);
		const UNSAFE_activeOption = getActiveOption();
		const UNSAFE_setActiveOption = react.useCallback((option) => {
			let nextOption = void 0;
			if (typeof option === "function") nextOption = option(getActiveOption());
			if (nextOption) activeDescendantController.focus(nextOption.id);
			else activeDescendantController.blur();
		}, [activeDescendantController, getActiveOption]);
		const [focusVisible, setFocusVisible] = react.useState(false);
		const [hasFocus, setHasFocus] = react.useState(false);
		const ignoreNextBlur = react.useRef(false);
		const isFirstMount = useFirstMount();
		const [controllableValue, setValue] = useControllableState({
			state: props.value,
			initialState: void 0
		});
		const { selectedOptions, selectOption: baseSelectOption, clearSelection } = useSelection$1(props);
		const selectOption = react.useCallback((ev, option) => {
			react_dom.unstable_batchedUpdates(() => {
				setValue(void 0);
				baseSelectOption(ev, option);
			});
		}, [setValue, baseSelectOption]);
		const value = react.useMemo(() => {
			if (controllableValue !== void 0) return controllableValue;
			if (isFirstMount && props.defaultValue !== void 0) return props.defaultValue;
			const selectedOptionsText = getOptionsMatchingValue((optionValue) => {
				return selectedOptions.includes(optionValue);
			}).map((option) => option.text);
			if (multiselect) return editable ? "" : selectedOptionsText.join(", ");
			return selectedOptionsText[0];
		}, [
			controllableValue,
			editable,
			getOptionsMatchingValue,
			multiselect,
			selectedOptions
		]);
		const [open, setOpenState] = useControllableState({
			state: props.open,
			defaultState: props.defaultOpen,
			initialState: false
		});
		const setOpen = react.useCallback((event, newState) => {
			if (disabled) return;
			onOpenChange === null || onOpenChange === void 0 || onOpenChange(event, { open: newState });
			react_dom.unstable_batchedUpdates(() => {
				if (!newState && !freeform) setValue(void 0);
				setOpenState(newState);
			});
		}, [
			onOpenChange,
			setOpenState,
			setValue,
			freeform,
			disabled
		]);
		react.useEffect(() => {
			if (open) {
				if (!multiselect && selectedOptions.length > 0) {
					const selectedOption = getOptionsMatchingValue((v) => v === selectedOptions[0]).pop();
					if (selectedOption === null || selectedOption === void 0 ? void 0 : selectedOption.id) activeDescendantController.focus(selectedOption.id);
				}
			} else activeDescendantController.blur();
		}, [open, activeDescendantController]);
		react.useEffect(() => {
			if (open && !disableAutoFocus && !activeDescendantController.active()) activeDescendantController.first();
		}, [
			open,
			children,
			disableAutoFocus,
			activeDescendantController,
			getOptionById
		]);
		const onActiveDescendantChange = useEventCallback((event) => {
			const previousOption = event.detail.previousId ? optionCollection.getOptionById(event.detail.previousId) : null;
			const nextOption = optionCollection.getOptionById(event.detail.id);
			onActiveOptionChange === null || onActiveOptionChange === void 0 || onActiveOptionChange(event, {
				event,
				type: "change",
				previousOption,
				nextOption
			});
		});
		return {
			...optionCollection,
			freeform,
			disabled,
			selectOption,
			clearSelection,
			selectedOptions,
			activeOption: UNSAFE_activeOption,
			appearance,
			clearable,
			focusVisible,
			ignoreNextBlur,
			inlinePopup,
			mountNode,
			open,
			hasFocus,
			setActiveOption: UNSAFE_setActiveOption,
			setFocusVisible,
			setHasFocus,
			setOpen,
			setValue,
			size: size$2,
			value,
			multiselect,
			onOptionClick: useEventCallback((e) => {
				if (!multiselect) setOpen(e, false);
			}),
			onActiveDescendantChange
		};
	};

//#endregion
//#region node_modules/@fluentui/react-combobox/lib/utils/useComboboxPositioning.js
	function useComboboxPositioning(props) {
		const { positioning } = props;
		const { targetRef, containerRef } = usePositioning({
			position: "below",
			align: "start",
			offset: {
				crossAxis: 0,
				mainAxis: 2
			},
			fallbackPositions: [
				"above",
				"after",
				"after-top",
				"before",
				"before-top"
			],
			matchTargetSize: "width",
			autoSize: true,
			...resolvePositioningShorthand(positioning)
		});
		return [containerRef, targetRef];
	}

//#endregion
//#region node_modules/@fluentui/react-combobox/lib/utils/useListboxSlot.js
/**
	* @internal
	* @returns  listbox slot with desired behaviour and props
	*/ function useListboxSlot(listboxSlotFromProp, ref, options) {
		const { state: { multiselect }, triggerRef, defaultProps } = options;
		const listboxId = useId("fluent-listbox", isResolvedShorthand(listboxSlotFromProp) ? listboxSlotFromProp.id : void 0);
		const listboxSlot = optional(listboxSlotFromProp, {
			renderByDefault: true,
			elementType: Listbox,
			defaultProps: {
				id: listboxId,
				multiselect,
				tabIndex: void 0,
				...defaultProps
			}
		});
		const fieldControlProps = useFieldControlProps_unstable({ id: listboxId }, { supportsLabelFor: true });
		if (listboxSlot && !listboxSlot["aria-label"] && !listboxSlot["aria-labelledby"] && fieldControlProps["aria-labelledby"]) listboxSlot["aria-labelledby"] = fieldControlProps["aria-labelledby"];
		/**
		* Clicking on the listbox should never blur the trigger
		* in a combobox
		*/ const onMouseDown = useEventCallback(mergeCallbacks((event) => {
			event.preventDefault();
		}, listboxSlot === null || listboxSlot === void 0 ? void 0 : listboxSlot.onMouseDown));
		const onClick = useEventCallback(mergeCallbacks((event) => {
			var _triggerRef_current;
			event.preventDefault();
			(_triggerRef_current = triggerRef.current) === null || _triggerRef_current === void 0 || _triggerRef_current.focus();
		}, listboxSlot === null || listboxSlot === void 0 ? void 0 : listboxSlot.onClick));
		const listboxRef = useMergedRefs(listboxSlot === null || listboxSlot === void 0 ? void 0 : listboxSlot.ref, ref);
		if (listboxSlot) {
			listboxSlot.ref = listboxRef;
			listboxSlot.onMouseDown = onMouseDown;
			listboxSlot.onClick = onClick;
		}
		return listboxSlot;
	}

//#endregion
//#region node_modules/@fluentui/react-combobox/lib/utils/useTriggerSlot.js
/**
	* Shared trigger behaviour for combobox and dropdown
	* @returns trigger slot with desired behaviour and props
	*/ function useTriggerSlot(triggerSlotFromProp, ref, options) {
		const { state: { open, setOpen, setHasFocus }, defaultProps, elementType, activeDescendantController } = options;
		const trigger = always(triggerSlotFromProp, {
			defaultProps: {
				type: "text",
				"aria-expanded": open,
				role: "combobox",
				...typeof defaultProps === "object" && defaultProps
			},
			elementType
		});
		trigger.ref = useMergedRefs(react.useRef(null), trigger.ref, ref);
		trigger.onBlur = mergeCallbacks((event) => {
			setOpen(event, false);
			setHasFocus(false);
		}, trigger.onBlur);
		trigger.onFocus = mergeCallbacks((event) => {
			if (event.target === event.currentTarget) setHasFocus(true);
		}, trigger.onFocus);
		trigger.onClick = mergeCallbacks((event) => {
			setOpen(event, !open);
		}, trigger.onClick);
		trigger.onKeyDown = mergeCallbacks(useTriggerKeydown({
			activeDescendantController,
			...options.state
		}), trigger.onKeyDown);
		return trigger;
	}
	function useTriggerKeydown(options) {
		const { activeDescendantController, getOptionById, setOpen, selectOption, multiselect, open } = options;
		const getActiveOption = react.useCallback(() => {
			const activeOptionId = activeDescendantController.active();
			return activeOptionId ? getOptionById(activeOptionId) : void 0;
		}, [activeDescendantController, getOptionById]);
		const first = () => {
			activeDescendantController.first();
		};
		const last = () => {
			activeDescendantController.last();
		};
		const next$1 = (activeOption) => {
			if (activeOption) activeDescendantController.next();
			else activeDescendantController.first();
		};
		const previous = (activeOption) => {
			if (activeOption) activeDescendantController.prev();
			else activeDescendantController.first();
		};
		const pageUp = () => {
			for (let i = 0; i < 10; i++) activeDescendantController.prev();
		};
		const pageDown = () => {
			for (let i = 0; i < 10; i++) activeDescendantController.next();
		};
		const setKeyboardNavigation = useSetKeyboardNavigation();
		return useEventCallback((e) => {
			const action = getDropdownActionFromKey(e, {
				open,
				multiselect
			});
			const activeOption = getActiveOption();
			switch (action) {
				case "First":
				case "Last":
				case "Next":
				case "Previous":
				case "PageDown":
				case "PageUp":
				case "Open":
				case "Close":
				case "CloseSelect":
				case "Select":
					e.preventDefault();
					break;
			}
			setKeyboardNavigation(true);
			switch (action) {
				case "First":
					first();
					break;
				case "Last":
					last();
					break;
				case "Next":
					next$1(activeOption);
					break;
				case "Previous":
					previous(activeOption);
					break;
				case "PageDown":
					pageDown();
					break;
				case "PageUp":
					pageUp();
					break;
				case "Open":
					setOpen(e, true);
					break;
				case "Close":
					e.stopPropagation();
					setOpen(e, false);
					break;
				case "CloseSelect": !multiselect && !(activeOption === null || activeOption === void 0 ? void 0 : activeOption.disabled) && setOpen(e, false);
				case "Select":
					activeOption && selectOption(e, activeOption);
					break;
				case "Tab":
					!multiselect && activeOption && selectOption(e, activeOption);
					break;
			}
		});
	}

//#endregion
//#region node_modules/@fluentui/react-combobox/lib/components/Combobox/useInputTriggerSlot.js
/**
	* @internal
	* useInputTriggerSlot returns a tuple of trigger/listbox shorthand,
	* with the semantics and event handlers needed for the Combobox and Dropdown components.
	* The element type of the ref should always match the element type used in the trigger shorthand.
	*/ function useInputTriggerSlot(triggerFromProps, ref, options) {
		"use no memo";
		const { state: { open, value, selectOption, setValue, multiselect, selectedOptions, clearSelection, getOptionById, setOpen }, freeform, defaultProps, activeDescendantController } = options;
		const onBlur = (event) => {
			if (!open && !freeform) {
				const activeOptionId = activeDescendantController.active();
				const activeOption = activeOptionId ? getOptionById(activeOptionId) : null;
				if (value && activeOption && value.trim().toLowerCase() === (activeOption === null || activeOption === void 0 ? void 0 : activeOption.text.toLowerCase())) selectOption(event, activeOption);
				setValue(void 0);
			}
		};
		const getOptionFromInput = (inputValue) => {
			const searchString = inputValue === null || inputValue === void 0 ? void 0 : inputValue.trim().toLowerCase();
			if (!searchString || searchString.length === 0) {
				activeDescendantController.blur();
				return;
			}
			const matcher = (optionText) => optionText.toLowerCase().indexOf(searchString) === 0;
			const match$1 = activeDescendantController.find((id) => {
				const option = getOptionById(id);
				return !!option && matcher(option.text);
			});
			if (!match$1) {
				activeDescendantController.blur();
				return;
			}
			return getOptionById(match$1);
		};
		const onChange = (event) => {
			const inputValue = event.target.value;
			setValue(inputValue);
			const matchingOption = getOptionFromInput(inputValue);
			if (!multiselect && selectedOptions.length === 1 && (inputValue.length < 1 || !matchingOption)) clearSelection(event);
		};
		const trigger = useTriggerSlot(triggerFromProps, ref, {
			state: options.state,
			defaultProps,
			elementType: "input",
			activeDescendantController
		});
		trigger.onChange = mergeCallbacks(trigger.onChange, onChange);
		trigger.onBlur = mergeCallbacks(trigger.onBlur, onBlur);
		const [hideActiveDescendant, setHideActiveDescendant] = react.useState(false);
		const isTyping = react.useRef(false);
		/**
		* Freeform combobox should not select
		*/ const defaultOnKeyDown = trigger.onKeyDown;
		trigger.onKeyDown = useEventCallback((event) => {
			if (!open && getDropdownActionFromKey(event) === "Type") setOpen(event, true);
			if (event.key === ArrowLeft || event.key === ArrowRight) setHideActiveDescendant(true);
			else setHideActiveDescendant(false);
			const action = getDropdownActionFromKey(event, {
				open,
				multiselect
			});
			if (action === "Type") isTyping.current = true;
			else if (action === "Open" && event.key !== " " || action === "Next" || action === "Previous" || action === "First" || action === "Last" || action === "PageUp" || action === "PageDown") isTyping.current = false;
			if ((isTyping.current || !open) && event.key === " ") {
				var _triggerFromProps_onKeyDown;
				triggerFromProps === null || triggerFromProps === void 0 || (_triggerFromProps_onKeyDown = triggerFromProps.onKeyDown) == null || _triggerFromProps_onKeyDown.call(triggerFromProps, event);
				return;
			}
			defaultOnKeyDown === null || defaultOnKeyDown === void 0 || defaultOnKeyDown(event);
		});
		if (hideActiveDescendant) trigger["aria-activedescendant"] = void 0;
		return trigger;
	}

//#endregion
//#region node_modules/@fluentui/react-combobox/lib/components/Combobox/useCombobox.js
/**
	* Create the state required to render Combobox.
	*
	* The returned state can be modified with hooks such as useComboboxStyles_unstable,
	* before being passed to renderCombobox_unstable.
	*
	* @param props - props from this instance of Combobox
	* @param ref - reference to root HTMLElement of Combobox
	*/ const useCombobox_unstable = (props, ref) => {
		"use no memo";
		var _state_clearIcon, _state_clearIcon1;
		props = useFieldControlProps_unstable(props, {
			supportsLabelFor: true,
			supportsRequired: true,
			supportsSize: true
		});
		const { listboxRef: activeDescendantListboxRef, activeParentRef, controller: activeDescendantController } = useActiveDescendant({ matchOption: (el) => el.classList.contains(optionClassNames.root) });
		const baseState = useComboboxBaseState({
			...props,
			editable: true,
			activeDescendantController
		});
		const { clearable, clearSelection, disabled, multiselect, open, selectedOptions, setOpen, value, hasFocus } = baseState;
		const [comboboxPopupRef, comboboxTargetRef] = useComboboxPositioning(props);
		const { disableAutoFocus = false, freeform, inlinePopup } = props;
		const comboId = useId("combobox-");
		const { primary: triggerNativeProps, root: rootNativeProps } = getPartitionedNativeProps({
			props,
			primarySlotTagName: "input",
			excludedPropNames: ["children", "size"]
		});
		const triggerRef = react.useRef(null);
		const listbox = useListboxSlot(props.listbox, useMergedRefs(comboboxPopupRef, activeDescendantListboxRef), {
			state: baseState,
			triggerRef,
			defaultProps: {
				children: props.children,
				disableAutoFocus
			}
		});
		var _props_input;
		const triggerSlot = useInputTriggerSlot((_props_input = props.input) !== null && _props_input !== void 0 ? _props_input : {}, useMergedRefs(triggerRef, activeParentRef, ref), {
			state: baseState,
			freeform,
			defaultProps: {
				type: "text",
				value: value !== null && value !== void 0 ? value : "",
				"aria-controls": open ? listbox === null || listbox === void 0 ? void 0 : listbox.id : void 0,
				...triggerNativeProps
			},
			activeDescendantController
		});
		const rootSlot = always(props.root, {
			defaultProps: {
				"aria-owns": !inlinePopup && open ? listbox === null || listbox === void 0 ? void 0 : listbox.id : void 0,
				...rootNativeProps
			},
			elementType: "div"
		});
		rootSlot.ref = useMergedRefs(rootSlot.ref, comboboxTargetRef);
		const showClearIcon = selectedOptions.length > 0 && !disabled && clearable && !multiselect;
		const state = {
			components: {
				root: "div",
				input: "input",
				expandIcon: "span",
				listbox: Listbox,
				clearIcon: "span"
			},
			root: rootSlot,
			input: triggerSlot,
			listbox: open || hasFocus ? listbox : void 0,
			clearIcon: optional(props.clearIcon, {
				defaultProps: {
					"aria-hidden": "true",
					children: /* @__PURE__ */ react.createElement(DismissRegular, null)
				},
				elementType: "span",
				renderByDefault: true
			}),
			expandIcon: optional(props.expandIcon, {
				renderByDefault: true,
				defaultProps: {
					"aria-disabled": disabled ? "true" : void 0,
					"aria-expanded": open,
					children: /* @__PURE__ */ react.createElement(ChevronDownRegular, null),
					role: "button"
				},
				elementType: "span"
			}),
			showClearIcon,
			activeDescendantController,
			...baseState
		};
		const { targetDocument } = useFluent();
		useOnClickOutside({
			element: targetDocument,
			callback: (event) => setOpen(event, false),
			refs: [
				triggerRef,
				comboboxPopupRef,
				comboboxTargetRef
			],
			disabled: !open
		});
		const { onMouseDown: onIconMouseDown } = state.expandIcon || {};
		const onExpandIconMouseDown = useEventCallback(mergeCallbacks(onIconMouseDown, (event) => {
			var _triggerRef_current;
			event.preventDefault();
			state.setOpen(event, !state.open);
			(_triggerRef_current = triggerRef.current) === null || _triggerRef_current === void 0 || _triggerRef_current.focus();
		}));
		if (state.expandIcon) {
			state.expandIcon.onMouseDown = onExpandIconMouseDown;
			const hasExpandLabel = state.expandIcon["aria-label"] || state.expandIcon["aria-labelledby"];
			const defaultOpenString = "Open";
			if (!hasExpandLabel) if (props["aria-labelledby"]) {
				var _state_expandIcon_id;
				const chevronId = (_state_expandIcon_id = state.expandIcon.id) !== null && _state_expandIcon_id !== void 0 ? _state_expandIcon_id : `${comboId}-chevron`;
				const chevronLabelledBy = `${chevronId} ${state.input["aria-labelledby"]}`;
				state.expandIcon["aria-label"] = defaultOpenString;
				state.expandIcon.id = chevronId;
				state.expandIcon["aria-labelledby"] = chevronLabelledBy;
			} else if (props["aria-label"]) state.expandIcon["aria-label"] = `${defaultOpenString} ${props["aria-label"]}`;
			else state.expandIcon["aria-label"] = defaultOpenString;
		}
		const onClearIconMouseDown = useEventCallback(mergeCallbacks((_state_clearIcon = state.clearIcon) === null || _state_clearIcon === void 0 ? void 0 : _state_clearIcon.onMouseDown, (ev) => {
			ev.preventDefault();
		}));
		const onClearIconClick = useEventCallback(mergeCallbacks((_state_clearIcon1 = state.clearIcon) === null || _state_clearIcon1 === void 0 ? void 0 : _state_clearIcon1.onClick, (ev) => {
			clearSelection(ev);
		}));
		if (state.clearIcon) {
			state.clearIcon.onMouseDown = onClearIconMouseDown;
			state.clearIcon.onClick = onClearIconClick;
		}
		if (multiselect) state.clearIcon = void 0;
		react.useEffect(() => {
			if (clearable && multiselect) console.error(`[@fluentui/react-combobox] "clearable" prop is not supported in multiselect mode.`);
		}, [clearable, multiselect]);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-combobox/lib/components/Combobox/renderCombobox.js
/**
	* Render the final JSX of Combobox
	*/ const renderCombobox_unstable = (state, contextValues) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, { children: /* @__PURE__ */ jsx(ActiveDescendantContextProvider, {
			value: contextValues.activeDescendant,
			children: /* @__PURE__ */ jsx(ListboxProvider, {
				value: contextValues.listbox,
				children: /* @__PURE__ */ jsxs(ComboboxContext.Provider, {
					value: contextValues.combobox,
					children: [
						/* @__PURE__ */ jsx(state.input, {}),
						state.clearIcon && /* @__PURE__ */ jsx(state.clearIcon, {}),
						state.expandIcon && /* @__PURE__ */ jsx(state.expandIcon, {}),
						state.listbox && (state.inlinePopup ? /* @__PURE__ */ jsx(state.listbox, {}) : /* @__PURE__ */ jsx(Portal, {
							mountNode: state.mountNode,
							children: /* @__PURE__ */ jsx(state.listbox, {})
						}))
					]
				})
			})
		}) });
	};

//#endregion
//#region node_modules/@fluentui/react-combobox/lib/components/Combobox/useComboboxStyles.styles.js
	const comboboxClassNames = {
		root: "fui-Combobox",
		input: "fui-Combobox__input",
		expandIcon: "fui-Combobox__expandIcon",
		clearIcon: "fui-Combobox__clearIcon",
		listbox: "fui-Combobox__listbox"
	};
	/**
	* Styles for Combobox
	*/
	const useStyles$93 = /* @__PURE__ */ __styles({
		root: {
			Bt984gj: "f122n59",
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "ft85np5",
			B7ck84d: "f1ewtqcl",
			i8kkvl: "f14mj54c",
			mc9l5x: "fwk3njj",
			Budl1dq: "fz17x9o",
			Brf1p80: "f1869bpl",
			Bf4jedk: "f1exfvgq",
			qhf8xq: "f10pi13n",
			ha4doy: "fmrv4ls",
			Bbr2w1p: "f14a1fxs",
			Bduesf4: "f3e99gv",
			Bpq79vn: "fhljsf7",
			li1rpt: "f1gw3sf2",
			Bsft5z2: "f13zj6fq",
			E3zdtr: "f1mdlcz9",
			Eqx8gd: ["f1a7op3", "f1cjjd47"],
			By385i5: "f1gboi2j",
			B1piin3: ["f1cjjd47", "f1a7op3"],
			Dlnsje: "f145g4dw",
			d9w3h3: ["f1kp91vd", "f1ibwz09"],
			B3778ie: ["f1ibwz09", "f1kp91vd"],
			B1q35kw: 0,
			Bw17bha: 0,
			Bcgy8vk: 0,
			Bjuhk93: "f1mnjydx",
			Gjdm7m: "f13evtba",
			b1kco5: "f1yk9hq",
			Ba2ppi3: "fhwpy7i",
			F2fol1: "f14ee0xe",
			lck23g: "f1xhbsuh",
			wi16st: "fsrmcvb",
			ywj3b2: "f1t3k7v9",
			umuwi5: "fjw5xc1",
			Blcqepd: "f1xdyd5c",
			nplu4u: "fatpbeo",
			Bioka5o: "fb7uyps",
			Bnupc0a: "fx04xgm",
			bing71: "f1c7in40",
			Bercvud: "f1ibeo51"
		},
		listbox: {
			E5pizo: "f1hg901r",
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "ft85np5",
			Bxyxcbc: "fmmk62d",
			B7ck84d: "f1ewtqcl"
		},
		listboxCollapsed: { mc9l5x: "fjseox" },
		inlineListbox: { Bj3rh1h: "f19g0ac" },
		small: {
			Bqenvij: "frvgh55",
			z189sj: ["fdw0yi8", "fk8j09s"]
		},
		medium: {
			Bqenvij: "f1d2rq10",
			z189sj: ["f11gcy0p", "f1ng84yb"]
		},
		large: {
			i8kkvl: "f1rjii52",
			Bqenvij: "fbhnoac",
			z189sj: ["fw5db7e", "f1uw59to"]
		},
		outline: {
			De3pzq: "fxugw4r",
			Bgfg5da: 0,
			B9xav0g: "f1c1zstj",
			oivjwe: 0,
			Bn0qgzm: 0,
			B4g9neb: 0,
			zhjwy3: 0,
			wvpqe5: 0,
			ibv6hh: 0,
			u1mtju: 0,
			h3c5rm: 0,
			vrafjx: 0,
			Bekrc4i: 0,
			i8vvqc: 0,
			g2u3we: 0,
			icvyot: 0,
			B4j52fo: 0,
			irswps: "fhz96rm"
		},
		outlineInteractive: {
			Bgoe8wy: "fvcxoqz",
			Bwzppfd: ["f1ub3y4t", "f1m52nbi"],
			oetu4i: "f1l4zc64",
			gg5e9n: ["f1m52nbi", "f1ub3y4t"],
			B6oc9vd: "fvs00aa",
			ak43y8: ["f1assf6x", "f4ruux4"],
			wmxk5l: "f1z0osm6",
			B50zh58: ["f4ruux4", "f1assf6x"],
			Bvq3b66: "f1b473iu",
			Brahy3i: ["f381qr8", "ft4skwv"],
			zoxjo1: "f1qzcrsd",
			an54nd: ["ft4skwv", "f381qr8"]
		},
		underline: {
			De3pzq: "f1c21dwh",
			B9xav0g: 0,
			oivjwe: 0,
			Bn0qgzm: 0,
			Bgfg5da: "f9ez7ne",
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "fokr779"
		},
		"filled-lighter": {
			De3pzq: "fxugw4r",
			Bgfg5da: 0,
			B9xav0g: 0,
			oivjwe: 0,
			Bn0qgzm: 0,
			B4g9neb: 0,
			zhjwy3: 0,
			wvpqe5: 0,
			ibv6hh: 0,
			u1mtju: 0,
			h3c5rm: 0,
			vrafjx: 0,
			Bekrc4i: 0,
			i8vvqc: 0,
			g2u3we: 0,
			icvyot: 0,
			B4j52fo: 0,
			irswps: "f88035w"
		},
		"filled-darker": {
			De3pzq: "f16xq7d1",
			Bgfg5da: 0,
			B9xav0g: 0,
			oivjwe: 0,
			Bn0qgzm: 0,
			B4g9neb: 0,
			zhjwy3: 0,
			wvpqe5: 0,
			ibv6hh: 0,
			u1mtju: 0,
			h3c5rm: 0,
			vrafjx: 0,
			Bekrc4i: 0,
			i8vvqc: 0,
			g2u3we: 0,
			icvyot: 0,
			B4j52fo: 0,
			irswps: "f88035w"
		},
		invalid: {
			tvckwq: "fs4k3qj",
			gk2u95: ["fcee079", "fmyw78r"],
			hhx65j: "f1fgmyf4",
			Bxowmz0: ["fmyw78r", "fcee079"]
		},
		invalidUnderline: { hhx65j: "f1fgmyf4" },
		disabled: {
			Bceei9c: "fdrzuqr",
			De3pzq: "f1c21dwh",
			g2u3we: "f1jj8ep1",
			h3c5rm: ["f15xbau", "fy0fskl"],
			B9xav0g: "f4ikngz",
			zhjwy3: ["fy0fskl", "f15xbau"],
			Bcq6wej: "f9dbb4x",
			Jcjdmf: ["f3qs60o", "f5u9ap2"],
			sc4o1m: "fwd1oij",
			Bosien3: ["f5u9ap2", "f3qs60o"]
		}
	}, {
		d: [
			".f122n59{align-items:center;}",
			[".ft85np5{border-radius:var(--borderRadiusMedium);}", { p: -1 }],
			".f1ewtqcl{box-sizing:border-box;}",
			".f14mj54c{column-gap:var(--spacingHorizontalXXS);}",
			".fwk3njj{display:inline-grid;}",
			".fz17x9o{grid-template-columns:1fr auto;}",
			".f1869bpl{justify-content:space-between;}",
			".f1exfvgq{min-width:250px;}",
			".f10pi13n{position:relative;}",
			".fmrv4ls{vertical-align:middle;}",
			".f1gw3sf2::after{box-sizing:border-box;}",
			".f13zj6fq::after{content:\"\";}",
			".f1mdlcz9::after{position:absolute;}",
			".f1a7op3::after{left:-1px;}",
			".f1cjjd47::after{right:-1px;}",
			".f1gboi2j::after{bottom:-1px;}",
			".f145g4dw::after{height:max(2px, var(--borderRadiusMedium));}",
			".f1kp91vd::after{border-bottom-left-radius:var(--borderRadiusMedium);}",
			".f1ibwz09::after{border-bottom-right-radius:var(--borderRadiusMedium);}",
			[".f1mnjydx::after{border-bottom:var(--strokeWidthThick) solid var(--colorCompoundBrandStroke);}", { p: -1 }],
			".f13evtba::after{clip-path:inset(calc(100% - 2px) 0 0 0);}",
			".f1yk9hq::after{transform:scaleX(0);}",
			".fhwpy7i::after{transition-property:transform;}",
			".f14ee0xe::after{transition-duration:var(--durationUltraFast);}",
			".f1xhbsuh::after{transition-delay:var(--curveAccelerateMid);}",
			".f1hg901r{box-shadow:var(--shadow16);}",
			[".ft85np5{border-radius:var(--borderRadiusMedium);}", { p: -1 }],
			".fmmk62d{max-height:80vh;}",
			".fjseox{display:none;}",
			".f19g0ac{z-index:1;}",
			".frvgh55{height:24px;}",
			".fdw0yi8{padding-right:var(--spacingHorizontalSNudge);}",
			".fk8j09s{padding-left:var(--spacingHorizontalSNudge);}",
			".f1d2rq10{height:32px;}",
			".f11gcy0p{padding-right:var(--spacingHorizontalMNudge);}",
			".f1ng84yb{padding-left:var(--spacingHorizontalMNudge);}",
			".f1rjii52{column-gap:var(--spacingHorizontalSNudge);}",
			".fbhnoac{height:40px;}",
			".fw5db7e{padding-right:var(--spacingHorizontalM);}",
			".f1uw59to{padding-left:var(--spacingHorizontalM);}",
			".fxugw4r{background-color:var(--colorNeutralBackground1);}",
			[".fhz96rm{border:var(--strokeWidthThin) solid var(--colorNeutralStroke1);}", { p: -2 }],
			".f1c1zstj{border-bottom-color:var(--colorNeutralStrokeAccessible);}",
			".f1c21dwh{background-color:var(--colorTransparentBackground);}",
			[".f9ez7ne{border-bottom:var(--strokeWidthThin) solid var(--colorNeutralStrokeAccessible);}", { p: -1 }],
			[".fokr779{border-radius:0;}", { p: -1 }],
			[".f88035w{border:var(--strokeWidthThin) solid var(--colorTransparentStroke);}", { p: -2 }],
			".f16xq7d1{background-color:var(--colorNeutralBackground3);}",
			[".f88035w{border:var(--strokeWidthThin) solid var(--colorTransparentStroke);}", { p: -2 }],
			".fs4k3qj:not(:focus-within),.fs4k3qj:hover:not(:focus-within){border-top-color:var(--colorPaletteRedBorder2);}",
			".fcee079:not(:focus-within),.fcee079:hover:not(:focus-within){border-right-color:var(--colorPaletteRedBorder2);}",
			".fmyw78r:not(:focus-within),.fmyw78r:hover:not(:focus-within){border-left-color:var(--colorPaletteRedBorder2);}",
			".f1fgmyf4:not(:focus-within),.f1fgmyf4:hover:not(:focus-within){border-bottom-color:var(--colorPaletteRedBorder2);}",
			".fdrzuqr{cursor:not-allowed;}",
			".f1jj8ep1{border-top-color:var(--colorNeutralStrokeDisabled);}",
			".f15xbau{border-right-color:var(--colorNeutralStrokeDisabled);}",
			".fy0fskl{border-left-color:var(--colorNeutralStrokeDisabled);}",
			".f4ikngz{border-bottom-color:var(--colorNeutralStrokeDisabled);}"
		],
		w: [
			".f14a1fxs:focus-within{outline-width:2px;}",
			".f3e99gv:focus-within{outline-style:solid;}",
			".fhljsf7:focus-within{outline-color:transparent;}",
			".fjw5xc1:focus-within::after{transform:scaleX(1);}",
			".f1xdyd5c:focus-within::after{transition-property:transform;}",
			".fatpbeo:focus-within::after{transition-duration:var(--durationNormal);}",
			".fb7uyps:focus-within::after{transition-delay:var(--curveDecelerateMid);}",
			".f1ibeo51:focus-within:active::after{border-bottom-color:var(--colorCompoundBrandStrokePressed);}",
			".f1b473iu:focus-within{border-top-color:var(--colorNeutralStroke1Pressed);}",
			".f381qr8:focus-within{border-right-color:var(--colorNeutralStroke1Pressed);}",
			".ft4skwv:focus-within{border-left-color:var(--colorNeutralStroke1Pressed);}",
			".f1qzcrsd:focus-within{border-bottom-color:var(--colorNeutralStrokeAccessiblePressed);}"
		],
		m: [
			["@media screen and (prefers-reduced-motion: reduce){.fsrmcvb::after{transition-duration:0.01ms;}}", { m: "screen and (prefers-reduced-motion: reduce)" }],
			["@media screen and (prefers-reduced-motion: reduce){.f1t3k7v9::after{transition-delay:0.01ms;}}", { m: "screen and (prefers-reduced-motion: reduce)" }],
			["@media screen and (prefers-reduced-motion: reduce){.fx04xgm:focus-within::after{transition-duration:0.01ms;}}", { m: "screen and (prefers-reduced-motion: reduce)" }],
			["@media screen and (prefers-reduced-motion: reduce){.f1c7in40:focus-within::after{transition-delay:0.01ms;}}", { m: "screen and (prefers-reduced-motion: reduce)" }],
			["@media (forced-colors: active){.f9dbb4x{border-top-color:GrayText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f3qs60o{border-right-color:GrayText;}.f5u9ap2{border-left-color:GrayText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fwd1oij{border-bottom-color:GrayText;}}", { m: "(forced-colors: active)" }]
		],
		h: [
			".fvcxoqz:hover{border-top-color:var(--colorNeutralStroke1Hover);}",
			".f1ub3y4t:hover{border-right-color:var(--colorNeutralStroke1Hover);}",
			".f1m52nbi:hover{border-left-color:var(--colorNeutralStroke1Hover);}",
			".f1l4zc64:hover{border-bottom-color:var(--colorNeutralStrokeAccessibleHover);}"
		],
		a: [
			".fvs00aa:active{border-top-color:var(--colorNeutralStroke1Pressed);}",
			".f1assf6x:active{border-right-color:var(--colorNeutralStroke1Pressed);}",
			".f4ruux4:active{border-left-color:var(--colorNeutralStroke1Pressed);}",
			".f1z0osm6:active{border-bottom-color:var(--colorNeutralStrokeAccessiblePressed);}"
		]
	});
	const useInputStyles$8 = /* @__PURE__ */ __styles({
		input: {
			qb2dma: "f1ub7u0d",
			De3pzq: "f1c21dwh",
			Bgfg5da: 0,
			B9xav0g: 0,
			oivjwe: 0,
			Bn0qgzm: 0,
			B4g9neb: 0,
			zhjwy3: 0,
			wvpqe5: 0,
			ibv6hh: 0,
			u1mtju: 0,
			h3c5rm: 0,
			vrafjx: 0,
			Bekrc4i: 0,
			i8vvqc: 0,
			g2u3we: 0,
			icvyot: 0,
			B4j52fo: 0,
			irswps: "f3bhgqh",
			sj55zd: "f19n0e5",
			Bahqtrf: "fk6fouc",
			Brovlpu: "ftqa4ok",
			yvdlaj: "fwyc1cq",
			B3o7kgh: "f13ta7ih"
		},
		small: {
			Bahqtrf: "fk6fouc",
			Be2twd7: "fy9rknc",
			Bhrd7zp: "figsok6",
			Bg96gwp: "fwrc4pm",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: ["fxe2rs", "f1gflqzi"]
		},
		medium: {
			Bahqtrf: "fk6fouc",
			Be2twd7: "fkhj508",
			Bhrd7zp: "figsok6",
			Bg96gwp: "f1i3iumi",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: ["fzy81xo", "f58b53b"]
		},
		large: {
			Bahqtrf: "fk6fouc",
			Be2twd7: "fod5ikn",
			Bhrd7zp: "figsok6",
			Bg96gwp: "faaz57k",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: ["f1kdav7a", "footqm6"]
		},
		disabled: {
			sj55zd: "f1s2aq7o",
			De3pzq: "f1c21dwh",
			Bceei9c: "fdrzuqr",
			yvdlaj: "fahhnxm"
		}
	}, {
		d: [
			".f1ub7u0d{align-self:stretch;}",
			".f1c21dwh{background-color:var(--colorTransparentBackground);}",
			[".f3bhgqh{border:none;}", { p: -2 }],
			".f19n0e5{color:var(--colorNeutralForeground1);}",
			".fk6fouc{font-family:var(--fontFamilyBase);}",
			".fwyc1cq::-webkit-input-placeholder{color:var(--colorNeutralForeground4);}",
			".fwyc1cq::-moz-placeholder{color:var(--colorNeutralForeground4);}",
			".f13ta7ih::-webkit-input-placeholder{opacity:1;}",
			".f13ta7ih::-moz-placeholder{opacity:1;}",
			".fy9rknc{font-size:var(--fontSizeBase200);}",
			".figsok6{font-weight:var(--fontWeightRegular);}",
			".fwrc4pm{line-height:var(--lineHeightBase200);}",
			[".fxe2rs{padding:0 0 0 calc(var(--spacingHorizontalSNudge) + var(--spacingHorizontalXXS));}", { p: -1 }],
			[".f1gflqzi{padding:0 calc(var(--spacingHorizontalSNudge) + var(--spacingHorizontalXXS)) 0 0;}", { p: -1 }],
			".fkhj508{font-size:var(--fontSizeBase300);}",
			".f1i3iumi{line-height:var(--lineHeightBase300);}",
			[".fzy81xo{padding:0 0 0 calc(var(--spacingHorizontalMNudge) + var(--spacingHorizontalXXS));}", { p: -1 }],
			[".f58b53b{padding:0 calc(var(--spacingHorizontalMNudge) + var(--spacingHorizontalXXS)) 0 0;}", { p: -1 }],
			".fod5ikn{font-size:var(--fontSizeBase400);}",
			".faaz57k{line-height:var(--lineHeightBase400);}",
			[".f1kdav7a{padding:0 0 0 calc(var(--spacingHorizontalM) + var(--spacingHorizontalSNudge));}", { p: -1 }],
			[".footqm6{padding:0 calc(var(--spacingHorizontalM) + var(--spacingHorizontalSNudge)) 0 0;}", { p: -1 }],
			".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}",
			".fdrzuqr{cursor:not-allowed;}",
			".fahhnxm::-webkit-input-placeholder{color:var(--colorNeutralForegroundDisabled);}",
			".fahhnxm::-moz-placeholder{color:var(--colorNeutralForegroundDisabled);}"
		],
		f: [".ftqa4ok:focus{outline-style:none;}"]
	});
	const useIconStyles$9 = /* @__PURE__ */ __styles({
		icon: {
			B7ck84d: "f1ewtqcl",
			sj55zd: "fxkbij4",
			Bceei9c: "f1k6fduh",
			mc9l5x: "ftgm304",
			Be2twd7: "f1pp30po",
			Bo70h7d: "fvc9v3g"
		},
		hidden: { mc9l5x: "fjseox" },
		visuallyHidden: {
			Bh84pgu: "f1ekcaio",
			Bqenvij: "f1mpe4l3",
			jrapky: 0,
			Frg6f3: 0,
			t21cq0: 0,
			B6of3ja: 0,
			B74szlk: "f1jlpb2r",
			B68tc82: 0,
			Bmxbyg5: 0,
			Bpg54ce: "f1a3p1vp",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f1c5fvqg",
			a9b677: "frkrog8",
			qhf8xq: "f1euv43f"
		},
		small: {
			Be2twd7: "f4ybsrx",
			Frg6f3: ["f1h9en5y", "f1xk557c"]
		},
		medium: {
			Be2twd7: "fe5j1ua",
			Frg6f3: ["f1h9en5y", "f1xk557c"]
		},
		large: {
			Be2twd7: "f1rt2boy",
			Frg6f3: ["f1t5qyk5", "f1ikr372"]
		},
		disabled: {
			sj55zd: "f1s2aq7o",
			Bceei9c: "fdrzuqr"
		}
	}, { d: [
		".f1ewtqcl{box-sizing:border-box;}",
		".fxkbij4{color:var(--colorNeutralStrokeAccessible);}",
		".f1k6fduh{cursor:pointer;}",
		".ftgm304{display:block;}",
		".f1pp30po{font-size:var(--fontSizeBase500);}",
		".fvc9v3g svg{display:block;}",
		".fjseox{display:none;}",
		".f1ekcaio{clip:rect(0px, 0px, 0px, 0px);}",
		".f1mpe4l3{height:1px;}",
		[".f1jlpb2r{margin:-1px;}", { p: -1 }],
		[".f1a3p1vp{overflow:hidden;}", { p: -1 }],
		[".f1c5fvqg{padding:0px;}", { p: -1 }],
		".frkrog8{width:1px;}",
		".f1euv43f{position:absolute;}",
		".f4ybsrx{font-size:16px;}",
		".f1h9en5y{margin-left:var(--spacingHorizontalXXS);}",
		".f1xk557c{margin-right:var(--spacingHorizontalXXS);}",
		".fe5j1ua{font-size:20px;}",
		".f1rt2boy{font-size:24px;}",
		".f1t5qyk5{margin-left:var(--spacingHorizontalSNudge);}",
		".f1ikr372{margin-right:var(--spacingHorizontalSNudge);}",
		".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}",
		".fdrzuqr{cursor:not-allowed;}"
	] });
	/**
	* Apply styling to the Combobox slots based on the state
	*/
	const useComboboxStyles_unstable = (state) => {
		"use no memo";
		const { appearance, open, size: size$2, showClearIcon } = state;
		const invalid = `${state.input["aria-invalid"]}` === "true";
		const disabled = state.input.disabled;
		const styles = useStyles$93();
		const iconStyles = useIconStyles$9();
		const inputStyles = useInputStyles$8();
		state.root.className = mergeClasses(comboboxClassNames.root, styles.root, styles[appearance], styles[size$2], !disabled && appearance === "outline" && styles.outlineInteractive, invalid && appearance !== "underline" && styles.invalid, invalid && appearance === "underline" && styles.invalidUnderline, disabled && styles.disabled, state.root.className);
		state.input.className = mergeClasses(comboboxClassNames.input, inputStyles.input, inputStyles[size$2], disabled && inputStyles.disabled, state.input.className);
		if (state.listbox) state.listbox.className = mergeClasses(comboboxClassNames.listbox, styles.listbox, state.inlinePopup && styles.inlineListbox, !open && styles.listboxCollapsed, state.listbox.className);
		if (state.expandIcon) state.expandIcon.className = mergeClasses(comboboxClassNames.expandIcon, iconStyles.icon, iconStyles[size$2], disabled && iconStyles.disabled, showClearIcon && iconStyles.visuallyHidden, state.expandIcon.className);
		if (state.clearIcon) state.clearIcon.className = mergeClasses(comboboxClassNames.clearIcon, iconStyles.icon, iconStyles[size$2], disabled && iconStyles.disabled, !showClearIcon && iconStyles.hidden, state.clearIcon.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-combobox/lib/components/Combobox/Combobox.js
/**
	* Combobox component: a selection control that allows users to choose from a set of possible options
	*/ const Combobox = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useCombobox_unstable(props, ref);
		const contextValues = useComboboxContextValues(state);
		useComboboxStyles_unstable(state);
		useCustomStyleHook("useComboboxStyles_unstable")(state);
		return renderCombobox_unstable(state, contextValues);
	});
	Combobox.displayName = "Combobox";

//#endregion
//#region node_modules/@fluentui/react-combobox/lib/components/Dropdown/useButtonTriggerSlot.js
/**
	* @internal
	* useButtonTriggerSlot returns a tuple of trigger/listbox shorthand,
	* with the semantics and event handlers needed for the Combobox and Dropdown components.
	* The element type of the ref should always match the element type used in the trigger shorthand.
	*/ function useButtonTriggerSlot(triggerFromProps, ref, options) {
		"use no memo";
		const { state: { open, setOpen, getOptionById }, defaultProps, activeDescendantController } = options;
		const searchString = react.useRef("");
		const [setKeyTimeout, clearKeyTimeout] = useTimeout();
		const moveToNextMatchingOption = (matcher, opt = { startFromNext: false }) => {
			const { startFromNext } = opt;
			const activeOptionId = activeDescendantController.active();
			const nextInOrder = activeDescendantController.find((id) => {
				const option = getOptionById(id);
				return !!option && matcher(option.text);
			}, { startFrom: startFromNext ? activeDescendantController.next({ passive: true }) : activeOptionId });
			if (nextInOrder) return nextInOrder;
			return activeDescendantController.find((id) => {
				const option = getOptionById(id);
				return !!option && matcher(option.text);
			});
		};
		const moveToNextMatchingOptionWithSameCharacterHandling = () => {
			if (moveToNextMatchingOption((optionText) => {
				return optionText.toLocaleLowerCase().indexOf(searchString.current) === 0;
			}, { startFromNext: searchString.current.length === 1 })) return;
			if (allCharactersSame(searchString.current) && moveToNextMatchingOption((optionText) => {
				return optionText.toLocaleLowerCase().indexOf(searchString.current[0]) === 0;
			}, { startFromNext: true })) return;
			activeDescendantController.blur();
		};
		const onTriggerKeyDown = (ev) => {
			clearKeyTimeout();
			if (getDropdownActionFromKey(ev) === "Type") {
				searchString.current += ev.key.toLowerCase();
				setKeyTimeout(() => {
					searchString.current = "";
				}, 500);
				if (open) moveToNextMatchingOptionWithSameCharacterHandling();
				!open && setOpen(ev, true);
			}
		};
		const trigger = useTriggerSlot(triggerFromProps, ref, {
			state: options.state,
			defaultProps,
			elementType: "button",
			activeDescendantController
		});
		trigger.onKeyDown = mergeCallbacks(onTriggerKeyDown, trigger.onKeyDown);
		return trigger;
	}
	/**
	* @returns - whether every character in the string is the same
	*/ function allCharactersSame(str) {
		for (let i = 1; i < str.length; i++) if (str[i] !== str[i - 1]) return false;
		return true;
	}

//#endregion
//#region node_modules/@fluentui/react-combobox/lib/components/Dropdown/useDropdown.js
/**
	* Create the state required to render Dropdown.
	*
	* The returned state can be modified with hooks such as useDropdownStyles_unstable,
	* before being passed to renderDropdown_unstable.
	*
	* @param props - props from this instance of Dropdown
	* @param ref - reference to root HTMLElement of Dropdown
	*/ const useDropdown_unstable = (props, ref) => {
		"use no memo";
		var _state_clearButton;
		props = useFieldControlProps_unstable(props, {
			supportsLabelFor: true,
			supportsSize: true
		});
		const { listboxRef: activeDescendantListboxRef, activeParentRef, controller: activeDescendantController } = useActiveDescendant({ matchOption: (el) => el.classList.contains(optionClassNames.root) });
		const baseState = useComboboxBaseState({
			...props,
			activeDescendantController,
			freeform: false
		});
		const { clearable, clearSelection, disabled, hasFocus, multiselect, open, selectedOptions, setOpen } = baseState;
		const { primary: triggerNativeProps, root: rootNativeProps } = getPartitionedNativeProps({
			props,
			primarySlotTagName: "button",
			excludedPropNames: ["children"]
		});
		const [comboboxPopupRef, comboboxTargetRef] = useComboboxPositioning(props);
		const triggerRef = react.useRef(null);
		const listbox = useListboxSlot(props.listbox, useMergedRefs(comboboxPopupRef, activeDescendantListboxRef), {
			state: baseState,
			triggerRef,
			defaultProps: { children: props.children }
		});
		const { targetDocument } = useFluent();
		useOnClickOutside({
			element: targetDocument,
			callback: (event) => setOpen(event, false),
			refs: [
				triggerRef,
				comboboxPopupRef,
				comboboxTargetRef
			],
			disabled: !open
		});
		var _props_button;
		const trigger = useButtonTriggerSlot((_props_button = props.button) !== null && _props_button !== void 0 ? _props_button : {}, useMergedRefs(triggerRef, activeParentRef, ref), {
			state: baseState,
			defaultProps: {
				type: "button",
				tabIndex: triggerNativeProps.disabled ? void 0 : 0,
				children: baseState.value || props.placeholder,
				"aria-controls": open ? listbox === null || listbox === void 0 ? void 0 : listbox.id : void 0,
				...triggerNativeProps
			},
			activeDescendantController
		});
		const rootSlot = always(props.root, {
			defaultProps: {
				"aria-owns": !props.inlinePopup && open ? listbox === null || listbox === void 0 ? void 0 : listbox.id : void 0,
				children: props.children,
				...rootNativeProps
			},
			elementType: "div"
		});
		rootSlot.ref = useMergedRefs(rootSlot.ref, comboboxTargetRef);
		const showClearButton = selectedOptions.length > 0 && !disabled && clearable && !multiselect;
		const state = {
			components: {
				root: "div",
				button: "button",
				clearButton: "button",
				expandIcon: "span",
				listbox: Listbox
			},
			root: rootSlot,
			button: trigger,
			listbox: open || hasFocus ? listbox : void 0,
			clearButton: optional(props.clearButton, {
				defaultProps: {
					"aria-label": "Clear selection",
					children: /* @__PURE__ */ react.createElement(DismissRegular, null),
					tabIndex: showClearButton ? 0 : void 0,
					type: "button"
				},
				elementType: "button",
				renderByDefault: true
			}),
			expandIcon: optional(props.expandIcon, {
				renderByDefault: true,
				defaultProps: { children: /* @__PURE__ */ react.createElement(ChevronDownRegular, null) },
				elementType: "span"
			}),
			placeholderVisible: !baseState.value && !!props.placeholder,
			showClearButton,
			activeDescendantController,
			...baseState
		};
		const onClearButtonClick = useEventCallback(mergeCallbacks((_state_clearButton = state.clearButton) === null || _state_clearButton === void 0 ? void 0 : _state_clearButton.onClick, (ev) => {
			var _triggerRef_current;
			clearSelection(ev);
			(_triggerRef_current = triggerRef.current) === null || _triggerRef_current === void 0 || _triggerRef_current.focus();
		}));
		if (state.clearButton) state.clearButton.onClick = onClearButtonClick;
		if (multiselect) state.clearButton = void 0;
		react.useEffect(() => {
			if (clearable && multiselect) console.error(`[@fluentui/react-combobox] "clearable" prop is not supported in multiselect mode.`);
		}, [clearable, multiselect]);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-combobox/lib/components/Dropdown/renderDropdown.js
/**
	* Render the final JSX of Dropdown
	*/ const renderDropdown_unstable = (state, contextValues) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, { children: /* @__PURE__ */ jsx(ActiveDescendantContextProvider, {
			value: contextValues.activeDescendant,
			children: /* @__PURE__ */ jsx(ListboxContext.Provider, {
				value: contextValues.listbox,
				children: /* @__PURE__ */ jsxs(ComboboxContext.Provider, {
					value: contextValues.combobox,
					children: [
						/* @__PURE__ */ jsxs(state.button, { children: [state.button.children, state.expandIcon && /* @__PURE__ */ jsx(state.expandIcon, {})] }),
						state.clearButton && /* @__PURE__ */ jsx(state.clearButton, {}),
						state.listbox && (state.inlinePopup ? /* @__PURE__ */ jsx(state.listbox, {}) : /* @__PURE__ */ jsx(Portal, {
							mountNode: state.mountNode,
							children: /* @__PURE__ */ jsx(state.listbox, {})
						}))
					]
				})
			})
		}) });
	};

//#endregion
//#region node_modules/@fluentui/react-combobox/lib/components/Dropdown/useDropdownStyles.styles.js
	const dropdownClassNames = {
		root: "fui-Dropdown",
		button: "fui-Dropdown__button",
		clearButton: "fui-Dropdown__clearButton",
		expandIcon: "fui-Dropdown__expandIcon",
		listbox: "fui-Dropdown__listbox"
	};
	/**
	* Styles for Dropdown
	*/
	const useStyles$92 = /* @__PURE__ */ __styles({
		root: {
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "ft85np5",
			B7ck84d: "f1ewtqcl",
			mc9l5x: "ftuwxu6",
			Bf4jedk: "f1exfvgq",
			qhf8xq: "f10pi13n",
			ha4doy: "fmrv4ls",
			Bbr2w1p: "f14a1fxs",
			Bduesf4: "f3e99gv",
			Bpq79vn: "fhljsf7",
			li1rpt: "f1gw3sf2",
			Bsft5z2: "f13zj6fq",
			E3zdtr: "f1mdlcz9",
			Eqx8gd: ["f1a7op3", "f1cjjd47"],
			By385i5: "f1gboi2j",
			B1piin3: ["f1cjjd47", "f1a7op3"],
			Dlnsje: "ffyw7fx",
			d9w3h3: ["f1kp91vd", "f1ibwz09"],
			B3778ie: ["f1ibwz09", "f1kp91vd"],
			B1q35kw: 0,
			Bw17bha: 0,
			Bcgy8vk: 0,
			Bjuhk93: "f1mnjydx",
			Gjdm7m: "f13evtba",
			b1kco5: "f1yk9hq",
			Ba2ppi3: "fhwpy7i",
			F2fol1: "f14ee0xe",
			lck23g: "f1xhbsuh",
			wi16st: "fsrmcvb",
			ywj3b2: "f1t3k7v9",
			umuwi5: "fjw5xc1",
			Blcqepd: "f1xdyd5c",
			nplu4u: "fatpbeo",
			Bioka5o: "fb7uyps",
			Bnupc0a: "fx04xgm",
			bing71: "f1c7in40",
			Bercvud: "f1ibeo51",
			Br277j9: "f18qfb8s",
			Btis473: "f1m082s7"
		},
		listbox: {
			B7ck84d: "f1ewtqcl",
			E5pizo: "f1hg901r",
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "ft85np5",
			Bxyxcbc: "fmmk62d"
		},
		listboxCollapsed: { mc9l5x: "fjseox" },
		inlineListbox: { Bj3rh1h: "f19g0ac" },
		button: {
			Bt984gj: "f122n59",
			De3pzq: "f1c21dwh",
			Bgfg5da: 0,
			B9xav0g: 0,
			oivjwe: 0,
			Bn0qgzm: 0,
			B4g9neb: 0,
			zhjwy3: 0,
			wvpqe5: 0,
			ibv6hh: 0,
			u1mtju: 0,
			h3c5rm: 0,
			vrafjx: 0,
			Bekrc4i: 0,
			i8vvqc: 0,
			g2u3we: 0,
			icvyot: 0,
			B4j52fo: 0,
			irswps: "f3bhgqh",
			B7ck84d: "f1ewtqcl",
			sj55zd: "f19n0e5",
			i8kkvl: "f14mj54c",
			Bceei9c: "f1k6fduh",
			mc9l5x: "f13qh94s",
			Bahqtrf: "fk6fouc",
			Budl1dq: "f12nh0o2",
			Brf1p80: "f1869bpl",
			fsow6f: ["f1o700av", "fes3tcz"],
			a9b677: "fly5x3f",
			Brovlpu: "ftqa4ok"
		},
		placeholder: { sj55zd: "fxc4j92" },
		small: {
			Bahqtrf: "fk6fouc",
			Be2twd7: "fy9rknc",
			Bhrd7zp: "figsok6",
			Bg96gwp: "fwrc4pm",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: ["fye6m5k", "f3cq2dl"]
		},
		medium: {
			Bahqtrf: "fk6fouc",
			Be2twd7: "fkhj508",
			Bhrd7zp: "figsok6",
			Bg96gwp: "f1i3iumi",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: ["f14ev680", "f58uxzw"]
		},
		large: {
			i8kkvl: "f1rjii52",
			Bahqtrf: "fk6fouc",
			Be2twd7: "fod5ikn",
			Bhrd7zp: "figsok6",
			Bg96gwp: "faaz57k",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: ["f139mn7i", "f1v3q0m"]
		},
		outline: {
			De3pzq: "fxugw4r",
			Bgfg5da: 0,
			B9xav0g: "f1c1zstj",
			oivjwe: 0,
			Bn0qgzm: 0,
			B4g9neb: 0,
			zhjwy3: 0,
			wvpqe5: 0,
			ibv6hh: 0,
			u1mtju: 0,
			h3c5rm: 0,
			vrafjx: 0,
			Bekrc4i: 0,
			i8vvqc: 0,
			g2u3we: 0,
			icvyot: 0,
			B4j52fo: 0,
			irswps: "fhz96rm"
		},
		outlineInteractive: {
			Bgoe8wy: "fvcxoqz",
			Bwzppfd: ["f1ub3y4t", "f1m52nbi"],
			oetu4i: "f1l4zc64",
			gg5e9n: ["f1m52nbi", "f1ub3y4t"],
			B6oc9vd: "fvs00aa",
			ak43y8: ["f1assf6x", "f4ruux4"],
			wmxk5l: "f1z0osm6",
			B50zh58: ["f4ruux4", "f1assf6x"],
			Bvq3b66: "f1b473iu",
			Brahy3i: ["f381qr8", "ft4skwv"],
			zoxjo1: "f1qzcrsd",
			an54nd: ["ft4skwv", "f381qr8"]
		},
		underline: {
			De3pzq: "f1c21dwh",
			B9xav0g: 0,
			oivjwe: 0,
			Bn0qgzm: 0,
			Bgfg5da: "f9ez7ne",
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "fokr779"
		},
		"filled-lighter": {
			De3pzq: "fxugw4r",
			Bgfg5da: 0,
			B9xav0g: 0,
			oivjwe: 0,
			Bn0qgzm: 0,
			B4g9neb: 0,
			zhjwy3: 0,
			wvpqe5: 0,
			ibv6hh: 0,
			u1mtju: 0,
			h3c5rm: 0,
			vrafjx: 0,
			Bekrc4i: 0,
			i8vvqc: 0,
			g2u3we: 0,
			icvyot: 0,
			B4j52fo: 0,
			irswps: "fs2rfia"
		},
		"filled-darker": {
			De3pzq: "f16xq7d1",
			Bgfg5da: 0,
			B9xav0g: 0,
			oivjwe: 0,
			Bn0qgzm: 0,
			B4g9neb: 0,
			zhjwy3: 0,
			wvpqe5: 0,
			ibv6hh: 0,
			u1mtju: 0,
			h3c5rm: 0,
			vrafjx: 0,
			Bekrc4i: 0,
			i8vvqc: 0,
			g2u3we: 0,
			icvyot: 0,
			B4j52fo: 0,
			irswps: "fs2rfia"
		},
		invalid: {
			tvckwq: "fs4k3qj",
			gk2u95: ["fcee079", "fmyw78r"],
			hhx65j: "f1fgmyf4",
			Bxowmz0: ["fmyw78r", "fcee079"]
		},
		invalidUnderline: { hhx65j: "f1fgmyf4" },
		disabled: {
			Bceei9c: "fdrzuqr",
			De3pzq: "f1c21dwh",
			g2u3we: "f1jj8ep1",
			h3c5rm: ["f15xbau", "fy0fskl"],
			B9xav0g: "f4ikngz",
			zhjwy3: ["fy0fskl", "f15xbau"],
			Bcq6wej: "f9dbb4x",
			Jcjdmf: ["f3qs60o", "f5u9ap2"],
			sc4o1m: "fwd1oij",
			Bosien3: ["f5u9ap2", "f3qs60o"]
		},
		disabledText: {
			sj55zd: "f1s2aq7o",
			Bceei9c: "fdrzuqr"
		},
		hidden: { mc9l5x: "fjseox" }
	}, {
		d: [
			[".ft85np5{border-radius:var(--borderRadiusMedium);}", { p: -1 }],
			".f1ewtqcl{box-sizing:border-box;}",
			".ftuwxu6{display:inline-flex;}",
			".f1exfvgq{min-width:250px;}",
			".f10pi13n{position:relative;}",
			".fmrv4ls{vertical-align:middle;}",
			".f1gw3sf2::after{box-sizing:border-box;}",
			".f13zj6fq::after{content:\"\";}",
			".f1mdlcz9::after{position:absolute;}",
			".f1a7op3::after{left:-1px;}",
			".f1cjjd47::after{right:-1px;}",
			".f1gboi2j::after{bottom:-1px;}",
			".ffyw7fx::after{height:max(var(--strokeWidthThick), var(--borderRadiusMedium));}",
			".f1kp91vd::after{border-bottom-left-radius:var(--borderRadiusMedium);}",
			".f1ibwz09::after{border-bottom-right-radius:var(--borderRadiusMedium);}",
			[".f1mnjydx::after{border-bottom:var(--strokeWidthThick) solid var(--colorCompoundBrandStroke);}", { p: -1 }],
			".f13evtba::after{clip-path:inset(calc(100% - 2px) 0 0 0);}",
			".f1yk9hq::after{transform:scaleX(0);}",
			".fhwpy7i::after{transition-property:transform;}",
			".f14ee0xe::after{transition-duration:var(--durationUltraFast);}",
			".f1xhbsuh::after{transition-delay:var(--curveAccelerateMid);}",
			".f1hg901r{box-shadow:var(--shadow16);}",
			[".ft85np5{border-radius:var(--borderRadiusMedium);}", { p: -1 }],
			".fmmk62d{max-height:80vh;}",
			".fjseox{display:none;}",
			".f19g0ac{z-index:1;}",
			".f122n59{align-items:center;}",
			".f1c21dwh{background-color:var(--colorTransparentBackground);}",
			[".f3bhgqh{border:none;}", { p: -2 }],
			".f19n0e5{color:var(--colorNeutralForeground1);}",
			".f14mj54c{column-gap:var(--spacingHorizontalXXS);}",
			".f1k6fduh{cursor:pointer;}",
			".f13qh94s{display:grid;}",
			".fk6fouc{font-family:var(--fontFamilyBase);}",
			".f12nh0o2{grid-template-columns:[content] 1fr [icon] auto [end];}",
			".f1869bpl{justify-content:space-between;}",
			".f1o700av{text-align:left;}",
			".fes3tcz{text-align:right;}",
			".fly5x3f{width:100%;}",
			".fxc4j92{color:var(--colorNeutralForeground4);}",
			".fy9rknc{font-size:var(--fontSizeBase200);}",
			".figsok6{font-weight:var(--fontWeightRegular);}",
			".fwrc4pm{line-height:var(--lineHeightBase200);}",
			[".fye6m5k{padding:3px var(--spacingHorizontalSNudge) 3px calc(var(--spacingHorizontalSNudge) + var(--spacingHorizontalXXS));}", { p: -1 }],
			[".f3cq2dl{padding:3px calc(var(--spacingHorizontalSNudge) + var(--spacingHorizontalXXS)) 3px var(--spacingHorizontalSNudge);}", { p: -1 }],
			".fkhj508{font-size:var(--fontSizeBase300);}",
			".f1i3iumi{line-height:var(--lineHeightBase300);}",
			[".f14ev680{padding:5px var(--spacingHorizontalMNudge) 5px calc(var(--spacingHorizontalMNudge) + var(--spacingHorizontalXXS));}", { p: -1 }],
			[".f58uxzw{padding:5px calc(var(--spacingHorizontalMNudge) + var(--spacingHorizontalXXS)) 5px var(--spacingHorizontalMNudge);}", { p: -1 }],
			".f1rjii52{column-gap:var(--spacingHorizontalSNudge);}",
			".fod5ikn{font-size:var(--fontSizeBase400);}",
			".faaz57k{line-height:var(--lineHeightBase400);}",
			[".f139mn7i{padding:7px var(--spacingHorizontalM) 7px calc(var(--spacingHorizontalM) + var(--spacingHorizontalSNudge));}", { p: -1 }],
			[".f1v3q0m{padding:7px calc(var(--spacingHorizontalM) + var(--spacingHorizontalSNudge)) 7px var(--spacingHorizontalM);}", { p: -1 }],
			".fxugw4r{background-color:var(--colorNeutralBackground1);}",
			[".fhz96rm{border:var(--strokeWidthThin) solid var(--colorNeutralStroke1);}", { p: -2 }],
			".f1c1zstj{border-bottom-color:var(--colorNeutralStrokeAccessible);}",
			[".f9ez7ne{border-bottom:var(--strokeWidthThin) solid var(--colorNeutralStrokeAccessible);}", { p: -1 }],
			[".fokr779{border-radius:0;}", { p: -1 }],
			[".fs2rfia{border:var(--strokeWidthThin) solid transparent;}", { p: -2 }],
			".f16xq7d1{background-color:var(--colorNeutralBackground3);}",
			[".fs2rfia{border:var(--strokeWidthThin) solid transparent;}", { p: -2 }],
			".fs4k3qj:not(:focus-within),.fs4k3qj:hover:not(:focus-within){border-top-color:var(--colorPaletteRedBorder2);}",
			".fcee079:not(:focus-within),.fcee079:hover:not(:focus-within){border-right-color:var(--colorPaletteRedBorder2);}",
			".fmyw78r:not(:focus-within),.fmyw78r:hover:not(:focus-within){border-left-color:var(--colorPaletteRedBorder2);}",
			".f1fgmyf4:not(:focus-within),.f1fgmyf4:hover:not(:focus-within){border-bottom-color:var(--colorPaletteRedBorder2);}",
			".fdrzuqr{cursor:not-allowed;}",
			".f1jj8ep1{border-top-color:var(--colorNeutralStrokeDisabled);}",
			".f15xbau{border-right-color:var(--colorNeutralStrokeDisabled);}",
			".fy0fskl{border-left-color:var(--colorNeutralStrokeDisabled);}",
			".f4ikngz{border-bottom-color:var(--colorNeutralStrokeDisabled);}",
			".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}"
		],
		w: [
			".f14a1fxs:focus-within{outline-width:2px;}",
			".f3e99gv:focus-within{outline-style:solid;}",
			".fhljsf7:focus-within{outline-color:transparent;}",
			".fjw5xc1:focus-within::after{transform:scaleX(1);}",
			".f1xdyd5c:focus-within::after{transition-property:transform;}",
			".fatpbeo:focus-within::after{transition-duration:var(--durationNormal);}",
			".fb7uyps:focus-within::after{transition-delay:var(--curveDecelerateMid);}",
			".f1ibeo51:focus-within:active::after{border-bottom-color:var(--colorCompoundBrandStrokePressed);}",
			".f1b473iu:focus-within{border-top-color:var(--colorNeutralStroke1Pressed);}",
			".f381qr8:focus-within{border-right-color:var(--colorNeutralStroke1Pressed);}",
			".ft4skwv:focus-within{border-left-color:var(--colorNeutralStroke1Pressed);}",
			".f1qzcrsd:focus-within{border-bottom-color:var(--colorNeutralStrokeAccessiblePressed);}"
		],
		m: [
			["@media screen and (prefers-reduced-motion: reduce){.fsrmcvb::after{transition-duration:0.01ms;}}", { m: "screen and (prefers-reduced-motion: reduce)" }],
			["@media screen and (prefers-reduced-motion: reduce){.f1t3k7v9::after{transition-delay:0.01ms;}}", { m: "screen and (prefers-reduced-motion: reduce)" }],
			["@media screen and (prefers-reduced-motion: reduce){.fx04xgm:focus-within::after{transition-duration:0.01ms;}}", { m: "screen and (prefers-reduced-motion: reduce)" }],
			["@media screen and (prefers-reduced-motion: reduce){.f1c7in40:focus-within::after{transition-delay:0.01ms;}}", { m: "screen and (prefers-reduced-motion: reduce)" }],
			["@media (forced-colors: active){.f9dbb4x{border-top-color:GrayText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f3qs60o{border-right-color:GrayText;}.f5u9ap2{border-left-color:GrayText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fwd1oij{border-bottom-color:GrayText;}}", { m: "(forced-colors: active)" }]
		],
		t: ["@supports selector(:has(*)){.f18qfb8s:has(.fui-Dropdown__clearButton:focus)::after{border-bottom-color:initial;}}", "@supports selector(:has(*)){.f1m082s7:has(.fui-Dropdown__clearButton:focus)::after{transform:scaleX(0);}}"],
		f: [".ftqa4ok:focus{outline-style:none;}"],
		h: [
			".fvcxoqz:hover{border-top-color:var(--colorNeutralStroke1Hover);}",
			".f1ub3y4t:hover{border-right-color:var(--colorNeutralStroke1Hover);}",
			".f1m52nbi:hover{border-left-color:var(--colorNeutralStroke1Hover);}",
			".f1l4zc64:hover{border-bottom-color:var(--colorNeutralStrokeAccessibleHover);}"
		],
		a: [
			".fvs00aa:active{border-top-color:var(--colorNeutralStroke1Pressed);}",
			".f1assf6x:active{border-right-color:var(--colorNeutralStroke1Pressed);}",
			".f4ruux4:active{border-left-color:var(--colorNeutralStroke1Pressed);}",
			".f1z0osm6:active{border-bottom-color:var(--colorNeutralStrokeAccessiblePressed);}"
		]
	});
	const useIconStyles$8 = /* @__PURE__ */ __styles({
		icon: {
			B7ck84d: "f1ewtqcl",
			sj55zd: "fxkbij4",
			mc9l5x: "ftgm304",
			Be2twd7: "f1pp30po",
			Br312pm: "f12w6cgp",
			Bw0ie65: "f8bv1bt",
			Bo70h7d: "fvc9v3g"
		},
		small: {
			Be2twd7: "f4ybsrx",
			Frg6f3: ["f1h9en5y", "f1xk557c"]
		},
		medium: {
			Be2twd7: "fe5j1ua",
			Frg6f3: ["f1h9en5y", "f1xk557c"]
		},
		large: {
			Be2twd7: "f1rt2boy",
			Frg6f3: ["f1t5qyk5", "f1ikr372"]
		},
		disabled: { sj55zd: "f1s2aq7o" }
	}, { d: [
		".f1ewtqcl{box-sizing:border-box;}",
		".fxkbij4{color:var(--colorNeutralStrokeAccessible);}",
		".ftgm304{display:block;}",
		".f1pp30po{font-size:var(--fontSizeBase500);}",
		".f12w6cgp{grid-column-start:icon;}",
		".f8bv1bt{grid-column-end:end;}",
		".fvc9v3g svg{display:block;}",
		".f4ybsrx{font-size:16px;}",
		".f1h9en5y{margin-left:var(--spacingHorizontalXXS);}",
		".f1xk557c{margin-right:var(--spacingHorizontalXXS);}",
		".fe5j1ua{font-size:20px;}",
		".f1rt2boy{font-size:24px;}",
		".f1t5qyk5{margin-left:var(--spacingHorizontalSNudge);}",
		".f1ikr372{margin-right:var(--spacingHorizontalSNudge);}",
		".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}"
	] });
	const useBaseClearButtonStyle = /* @__PURE__ */ __resetStyles("rticfuj", "r1vp6jef", {
		r: [
			".rticfuj{align-self:center;background-color:var(--colorTransparentBackground);border:none;cursor:pointer;height:fit-content;margin:0;margin-right:var(--spacingHorizontalMNudge);padding:0;position:relative;}",
			".rticfuj:focus{outline-style:none;}",
			".rticfuj:focus-visible{outline-style:none;}",
			".rticfuj[data-fui-focus-visible]{border-top-color:transparent;border-right-color:transparent;border-bottom-color:transparent;border-left-color:transparent;}",
			".rticfuj[data-fui-focus-visible]::after{content:\"\";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);right:calc(2px * -1);bottom:calc(2px * -1);left:calc(2px * -1);}",
			".r1vp6jef{align-self:center;background-color:var(--colorTransparentBackground);border:none;cursor:pointer;height:fit-content;margin:0;margin-left:var(--spacingHorizontalMNudge);padding:0;position:relative;}",
			".r1vp6jef:focus{outline-style:none;}",
			".r1vp6jef:focus-visible{outline-style:none;}",
			".r1vp6jef[data-fui-focus-visible]{border-top-color:transparent;border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent;}",
			".r1vp6jef[data-fui-focus-visible]::after{content:\"\";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);left:calc(2px * -1);bottom:calc(2px * -1);right:calc(2px * -1);}"
		],
		s: ["@media (forced-colors: active){.rticfuj[data-fui-focus-visible]::after{border-top-color:Highlight;border-right-color:Highlight;border-bottom-color:Highlight;border-left-color:Highlight;}}", "@media (forced-colors: active){.r1vp6jef[data-fui-focus-visible]::after{border-top-color:Highlight;border-left-color:Highlight;border-bottom-color:Highlight;border-right-color:Highlight;}}"]
	});
	/**
	* Apply styling to the Dropdown slots based on the state
	*/
	const useDropdownStyles_unstable = (state) => {
		"use no memo";
		const { appearance, open, placeholderVisible, showClearButton, size: size$2 } = state;
		const invalid = `${state.button["aria-invalid"]}` === "true";
		const disabled = state.button.disabled;
		const styles = useStyles$92();
		const iconStyles = useIconStyles$8();
		const clearButtonStyle = useBaseClearButtonStyle();
		state.root.className = mergeClasses(dropdownClassNames.root, styles.root, styles[appearance], !disabled && appearance === "outline" && styles.outlineInteractive, invalid && appearance !== "underline" && styles.invalid, invalid && appearance === "underline" && styles.invalidUnderline, disabled && styles.disabled, state.root.className);
		state.button.className = mergeClasses(dropdownClassNames.button, styles.button, styles[size$2], placeholderVisible && styles.placeholder, disabled && styles.disabledText, state.button.className);
		if (state.listbox) state.listbox.className = mergeClasses(dropdownClassNames.listbox, styles.listbox, state.inlinePopup && styles.inlineListbox, !open && styles.listboxCollapsed, state.listbox.className);
		if (state.expandIcon) state.expandIcon.className = mergeClasses(dropdownClassNames.expandIcon, iconStyles.icon, iconStyles[size$2], disabled && iconStyles.disabled, showClearButton && styles.hidden, state.expandIcon.className);
		if (state.clearButton) state.clearButton.className = mergeClasses(dropdownClassNames.clearButton, clearButtonStyle, iconStyles.icon, iconStyles[size$2], disabled && iconStyles.disabled, !showClearButton && styles.hidden, state.clearButton.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-combobox/lib/components/Dropdown/Dropdown.js
/**
	* Dropdown component: a selection control that allows users to choose from a set of possible options
	*/ const Dropdown = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useDropdown_unstable(props, ref);
		const contextValues = useComboboxContextValues(state);
		useDropdownStyles_unstable(state);
		useCustomStyleHook("useDropdownStyles_unstable")(state);
		return renderDropdown_unstable(state, contextValues);
	});
	Dropdown.displayName = "Dropdown";

//#endregion
//#region node_modules/@fluentui/react-combobox/lib/components/OptionGroup/useOptionGroup.js
/**
	* Create the state required to render OptionGroup.
	*
	* The returned state can be modified with hooks such as useOptionGroupStyles_unstable,
	* before being passed to renderOptionGroup_unstable.
	*
	* @param props - props from this instance of OptionGroup
	* @param ref - reference to root HTMLElement of OptionGroup
	*/ const useOptionGroup_unstable = (props, ref) => {
		const labelId = useId("group-label");
		const { label } = props;
		return {
			components: {
				root: "div",
				label: "span"
			},
			root: always(getIntrinsicElementProps("div", {
				ref,
				role: "group",
				"aria-labelledby": label ? labelId : void 0,
				...props
			}), { elementType: "div" }),
			label: optional(label, {
				defaultProps: {
					id: labelId,
					role: "presentation"
				},
				elementType: "span"
			})
		};
	};

//#endregion
//#region node_modules/@fluentui/react-combobox/lib/components/OptionGroup/renderOptionGroup.js
/**
	* Render the final JSX of OptionGroup
	*/ const renderOptionGroup_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(state.root, { children: [state.label && /* @__PURE__ */ jsx(state.label, { children: state.label.children }), state.root.children] });
	};

//#endregion
//#region node_modules/@fluentui/react-combobox/lib/components/OptionGroup/useOptionGroupStyles.styles.js
	const optionGroupClassNames = {
		root: "fui-OptionGroup",
		label: "fui-OptionGroup__label"
	};
	/**
	* Styles for the root slot
	*/
	const useStyles$91 = /* @__PURE__ */ __styles({
		root: {
			mc9l5x: "f22iagw",
			Beiy3e4: "f1vx9l62",
			Belr9w4: "fiut8dr",
			B8lkq7l: "f1xxzjds",
			eii1in: 0,
			H93o2g: 0,
			Gwp8xu: 0,
			Bd39igo: "f16cmn8k",
			om0q45: "f5642y",
			Hl9o3s: "ffdf81h",
			sl1c2c: 0,
			z4hxbw: 0,
			B0i58d9: 0,
			Bi9x0x4: 0,
			Bgurq3m: "f1bsn9kn"
		},
		label: {
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "ft85np5",
			sj55zd: "f11d4kpn",
			mc9l5x: "ftgm304",
			Be2twd7: "fy9rknc",
			Bhrd7zp: "fl43uef",
			Bg96gwp: "fwrc4pm",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f1mpq0zz"
		}
	}, { d: [
		".f22iagw{display:flex;}",
		".f1vx9l62{flex-direction:column;}",
		".fiut8dr{row-gap:var(--spacingHorizontalXXS);}",
		".f1xxzjds:not(:last-child)::after{content:\"\";}",
		[".f16cmn8k:not(:last-child)::after{border-bottom:var(--strokeWidthThin) solid var(--colorNeutralStroke2);}", { p: -1 }],
		".f5642y:not(:last-child)::after{display:block;}",
		".ffdf81h:not(:last-child)::after{padding-bottom:var(--spacingHorizontalXS);}",
		[".f1bsn9kn:not(:last-child)::after{margin:0 calc(var(--spacingHorizontalXS) * -1) var(--spacingVerticalXS);}", { p: -1 }],
		[".ft85np5{border-radius:var(--borderRadiusMedium);}", { p: -1 }],
		".f11d4kpn{color:var(--colorNeutralForeground3);}",
		".ftgm304{display:block;}",
		".fy9rknc{font-size:var(--fontSizeBase200);}",
		".fl43uef{font-weight:var(--fontWeightSemibold);}",
		".fwrc4pm{line-height:var(--lineHeightBase200);}",
		[".f1mpq0zz{padding:var(--spacingHorizontalS) var(--spacingHorizontalSNudge);}", { p: -1 }]
	] });
	/**
	* Apply styling to the OptionGroup slots based on the state
	*/
	const useOptionGroupStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$91();
		state.root.className = mergeClasses(optionGroupClassNames.root, styles.root, state.root.className);
		if (state.label) state.label.className = mergeClasses(optionGroupClassNames.label, styles.label, state.label.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-combobox/lib/components/OptionGroup/OptionGroup.js
/**
	* OptionGroup component: allows grouping of Option components within a Combobox
	*/ const OptionGroup = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useOptionGroup_unstable(props, ref);
		useOptionGroupStyles_unstable(state);
		useCustomStyleHook("useOptionGroupStyles_unstable")(state);
		return renderOptionGroup_unstable(state);
	});
	OptionGroup.displayName = "OptionGroup";

//#endregion
//#region node_modules/@fluentui/react-combobox/lib/hooks/useComboboxFilter.js
	function defaultFilter(optionText, query) {
		if (query === "") return true;
		return optionText.toLowerCase().includes(query.toLowerCase());
	}
	function defaultToString(option) {
		return typeof option === "string" ? option : option.value;
	}
	/**
	* @internal
	*/ function useComboboxFilter(query, options, config) {
		const { filter = defaultFilter, noOptionsMessage = "We couldn't find any matches.", optionToReactKey = defaultToString, optionToText = defaultToString, renderOption = (option) => {
			if (typeof option === "string") return /* @__PURE__ */ react.createElement(Option, { key: option }, option);
			return /* @__PURE__ */ react.createElement(Option, {
				...option,
				key: optionToReactKey(option),
				text: optionToText(option),
				value: option.value
			}, option.children);
		} } = config;
		const filteredOptions = react.useMemo(() => {
			const searchValue = query.trim();
			return options.filter((option) => filter(optionToText(option), searchValue));
		}, [
			options,
			optionToText,
			filter,
			query
		]);
		if (filteredOptions.length === 0) return [/* @__PURE__ */ react.createElement(Option, {
			"aria-disabled": "true",
			key: "no-results",
			text: ""
		}, noOptionsMessage)];
		return filteredOptions.map((option) => renderOption(option));
	}

//#endregion
//#region node_modules/@fluentui/react-divider/lib/components/Divider/renderDivider.js
/**
	* Renders a Divider component by passing the slot props (defined in `state`) to the appropriate slots.
	*/ const renderDivider_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, { children: state.root.children !== void 0 && /* @__PURE__ */ jsx(state.wrapper, { children: state.root.children }) });
	};

//#endregion
//#region node_modules/@fluentui/react-divider/lib/components/Divider/useDivider.js
/**
	* Returns the props and state required to render the component
	* @param props - User-provided props to the Divider component.
	* @param ref - User-provided ref to be passed to the Divider component.
	*/ const useDivider_unstable = (props, ref) => {
		const { alignContent = "center", appearance = "default", inset: inset$1 = false, vertical = false, wrapper } = props;
		const dividerId = useId("divider-");
		return {
			alignContent,
			appearance,
			inset: inset$1,
			vertical,
			components: {
				root: "div",
				wrapper: "div"
			},
			root: always(getIntrinsicElementProps("div", {
				role: "separator",
				"aria-orientation": vertical ? "vertical" : "horizontal",
				"aria-labelledby": props.children ? dividerId : void 0,
				...props,
				ref
			}), { elementType: "div" }),
			wrapper: always(wrapper, {
				defaultProps: {
					id: dividerId,
					children: props.children
				},
				elementType: "div"
			})
		};
	};

//#endregion
//#region node_modules/@fluentui/react-divider/lib/components/Divider/useDividerStyles.styles.js
	const dividerClassNames = {
		root: "fui-Divider",
		wrapper: "fui-Divider__wrapper"
	};
	const useBaseStyles$7 = /* @__PURE__ */ __styles({
		base: {
			Bt984gj: "f122n59",
			B7ck84d: "f1ewtqcl",
			mc9l5x: "f22iagw",
			Beiy3e4: "f1063pyq",
			Bh6795r: "fqerorx",
			qhf8xq: "f10pi13n",
			Bahqtrf: "fk6fouc",
			Be2twd7: "fy9rknc",
			Bhrd7zp: "figsok6",
			Bg96gwp: "fwrc4pm",
			fsow6f: "f17mccla",
			Bcvre1j: "fyl8oag",
			Br0sdwz: "f16vkdww",
			Bn78ew0: "fhsnbul",
			li1rpt: "f1gw3sf2",
			ap17g6: "f1ly5f7u",
			B771hl4: "f1s3tz6t"
		},
		childless: {
			susq4k: "f1kyqvp9",
			Bicfajf: ["fzynn9s", "f1z0ukd1"],
			jwcpgy: ["fekrn8e", "ftdg338"],
			B4rk6o: "fesgyo"
		},
		start: { Bsft5z2: "f13zj6fq" },
		center: {
			Ftih45: "f1wl9k8s",
			Bsft5z2: "f13zj6fq"
		},
		end: { Ftih45: "f1wl9k8s" },
		brand: {
			sj55zd: "f16muhyy",
			Bq4z7u6: "fcbuu2a",
			Bk5zm6e: ["f1wdw2dr", "f1ttio3w"],
			Bqjgrrk: "f1582fpk",
			Bm6vgfq: ["f1ttio3w", "f1wdw2dr"],
			B0n5ga8: "f1ahrvm8",
			s924m2: ["f1cd3wbc", "f17hbk9y"],
			B1q35kw: "fvrapl0",
			Gp14am: ["f17hbk9y", "f1cd3wbc"]
		},
		"default": {
			sj55zd: "fkfq4zb",
			Bq4z7u6: "f1vccso1",
			Bk5zm6e: ["f1geml7w", "fjml6kk"],
			Bqjgrrk: "f1r7kh1m",
			Bm6vgfq: ["fjml6kk", "f1geml7w"],
			B0n5ga8: "f16j7guv",
			s924m2: ["fx01ahm", "fj1a37q"],
			B1q35kw: "fl8d8yv",
			Gp14am: ["fj1a37q", "fx01ahm"]
		},
		subtle: {
			sj55zd: "f11d4kpn",
			Bq4z7u6: "f5g06un",
			Bk5zm6e: ["f13sxdku", "f1n015lb"],
			Bqjgrrk: "f1x6bl8t",
			Bm6vgfq: ["f1n015lb", "f13sxdku"],
			B0n5ga8: "fvod1wy",
			s924m2: ["fwslg65", "flk0e17"],
			B1q35kw: "f103fvts",
			Gp14am: ["flk0e17", "fwslg65"]
		},
		strong: {
			sj55zd: "f19n0e5",
			Bq4z7u6: "f10tv6oz",
			Bk5zm6e: ["f16xp3sf", "f1seuxxq"],
			Bqjgrrk: "fwrmqbx",
			Bm6vgfq: ["f1seuxxq", "f16xp3sf"],
			B0n5ga8: "ft83z1f",
			s924m2: ["f1g4150c", "f192dr6e"],
			B1q35kw: "f1qnawh6",
			Gp14am: ["f192dr6e", "f1g4150c"]
		}
	}, { d: [
		".f122n59{align-items:center;}",
		".f1ewtqcl{box-sizing:border-box;}",
		".f22iagw{display:flex;}",
		".f1063pyq{flex-direction:row;}",
		".fqerorx{flex-grow:1;}",
		".f10pi13n{position:relative;}",
		".fk6fouc{font-family:var(--fontFamilyBase);}",
		".fy9rknc{font-size:var(--fontSizeBase200);}",
		".figsok6{font-weight:var(--fontWeightRegular);}",
		".fwrc4pm{line-height:var(--lineHeightBase200);}",
		".f17mccla{text-align:center;}",
		".fyl8oag::before{box-sizing:border-box;}",
		".f16vkdww::before{display:flex;}",
		".fhsnbul::before{flex-grow:1;}",
		".f1gw3sf2::after{box-sizing:border-box;}",
		".f1ly5f7u::after{display:flex;}",
		".f1s3tz6t::after{flex-grow:1;}",
		".f1kyqvp9::before{margin-bottom:0;}",
		".fzynn9s::before{margin-right:0;}",
		".f1z0ukd1::before{margin-left:0;}",
		".fekrn8e::after{margin-left:0;}",
		".ftdg338::after{margin-right:0;}",
		".fesgyo::after{margin-top:0;}",
		".f13zj6fq::after{content:\"\";}",
		".f1wl9k8s::before{content:\"\";}",
		".f16muhyy{color:var(--colorBrandForeground1);}",
		".fcbuu2a::before{border-top-color:var(--colorBrandStroke1);}",
		".f1wdw2dr::before{border-right-color:var(--colorBrandStroke1);}",
		".f1ttio3w::before{border-left-color:var(--colorBrandStroke1);}",
		".f1582fpk::before{border-bottom-color:var(--colorBrandStroke1);}",
		".f1ahrvm8::after{border-top-color:var(--colorBrandStroke1);}",
		".f1cd3wbc::after{border-right-color:var(--colorBrandStroke1);}",
		".f17hbk9y::after{border-left-color:var(--colorBrandStroke1);}",
		".fvrapl0::after{border-bottom-color:var(--colorBrandStroke1);}",
		".fkfq4zb{color:var(--colorNeutralForeground2);}",
		".f1vccso1::before{border-top-color:var(--colorNeutralStroke2);}",
		".f1geml7w::before{border-right-color:var(--colorNeutralStroke2);}",
		".fjml6kk::before{border-left-color:var(--colorNeutralStroke2);}",
		".f1r7kh1m::before{border-bottom-color:var(--colorNeutralStroke2);}",
		".f16j7guv::after{border-top-color:var(--colorNeutralStroke2);}",
		".fx01ahm::after{border-right-color:var(--colorNeutralStroke2);}",
		".fj1a37q::after{border-left-color:var(--colorNeutralStroke2);}",
		".fl8d8yv::after{border-bottom-color:var(--colorNeutralStroke2);}",
		".f11d4kpn{color:var(--colorNeutralForeground3);}",
		".f5g06un::before{border-top-color:var(--colorNeutralStroke3);}",
		".f13sxdku::before{border-right-color:var(--colorNeutralStroke3);}",
		".f1n015lb::before{border-left-color:var(--colorNeutralStroke3);}",
		".f1x6bl8t::before{border-bottom-color:var(--colorNeutralStroke3);}",
		".fvod1wy::after{border-top-color:var(--colorNeutralStroke3);}",
		".fwslg65::after{border-right-color:var(--colorNeutralStroke3);}",
		".flk0e17::after{border-left-color:var(--colorNeutralStroke3);}",
		".f103fvts::after{border-bottom-color:var(--colorNeutralStroke3);}",
		".f19n0e5{color:var(--colorNeutralForeground1);}",
		".f10tv6oz::before{border-top-color:var(--colorNeutralStroke1);}",
		".f16xp3sf::before{border-right-color:var(--colorNeutralStroke1);}",
		".f1seuxxq::before{border-left-color:var(--colorNeutralStroke1);}",
		".fwrmqbx::before{border-bottom-color:var(--colorNeutralStroke1);}",
		".ft83z1f::after{border-top-color:var(--colorNeutralStroke1);}",
		".f1g4150c::after{border-right-color:var(--colorNeutralStroke1);}",
		".f192dr6e::after{border-left-color:var(--colorNeutralStroke1);}",
		".f1qnawh6::after{border-bottom-color:var(--colorNeutralStroke1);}"
	] });
	const useHorizontalStyles = /* @__PURE__ */ __styles({
		base: {
			a9b677: "fly5x3f",
			Bdkvgpv: "f163fonl",
			B0qfbqy: "f51yk4v",
			pbipgd: "f13rof3u",
			Bm2nyyq: "f8rth92",
			xrcqlc: "f6czdpx",
			i5u598: "f1iyka9k"
		},
		inset: {
			uwmqm3: ["fjlbh76", "f11qrl6u"],
			z189sj: ["f11qrl6u", "fjlbh76"]
		},
		start: {
			fsow6f: ["f1o700av", "fes3tcz"],
			Ftih45: "f1wl9k8s",
			Bicfajf: ["f1ojjlep", "fk1kexq"],
			Bxwl2t9: "f1he2m4d",
			jwcpgy: ["f12w1bnb", "f1558wlj"]
		},
		center: {
			fsow6f: "f17mccla",
			Bicfajf: ["f1ojjlep", "fk1kexq"],
			jwcpgy: ["f12w1bnb", "f1558wlj"]
		},
		end: {
			fsow6f: ["fes3tcz", "f1o700av"],
			Bicfajf: ["f1ojjlep", "fk1kexq"],
			Bsft5z2: "f13zj6fq",
			jwcpgy: ["f12w1bnb", "f1558wlj"],
			Iy66sp: "f1ayce8x"
		}
	}, { d: [
		".fly5x3f{width:100%;}",
		".f163fonl::before{border-top-style:solid;}",
		".f51yk4v::before{border-top-width:var(--strokeWidthThin);}",
		".f13rof3u::before{min-width:8px;}",
		".f8rth92::after{border-top-style:solid;}",
		".f6czdpx::after{border-top-width:var(--strokeWidthThin);}",
		".f1iyka9k::after{min-width:8px;}",
		".fjlbh76{padding-left:12px;}",
		".f11qrl6u{padding-right:12px;}",
		".f1o700av{text-align:left;}",
		".fes3tcz{text-align:right;}",
		".f1wl9k8s::before{content:\"\";}",
		".f1ojjlep::before{margin-right:12px;}",
		".fk1kexq::before{margin-left:12px;}",
		".f1he2m4d::before{max-width:8px;}",
		".f12w1bnb::after{margin-left:12px;}",
		".f1558wlj::after{margin-right:12px;}",
		".f17mccla{text-align:center;}",
		".f13zj6fq::after{content:\"\";}",
		".f1ayce8x::after{max-width:8px;}"
	] });
	const useVerticalStyles = /* @__PURE__ */ __styles({
		base: {
			Beiy3e4: "f1vx9l62",
			sshi5w: "f16gbxbe",
			m598lv: ["f1yq6w5o", "f1jpmc5p"],
			B4f6apu: ["f9sc749", "f1x8pvcy"],
			zkzzav: "fhkwbjy",
			Barhvk9: ["flthirb", "ftkbnf5"],
			Ihftqj: ["f13hvwk3", "f1en4csx"],
			Bde111x: "f19onpk6"
		},
		inset: {
			B6of3ja: "f1xdg43u",
			jrapky: "f1jlhsmd"
		},
		withChildren: { sshi5w: "f1tjaq3g" },
		start: {
			Ftih45: "f1wl9k8s",
			susq4k: "fg2pwug",
			Bbdr6tz: "fkjtzyi",
			B4rk6o: "f8vk40g"
		},
		center: {
			susq4k: "fg2pwug",
			B4rk6o: "f8vk40g"
		},
		end: {
			susq4k: "fg2pwug",
			Bsft5z2: "f13zj6fq",
			B4rk6o: "f8vk40g",
			gn64ia: "fqg5mu5"
		}
	}, { d: [
		".f1vx9l62{flex-direction:column;}",
		".f16gbxbe{min-height:20px;}",
		".f1yq6w5o::before{border-right-style:solid;}",
		".f1jpmc5p::before{border-left-style:solid;}",
		".f9sc749::before{border-right-width:var(--strokeWidthThin);}",
		".f1x8pvcy::before{border-left-width:var(--strokeWidthThin);}",
		".fhkwbjy::before{min-height:8px;}",
		".flthirb::after{border-right-style:solid;}",
		".ftkbnf5::after{border-left-style:solid;}",
		".f13hvwk3::after{border-right-width:var(--strokeWidthThin);}",
		".f1en4csx::after{border-left-width:var(--strokeWidthThin);}",
		".f19onpk6::after{min-height:8px;}",
		".f1xdg43u{margin-top:12px;}",
		".f1jlhsmd{margin-bottom:12px;}",
		".f1tjaq3g{min-height:84px;}",
		".f1wl9k8s::before{content:\"\";}",
		".fg2pwug::before{margin-bottom:12px;}",
		".fkjtzyi::before{max-height:8px;}",
		".f8vk40g::after{margin-top:12px;}",
		".f13zj6fq::after{content:\"\";}",
		".fqg5mu5::after{max-height:8px;}"
	] });
	const useDividerStyles_unstable = (state) => {
		"use no memo";
		const baseStyles = useBaseStyles$7();
		const horizontalStyles = useHorizontalStyles();
		const verticalStyles = useVerticalStyles();
		const { alignContent, appearance, inset: inset$1, vertical } = state;
		state.root.className = mergeClasses(dividerClassNames.root, baseStyles.base, baseStyles[alignContent], appearance && baseStyles[appearance], !vertical && horizontalStyles.base, !vertical && inset$1 && horizontalStyles.inset, !vertical && horizontalStyles[alignContent], vertical && verticalStyles.base, vertical && inset$1 && verticalStyles.inset, vertical && verticalStyles[alignContent], vertical && state.root.children !== void 0 && verticalStyles.withChildren, state.root.children === void 0 && baseStyles.childless, state.root.className);
		if (state.wrapper) state.wrapper.className = mergeClasses(dividerClassNames.wrapper, state.wrapper.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-divider/lib/components/Divider/Divider.js
/**
	* A divider visually segments content into groups.
	*/ const Divider = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useDivider_unstable(props, ref);
		useDividerStyles_unstable(state);
		useCustomStyleHook("useDividerStyles_unstable")(state);
		return renderDivider_unstable(state);
	});
	Divider.displayName = "Divider";

//#endregion
//#region node_modules/@fluentui/react-input/lib/components/Input/useInput.js
/**
	* Create the state required to render Input.
	*
	* The returned state can be modified with hooks such as useInputStyles_unstable,
	* before being passed to renderInput_unstable.
	*
	* @param props - props from this instance of Input
	* @param ref - reference to `<input>` element of Input
	*/ const useInput_unstable = (props, ref) => {
		props = useFieldControlProps_unstable(props, {
			supportsLabelFor: true,
			supportsRequired: true,
			supportsSize: true
		});
		const overrides = useOverrides();
		var _overrides_inputDefaultAppearance;
		const { size: size$2 = "medium", appearance = (_overrides_inputDefaultAppearance = overrides.inputDefaultAppearance) !== null && _overrides_inputDefaultAppearance !== void 0 ? _overrides_inputDefaultAppearance : "outline", onChange } = props;
		if (appearance === "filled-darker-shadow" || appearance === "filled-lighter-shadow") console.error("The 'filled-darker-shadow' and 'filled-lighter-shadow' appearances are deprecated and will be removed in the future.");
		const [value, setValue] = useControllableState({
			state: props.value,
			defaultState: props.defaultValue,
			initialState: ""
		});
		const nativeProps = getPartitionedNativeProps({
			props,
			primarySlotTagName: "input",
			excludedPropNames: [
				"size",
				"onChange",
				"value",
				"defaultValue"
			]
		});
		const state = {
			size: size$2,
			appearance,
			components: {
				root: "span",
				input: "input",
				contentBefore: "span",
				contentAfter: "span"
			},
			input: always(props.input, {
				defaultProps: {
					type: "text",
					ref,
					...nativeProps.primary
				},
				elementType: "input"
			}),
			contentAfter: optional(props.contentAfter, { elementType: "span" }),
			contentBefore: optional(props.contentBefore, { elementType: "span" }),
			root: always(props.root, {
				defaultProps: nativeProps.root,
				elementType: "span"
			})
		};
		state.input.value = value;
		state.input.onChange = useEventCallback((ev) => {
			const newValue = ev.target.value;
			onChange === null || onChange === void 0 || onChange(ev, { value: newValue });
			setValue(newValue);
		});
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-input/lib/components/Input/renderInput.js
/**
	* Render the final JSX of Input
	*/ const renderInput_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(state.root, { children: [
			state.contentBefore && /* @__PURE__ */ jsx(state.contentBefore, {}),
			/* @__PURE__ */ jsx(state.input, {}),
			state.contentAfter && /* @__PURE__ */ jsx(state.contentAfter, {})
		] });
	};

//#endregion
//#region node_modules/@fluentui/react-input/lib/components/Input/useInputStyles.styles.js
	const inputClassNames = {
		root: "fui-Input",
		input: "fui-Input__input",
		contentBefore: "fui-Input__contentBefore",
		contentAfter: "fui-Input__contentAfter"
	};
	tokens.spacingHorizontalSNudge, tokens.spacingHorizontalMNudge, tokens.spacingHorizontalM, tokens.spacingHorizontalXXS, tokens.spacingHorizontalXXS, tokens.spacingHorizontalSNudge, tokens.spacingHorizontalS, tokens.spacingHorizontalM, `${tokens.spacingHorizontalM}${tokens.spacingHorizontalSNudge}`;
	const useRootClassName$4 = /* @__PURE__ */ __resetStyles("r1oeeo9n", "r9sxh5", {
		r: [
			".r1oeeo9n{display:inline-flex;align-items:center;flex-wrap:nowrap;gap:var(--spacingHorizontalXXS);border-radius:var(--borderRadiusMedium);position:relative;box-sizing:border-box;vertical-align:middle;min-height:32px;font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase300);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase300);background-color:var(--colorNeutralBackground1);border:1px solid var(--colorNeutralStroke1);border-bottom-color:var(--colorNeutralStrokeAccessible);}",
			".r1oeeo9n::after{box-sizing:border-box;content:\"\";position:absolute;left:-1px;bottom:-1px;right:-1px;height:max(2px, var(--borderRadiusMedium));border-bottom-left-radius:var(--borderRadiusMedium);border-bottom-right-radius:var(--borderRadiusMedium);border-bottom:2px solid var(--colorCompoundBrandStroke);clip-path:inset(calc(100% - 2px) 0 0 0);transform:scaleX(0);transition-property:transform;transition-duration:var(--durationUltraFast);transition-delay:var(--curveAccelerateMid);}",
			".r1oeeo9n:focus-within::after{transform:scaleX(1);transition-property:transform;transition-duration:var(--durationNormal);transition-delay:var(--curveDecelerateMid);}",
			".r1oeeo9n:focus-within:active::after{border-bottom-color:var(--colorCompoundBrandStrokePressed);}",
			".r1oeeo9n:focus-within{outline:2px solid transparent;}",
			".r9sxh5{display:inline-flex;align-items:center;flex-wrap:nowrap;gap:var(--spacingHorizontalXXS);border-radius:var(--borderRadiusMedium);position:relative;box-sizing:border-box;vertical-align:middle;min-height:32px;font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase300);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase300);background-color:var(--colorNeutralBackground1);border:1px solid var(--colorNeutralStroke1);border-bottom-color:var(--colorNeutralStrokeAccessible);}",
			".r9sxh5::after{box-sizing:border-box;content:\"\";position:absolute;right:-1px;bottom:-1px;left:-1px;height:max(2px, var(--borderRadiusMedium));border-bottom-right-radius:var(--borderRadiusMedium);border-bottom-left-radius:var(--borderRadiusMedium);border-bottom:2px solid var(--colorCompoundBrandStroke);clip-path:inset(calc(100% - 2px) 0 0 0);transform:scaleX(0);transition-property:transform;transition-duration:var(--durationUltraFast);transition-delay:var(--curveAccelerateMid);}",
			".r9sxh5:focus-within::after{transform:scaleX(1);transition-property:transform;transition-duration:var(--durationNormal);transition-delay:var(--curveDecelerateMid);}",
			".r9sxh5:focus-within:active::after{border-bottom-color:var(--colorCompoundBrandStrokePressed);}",
			".r9sxh5:focus-within{outline:2px solid transparent;}"
		],
		s: [
			"@media screen and (prefers-reduced-motion: reduce){.r1oeeo9n::after{transition-duration:0.01ms;transition-delay:0.01ms;}}",
			"@media screen and (prefers-reduced-motion: reduce){.r1oeeo9n:focus-within::after{transition-duration:0.01ms;transition-delay:0.01ms;}}",
			"@media screen and (prefers-reduced-motion: reduce){.r9sxh5::after{transition-duration:0.01ms;transition-delay:0.01ms;}}",
			"@media screen and (prefers-reduced-motion: reduce){.r9sxh5:focus-within::after{transition-duration:0.01ms;transition-delay:0.01ms;}}"
		]
	});
	const useRootStyles$21 = /* @__PURE__ */ __styles({
		small: {
			sshi5w: "f1pha7fy",
			Bahqtrf: "fk6fouc",
			Be2twd7: "fy9rknc",
			Bhrd7zp: "figsok6",
			Bg96gwp: "fwrc4pm"
		},
		medium: {},
		large: {
			sshi5w: "f1w5jphr",
			Bahqtrf: "fk6fouc",
			Be2twd7: "fod5ikn",
			Bhrd7zp: "figsok6",
			Bg96gwp: "faaz57k",
			i8kkvl: 0,
			Belr9w4: 0,
			rmohyg: "f1eyhf9v"
		},
		outline: {},
		outlineInteractive: {
			Bgoe8wy: "fvcxoqz",
			Bwzppfd: ["f1ub3y4t", "f1m52nbi"],
			oetu4i: "f1l4zc64",
			gg5e9n: ["f1m52nbi", "f1ub3y4t"],
			Drbcw7: "f8vnjqi",
			udz0bu: ["fz1etlk", "f1hc16gm"],
			Be8ivqh: "f1klwx88",
			ofdepl: ["f1hc16gm", "fz1etlk"]
		},
		underline: {
			De3pzq: "f1c21dwh",
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "fokr779",
			icvyot: "f1ern45e",
			vrafjx: ["f1n71otn", "f1deefiw"],
			wvpqe5: ["f1deefiw", "f1n71otn"],
			Eqx8gd: ["f1n6gb5g", "f15yvnhg"],
			B1piin3: ["f15yvnhg", "f1n6gb5g"]
		},
		underlineInteractive: {
			oetu4i: "f1l4zc64",
			Be8ivqh: "f1klwx88",
			d9w3h3: 0,
			B3778ie: 0,
			B4j8arr: 0,
			Bl18szs: 0,
			Blrzh8d: "f2ale1x"
		},
		filled: {
			g2u3we: "fghlq4f",
			h3c5rm: ["f1gn591s", "fjscplz"],
			B9xav0g: "fb073pr",
			zhjwy3: ["fjscplz", "f1gn591s"]
		},
		filledInteractive: {
			q7v0qe: "ftmjh5b",
			kmh5ft: ["f17blpuu", "fsrcdbj"],
			nagaa4: "f1tpwn32",
			B1yhkcb: ["fsrcdbj", "f17blpuu"]
		},
		invalid: {
			tvckwq: "fs4k3qj",
			gk2u95: ["fcee079", "fmyw78r"],
			hhx65j: "f1fgmyf4",
			Bxowmz0: ["fmyw78r", "fcee079"]
		},
		"filled-darker": { De3pzq: "f16xq7d1" },
		"filled-lighter": { De3pzq: "fxugw4r" },
		"filled-darker-shadow": {
			De3pzq: "f16xq7d1",
			E5pizo: "fyed02w"
		},
		"filled-lighter-shadow": {
			De3pzq: "fxugw4r",
			E5pizo: "fyed02w"
		},
		disabled: {
			Bceei9c: "fdrzuqr",
			De3pzq: "f1c21dwh",
			g2u3we: "f1jj8ep1",
			h3c5rm: ["f15xbau", "fy0fskl"],
			B9xav0g: "f4ikngz",
			zhjwy3: ["fy0fskl", "f15xbau"],
			Bcq6wej: "f9dbb4x",
			Jcjdmf: ["f3qs60o", "f5u9ap2"],
			sc4o1m: "fwd1oij",
			Bosien3: ["f5u9ap2", "f3qs60o"],
			Bsft5z2: "fhr9occ",
			Bduesf4: "f99w1ws"
		},
		smallWithContentBefore: { uwmqm3: ["fk8j09s", "fdw0yi8"] },
		smallWithContentAfter: { z189sj: ["fdw0yi8", "fk8j09s"] },
		mediumWithContentBefore: { uwmqm3: ["f1ng84yb", "f11gcy0p"] },
		mediumWithContentAfter: { z189sj: ["f11gcy0p", "f1ng84yb"] },
		largeWithContentBefore: { uwmqm3: ["f1uw59to", "fw5db7e"] },
		largeWithContentAfter: { z189sj: ["fw5db7e", "f1uw59to"] }
	}, {
		d: [
			".f1pha7fy{min-height:24px;}",
			".fk6fouc{font-family:var(--fontFamilyBase);}",
			".fy9rknc{font-size:var(--fontSizeBase200);}",
			".figsok6{font-weight:var(--fontWeightRegular);}",
			".fwrc4pm{line-height:var(--lineHeightBase200);}",
			".f1w5jphr{min-height:40px;}",
			".fod5ikn{font-size:var(--fontSizeBase400);}",
			".faaz57k{line-height:var(--lineHeightBase400);}",
			[".f1eyhf9v{gap:var(--spacingHorizontalSNudge);}", { p: -1 }],
			".f1c21dwh{background-color:var(--colorTransparentBackground);}",
			[".fokr779{border-radius:0;}", { p: -1 }],
			".f1ern45e{border-top-style:none;}",
			".f1n71otn{border-right-style:none;}",
			".f1deefiw{border-left-style:none;}",
			".f1n6gb5g::after{left:0;}",
			".f15yvnhg::after{right:0;}",
			[".f2ale1x::after{border-radius:0;}", { p: -1 }],
			".fghlq4f{border-top-color:var(--colorTransparentStroke);}",
			".f1gn591s{border-right-color:var(--colorTransparentStroke);}",
			".fjscplz{border-left-color:var(--colorTransparentStroke);}",
			".fb073pr{border-bottom-color:var(--colorTransparentStroke);}",
			".fs4k3qj:not(:focus-within),.fs4k3qj:hover:not(:focus-within){border-top-color:var(--colorPaletteRedBorder2);}",
			".fcee079:not(:focus-within),.fcee079:hover:not(:focus-within){border-right-color:var(--colorPaletteRedBorder2);}",
			".fmyw78r:not(:focus-within),.fmyw78r:hover:not(:focus-within){border-left-color:var(--colorPaletteRedBorder2);}",
			".f1fgmyf4:not(:focus-within),.f1fgmyf4:hover:not(:focus-within){border-bottom-color:var(--colorPaletteRedBorder2);}",
			".f16xq7d1{background-color:var(--colorNeutralBackground3);}",
			".fxugw4r{background-color:var(--colorNeutralBackground1);}",
			".fyed02w{box-shadow:var(--shadow2);}",
			".fdrzuqr{cursor:not-allowed;}",
			".f1jj8ep1{border-top-color:var(--colorNeutralStrokeDisabled);}",
			".f15xbau{border-right-color:var(--colorNeutralStrokeDisabled);}",
			".fy0fskl{border-left-color:var(--colorNeutralStrokeDisabled);}",
			".f4ikngz{border-bottom-color:var(--colorNeutralStrokeDisabled);}",
			".fhr9occ::after{content:unset;}",
			".fk8j09s{padding-left:var(--spacingHorizontalSNudge);}",
			".fdw0yi8{padding-right:var(--spacingHorizontalSNudge);}",
			".f1ng84yb{padding-left:var(--spacingHorizontalMNudge);}",
			".f11gcy0p{padding-right:var(--spacingHorizontalMNudge);}",
			".f1uw59to{padding-left:var(--spacingHorizontalM);}",
			".fw5db7e{padding-right:var(--spacingHorizontalM);}"
		],
		h: [
			".fvcxoqz:hover{border-top-color:var(--colorNeutralStroke1Hover);}",
			".f1ub3y4t:hover{border-right-color:var(--colorNeutralStroke1Hover);}",
			".f1m52nbi:hover{border-left-color:var(--colorNeutralStroke1Hover);}",
			".f1l4zc64:hover{border-bottom-color:var(--colorNeutralStrokeAccessibleHover);}",
			".ftmjh5b:hover,.ftmjh5b:focus-within{border-top-color:var(--colorTransparentStrokeInteractive);}",
			".f17blpuu:hover,.f17blpuu:focus-within{border-right-color:var(--colorTransparentStrokeInteractive);}",
			".fsrcdbj:hover,.fsrcdbj:focus-within{border-left-color:var(--colorTransparentStrokeInteractive);}",
			".f1tpwn32:hover,.f1tpwn32:focus-within{border-bottom-color:var(--colorTransparentStrokeInteractive);}"
		],
		a: [
			".f8vnjqi:active,.f8vnjqi:focus-within{border-top-color:var(--colorNeutralStroke1Pressed);}",
			".fz1etlk:active,.fz1etlk:focus-within{border-right-color:var(--colorNeutralStroke1Pressed);}",
			".f1hc16gm:active,.f1hc16gm:focus-within{border-left-color:var(--colorNeutralStroke1Pressed);}",
			".f1klwx88:active,.f1klwx88:focus-within{border-bottom-color:var(--colorNeutralStrokeAccessiblePressed);}"
		],
		m: [
			["@media (forced-colors: active){.f9dbb4x{border-top-color:GrayText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f3qs60o{border-right-color:GrayText;}.f5u9ap2{border-left-color:GrayText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fwd1oij{border-bottom-color:GrayText;}}", { m: "(forced-colors: active)" }]
		],
		w: [".f99w1ws:focus-within{outline-style:none;}"]
	});
	const useInputClassName$1 = /* @__PURE__ */ __resetStyles("r12stul0", null, [
		".r12stul0{align-self:stretch;box-sizing:border-box;flex-grow:1;min-width:0;border-style:none;padding:0 var(--spacingHorizontalM);color:var(--colorNeutralForeground1);background-color:transparent;outline-style:none;font-family:inherit;font-size:inherit;font-weight:inherit;line-height:inherit;}",
		".r12stul0::-webkit-input-placeholder{color:var(--colorNeutralForeground4);opacity:1;}",
		".r12stul0::-moz-placeholder{color:var(--colorNeutralForeground4);opacity:1;}",
		".r12stul0::placeholder{color:var(--colorNeutralForeground4);opacity:1;}"
	]);
	const useInputElementStyles = /* @__PURE__ */ __styles({
		small: {
			uwmqm3: ["f1f5gg8d", "f1vdfbxk"],
			z189sj: ["f1vdfbxk", "f1f5gg8d"]
		},
		medium: {},
		large: {
			uwmqm3: ["fnphzt9", "flt1dlf"],
			z189sj: ["flt1dlf", "fnphzt9"]
		},
		smallWithContentBefore: { uwmqm3: ["fgiv446", "ffczdla"] },
		smallWithContentAfter: { z189sj: ["ffczdla", "fgiv446"] },
		mediumWithContentBefore: { uwmqm3: ["fgiv446", "ffczdla"] },
		mediumWithContentAfter: { z189sj: ["ffczdla", "fgiv446"] },
		largeWithContentBefore: { uwmqm3: ["fk8j09s", "fdw0yi8"] },
		largeWithContentAfter: { z189sj: ["fdw0yi8", "fk8j09s"] },
		disabled: {
			sj55zd: "f1s2aq7o",
			De3pzq: "f1c21dwh",
			Bceei9c: "fdrzuqr",
			yvdlaj: "fahhnxm"
		}
	}, { d: [
		".f1f5gg8d{padding-left:var(--spacingHorizontalS);}",
		".f1vdfbxk{padding-right:var(--spacingHorizontalS);}",
		".fnphzt9{padding-left:calc(var(--spacingHorizontalM) + var(--spacingHorizontalSNudge));}",
		".flt1dlf{padding-right:calc(var(--spacingHorizontalM) + var(--spacingHorizontalSNudge));}",
		".fgiv446{padding-left:var(--spacingHorizontalXXS);}",
		".ffczdla{padding-right:var(--spacingHorizontalXXS);}",
		".fk8j09s{padding-left:var(--spacingHorizontalSNudge);}",
		".fdw0yi8{padding-right:var(--spacingHorizontalSNudge);}",
		".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}",
		".f1c21dwh{background-color:var(--colorTransparentBackground);}",
		".fdrzuqr{cursor:not-allowed;}",
		".fahhnxm::-webkit-input-placeholder{color:var(--colorNeutralForegroundDisabled);}",
		".fahhnxm::-moz-placeholder{color:var(--colorNeutralForegroundDisabled);}"
	] });
	const useContentClassName = /* @__PURE__ */ __resetStyles("r1572tok", null, [".r1572tok{box-sizing:border-box;color:var(--colorNeutralForeground3);display:flex;}", ".r1572tok>svg{font-size:20px;}"]);
	const useContentStyles$2 = /* @__PURE__ */ __styles({
		disabled: { sj55zd: "f1s2aq7o" },
		small: { Duoase: "f3qv9w" },
		medium: {},
		large: { Duoase: "f16u2scb" }
	}, { d: [
		".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}",
		".f3qv9w>svg{font-size:16px;}",
		".f16u2scb>svg{font-size:24px;}"
	] });
	/**
	* Apply styling to the Input slots based on the state
	*/
	const useInputStyles_unstable = (state) => {
		"use no memo";
		const { size: size$2, appearance } = state;
		const disabled = state.input.disabled;
		const invalid = `${state.input["aria-invalid"]}` === "true";
		const filled = appearance.startsWith("filled");
		const rootStyles = useRootStyles$21();
		const inputStyles = useInputElementStyles();
		const contentStyles = useContentStyles$2();
		state.root.className = mergeClasses(inputClassNames.root, useRootClassName$4(), rootStyles[size$2], state.contentBefore && rootStyles[`${size$2}WithContentBefore`], state.contentAfter && rootStyles[`${size$2}WithContentAfter`], rootStyles[appearance], !disabled && appearance === "outline" && rootStyles.outlineInteractive, !disabled && appearance === "underline" && rootStyles.underlineInteractive, !disabled && filled && rootStyles.filledInteractive, filled && rootStyles.filled, !disabled && invalid && rootStyles.invalid, disabled && rootStyles.disabled, state.root.className);
		state.input.className = mergeClasses(inputClassNames.input, useInputClassName$1(), inputStyles[size$2], state.contentBefore && inputStyles[`${size$2}WithContentBefore`], state.contentAfter && inputStyles[`${size$2}WithContentAfter`], disabled && inputStyles.disabled, state.input.className);
		const contentClasses = [
			useContentClassName(),
			disabled && contentStyles.disabled,
			contentStyles[size$2]
		];
		if (state.contentBefore) state.contentBefore.className = mergeClasses(inputClassNames.contentBefore, ...contentClasses, state.contentBefore.className);
		if (state.contentAfter) state.contentAfter.className = mergeClasses(inputClassNames.contentAfter, ...contentClasses, state.contentAfter.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-input/lib/components/Input/Input.js
/**
	* The Input component allows people to enter and edit text.
	*/ const Input = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useInput_unstable(props, ref);
		useInputStyles_unstable(state);
		useCustomStyleHook("useInputStyles_unstable")(state);
		return renderInput_unstable(state);
	});
	Input.displayName = "Input";

//#endregion
//#region node_modules/@fluentui/react-image/lib/components/Image/renderImage.js
/**
	* Define the render function.
	* Given the state of an image, renders it.
	*/ const renderImage_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, {});
	};

//#endregion
//#region node_modules/@fluentui/react-image/lib/components/Image/useImage.js
/**
	* Given user props, returns state and render function for an Image.
	*/ const useImage_unstable = (props, ref) => {
		const { bordered = false, fit = "default", block = false, shape = "square", shadow = false } = props;
		return {
			bordered,
			fit,
			block,
			shape,
			shadow,
			components: { root: "img" },
			root: always(getIntrinsicElementProps("img", {
				ref,
				...props
			}), { elementType: "img" })
		};
	};

//#endregion
//#region node_modules/@fluentui/react-image/lib/components/Image/useImageStyles.styles.js
	const imageClassNames = { root: "fui-Image" };
	const useStyles$90 = /* @__PURE__ */ __styles({
		base: {
			g2u3we: "fj3muxo",
			h3c5rm: ["f1akhkt", "f1lxtadh"],
			B9xav0g: "f1aperda",
			zhjwy3: ["f1lxtadh", "f1akhkt"],
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "f1fabniw",
			B7ck84d: "f1ewtqcl",
			mc9l5x: "f14t3ns0"
		},
		bordered: {
			icvyot: "fzkkow9",
			vrafjx: ["fcdblym", "fjik90z"],
			oivjwe: "fg706s2",
			wvpqe5: ["fjik90z", "fcdblym"],
			B4j52fo: "f192inf7",
			Bekrc4i: ["f5tn483", "f1ojsxk5"],
			Bn0qgzm: "f1vxd6vx",
			ibv6hh: ["f1ojsxk5", "f5tn483"]
		},
		circular: {
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "f44lkw9"
		},
		rounded: {
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "ft85np5"
		},
		square: {},
		shadow: { E5pizo: "f1whvlc6" },
		center: {
			st4lth: "f1plgu50",
			Ermj5k: "f14xojzb"
		},
		contain: {
			st4lth: "f1kle4es",
			Ermj5k: "f14xojzb"
		},
		"default": {},
		cover: {
			st4lth: "f1ps3kmd",
			Ermj5k: "f14xojzb"
		},
		none: {
			st4lth: "f1plgu50",
			Ermj5k: ["f13uwng7", "fjmyj0p"]
		},
		fitFill: {
			Bqenvij: "f1l02sjl",
			a9b677: "fly5x3f"
		},
		block: { a9b677: "fly5x3f" }
	}, { d: [
		".fj3muxo{border-top-color:var(--colorNeutralStroke1);}",
		".f1akhkt{border-right-color:var(--colorNeutralStroke1);}",
		".f1lxtadh{border-left-color:var(--colorNeutralStroke1);}",
		".f1aperda{border-bottom-color:var(--colorNeutralStroke1);}",
		[".f1fabniw{border-radius:var(--borderRadiusNone);}", { p: -1 }],
		".f1ewtqcl{box-sizing:border-box;}",
		".f14t3ns0{display:inline-block;}",
		".fzkkow9{border-top-style:solid;}",
		".fcdblym{border-right-style:solid;}",
		".fjik90z{border-left-style:solid;}",
		".fg706s2{border-bottom-style:solid;}",
		".f192inf7{border-top-width:var(--strokeWidthThin);}",
		".f5tn483{border-right-width:var(--strokeWidthThin);}",
		".f1ojsxk5{border-left-width:var(--strokeWidthThin);}",
		".f1vxd6vx{border-bottom-width:var(--strokeWidthThin);}",
		[".f44lkw9{border-radius:var(--borderRadiusCircular);}", { p: -1 }],
		[".ft85np5{border-radius:var(--borderRadiusMedium);}", { p: -1 }],
		".f1whvlc6{box-shadow:var(--shadow4);}",
		".f1plgu50{object-fit:none;}",
		".f14xojzb{object-position:center;}",
		".f1kle4es{object-fit:contain;}",
		".f1ps3kmd{object-fit:cover;}",
		".f13uwng7{object-position:left top;}",
		".fjmyj0p{object-position:right top;}",
		".f1l02sjl{height:100%;}",
		".fly5x3f{width:100%;}"
	] });
	const useImageStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$90();
		const { height, width } = state.root;
		const hasExplicitSize = height != null || width != null;
		const shouldApplyFitFill = state.fit !== "default" && !hasExplicitSize;
		state.root.className = mergeClasses(imageClassNames.root, styles.base, state.block && styles.block, state.bordered && styles.bordered, state.shadow && styles.shadow, styles[state.fit], shouldApplyFitFill && styles.fitFill, styles[state.shape], state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-image/lib/components/Image/Image.js
/**
	* The Image component ensures the consistent styling of images.
	*/ const Image = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useImage_unstable(props, ref);
		useImageStyles_unstable(state);
		useCustomStyleHook("useImageStyles_unstable")(state);
		return renderImage_unstable(state);
	});
	Image.displayName = "Image";

//#endregion
//#region node_modules/@fluentui/react-link/lib/components/Link/useLinkState.js
/**
	* The useLinkState_unstable hook processes the Link state.
	* @param state - Link state to mutate.
	*/ const useLinkState_unstable = (state) => {
		const { disabled, disabledFocusable } = state;
		const { onClick, onKeyDown, role, tabIndex } = state.root;
		if (state.root.as === "a") {
			state.root.href = disabled ? void 0 : state.root.href;
			if (disabled || disabledFocusable) state.root.role = role || "link";
		}
		if (state.root.as === "a" || state.root.as === "span") state.root.tabIndex = tabIndex !== null && tabIndex !== void 0 ? tabIndex : disabled && !disabledFocusable ? void 0 : 0;
		state.root.onClick = (ev) => {
			if (disabled || disabledFocusable) ev.preventDefault();
			else onClick === null || onClick === void 0 || onClick(ev);
		};
		state.root.onKeyDown = (ev) => {
			const keyPressed = ev.key === Enter || ev.key === Space;
			if ((disabled || disabledFocusable) && keyPressed) {
				ev.preventDefault();
				ev.stopPropagation();
			} else {
				onKeyDown === null || onKeyDown === void 0 || onKeyDown(ev);
				if (state.root.as === "span" && !!state.root.onClick && !onKeyDown && keyPressed) {
					ev.preventDefault();
					ev.currentTarget.click();
				}
			}
		};
		state.disabled = disabled || disabledFocusable;
		state.root["aria-disabled"] = disabled || disabledFocusable || void 0;
		if (state.root.as === "button") state.root.disabled = disabled && !disabledFocusable;
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-link/lib/contexts/linkContext.js
	const LinkContext = react.createContext(void 0);
	const linkContextDefaultValue = { inline: false };
	const LinkContextProvider = LinkContext.Provider;
	const useLinkContext = () => {
		var _React_useContext;
		return (_React_useContext = react.useContext(LinkContext)) !== null && _React_useContext !== void 0 ? _React_useContext : linkContextDefaultValue;
	};

//#endregion
//#region node_modules/@fluentui/react-link/lib/components/Link/useLink.js
/**
	* Given user props, defines default props for the Link, calls useLinkState_unstable, and returns processed state.
	* @param props - User provided props to the Link component.
	* @param ref - User provided ref to be passed to the Link component.
	*/ const useLink_unstable = (props, ref) => {
		const backgroundAppearance = useBackgroundAppearance();
		const { inline: inlineContext } = useLinkContext();
		const { appearance = "default", disabled = false, disabledFocusable = false, inline = false } = props;
		const elementType = props.as || (props.href ? "a" : "button");
		const propsWithAssignedAs = {
			role: elementType === "span" ? "button" : void 0,
			type: elementType === "button" ? "button" : void 0,
			...props,
			as: elementType
		};
		const state = {
			appearance,
			disabled,
			disabledFocusable,
			inline: inline !== null && inline !== void 0 ? inline : !!inlineContext,
			components: { root: elementType },
			root: always(getIntrinsicElementProps(elementType, {
				ref,
				...propsWithAssignedAs
			}), { elementType }),
			backgroundAppearance
		};
		useLinkState_unstable(state);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-link/lib/components/Link/useLinkStyles.styles.js
	const linkClassNames = { root: "fui-Link" };
	const useStyles$89 = /* @__PURE__ */ __styles({
		focusIndicator: {
			Bttzg6e: "fhgqx19",
			B3uz8dt: "f1olyrje",
			B6ihwck: "f1p93eir",
			g9k6zt: "f1nev41a"
		},
		root: {
			B486eqv: "f2hkw1w",
			De3pzq: "f3rmtva",
			B7ck84d: "f1ewtqcl",
			sj55zd: "fyind8e",
			Bceei9c: "f1k6fduh",
			mc9l5x: "f1w7gpdv",
			Bahqtrf: "fk6fouc",
			Be2twd7: "fkhj508",
			Bhrd7zp: "figsok6",
			jrapky: 0,
			Frg6f3: 0,
			t21cq0: 0,
			B6of3ja: 0,
			B74szlk: "f1s184ao",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f1mk8lai",
			B68tc82: 0,
			Bmxbyg5: 0,
			Bpg54ce: "fnbmjn9",
			fsow6f: ["f1o700av", "fes3tcz"],
			w71qe1: "f1iuv45f",
			Bkioxbp: "f1cmlufx",
			ygn44y: "f9n3di6",
			famaaq: "f1ids18y",
			Bde5pd6: "f1tx3yz7",
			Bi91k9c: "f1deo86v",
			i089h6: "f1eh06m1",
			lj723h: "f1iescvh"
		},
		button: {
			icvyot: "f1ern45e",
			vrafjx: ["f1n71otn", "f1deefiw"],
			oivjwe: "f1h8hb77",
			wvpqe5: ["f1deefiw", "f1n71otn"]
		},
		href: { Be2twd7: "fjoy568" },
		subtle: {
			sj55zd: "f2yjg6r",
			Bde5pd6: "f1tx3yz7",
			Bi91k9c: "fj1cjhr",
			i089h6: "f1eh06m1",
			lj723h: "fhucn0c"
		},
		inline: { w71qe1: "f13mvf36" },
		disabled: {
			w71qe1: "f1iuv45f",
			sj55zd: "f1s2aq7o",
			Bceei9c: "fdrzuqr",
			Bde5pd6: "fbnuktb",
			Bi91k9c: "fvgxktp",
			i089h6: "fljg2da",
			lj723h: "f19wldhg"
		},
		inverted: {
			sj55zd: "f1w7i9ko",
			Bi91k9c: "fni4grw",
			lj723h: "fipv1hy"
		},
		brand: {
			sj55zd: "f179xftw",
			Bi91k9c: "f1sk1dtk",
			lj723h: "f182g21t"
		}
	}, {
		d: [
			".fhgqx19[data-fui-focus-visible]{text-decoration-color:var(--colorStrokeFocus2);}",
			".f1olyrje[data-fui-focus-visible]{text-decoration-line:underline;}",
			".f1p93eir[data-fui-focus-visible]{text-decoration-style:double;}",
			".f1nev41a[data-fui-focus-visible]{outline-style:none;}",
			".f3rmtva{background-color:transparent;}",
			".f1ewtqcl{box-sizing:border-box;}",
			".fyind8e{color:var(--colorBrandForegroundLink);}",
			".f1k6fduh{cursor:pointer;}",
			".f1w7gpdv{display:inline;}",
			".fk6fouc{font-family:var(--fontFamilyBase);}",
			".fkhj508{font-size:var(--fontSizeBase300);}",
			".figsok6{font-weight:var(--fontWeightRegular);}",
			[".f1s184ao{margin:0;}", { p: -1 }],
			[".f1mk8lai{padding:0;}", { p: -1 }],
			[".fnbmjn9{overflow:inherit;}", { p: -1 }],
			".f1o700av{text-align:left;}",
			".fes3tcz{text-align:right;}",
			".f1iuv45f{text-decoration-line:none;}",
			".f1cmlufx{text-decoration-thickness:var(--strokeWidthThin);}",
			".f9n3di6{text-overflow:inherit;}",
			".f1ids18y{-webkit-user-select:text;-moz-user-select:text;user-select:text;}",
			".f1ern45e{border-top-style:none;}",
			".f1n71otn{border-right-style:none;}",
			".f1deefiw{border-left-style:none;}",
			".f1h8hb77{border-bottom-style:none;}",
			".fjoy568{font-size:inherit;}",
			".f2yjg6r{color:var(--colorNeutralForeground2Link);}",
			".f13mvf36{text-decoration-line:underline;}",
			".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}",
			".fdrzuqr{cursor:not-allowed;}",
			".f1w7i9ko{color:var(--colorNeutralForegroundInverted2);}",
			".f179xftw{color:var(--colorNeutralForegroundInvertedLink);}"
		],
		i: [".f2hkw1w:focus-visible{outline-style:none;}"],
		h: [
			".f1tx3yz7:hover{text-decoration-line:underline;}",
			".f1deo86v:hover{color:var(--colorBrandForegroundLinkHover);}",
			".fj1cjhr:hover{color:var(--colorNeutralForeground2LinkHover);}",
			".fbnuktb:hover{text-decoration-line:none;}",
			".fvgxktp:hover{color:var(--colorNeutralForegroundDisabled);}",
			".fni4grw:hover{color:var(--colorNeutralForegroundInverted2);}",
			".f1sk1dtk:hover{color:var(--colorNeutralForegroundInvertedLinkHover);}"
		],
		a: [
			".f1eh06m1:active{text-decoration-line:underline;}",
			".f1iescvh:active{color:var(--colorBrandForegroundLinkPressed);}",
			".fhucn0c:active{color:var(--colorNeutralForeground2LinkPressed);}",
			".fljg2da:active{text-decoration-line:none;}",
			".f19wldhg:active{color:var(--colorNeutralForegroundDisabled);}",
			".fipv1hy:active{color:var(--colorNeutralForegroundInverted2);}",
			".f182g21t:active{color:var(--colorNeutralForegroundInvertedLinkPressed);}"
		]
	});
	const useLinkStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$89();
		const { appearance, disabled, inline, root, backgroundAppearance } = state;
		state.root.className = mergeClasses(linkClassNames.root, styles.root, styles.focusIndicator, root.as === "a" && root.href && styles.href, root.as === "button" && styles.button, appearance === "subtle" && styles.subtle, backgroundAppearance === "inverted" && styles.inverted, backgroundAppearance === "brand" && styles.brand, inline && styles.inline, disabled && styles.disabled, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-link/lib/components/Link/renderLink.js
/**
	* Renders a Link component by passing the state defined props to the appropriate slots.
	*/ const renderLink_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, {});
	};

//#endregion
//#region node_modules/@fluentui/react-link/lib/components/Link/Link.js
/**
	* A Link is a reference to data that a user can follow by clicking or tapping it.
	*/ const Link = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useLink_unstable(props, ref);
		useLinkStyles_unstable(state);
		useCustomStyleHook("useLinkStyles_unstable")(state);
		return renderLink_unstable(state);
	});
	Link.displayName = "Link";

//#endregion
//#region node_modules/@fluentui/react-menu/lib/contexts/menuContext.js
	const MenuContext = createContext(void 0);
	const menuContextDefaultValue = {
		open: false,
		setOpen: () => false,
		checkedValues: {},
		onCheckedValueChange: () => null,
		isSubmenu: false,
		triggerRef: { current: null },
		menuPopoverRef: { current: null },
		mountNode: null,
		triggerId: "",
		openOnContext: false,
		openOnHover: false,
		hasIcons: false,
		hasCheckmarks: false,
		inline: false,
		persistOnItemClick: false
	};
	const MenuProvider = MenuContext.Provider;
	const useMenuContext_unstable = (selector) => useContextSelector(MenuContext, (ctx = menuContextDefaultValue) => selector(ctx));

//#endregion
//#region node_modules/@fluentui/react-menu/lib/contexts/menuTriggerContext.js
/**
	* Context used communicate with a child menu item that it is a trigger for a submenu
	*/ const MenuTriggerContext = react.createContext(void 0);
	const menuTriggerContextDefaultValue = false;
	const MenuTriggerContextProvider = MenuTriggerContext.Provider;
	const useMenuTriggerContext_unstable = () => {
		var _React_useContext;
		return (_React_useContext = react.useContext(MenuTriggerContext)) !== null && _React_useContext !== void 0 ? _React_useContext : menuTriggerContextDefaultValue;
	};

//#endregion
//#region node_modules/@fluentui/react-menu/lib/contexts/menuGroupContext.js
	const MenuGroupContext = react.createContext(void 0);
	const menuGroupContextDefaultValue = { headerId: "" };
	const MenuGroupContextProvider = MenuGroupContext.Provider;
	const useMenuGroupContext_unstable = () => {
		var _React_useContext;
		return (_React_useContext = react.useContext(MenuGroupContext)) !== null && _React_useContext !== void 0 ? _React_useContext : menuGroupContextDefaultValue;
	};

//#endregion
//#region node_modules/@fluentui/react-menu/lib/contexts/menuListContext.js
	const MenuListContext = createContext(void 0);
	const menuListContextDefaultValue = {
		checkedValues: {},
		setFocusByFirstCharacter: () => null,
		toggleCheckbox: () => null,
		selectRadio: () => null,
		hasIcons: false,
		hasCheckmarks: false
	};
	const MenuListProvider = MenuListContext.Provider;
	const useMenuListContext_unstable = (selector) => useContextSelector(MenuListContext, (ctx = menuListContextDefaultValue) => selector(ctx));

//#endregion
//#region node_modules/@fluentui/react-menu/lib/utils/useOnMenuEnter.js
/**
	* Name of the custom event
	*/ const MENU_ENTER_EVENT = "fuimenuenter";
	/**
	* This hook works similarly to @see useOnClickOutside
	*
	* Problem: Trying to behave the same as system menus:
	* When the mouse leaves a stack of nested menus the stack should not dismiss.
	* However if the mouse leaves a stack of menus and enters a parent menu all its children menu should dismiss.
	*
	* We don't use the native mouseenter event because it would trigger too many times in the document
	* Instead, dispatch custom DOM event from the menu so that it can bubble
	* Each nested menu can use the listener to check if the event is from a child or parent menu
	*/ const useOnMenuMouseEnter = (options) => {
		const { refs, callback, element, disabled } = options;
		const listener = useEventCallback((ev) => {
			const popoverRef = refs[0];
			const someMenuPopover = ev.target;
			var _popoverRef_current;
			if (!elementContains((_popoverRef_current = popoverRef.current) !== null && _popoverRef_current !== void 0 ? _popoverRef_current : null, someMenuPopover) && !disabled) callback(ev);
		});
		react.useEffect(() => {
			if (element == null) return;
			if (!disabled) element.addEventListener(MENU_ENTER_EVENT, listener);
			return () => {
				element.removeEventListener(MENU_ENTER_EVENT, listener);
			};
		}, [
			listener,
			element,
			disabled
		]);
	};
	/**
	* Dispatches the custom MouseEvent enter event. Similar to calling `el.click()`
	* @param el - element for the event target
	* @param nativeEvent - the native mouse event this is mapped to
	*/ const dispatchMenuEnterEvent = (el, nativeEvent) => {
		el.dispatchEvent(new CustomEvent(MENU_ENTER_EVENT, {
			bubbles: true,
			detail: { nativeEvent }
		}));
	};

//#endregion
//#region node_modules/@fluentui/react-menu/lib/utils/useIsSubmenu.js
/**
	* A component can be a part of a submenu whether its menu context `isSubmenu` flag is true
	* or whether it is a part of a `MenuList`
	*
	* A simple hook to check box contexts easily
	*
	* @returns whether the component is part of a submenu
	*/ function useIsSubmenu() {
		const menuContextValue = useMenuContext_unstable((context) => context.isSubmenu);
		const hasMenuListContext = useHasParentContext(MenuListContext);
		return menuContextValue || hasMenuListContext;
	}

//#endregion
//#region node_modules/@fluentui/react-menu/lib/utils/useValidateNesting.js
	const useValidateNesting = (componentName) => {
		"use no memo";
		const { targetDocument } = useFluent();
		const triggerRef = useMenuContext_unstable((context) => context.triggerRef);
		const inline = useMenuContext_unstable((context) => context.inline);
		const ref = react.useRef(null);
		react.useEffect(() => {
			let ancestor = ref.current;
			let ancestorComponentName = "";
			do {
				var _ancestor_parentElement;
				ancestor = (_ancestor_parentElement = ancestor === null || ancestor === void 0 ? void 0 : ancestor.parentElement) !== null && _ancestor_parentElement !== void 0 ? _ancestor_parentElement : null;
				if (ancestor === null || ancestor === void 0 ? void 0 : ancestor.classList.contains("fui-MenuList")) break;
				else if (ancestor === null || ancestor === void 0 ? void 0 : ancestor.classList.contains("fui-MenuGrid")) ancestorComponentName = "MenuGrid";
				else if (ancestor === null || ancestor === void 0 ? void 0 : ancestor.classList.contains("fui-MenuGridItem")) ancestorComponentName = "MenuGridItem";
				else if (ancestor === null || ancestor === void 0 ? void 0 : ancestor.classList.contains("fui-MenuGridRow")) ancestorComponentName = "MenuGridRow";
				else if (ancestor === null || ancestor === void 0 ? void 0 : ancestor.classList.contains("fui-MenuGridCell")) ancestorComponentName = "MenuGridCell";
				if ([
					"MenuItem",
					"MenuItemCheckbox",
					"MenuItemRadio"
				].includes(componentName)) {
					if ([
						"MenuGrid",
						"MenuGridItem",
						"MenuGridRow",
						"MenuGridCell"
					].includes(ancestorComponentName)) throw new Error(`${componentName} is incorrectly nested within ${ancestorComponentName}. You probably want to wrap it in a MenuList instead.`);
				} else if (componentName === "MenuList") {
					if (ancestorComponentName === "MenuGridCell") {
						if (inline && getCellOfTrigger(triggerRef.current, targetDocument) === ancestor) break;
						throw new Error(`MenuList is incorrectly nested within MenuGridCell.`);
					} else if ([
						"MenuGrid",
						"MenuGridItem",
						"MenuGridRow"
					].includes(ancestorComponentName)) throw new Error(`MenuList is incorrectly nested within ${ancestorComponentName}.`);
				}
			} while (ancestor && ancestor !== (targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.body));
		}, [
			componentName,
			ref,
			triggerRef,
			inline,
			targetDocument
		]);
		return ref;
	};
	const getCellOfTrigger = (trigger, targetDocument) => {
		let ancestor = trigger === null || trigger === void 0 ? void 0 : trigger.parentElement;
		while (ancestor && ancestor !== (targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.body)) {
			if (ancestor === null || ancestor === void 0 ? void 0 : ancestor.classList.contains("fui-MenuGridCell")) return ancestor;
			var _ancestor_parentElement;
			ancestor = (_ancestor_parentElement = ancestor === null || ancestor === void 0 ? void 0 : ancestor.parentElement) !== null && _ancestor_parentElement !== void 0 ? _ancestor_parentElement : null;
		}
		return null;
	};

//#endregion
//#region node_modules/@fluentui/react-menu/lib/utils/useOnMenuSafeZoneTimeout.js
/**
	* Name of the custom event
	*/ const MENU_SAFEZONE_TIMEOUT_EVENT = "fuimenusafezonetimeout";
	/**
	* This hook listeners on a menu trigger for a custom event for an indication that a safe zone was closed over the
	* matching item.
	*/ const useOnMenuSafeZoneTimeout = (listener) => {
		const elementRef = react.useRef(null);
		return react.useCallback((element) => {
			var _elementRef_current;
			(_elementRef_current = elementRef.current) === null || _elementRef_current === void 0 || _elementRef_current.removeEventListener(MENU_SAFEZONE_TIMEOUT_EVENT, listener);
			element === null || element === void 0 || element.addEventListener(MENU_SAFEZONE_TIMEOUT_EVENT, listener);
			elementRef.current = element;
		}, [listener]);
	};

//#endregion
//#region node_modules/@fluentui/react-menu/lib/selectable/useCheckmarkStyles.styles.js
	const useStyles$88 = /* @__PURE__ */ __styles({
		root: {
			a9b677: "fjw5fx7",
			Bqenvij: "fd461yt",
			Bcdw1i0: "fd7fpy0",
			Bnnss6s: "fi64zpg"
		},
		rootChecked: {
			Bcdw1i0: "f1022m68",
			Bnnss6s: "fi64zpg"
		}
	}, { d: [
		".fjw5fx7{width:16px;}",
		".fd461yt{height:16px;}",
		".fd7fpy0{visibility:hidden;}",
		".fi64zpg{flex-shrink:0;}",
		".f1022m68{visibility:visible;}"
	] });
	/**
	* Applies styles to a checkmark slot for selectable menu items
	*
	* @param state - should contain a `checkmark` slot
	*/
	const useCheckmarkStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$88();
		if (state.checkmark) state.checkmark.className = mergeClasses(styles.root, state.checked && styles.rootChecked, state.checkmark.className);
	};

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/MenuItem/useMenuItemStyles.styles.js
	const menuItemClassNames = {
		root: "fui-MenuItem",
		icon: "fui-MenuItem__icon",
		checkmark: "fui-MenuItem__checkmark",
		submenuIndicator: "fui-MenuItem__submenuIndicator",
		content: "fui-MenuItem__content",
		secondaryContent: "fui-MenuItem__secondaryContent",
		subText: "fui-MenuItem__subText"
	};
	const useRootBaseStyles$8 = /* @__PURE__ */ __resetStyles("rfoezjv", "r8lt3v0", {
		r: [
			".rfoezjv{border-radius:var(--borderRadiusMedium);position:relative;color:var(--colorNeutralForeground2);background-color:var(--colorNeutralBackground1);padding-right:var(--spacingVerticalSNudge);padding-left:var(--spacingVerticalSNudge);padding-top:var(--spacingVerticalSNudge);padding-bottom:var(--spacingVerticalSNudge);box-sizing:border-box;max-width:290px;min-height:32px;flex-shrink:0;display:flex;align-items:start;font-size:var(--fontSizeBase300);cursor:pointer;gap:4px;-webkit-user-select:none;-moz-user-select:none;user-select:none;}",
			".rfoezjv:hover{background-color:var(--colorNeutralBackground1Hover);color:var(--colorNeutralForeground2Hover);}",
			".rfoezjv:hover .fui-Icon-filled{display:inline;}",
			".rfoezjv:hover .fui-Icon-regular{display:none;}",
			".rfoezjv:hover .fui-MenuItem__icon{color:var(--colorNeutralForeground2BrandSelected);}",
			".rfoezjv:hover .fui-MenuItem__subText{color:var(--colorNeutralForeground3Hover);}",
			".rfoezjv:hover:active{background-color:var(--colorNeutralBackground1Pressed);color:var(--colorNeutralForeground2Pressed);}",
			".rfoezjv:hover:active .fui-MenuItem__subText{color:var(--colorNeutralForeground3Pressed);}",
			".rfoezjv:focus{outline-style:none;}",
			".rfoezjv:focus-visible{outline-style:none;}",
			".rfoezjv[data-fui-focus-visible]{border-top-color:transparent;border-right-color:transparent;border-bottom-color:transparent;border-left-color:transparent;}",
			".rfoezjv[data-fui-focus-visible]::after{content:\"\";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);right:calc(2px * -1);bottom:calc(2px * -1);left:calc(2px * -1);}",
			".r8lt3v0{border-radius:var(--borderRadiusMedium);position:relative;color:var(--colorNeutralForeground2);background-color:var(--colorNeutralBackground1);padding-left:var(--spacingVerticalSNudge);padding-right:var(--spacingVerticalSNudge);padding-top:var(--spacingVerticalSNudge);padding-bottom:var(--spacingVerticalSNudge);box-sizing:border-box;max-width:290px;min-height:32px;flex-shrink:0;display:flex;align-items:start;font-size:var(--fontSizeBase300);cursor:pointer;gap:4px;-webkit-user-select:none;-moz-user-select:none;user-select:none;}",
			".r8lt3v0:hover{background-color:var(--colorNeutralBackground1Hover);color:var(--colorNeutralForeground2Hover);}",
			".r8lt3v0:hover .fui-Icon-filled{display:inline;}",
			".r8lt3v0:hover .fui-Icon-regular{display:none;}",
			".r8lt3v0:hover .fui-MenuItem__icon{color:var(--colorNeutralForeground2BrandSelected);}",
			".r8lt3v0:hover .fui-MenuItem__subText{color:var(--colorNeutralForeground3Hover);}",
			".r8lt3v0:hover:active{background-color:var(--colorNeutralBackground1Pressed);color:var(--colorNeutralForeground2Pressed);}",
			".r8lt3v0:hover:active .fui-MenuItem__subText{color:var(--colorNeutralForeground3Pressed);}",
			".r8lt3v0:focus{outline-style:none;}",
			".r8lt3v0:focus-visible{outline-style:none;}",
			".r8lt3v0[data-fui-focus-visible]{border-top-color:transparent;border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent;}",
			".r8lt3v0[data-fui-focus-visible]::after{content:\"\";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);left:calc(2px * -1);bottom:calc(2px * -1);right:calc(2px * -1);}"
		],
		s: [
			"@media (forced-colors: active){.rfoezjv:hover{background-color:Canvas;border-color:Highlight;color:Highlight;}.rfoezjv:focus{outline-style:none;}.rfoezjv:focus-visible{outline-style:none;}.rfoezjv[data-fui-focus-visible]{border-top-color:transparent;border-right-color:transparent;border-bottom-color:transparent;border-left-color:transparent;}@media (forced-colors: active){.rfoezjv[data-fui-focus-visible]::after{border-top-color:Highlight;border-right-color:Highlight;border-bottom-color:Highlight;border-left-color:Highlight;}}.rfoezjv[data-fui-focus-visible]::after{content:\"\";position:absolute;pointer-events:none;z-index:1;border:2px solid Highlight;border-radius:var(--borderRadiusMedium);top:calc(2px * -1);right:calc(2px * -1);bottom:calc(2px * -1);left:calc(2px * -1);}}",
			"@media (forced-colors: active){.rfoezjv[data-fui-focus-visible]::after{border-top-color:Highlight;border-right-color:Highlight;border-bottom-color:Highlight;border-left-color:Highlight;}}",
			"@media (forced-colors: active){.r8lt3v0:hover{background-color:Canvas;border-color:Highlight;color:Highlight;}.r8lt3v0:focus{outline-style:none;}.r8lt3v0:focus-visible{outline-style:none;}.r8lt3v0[data-fui-focus-visible]{border-top-color:transparent;border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent;}@media (forced-colors: active){.r8lt3v0[data-fui-focus-visible]::after{border-top-color:Highlight;border-left-color:Highlight;border-bottom-color:Highlight;border-right-color:Highlight;}}.r8lt3v0[data-fui-focus-visible]::after{content:\"\";position:absolute;pointer-events:none;z-index:1;border:2px solid Highlight;border-radius:var(--borderRadiusMedium);top:calc(2px * -1);left:calc(2px * -1);bottom:calc(2px * -1);right:calc(2px * -1);}}",
			"@media (forced-colors: active){.r8lt3v0[data-fui-focus-visible]::after{border-top-color:Highlight;border-left-color:Highlight;border-bottom-color:Highlight;border-right-color:Highlight;}}"
		]
	});
	const useContentBaseStyles = /* @__PURE__ */ __resetStyles("r1ls86vo", "rpbc5dr", [".r1ls86vo{padding-left:2px;padding-right:2px;background-color:transparent;flex-grow:1;}", ".rpbc5dr{padding-right:2px;padding-left:2px;background-color:transparent;flex-grow:1;}"]);
	const useSecondaryContentBaseStyles = /* @__PURE__ */ __resetStyles("r12mwwux", "r1ewgu5j", [
		".r12mwwux{padding-left:2px;padding-right:2px;font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase200);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase300);color:var(--colorNeutralForeground3);}",
		".r12mwwux:hover{color:var(--colorNeutralForeground3Hover);}",
		".r12mwwux:focus{color:var(--colorNeutralForeground3Hover);}",
		".r1ewgu5j{padding-right:2px;padding-left:2px;font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase200);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase300);color:var(--colorNeutralForeground3);}",
		".r1ewgu5j:hover{color:var(--colorNeutralForeground3Hover);}",
		".r1ewgu5j:focus{color:var(--colorNeutralForeground3Hover);}"
	]);
	const useIconBaseStyles$2 = /* @__PURE__ */ __resetStyles("ro9koqv", null, [".ro9koqv{width:20px;height:20px;font-size:20px;line-height:0;align-items:center;display:inline-flex;justify-content:center;flex-shrink:0;}"]);
	const useSubmenuIndicatorBaseStyles = /* @__PURE__ */ __resetStyles("r9c34qo", null, [".r9c34qo{width:20px;height:20px;font-size:20px;line-height:0;align-items:center;display:inline-flex;justify-content:center;}"]);
	const useSubtextBaseStyles = /* @__PURE__ */ __resetStyles("rk2ppru", null, [".rk2ppru{font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase100);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase100);color:var(--colorNeutralForeground3);}"]);
	const useStyles$87 = /* @__PURE__ */ __styles({
		checkmark: { B6of3ja: "fmnzpld" },
		splitItemMain: { Bh6795r: "fqerorx" },
		splitItemTrigger: {
			Btl43ni: ["f1ozlkrg", "f10ostut"],
			Beyfa6y: ["f1deotkl", "f1krrbdw"],
			uwmqm3: ["f1cnd47f", "fhxju0i"],
			Ftih45: "f1wl9k8s",
			Ccq8qp: "f1yn80uh",
			Baz25je: "f68mna0",
			cmx5o7: "f1p5zmk"
		},
		disabled: {
			sj55zd: "f1s2aq7o",
			Bi91k9c: "fvgxktp",
			Jwef8y: "f1ijtazh",
			eoavqd: "fphbwmw",
			Bk3fhr4: "f19vpps7",
			Bmfj8id: "fv5swzo",
			Bg7n49j: "f1q1x1ba",
			c7f7en: "ff3wrqt",
			B2d53fq: "fcvwxyo",
			iro3zm: "f1to34ca",
			Bumww26: "fszh5vc",
			t0hwav: "ft33916",
			B7iucu3: "f1cyfu5x",
			Bahaeuw: "fa9u7a5",
			Bbkh6qg: "f1wzezsb",
			B3ejlan: "f1egomlm",
			B41git9: "f1wf2001",
			Boq1n10: "fied5gk",
			Dcq74g: "f1efp33f",
			rxnm8d: "f1m2zpi7",
			wxluhh: "fei14nx",
			idgcvv: "f12hmwa5",
			j9xr24: "f1hzwxd0"
		}
	}, {
		d: [
			".fmnzpld{margin-top:2px;}",
			".fqerorx{flex-grow:1;}",
			".f1ozlkrg{border-top-left-radius:0;}",
			".f10ostut{border-top-right-radius:0;}",
			".f1deotkl{border-bottom-left-radius:0;}",
			".f1krrbdw{border-bottom-right-radius:0;}",
			".f1cnd47f{padding-left:0;}",
			".fhxju0i{padding-right:0;}",
			".f1wl9k8s::before{content:\"\";}",
			".f1yn80uh::before{width:var(--strokeWidthThin);}",
			".f68mna0::before{height:24px;}",
			".f1p5zmk::before{background-color:var(--colorNeutralStroke1);}",
			".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}"
		],
		h: [
			".fvgxktp:hover{color:var(--colorNeutralForegroundDisabled);}",
			".f1ijtazh:hover{background-color:var(--colorNeutralBackground1);}",
			".fphbwmw:hover{cursor:not-allowed;}",
			".f19vpps7:hover .fui-Icon-filled{display:none;}",
			".fv5swzo:hover .fui-Icon-regular{display:inline;}",
			".f1q1x1ba:hover .fui-MenuItem__icon{color:var(--colorNeutralForegroundDisabled);}",
			".ff3wrqt:hover .fui-MenuItem__subText{color:var(--colorNeutralForegroundDisabled);}",
			".fcvwxyo:hover:active{color:var(--colorNeutralForegroundDisabled);}",
			".f1to34ca:hover:active{background-color:var(--colorNeutralBackground1);}",
			".fszh5vc:hover:active .fui-MenuItem__subText{color:var(--colorNeutralForegroundDisabled);}"
		],
		f: [".ft33916:focus{color:var(--colorNeutralForegroundDisabled);}"],
		m: [
			["@media (forced-colors: active){.f1cyfu5x{color:GrayText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fa9u7a5:hover{color:GrayText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1wzezsb:hover{background-color:Canvas;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1egomlm:hover .fui-MenuItem__icon{color:GrayText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1wf2001:hover .fui-MenuItem__icon{background-color:Canvas;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fied5gk:hover .fui-MenuItem__subText{color:GrayText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1efp33f:hover:active{color:GrayText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1m2zpi7:hover:active{background-color:Canvas;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fei14nx:hover:active .fui-MenuItem__subText{color:GrayText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f12hmwa5:focus{color:GrayText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1hzwxd0:focus{background-color:Canvas;}}", { m: "(forced-colors: active)" }]
		]
	});
	const useSubTextStyles = /* @__PURE__ */ __styles({ disabled: {
		sj55zd: "f1s2aq7o",
		B7iucu3: "f1cyfu5x"
	} }, {
		d: [".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}"],
		m: [["@media (forced-colors: active){.f1cyfu5x{color:GrayText;}}", { m: "(forced-colors: active)" }]]
	});
	const useMultilineStyles$2 = /* @__PURE__ */ __styles({
		content: {
			mc9l5x: "f22iagw",
			Beiy3e4: "f1vx9l62"
		},
		secondaryContent: { qb2dma: "f7nlbp4" },
		submenuIndicator: { qb2dma: "f7nlbp4" }
	}, { d: [
		".f22iagw{display:flex;}",
		".f1vx9l62{flex-direction:column;}",
		".f7nlbp4{align-self:center;}"
	] });
	/** Applies style classnames to slots */
	const useMenuItemStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$87();
		const rootBaseStyles = useRootBaseStyles$8();
		const contentBaseStyles = useContentBaseStyles();
		const secondaryContentBaseStyles = useSecondaryContentBaseStyles();
		const iconBaseStyles = useIconBaseStyles$2();
		const submenuIndicatorBaseStyles = useSubmenuIndicatorBaseStyles();
		const multilineStyles = useMultilineStyles$2();
		const subtextBaseStyles = useSubtextBaseStyles();
		const subTextStyles = useSubTextStyles();
		const multiline = !!state.subText;
		state.root.className = mergeClasses(menuItemClassNames.root, rootBaseStyles, state.disabled && styles.disabled, state.root.className);
		if (state.content) state.content.className = mergeClasses(menuItemClassNames.content, contentBaseStyles, state.content.className, multiline && multilineStyles.content);
		if (state.checkmark) state.checkmark.className = mergeClasses(menuItemClassNames.checkmark, styles.checkmark, state.checkmark.className);
		if (state.secondaryContent) state.secondaryContent.className = mergeClasses(menuItemClassNames.secondaryContent, secondaryContentBaseStyles, state.disabled && styles.disabled, state.secondaryContent.className, multiline && multilineStyles.secondaryContent);
		if (state.icon) state.icon.className = mergeClasses(menuItemClassNames.icon, iconBaseStyles, state.icon.className);
		if (state.submenuIndicator) state.submenuIndicator.className = mergeClasses(menuItemClassNames.submenuIndicator, submenuIndicatorBaseStyles, state.submenuIndicator.className, multiline && multilineStyles.submenuIndicator);
		if (state.subText) state.subText.className = mergeClasses(menuItemClassNames.subText, state.disabled && subTextStyles.disabled, state.subText.className, subtextBaseStyles);
		useCheckmarkStyles_unstable(state);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/Menu/useMenu.js
	const submenuFallbackPositions = [
		"after",
		"after-bottom",
		"before-top",
		"before",
		"before-bottom",
		"above"
	];
	/**
	* Create the state required to render Menu.
	*
	* The returned state can be modified with hooks such as useMenuStyles,
	* before being passed to renderMenu_unstable.
	*
	* @param props - props from this instance of Menu
	*/ const useMenu_unstable = (props) => {
		const isSubmenu = useIsSubmenu();
		const { hoverDelay = 500, inline = false, hasCheckmarks = false, hasIcons = false, closeOnScroll = false, openOnContext = false, persistOnItemClick = false, openOnHover = isSubmenu, defaultCheckedValues, mountNode = null, safeZone } = props;
		const { targetDocument } = useFluent();
		const triggerId = useId("menu");
		const [contextTarget, setContextTarget] = usePositioningMouseTarget();
		const positioningOptions = {
			position: isSubmenu ? "after" : "below",
			align: isSubmenu ? "top" : "start",
			target: props.openOnContext ? contextTarget : void 0,
			fallbackPositions: isSubmenu ? submenuFallbackPositions : void 0,
			...resolvePositioningShorthand(props.positioning)
		};
		const children = react.Children.toArray(props.children);
		if (children.length === 0) console.warn("Menu must contain at least one child");
		if (children.length > 2) console.warn("Menu must contain at most two children");
		let menuTrigger = void 0;
		let menuPopover = void 0;
		if (children.length === 2) {
			menuTrigger = children[0];
			menuPopover = children[1];
		} else if (children.length === 1) menuPopover = children[0];
		const { targetRef, containerRef } = usePositioning(positioningOptions);
		const enableSafeZone = safeZone && openOnHover;
		const safeZoneDescriptorRef = react.useRef({
			isInside: false,
			mouseCoordinates: {
				x: 0,
				y: 0
			}
		});
		const safeZoneHandle = useSafeZoneArea({
			disabled: !enableSafeZone,
			timeout: typeof safeZone === "object" ? safeZone.timeout : 300,
			onSafeZoneEnter: (e) => {
				setOpen(e, {
					open: true,
					keyboard: false,
					type: "menuSafeZoneMouseEnter",
					event: e
				});
				safeZoneDescriptorRef.current.isInside = true;
			},
			onSafeZoneLeave: () => {
				safeZoneDescriptorRef.current.isInside = false;
			},
			onSafeZoneMove: (e) => {
				safeZoneDescriptorRef.current.mouseCoordinates = {
					x: e.clientX,
					y: e.clientY
				};
			},
			onSafeZoneTimeout: () => {
				const event = new CustomEvent(MENU_SAFEZONE_TIMEOUT_EVENT);
				setOpen(event, {
					open: false,
					keyboard: false,
					type: "menuSafeZoneTimeout",
					event
				});
				if (safeZoneDescriptorRef.current.isInside && targetDocument) {
					const menuItemEl = targetDocument.elementsFromPoint(safeZoneDescriptorRef.current.mouseCoordinates.x, safeZoneDescriptorRef.current.mouseCoordinates.y).find((el) => {
						return el.classList.contains(menuItemClassNames.root);
					});
					menuItemEl === null || menuItemEl === void 0 || menuItemEl.dispatchEvent(event);
				}
			}
		});
		const triggerRef = useMergedRefs(targetRef, safeZoneHandle.targetRef);
		const menuPopoverRef = useMergedRefs(containerRef, safeZoneHandle.containerRef);
		const [open, setOpen] = useMenuOpenState({
			hoverDelay,
			isSubmenu,
			setContextTarget,
			closeOnScroll,
			menuPopoverRef,
			triggerRef,
			open: props.open,
			defaultOpen: props.defaultOpen,
			onOpenChange: props.onOpenChange,
			openOnContext
		});
		const [checkedValues, onCheckedValueChange] = useMenuSelectableState({
			checkedValues: props.checkedValues,
			defaultCheckedValues,
			onCheckedValueChange: props.onCheckedValueChange
		});
		return {
			inline,
			hoverDelay,
			triggerId,
			isSubmenu,
			openOnHover,
			contextTarget,
			setContextTarget,
			hasCheckmarks,
			hasIcons,
			closeOnScroll,
			menuTrigger,
			menuPopover,
			mountNode,
			triggerRef,
			menuPopoverRef,
			components: {},
			openOnContext,
			open,
			setOpen,
			checkedValues,
			onCheckedValueChange,
			persistOnItemClick,
			safeZone: safeZoneHandle.elementToRender
		};
	};
	/**
	* Adds appropriate state values and handlers for selectable items
	* i.e checkboxes and radios
	*/ const useMenuSelectableState = (props) => {
		const [checkedValues, setCheckedValues] = useControllableState({
			state: props.checkedValues,
			defaultState: props.defaultCheckedValues,
			initialState: {}
		});
		return [checkedValues, useEventCallback((e, { name, checkedItems }) => {
			var _props_onCheckedValueChange;
			(_props_onCheckedValueChange = props.onCheckedValueChange) === null || _props_onCheckedValueChange === void 0 || _props_onCheckedValueChange.call(props, e, {
				name,
				checkedItems
			});
			setCheckedValues((currentValue) => ({
				...currentValue,
				[name]: checkedItems
			}));
		})];
	};
	const useMenuOpenState = (state) => {
		"use no memo";
		const { targetDocument } = useFluent();
		const parentSetOpen = useMenuContext_unstable((context) => context.setOpen);
		const onOpenChange = useEventCallback((e, data) => {
			var _state_onOpenChange;
			return (_state_onOpenChange = state.onOpenChange) === null || _state_onOpenChange === void 0 ? void 0 : _state_onOpenChange.call(state, e, data);
		});
		const enteringTriggerRef = react.useRef(false);
		const [open, setOpenState] = useControllableState({
			state: state.open,
			defaultState: state.defaultOpen,
			initialState: false
		});
		const trySetOpen = useEventCallback((e, data) => {
			const event = e instanceof CustomEvent && e.type === MENU_ENTER_EVENT ? e.detail.nativeEvent : e;
			onOpenChange === null || onOpenChange === void 0 || onOpenChange(event, { ...data });
			if (data.open && e.type === "contextmenu") state.setContextTarget(e);
			if (!data.open) state.setContextTarget(void 0);
			if (data.bubble) parentSetOpen(e, { ...data });
			setOpenState(data.open);
		});
		const [setOpenTimeout, clearOpenTimeout] = useTimeout();
		const setOpen = useEventCallback((e, data) => {
			clearOpenTimeout();
			if (!(e instanceof Event) && e.persist) e.persist();
			if (!data.ignoreHoverDelay && (e.type === "mouseleave" || e.type === "mouseover" || e.type === "mousemove" || e.type === MENU_ENTER_EVENT)) {
				var _state_triggerRef_current;
				if ((_state_triggerRef_current = state.triggerRef.current) === null || _state_triggerRef_current === void 0 ? void 0 : _state_triggerRef_current.contains(e.target)) enteringTriggerRef.current = e.type === "mouseover" || e.type === "mousemove";
				setOpenTimeout(() => trySetOpen(e, data), state.hoverDelay);
			} else trySetOpen(e, data);
		});
		useOnClickOutside({
			contains: elementContains,
			disabled: !open,
			element: targetDocument,
			refs: [state.menuPopoverRef, !state.openOnContext && state.triggerRef].filter(Boolean),
			callback: (event) => setOpen(event, {
				open: false,
				type: "clickOutside",
				event
			})
		});
		const closeOnScroll = state.openOnContext || state.closeOnScroll;
		useOnScrollOutside({
			contains: elementContains,
			element: targetDocument,
			callback: (event) => setOpen(event, {
				open: false,
				type: "scrollOutside",
				event
			}),
			refs: [state.menuPopoverRef, !state.openOnContext && state.triggerRef].filter(Boolean),
			disabled: !open || !closeOnScroll
		});
		useOnMenuMouseEnter({
			element: targetDocument,
			callback: (event) => {
				if (!enteringTriggerRef.current) setOpen(event, {
					open: false,
					type: "menuMouseEnter",
					event
				});
			},
			disabled: !open,
			refs: [state.menuPopoverRef]
		});
		const { findFirstFocusable } = useFocusFinders();
		const focusFirst = react.useCallback(() => {
			const firstFocusable = findFirstFocusable(state.menuPopoverRef.current);
			firstFocusable === null || firstFocusable === void 0 || firstFocusable.focus();
		}, [findFirstFocusable, state.menuPopoverRef]);
		const firstMount = useFirstMount();
		react.useEffect(() => {
			if (open) focusFirst();
			else if (!firstMount) {
				if ((targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.activeElement) === (targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.body)) {
					var _state_triggerRef_current;
					(_state_triggerRef_current = state.triggerRef.current) === null || _state_triggerRef_current === void 0 || _state_triggerRef_current.focus();
				}
			}
		}, [
			state.triggerRef,
			state.isSubmenu,
			open,
			focusFirst,
			targetDocument,
			state.menuPopoverRef
		]);
		return [open, setOpen];
	};

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/Menu/useMenuContextValues.js
	function useMenuContextValues_unstable(state) {
		const { checkedValues, hasCheckmarks, hasIcons, inline, isSubmenu, menuPopoverRef, mountNode, onCheckedValueChange, open, openOnContext, openOnHover, persistOnItemClick, safeZone, setOpen, triggerId, triggerRef } = state;
		return { menu: {
			checkedValues,
			hasCheckmarks,
			hasIcons,
			inline,
			isSubmenu,
			menuPopoverRef,
			mountNode,
			onCheckedValueChange,
			open,
			openOnContext,
			openOnHover,
			persistOnItemClick,
			safeZone,
			setOpen,
			triggerId,
			triggerRef
		} };
	}

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/Menu/renderMenu.js
/**
	* Render the final JSX of Menu
	*/ const renderMenu_unstable = (state, contextValues) => {
		return /* @__PURE__ */ react.createElement(MenuProvider, { value: contextValues.menu }, state.menuTrigger, state.open && state.menuPopover);
	};

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/Menu/Menu.js
/**
	* Wrapper component that manages state for a popup MenuList and a MenuTrigger
	*/ const Menu = (props) => {
		const state = useMenu_unstable(props);
		return renderMenu_unstable(state, useMenuContextValues_unstable(state));
	};
	Menu.displayName = "Menu";

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/MenuDivider/useMenuDivider.js
/**
	* Given user props, returns state and render function for a MenuDivider.
	*/ const useMenuDivider_unstable = (props, ref) => {
		return {
			components: { root: "div" },
			root: always(getIntrinsicElementProps("div", {
				role: "presentation",
				"aria-hidden": true,
				...props,
				ref
			}), { elementType: "div" })
		};
	};

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/MenuDivider/useMenuDividerStyles.styles.js
	const menuDividerClassNames = { root: "fui-MenuDivider" };
	const useStyles$86 = /* @__PURE__ */ __styles({ root: {
		jrapky: 0,
		Frg6f3: 0,
		t21cq0: 0,
		B6of3ja: 0,
		B74szlk: "f8dz51a",
		a9b677: "f14z66ap",
		B9xav0g: 0,
		oivjwe: 0,
		Bn0qgzm: 0,
		Bgfg5da: "f1facbz3"
	} }, { d: [
		[".f8dz51a{margin:4px -5px 4px -5px;}", { p: -1 }],
		".f14z66ap{width:auto;}",
		[".f1facbz3{border-bottom:var(--strokeWidthThin) solid var(--colorNeutralStroke2);}", { p: -1 }]
	] });
	const useMenuDividerStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$86();
		state.root.className = mergeClasses(menuDividerClassNames.root, styles.root, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/MenuDivider/renderMenuDivider.js
/**
	* Redefine the render function to add slots. Reuse the menudivider structure but add
	* slots to children.
	*/ const renderMenuDivider_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, {});
	};

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/MenuDivider/MenuDivider.js
/**
	* Define a styled MenuDivider, using the `useMenuDivider_unstable` hook.
	*/ const MenuDivider = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useMenuDivider_unstable(props, ref);
		useMenuDividerStyles_unstable(state);
		useCustomStyleHook("useMenuDividerStyles_unstable")(state);
		return renderMenuDivider_unstable(state);
	});
	MenuDivider.displayName = "MenuDivider";

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/MenuGroup/useMenuGroup.js
/**
	* Given user props, returns state and render function for a MenuGroup.
	*/ function useMenuGroup_unstable(props, ref) {
		const headerId = useId("menu-group");
		return {
			components: { root: "div" },
			root: always(getIntrinsicElementProps("div", {
				ref,
				"aria-labelledby": headerId,
				role: "group",
				...props
			}), { elementType: "div" }),
			headerId
		};
	}

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/MenuGroup/renderMenuGroup.js
/**
	* Redefine the render function to add slots. Reuse the menugroup structure but add
	* slots to children.
	*/ const renderMenuGroup_unstable = (state, contextValues) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(MenuGroupContextProvider, {
			value: contextValues.menuGroup,
			children: /* @__PURE__ */ jsx(state.root, {})
		});
	};

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/MenuGroup/useMenuGroupContextValues.js
	function useMenuGroupContextValues_unstable(state) {
		const { headerId } = state;
		return { menuGroup: react.useMemo(() => ({ headerId }), [headerId]) };
	}

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/MenuGroup/useMenuGroupStyles.styles.js
	const menuGroupClassNames = { root: "fui-MenuGroup" };
	const useMenuGroupStyles_unstable = (state) => {
		"use no memo";
		state.root.className = mergeClasses(menuGroupClassNames.root, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/MenuGroup/MenuGroup.js
/**
	* Define a styled MenuGroup, using the `useMenuGroup_unstable` hook.
	*/ const MenuGroup = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useMenuGroup_unstable(props, ref);
		const contextValues = useMenuGroupContextValues_unstable(state);
		useMenuGroupStyles_unstable(state);
		useCustomStyleHook("useMenuGroupStyles_unstable")(state);
		return renderMenuGroup_unstable(state, contextValues);
	});
	MenuGroup.displayName = "MenuGroup";

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/MenuGroupHeader/useMenuGroupHeader.js
/**
	* Given user props, returns state and render function for a MenuGroupHeader.
	*/ function useMenuGroupHeader_unstable(props, ref) {
		const { headerId: id } = useMenuGroupContext_unstable();
		return {
			components: { root: "div" },
			root: always(getIntrinsicElementProps("div", {
				ref,
				id,
				...props
			}), { elementType: "div" })
		};
	}

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/MenuGroupHeader/useMenuGroupHeaderStyles.styles.js
	const menuGroupHeaderClassNames = { root: "fui-MenuGroupHeader" };
	const useStyles$85 = /* @__PURE__ */ __styles({ root: {
		Be2twd7: "fy9rknc",
		sj55zd: "f11d4kpn",
		uwmqm3: ["f177v4lu", "f19lj068"],
		z189sj: ["f19lj068", "f177v4lu"],
		Bhrd7zp: "fl43uef",
		Bqenvij: "f1d2rq10",
		mc9l5x: "f22iagw",
		Bt984gj: "f122n59"
	} }, { d: [
		".fy9rknc{font-size:var(--fontSizeBase200);}",
		".f11d4kpn{color:var(--colorNeutralForeground3);}",
		".f177v4lu{padding-left:8px;}",
		".f19lj068{padding-right:8px;}",
		".fl43uef{font-weight:var(--fontWeightSemibold);}",
		".f1d2rq10{height:32px;}",
		".f22iagw{display:flex;}",
		".f122n59{align-items:center;}"
	] });
	const useMenuGroupHeaderStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$85();
		state.root.className = mergeClasses(menuGroupHeaderClassNames.root, styles.root, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/MenuGroupHeader/renderMenuGroupHeader.js
/**
	* Redefine the render function to add slots. Reuse the menugroupheader structure but add
	* slots to children.
	*/ const renderMenuGroupHeader_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, {});
	};

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/MenuGroupHeader/MenuGroupHeader.js
/**
	* Define a styled MenuGroupHeader, using the `useMenuGroupHeader_unstable` hook.
	*/ const MenuGroupHeader = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useMenuGroupHeader_unstable(props, ref);
		useMenuGroupHeaderStyles_unstable(state);
		useCustomStyleHook("useMenuGroupHeaderStyles_unstable")(state);
		return renderMenuGroupHeader_unstable(state);
	});
	MenuGroupHeader.displayName = "MenuGroupHeader";

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/MenuItem/useCharacterSearch.js
	const useCharacterSearch = (state, ref) => {
		"use no memo";
		const setFocusByFirstCharacter = useMenuListContext_unstable((context) => context.setFocusByFirstCharacter);
		const { onKeyDown: originalOnKeyDown } = state.root;
		state.root.onKeyDown = (e) => {
			var _e_key;
			originalOnKeyDown === null || originalOnKeyDown === void 0 || originalOnKeyDown(e);
			if (((_e_key = e.key) === null || _e_key === void 0 ? void 0 : _e_key.length) > 1) return;
			if (ref.current) setFocusByFirstCharacter === null || setFocusByFirstCharacter === void 0 || setFocusByFirstCharacter(e, ref.current);
		};
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-menu/lib/contexts/menuSplitGroupContext.js
/**
	* Context used communicate with a child menu item that it is a trigger for a submenu
	*/ const MenuSplitGroupContext = react.createContext(void 0);
	const menuSplitGroupContextDefaultValue = { setMultiline: () => null };
	const MenuSplitGroupContextProvider = MenuSplitGroupContext.Provider;
	const useMenuSplitGroupContext_unstable = () => {
		var _React_useContext;
		return (_React_useContext = react.useContext(MenuSplitGroupContext)) !== null && _React_useContext !== void 0 ? _React_useContext : menuSplitGroupContextDefaultValue;
	};
	const useIsInMenuSplitGroup = () => {
		return useMenuSplitGroupContext_unstable() !== menuSplitGroupContextDefaultValue;
	};

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/MenuItem/useMenuItem.js
	const ChevronRightIcon = bundleIcon_default(ChevronRightFilled, ChevronRightRegular);
	const ChevronLeftIcon = bundleIcon_default(ChevronLeftFilled, ChevronLeftRegular);
	/**
	* Returns the props and state required to render the component
	*/ const useMenuItem_unstable = (props, ref) => {
		const isSubmenuTrigger = useMenuTriggerContext_unstable();
		const persistOnClickContext = useMenuContext_unstable((context) => context.persistOnItemClick);
		const { as = "div", disabled = false, hasSubmenu = isSubmenuTrigger, persistOnClick = persistOnClickContext, content: _content, ...rest } = props;
		const { hasIcons, hasCheckmarks } = useIconAndCheckmarkAlignment({ hasSubmenu });
		const setOpen = useMenuContext_unstable((context) => context.setOpen);
		useNotifySplitItemMultiline({
			multiline: !!props.subText,
			hasSubmenu
		});
		const { dir } = useFluent();
		const innerRef = react.useRef(null);
		const dismissedWithKeyboardRef = react.useRef(false);
		const validateNestingRef = useValidateNesting(getValidateNestingComponentName(props.role));
		const state = {
			hasSubmenu,
			disabled,
			persistOnClick,
			components: {
				root: "div",
				icon: "span",
				checkmark: "span",
				submenuIndicator: "span",
				content: "span",
				secondaryContent: "span",
				subText: "span"
			},
			root: always(getIntrinsicElementProps(as, useARIAButtonProps(as, {
				role: "menuitem",
				...rest,
				disabled: false,
				disabledFocusable: disabled,
				ref: useMergedRefs(ref, innerRef, validateNestingRef),
				onKeyDown: useEventCallback((event) => {
					var _props_onKeyDown;
					(_props_onKeyDown = props.onKeyDown) === null || _props_onKeyDown === void 0 || _props_onKeyDown.call(props, event);
					if (!event.isDefaultPrevented() && (event.key === Space || event.key === Enter)) dismissedWithKeyboardRef.current = true;
				}),
				onMouseMove: useEventCallback((event) => {
					var _props_onMouseMove;
					if (event.currentTarget.ownerDocument.activeElement !== event.currentTarget) {
						var _innerRef_current;
						(_innerRef_current = innerRef.current) === null || _innerRef_current === void 0 || _innerRef_current.focus();
					}
					(_props_onMouseMove = props.onMouseMove) === null || _props_onMouseMove === void 0 || _props_onMouseMove.call(props, event);
				}),
				onClick: useEventCallback((event) => {
					var _props_onClick;
					if (!hasSubmenu && !persistOnClick) {
						setOpen(event, {
							open: false,
							keyboard: dismissedWithKeyboardRef.current,
							bubble: true,
							type: "menuItemClick",
							event
						});
						dismissedWithKeyboardRef.current = false;
					}
					(_props_onClick = props.onClick) === null || _props_onClick === void 0 || _props_onClick.call(props, event);
				})
			})), { elementType: "div" }),
			icon: optional(props.icon, {
				renderByDefault: hasIcons,
				elementType: "span"
			}),
			checkmark: optional(props.checkmark, {
				renderByDefault: hasCheckmarks,
				elementType: "span"
			}),
			submenuIndicator: optional(props.submenuIndicator, {
				renderByDefault: hasSubmenu,
				defaultProps: { children: dir === "ltr" ? /* @__PURE__ */ react.createElement(ChevronRightIcon, null) : /* @__PURE__ */ react.createElement(ChevronLeftIcon, null) },
				elementType: "span"
			}),
			content: optional(props.content, {
				renderByDefault: !!props.children,
				defaultProps: { children: props.children },
				elementType: "span"
			}),
			secondaryContent: optional(props.secondaryContent, { elementType: "span" }),
			subText: optional(props.subText, { elementType: "span" })
		};
		useCharacterSearch(state, innerRef);
		return state;
	};
	/**
	* MenuSplitGroup needs to apply extra styles when its main item is in multiline layout mode
	* Notify the parent MenuSplitGroup so that it can handle this case
	*/ const useNotifySplitItemMultiline = (options) => {
		const { hasSubmenu, multiline } = options;
		const isSplitItemTrigger = useIsInMenuSplitGroup() && hasSubmenu;
		const { setMultiline } = useMenuSplitGroupContext_unstable();
		useIsomorphicLayoutEffect(() => {
			if (!isSplitItemTrigger) setMultiline(multiline);
		}, [
			setMultiline,
			multiline,
			isSplitItemTrigger
		]);
	};
	const useIconAndCheckmarkAlignment = (options) => {
		const { hasSubmenu } = options;
		const hasIcons = useMenuListContext_unstable((context) => context.hasIcons);
		const hasCheckmarks = useMenuListContext_unstable((context) => context.hasCheckmarks);
		const isSplitItemTrigger = useIsInMenuSplitGroup() && hasSubmenu;
		return {
			hasIcons: hasIcons && !isSplitItemTrigger,
			hasCheckmarks: hasCheckmarks && !isSplitItemTrigger
		};
	};
	const getValidateNestingComponentName = (role) => {
		switch (role) {
			case "menuitemcheckbox": return "MenuItemCheckbox";
			case "menuitemradio": return "MenuItemRadio";
		}
		return "MenuItem";
	};

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/MenuItem/renderMenuItem.js
/**
	* Function that renders the final JSX of the component
	*/ const renderMenuItem_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(state.root, { children: [
			state.checkmark && /* @__PURE__ */ jsx(state.checkmark, {}),
			state.icon && /* @__PURE__ */ jsx(state.icon, {}),
			state.content && /* @__PURE__ */ jsxs(state.content, { children: [state.content.children, state.subText && /* @__PURE__ */ jsx(state.subText, {})] }),
			state.secondaryContent && /* @__PURE__ */ jsx(state.secondaryContent, {}),
			state.submenuIndicator && /* @__PURE__ */ jsx(state.submenuIndicator, {})
		] });
	};

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/MenuItem/MenuItem.js
/**
	* Define a styled MenuItem, using the `useMenuItem_unstable` and `useMenuItemStyles_unstable` hook.
	*/ const MenuItem = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useMenuItem_unstable(props, ref);
		useMenuItemStyles_unstable(state);
		useCustomStyleHook("useMenuItemStyles_unstable")(state);
		return renderMenuItem_unstable(state);
	});
	MenuItem.displayName = "MenuItem";

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/MenuItemCheckbox/useMenuItemCheckbox.js
/** Returns the props and state required to render the component */ const useMenuItemCheckbox_unstable = (props, ref) => {
		const toggleCheckbox = useMenuListContext_unstable((context) => context.toggleCheckbox);
		const { name, value } = props;
		const checked = useMenuListContext_unstable((context) => {
			var _context_checkedValues;
			return (((_context_checkedValues = context.checkedValues) === null || _context_checkedValues === void 0 ? void 0 : _context_checkedValues[name]) || []).indexOf(value) !== -1;
		});
		return {
			...useMenuItem_unstable({
				role: "menuitemcheckbox",
				persistOnClick: true,
				...props,
				"aria-checked": checked,
				checkmark: optional(props.checkmark, {
					defaultProps: { children: /* @__PURE__ */ react.createElement(Checkmark16Filled, null) },
					renderByDefault: true,
					elementType: "span"
				}),
				onClick: (e) => {
					var _props_onClick;
					toggleCheckbox === null || toggleCheckbox === void 0 || toggleCheckbox(e, name, value, checked);
					(_props_onClick = props.onClick) === null || _props_onClick === void 0 || _props_onClick.call(props, e);
				}
			}, ref),
			name,
			value,
			checked
		};
	};

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/MenuItemCheckbox/renderMenuItemCheckbox.js
/** Function that renders the final JSX of the component  */ const renderMenuItemCheckbox_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(state.root, { children: [
			state.checkmark && /* @__PURE__ */ jsx(state.checkmark, {}),
			state.icon && /* @__PURE__ */ jsx(state.icon, {}),
			state.content && /* @__PURE__ */ jsxs(state.content, { children: [state.content.children, state.subText && /* @__PURE__ */ jsx(state.subText, {})] }),
			state.secondaryContent && /* @__PURE__ */ jsx(state.secondaryContent, {})
		] });
	};

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/MenuItemCheckbox/useMenuItemCheckboxStyles.styles.js
	const menuItemCheckboxClassNames = {
		root: "fui-MenuItemCheckbox",
		icon: "fui-MenuItemCheckbox__icon",
		checkmark: "fui-MenuItemCheckbox__checkmark",
		content: "fui-MenuItemCheckbox__content",
		secondaryContent: "fui-MenuItemCheckbox__secondaryContent",
		subText: "fui-MenuItemCheckbox__subText"
	};
	const useMenuItemCheckboxStyles_unstable = (state) => {
		"use no memo";
		state.root.className = mergeClasses(menuItemCheckboxClassNames.root, state.root.className);
		if (state.content) state.content.className = mergeClasses(menuItemCheckboxClassNames.content, state.content.className);
		if (state.secondaryContent) state.secondaryContent.className = mergeClasses(menuItemCheckboxClassNames.secondaryContent, state.secondaryContent.className);
		if (state.icon) state.icon.className = mergeClasses(menuItemCheckboxClassNames.icon, state.icon.className);
		if (state.checkmark) state.checkmark.className = mergeClasses(menuItemCheckboxClassNames.checkmark, state.checkmark.className);
		if (state.subText) state.subText.className = mergeClasses(menuItemCheckboxClassNames.subText, state.subText.className);
		useMenuItemStyles_unstable(state);
		useCheckmarkStyles_unstable(state);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/MenuItemCheckbox/MenuItemCheckbox.js
/**
	* Define a styled MenuItemCheckbox, using the `useMenuItemCheckbox_unstable` hook.
	*/ const MenuItemCheckbox = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useMenuItemCheckbox_unstable(props, ref);
		useMenuItemCheckboxStyles_unstable(state);
		useCustomStyleHook("useMenuItemCheckboxStyles_unstable")(state);
		return renderMenuItemCheckbox_unstable(state);
	});
	MenuItemCheckbox.displayName = "MenuItemCheckbox";

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/MenuItemRadio/useMenuItemRadio.js
/**
	* Given user props, returns state and render function for a MenuItemRadio.
	*/ const useMenuItemRadio_unstable = (props, ref) => {
		const { name, value } = props;
		const checked = useMenuListContext_unstable((context) => {
			var _context_checkedValues;
			return (((_context_checkedValues = context.checkedValues) === null || _context_checkedValues === void 0 ? void 0 : _context_checkedValues[name]) || []).indexOf(value) !== -1;
		});
		const selectRadio = useMenuListContext_unstable((context) => context.selectRadio);
		return {
			...useMenuItem_unstable({
				...props,
				role: "menuitemradio",
				"aria-checked": checked,
				checkmark: optional(props.checkmark, {
					defaultProps: { children: /* @__PURE__ */ react.createElement(Checkmark16Filled, null) },
					renderByDefault: true,
					elementType: "span"
				}),
				onClick: (e) => {
					var _props_onClick;
					selectRadio === null || selectRadio === void 0 || selectRadio(e, name, value, checked);
					(_props_onClick = props.onClick) === null || _props_onClick === void 0 || _props_onClick.call(props, e);
				}
			}, ref),
			checked,
			name,
			value
		};
	};

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/MenuItemRadio/renderMenuItemRadio.js
/**
	* Redefine the render function to add slots. Reuse the menuitemradio structure but add
	* slots to children.
	*/ const renderMenuItemRadio_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(state.root, { children: [
			state.checkmark && /* @__PURE__ */ jsx(state.checkmark, {}),
			state.icon && /* @__PURE__ */ jsx(state.icon, {}),
			state.content && /* @__PURE__ */ jsxs(state.content, { children: [state.content.children, state.subText && /* @__PURE__ */ jsx(state.subText, {})] }),
			state.secondaryContent && /* @__PURE__ */ jsx(state.secondaryContent, {})
		] });
	};

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/MenuItemRadio/useMenuItemRadioStyles.styles.js
	const menuItemRadioClassNames = {
		root: "fui-MenuItemRadio",
		icon: "fui-MenuItemRadio__icon",
		checkmark: "fui-MenuItemRadio__checkmark",
		content: "fui-MenuItemRadio__content",
		secondaryContent: "fui-MenuItemRadio__secondaryContent",
		subText: "fui-MenuItemRadio__subText"
	};
	const useMenuItemRadioStyles_unstable = (state) => {
		"use no memo";
		state.root.className = mergeClasses(menuItemRadioClassNames.root, state.root.className);
		if (state.content) state.content.className = mergeClasses(menuItemRadioClassNames.content, state.content.className);
		if (state.secondaryContent) state.secondaryContent.className = mergeClasses(menuItemRadioClassNames.secondaryContent, state.secondaryContent.className);
		if (state.icon) state.icon.className = mergeClasses(menuItemRadioClassNames.icon, state.icon.className);
		if (state.checkmark) state.checkmark.className = mergeClasses(menuItemRadioClassNames.checkmark, state.checkmark.className);
		if (state.subText) state.subText.className = mergeClasses(menuItemRadioClassNames.subText, state.subText.className);
		useMenuItemStyles_unstable(state);
		useCheckmarkStyles_unstable(state);
	};

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/MenuItemRadio/MenuItemRadio.js
/**
	* Define a styled MenuItemRadio, using the `useMenuItemRadio_unstable` hook.
	*/ const MenuItemRadio = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useMenuItemRadio_unstable(props, ref);
		useMenuItemRadioStyles_unstable(state);
		useCustomStyleHook("useMenuItemRadioStyles_unstable")(state);
		return renderMenuItemRadio_unstable(state);
	});
	MenuItemRadio.displayName = "MenuItemRadio";

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/MenuList/useMenuList.js
/**
	* Returns the props and state required to render the component
	*/ const useMenuList_unstable = (props, ref) => {
		const { findAllFocusable } = useFocusFinders();
		const { targetDocument } = useFluent();
		const menuContext = useMenuContextSelectors();
		const hasMenuContext = useHasParentContext(MenuContext);
		const focusAttributes = useArrowNavigationGroup({ circular: true });
		if (usingPropsAndMenuContext(props, menuContext, hasMenuContext)) console.warn("You are using both MenuList and Menu props, we recommend you to use Menu props when available");
		const innerRef = react.useRef(null);
		const validateNestingRef = useValidateNesting("MenuList");
		react.useEffect(() => {
			const element = innerRef.current;
			if (hasMenuContext && targetDocument && element) {
				const onTabsterMoveFocus = (e) => {
					const nextElement = e.detail.next;
					if (nextElement && element.contains(targetDocument.activeElement) && !element.contains(nextElement)) e.preventDefault();
				};
				targetDocument.addEventListener(TabsterMoveFocusEventName, onTabsterMoveFocus);
				return () => {
					targetDocument.removeEventListener(TabsterMoveFocusEventName, onTabsterMoveFocus);
				};
			}
		}, [
			innerRef,
			targetDocument,
			hasMenuContext
		]);
		const setFocusByFirstCharacter = react.useCallback((e, itemEl) => {
			const acceptedRoles = [
				"menuitem",
				"menuitemcheckbox",
				"menuitemradio"
			];
			if (!innerRef.current) return;
			const menuItems = findAllFocusable(innerRef.current, (el) => el.hasAttribute("role") && acceptedRoles.indexOf(el.getAttribute("role")) !== -1);
			let startIndex = menuItems.indexOf(itemEl) + 1;
			if (startIndex === menuItems.length) startIndex = 0;
			const firstChars = menuItems.map((menuItem) => {
				var _menuItem_textContent;
				return (_menuItem_textContent = menuItem.textContent) === null || _menuItem_textContent === void 0 ? void 0 : _menuItem_textContent.charAt(0).toLowerCase();
			});
			const char$1 = e.key.toLowerCase();
			const getIndexFirstChars = (start, firstChar) => {
				for (let i = start; i < firstChars.length; i++) if (char$1 === firstChars[i]) return i;
				return -1;
			};
			let index = getIndexFirstChars(startIndex, char$1);
			if (index === -1) index = getIndexFirstChars(0, char$1);
			if (index > -1) menuItems[index].focus();
		}, [findAllFocusable]);
		var _props_checkedValues;
		const [checkedValues, setCheckedValues] = useControllableState({
			state: (_props_checkedValues = props.checkedValues) !== null && _props_checkedValues !== void 0 ? _props_checkedValues : hasMenuContext ? menuContext.checkedValues : void 0,
			defaultState: props.defaultCheckedValues,
			initialState: {}
		});
		var _props_onCheckedValueChange;
		const handleCheckedValueChange = (_props_onCheckedValueChange = props.onCheckedValueChange) !== null && _props_onCheckedValueChange !== void 0 ? _props_onCheckedValueChange : hasMenuContext ? menuContext.onCheckedValueChange : void 0;
		const toggleCheckbox = useEventCallback((e, name, value, checked) => {
			const newCheckedItems = [...(checkedValues === null || checkedValues === void 0 ? void 0 : checkedValues[name]) || []];
			if (checked) newCheckedItems.splice(newCheckedItems.indexOf(value), 1);
			else newCheckedItems.push(value);
			handleCheckedValueChange === null || handleCheckedValueChange === void 0 || handleCheckedValueChange(e, {
				name,
				checkedItems: newCheckedItems
			});
			setCheckedValues((s) => ({
				...s,
				[name]: newCheckedItems
			}));
		});
		const selectRadio = useEventCallback((e, name, value) => {
			const newCheckedItems = [value];
			setCheckedValues((s) => ({
				...s,
				[name]: newCheckedItems
			}));
			handleCheckedValueChange === null || handleCheckedValueChange === void 0 || handleCheckedValueChange(e, {
				name,
				checkedItems: newCheckedItems
			});
		});
		return {
			components: { root: "div" },
			root: always(getIntrinsicElementProps("div", {
				ref: useMergedRefs(ref, innerRef, validateNestingRef),
				role: "menu",
				"aria-labelledby": menuContext.triggerId,
				...focusAttributes,
				...props
			}), { elementType: "div" }),
			hasIcons: menuContext.hasIcons || false,
			hasCheckmarks: menuContext.hasCheckmarks || false,
			checkedValues,
			hasMenuContext,
			setFocusByFirstCharacter,
			selectRadio,
			toggleCheckbox
		};
	};
	/**
	* Adds some sugar to fetching multiple context selector values
	*/ const useMenuContextSelectors = () => {
		return {
			checkedValues: useMenuContext_unstable((context) => context.checkedValues),
			onCheckedValueChange: useMenuContext_unstable((context) => context.onCheckedValueChange),
			triggerId: useMenuContext_unstable((context) => context.triggerId),
			hasIcons: useMenuContext_unstable((context) => context.hasIcons),
			hasCheckmarks: useMenuContext_unstable((context) => context.hasCheckmarks)
		};
	};
	/**
	* Helper function to detect if props and MenuContext values are both used
	*/ const usingPropsAndMenuContext = (props, contextValue, hasMenuContext) => {
		let isUsingPropsAndContext = false;
		for (const val in contextValue) if (props[val]) isUsingPropsAndContext = true;
		return hasMenuContext && isUsingPropsAndContext;
	};

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/MenuList/renderMenuList.js
/**
	* Function that renders the final JSX of the component
	*/ const renderMenuList_unstable = (state, contextValues) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(MenuListProvider, {
			value: contextValues.menuList,
			children: /* @__PURE__ */ jsx(state.root, {})
		});
	};

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/MenuList/useMenuListContextValues.js
	function useMenuListContextValues_unstable(state) {
		const { checkedValues, hasCheckmarks, hasIcons, selectRadio, setFocusByFirstCharacter, toggleCheckbox } = state;
		return { menuList: {
			checkedValues,
			hasCheckmarks,
			hasIcons,
			selectRadio,
			setFocusByFirstCharacter,
			toggleCheckbox
		} };
	}

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/MenuList/useMenuListStyles.styles.js
	const menuListClassNames = { root: "fui-MenuList" };
	const useStyles$84 = /* @__PURE__ */ __styles({
		root: {
			mc9l5x: "f22iagw",
			Beiy3e4: "f1vx9l62",
			i8kkvl: 0,
			Belr9w4: 0,
			rmohyg: "f1t6b6ee"
		},
		hasMenuContext: { Bqenvij: "f1l02sjl" }
	}, { d: [
		".f22iagw{display:flex;}",
		".f1vx9l62{flex-direction:column;}",
		[".f1t6b6ee{gap:2px;}", { p: -1 }],
		".f1l02sjl{height:100%;}"
	] });
	/**
	* Apply styling to the Menu slots based on the state
	*/
	const useMenuListStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$84();
		state.root.className = mergeClasses(menuListClassNames.root, styles.root, state.hasMenuContext && styles.hasMenuContext, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/MenuList/MenuList.js
/**
	* Define a styled MenuList, using the `useMenuList_unstable` hook.
	*/ const MenuList = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useMenuList_unstable(props, ref);
		const contextValues = useMenuListContextValues_unstable(state);
		useMenuListStyles_unstable(state);
		useCustomStyleHook("useMenuListStyles_unstable")(state);
		return renderMenuList_unstable(state, contextValues);
	});
	MenuList.displayName = "MenuList";

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/MenuPopover/useMenuPopover.js
/**
	* Create the state required to render MenuPopover.
	*
	* The returned state can be modified with hooks such as useMenuPopoverStyles_unstable,
	* before being passed to renderMenuPopover_unstable.
	*
	* @param props - props from this instance of MenuPopover
	* @param ref - reference to root HTMLElement of MenuPopover
	*/ const useMenuPopover_unstable = (props, ref) => {
		"use no memo";
		const safeZone = useMenuContext_unstable((context) => context.safeZone);
		const popoverRef = useMenuContext_unstable((context) => context.menuPopoverRef);
		const setOpen = useMenuContext_unstable((context) => context.setOpen);
		const open = useMenuContext_unstable((context) => context.open);
		const openOnHover = useMenuContext_unstable((context) => context.openOnHover);
		const triggerRef = useMenuContext_unstable((context) => context.triggerRef);
		const isSubmenu = useIsSubmenu();
		const canDispatchCustomEventRef = react.useRef(true);
		const restoreFocusSourceAttributes = useRestoreFocusSource();
		const [setThrottleTimeout, clearThrottleTimeout] = useTimeout();
		const { dir } = useFluent();
		const CloseArrowKey = dir === "ltr" ? ArrowLeft : ArrowRight;
		const mouseOverListenerCallbackRef = react.useCallback((node$1) => {
			if (node$1) node$1.addEventListener("mouseover", (e) => {
				if (canDispatchCustomEventRef.current) {
					canDispatchCustomEventRef.current = false;
					dispatchMenuEnterEvent(popoverRef.current, e);
					setThrottleTimeout(() => {
						canDispatchCustomEventRef.current = true;
					}, 250);
				}
			});
		}, [popoverRef, setThrottleTimeout]);
		react.useEffect(() => {
			return () => clearThrottleTimeout();
		}, [clearThrottleTimeout]);
		var _useMenuContext_unstable;
		const inline = (_useMenuContext_unstable = useMenuContext_unstable((context) => context.inline)) !== null && _useMenuContext_unstable !== void 0 ? _useMenuContext_unstable : false;
		const mountNode = useMenuContext_unstable((context) => context.mountNode);
		const rootProps = always(getIntrinsicElementProps("div", {
			role: "presentation",
			...restoreFocusSourceAttributes,
			...props,
			ref: useMergedRefs(ref, popoverRef, mouseOverListenerCallbackRef)
		}), { elementType: "div" });
		const { onMouseEnter: onMouseEnterOriginal, onKeyDown: onKeyDownOriginal } = rootProps;
		rootProps.onMouseEnter = useEventCallback((event) => {
			if (openOnHover || isSubmenu) setOpen(event, {
				open: true,
				keyboard: false,
				type: "menuPopoverMouseEnter",
				event
			});
			onMouseEnterOriginal === null || onMouseEnterOriginal === void 0 || onMouseEnterOriginal(event);
		});
		rootProps.onKeyDown = useEventCallback((event) => {
			const key = event.key;
			if (key === Escape || isSubmenu && key === CloseArrowKey) {
				var _popoverRef_current;
				if (open && ((_popoverRef_current = popoverRef.current) === null || _popoverRef_current === void 0 ? void 0 : _popoverRef_current.contains(event.target)) && !event.isDefaultPrevented()) {
					setOpen(event, {
						open: false,
						keyboard: true,
						type: "menuPopoverKeyDown",
						event
					});
					event.preventDefault();
				}
			}
			if (key === Tab$1) {
				setOpen(event, {
					open: false,
					keyboard: true,
					type: "menuPopoverKeyDown",
					event
				});
				if (!isSubmenu) {
					var _triggerRef_current;
					(_triggerRef_current = triggerRef.current) === null || _triggerRef_current === void 0 || _triggerRef_current.focus();
				}
			}
			onKeyDownOriginal === null || onKeyDownOriginal === void 0 || onKeyDownOriginal(event);
		});
		return {
			inline,
			mountNode,
			safeZone,
			components: { root: "div" },
			root: rootProps
		};
	};

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/MenuPopover/useMenuPopoverStyles.styles.js
	const menuPopoverClassNames = { root: "fui-MenuPopover" };
	const useStyles$83 = /* @__PURE__ */ __styles({ root: {
		Beyfa6y: 0,
		Bbmb7ep: 0,
		Btl43ni: 0,
		B7oj6ja: 0,
		Dimara: "ft85np5",
		De3pzq: "fxugw4r",
		sj55zd: "f19n0e5",
		B7ck84d: "f1ewtqcl",
		Bf4jedk: "fl8fusi",
		B2u0y6b: "f1kaai3v",
		B68tc82: "f1p9o1ba",
		a9b677: "f1ahpp82",
		E5pizo: "f1hg901r",
		Byoj8tv: 0,
		uwmqm3: 0,
		z189sj: 0,
		z8tnut: 0,
		B0ocmuz: "fd3pd8h",
		Bgfg5da: 0,
		B9xav0g: 0,
		oivjwe: 0,
		Bn0qgzm: 0,
		B4g9neb: 0,
		zhjwy3: 0,
		wvpqe5: 0,
		ibv6hh: 0,
		u1mtju: 0,
		h3c5rm: 0,
		vrafjx: 0,
		Bekrc4i: 0,
		i8vvqc: 0,
		g2u3we: 0,
		icvyot: 0,
		B4j52fo: 0,
		irswps: "f9ggezi",
		Bahqtrf: "fk6fouc",
		Be2twd7: "fkhj508",
		Bhrd7zp: "figsok6",
		Bg96gwp: "f1i3iumi",
		B93otf3: "f18k4bn6",
		vin17d: "fo1kyvf",
		Ezkn3b: "fetxo7e",
		nyiy2g: "f8x1vz1",
		swvrvq: "f8g0anz",
		Bkovbt3: "fezwn9i",
		hgjdhn: "fz5efge",
		fsy9dk: "f1ydixl4",
		B3ogreh: "f8dgqj5",
		jv49x5: "fnyfnr8",
		Bk7o48c: "fgw77r4",
		Bv12yb3: "f1noc5he",
		i09l9u: "f1k46bua",
		Bcrj8ia: "f1lhuzxm",
		Bmmhre5: "f1f9qikc"
	} }, {
		d: [
			[".ft85np5{border-radius:var(--borderRadiusMedium);}", { p: -1 }],
			".fxugw4r{background-color:var(--colorNeutralBackground1);}",
			".f19n0e5{color:var(--colorNeutralForeground1);}",
			".f1ewtqcl{box-sizing:border-box;}",
			".fl8fusi{min-width:138px;}",
			".f1kaai3v{max-width:300px;}",
			".f1p9o1ba{overflow-x:hidden;}",
			".f1ahpp82{width:max-content;}",
			".f1hg901r{box-shadow:var(--shadow16);}",
			[".fd3pd8h{padding:4px;}", { p: -1 }],
			[".f9ggezi{border:1px solid var(--colorTransparentStroke);}", { p: -2 }],
			".fk6fouc{font-family:var(--fontFamilyBase);}",
			".fkhj508{font-size:var(--fontSizeBase300);}",
			".figsok6{font-weight:var(--fontWeightRegular);}",
			".f1i3iumi{line-height:var(--lineHeightBase300);}",
			".f18k4bn6{animation-composition:accumulate;}",
			".fo1kyvf{animation-duration:var(--durationSlower);}",
			".fetxo7e{animation-timing-function:var(--curveDecelerateMid);}",
			".f8x1vz1{--fui-positioning-slide-distance-x:0px;}",
			".f8g0anz{--fui-positioning-slide-distance-y:10px;}",
			".fezwn9i[data-popper-placement^=right]{--fui-positioning-slide-distance-x:-10px;}",
			".fz5efge[data-popper-placement^=right]{--fui-positioning-slide-distance-y:0px;}",
			".f1ydixl4[data-popper-placement^=bottom]{--fui-positioning-slide-distance-x:0px;}",
			".f8dgqj5[data-popper-placement^=bottom]{--fui-positioning-slide-distance-y:-10px;}",
			".fnyfnr8[data-popper-placement^=left]{--fui-positioning-slide-distance-x:10px;}",
			".fgw77r4[data-popper-placement^=left]{--fui-positioning-slide-distance-y:0px;}",
			".f1noc5he{animation-name:f1m0q9mo,f79suad;}"
		],
		k: ["@keyframes f1m0q9mo{from{opacity:-1;}to{opacity:0;}}", "@keyframes f79suad{from{transform:translate(var(--fui-positioning-slide-distance-x), var(--fui-positioning-slide-distance-y));}}"],
		m: [["@media (prefers-reduced-motion){.f1k46bua[data-popper-placement]{animation-duration:1ms;}}", { m: "(prefers-reduced-motion)" }], ["@media (prefers-reduced-motion){.f1lhuzxm[data-popper-placement]{animation-name:f1m0q9mo;}}", { m: "(prefers-reduced-motion)" }]],
		t: ["@supports not (animation-composition: accumulate){.f1f9qikc[data-popper-placement]{animation-name:f1m0q9mo;}}"]
	});
	/**
	* Apply styling to the Menu slots based on the state
	*/
	const useMenuPopoverStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$83();
		state.root.className = mergeClasses(menuPopoverClassNames.root, styles.root, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/MenuPopover/renderMenuPopover.js
/**
	* Render the final JSX of MenuPopover
	*/ const renderMenuPopover_unstable = (state) => {
		assertSlots(state);
		if (state.inline) return /* @__PURE__ */ jsxs(react.Fragment, { children: [/* @__PURE__ */ jsx(state.root, {}), state.safeZone] });
		return /* @__PURE__ */ jsxs(Portal, {
			mountNode: state.mountNode,
			children: [/* @__PURE__ */ jsx(state.root, {}), state.safeZone]
		});
	};

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/MenuPopover/MenuPopover.js
/**
	* Popover intended to wrap `MenuList` and adds styling and interaction support specific to menus
	*/ const MenuPopover = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useMenuPopover_unstable(props, ref);
		useMenuPopoverStyles_unstable(state);
		useCustomStyleHook("useMenuPopoverStyles_unstable")(state);
		return renderMenuPopover_unstable(state);
	});
	MenuPopover.displayName = "MenuPopover";

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/MenuSplitGroup/useMenuSplitGroupStyles.styles.js
	const menuSplitGroupMultilineAttr = "data-multiline";
	const menuSplitGroupClassNames = { root: "fui-MenuSplitGroup" };
	/**
	* Styles for the root slot
	* TODO - remove the use of nested combinators to style child menu items
	*/
	const useStyles$82 = /* @__PURE__ */ __styles({ root: {
		Bhlrgs3: "f1v24km9",
		mc9l5x: "f22iagw",
		rue6gn: 0,
		oe75ve: 0,
		Bbblmiw: 0,
		Bn2ps6a: "fa49so4",
		Bu15iap: ["fsdyxoe", "fuk6rhi"],
		B71tm0z: ["fn8z6db", "f1be8c1t"],
		Gjs4sj: ["f1vtn0lh", "f8hq2kl"],
		foni4y: "f7j48hl",
		Ie9k5m: "f13du8c1",
		f30fub: "fe64lw1",
		Jberyy: "f92oj5h"
	} }, { d: [
		".f1v24km9[data-multiline]>.fui-MenuItem:nth-of-type(2){align-self:center;}",
		".f22iagw{display:flex;}",
		[".fa49so4>.fui-MenuItem:nth-of-type(1){flex:1;}", { p: -1 }],
		".fsdyxoe>.fui-MenuItem:nth-of-type(2){border-top-left-radius:0;}",
		".fuk6rhi>.fui-MenuItem:nth-of-type(2){border-top-right-radius:0;}",
		".fn8z6db>.fui-MenuItem:nth-of-type(2){border-bottom-left-radius:0;}",
		".f1be8c1t>.fui-MenuItem:nth-of-type(2){border-bottom-right-radius:0;}",
		".f1vtn0lh>.fui-MenuItem:nth-of-type(2){padding-left:0;}",
		".f8hq2kl>.fui-MenuItem:nth-of-type(2){padding-right:0;}",
		".f7j48hl>.fui-MenuItem:nth-of-type(2)::before{content:\"\";}",
		".f13du8c1>.fui-MenuItem:nth-of-type(2)::before{width:var(--strokeWidthThin);}",
		".fe64lw1>.fui-MenuItem:nth-of-type(2)::before{height:20px;}",
		".f92oj5h>.fui-MenuItem:nth-of-type(2)::before{background-color:var(--colorNeutralStroke1);}"
	] });
	/**
	* Apply styling to the MenuSplitGroup slots based on the state
	*/
	const useMenuSplitGroupStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$82();
		state.root.className = mergeClasses(menuSplitGroupClassNames.root, styles.root, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/MenuSplitGroup/useMenuSplitGroup.js
/**
	* Create the state required to render MenuSplitGroup.
	*
	* The returned state can be modified with hooks such as useMenuSplitGroupStyles_unstable,
	* before being passed to renderMenuSplitGroup_unstable.
	*
	* @param props - props from this instance of MenuSplitGroup
	* @param ref - reference to root HTMLElement of MenuSplitGroup
	*/ const useMenuSplitGroup_unstable = (props, ref) => {
		const innerRef = react.useRef(void 0);
		const { dir, targetDocument } = useFluent();
		const nextArrowKey = getRTLSafeKey(ArrowRight, dir);
		const prevArrowKey = getRTLSafeKey(ArrowLeft, dir);
		const { findNextFocusable, findPrevFocusable } = useFocusFinders();
		const { multilineRef, setMultiline } = useHandleMultilineMenuItem();
		const onKeyDown = react.useCallback((e) => {
			var _innerRef_current;
			const activeElement = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.activeElement;
			if (!activeElement) return;
			if (!((_innerRef_current = innerRef.current) === null || _innerRef_current === void 0 ? void 0 : _innerRef_current.contains(activeElement))) return;
			if (e.key === nextArrowKey) {
				const next$1 = findNextFocusable(activeElement, { container: innerRef.current });
				next$1 === null || next$1 === void 0 || next$1.focus();
			}
			if (e.key === prevArrowKey) {
				const prev$1 = findPrevFocusable(activeElement, { container: innerRef.current });
				prev$1 === null || prev$1 === void 0 || prev$1.focus();
			}
		}, [
			findNextFocusable,
			findPrevFocusable,
			targetDocument,
			nextArrowKey,
			prevArrowKey
		]);
		return {
			components: { root: "div" },
			setMultiline,
			root: always(getIntrinsicElementProps("div", {
				role: "group",
				ref: useMergedRefs(ref, innerRef, multilineRef),
				onKeyDown,
				...props
			}), { elementType: "div" })
		};
	};
	/**
	* Creates a callback that lets a multiline menu item child set an attribute on this component
	* Children can mount before parents so we need to store the value and apply it when the parent is mounted
	*/ const useHandleMultilineMenuItem = () => {
		const [handle] = react.useState(() => {
			let isMultiline = false;
			let multilineNode = null;
			function applyAttr() {
				multilineNode === null || multilineNode === void 0 || multilineNode.toggleAttribute(menuSplitGroupMultilineAttr, isMultiline);
			}
			return {
				multilineRef: (node$1) => {
					if (node$1) {
						multilineNode = node$1;
						applyAttr();
					} else multilineNode = null;
				},
				setMultiline: (value) => {
					isMultiline = value;
					applyAttr();
				}
			};
		});
		return handle;
	};

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/MenuSplitGroup/renderMenuSplitGroup.js
/**
	* Render the final JSX of MenuSplitGroup
	*/ const renderMenuSplitGroup_unstable = (state, contexts) => {
		assertSlots(state);
		var _contexts_menuSplitGroup;
		return /* @__PURE__ */ jsx(MenuSplitGroupContextProvider, {
			value: (_contexts_menuSplitGroup = contexts === null || contexts === void 0 ? void 0 : contexts.menuSplitGroup) !== null && _contexts_menuSplitGroup !== void 0 ? _contexts_menuSplitGroup : menuSplitGroupContextDefaultValue,
			children: /* @__PURE__ */ jsx(state.root, {})
		});
	};

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/MenuSplitGroup/useMenuSplitGroupContextValues.js
	const useMenuSplitGroupContextValues = (state) => {
		"use no memo";
		return react.useMemo(() => {
			return { menuSplitGroup: { setMultiline: state.setMultiline } };
		}, [state.setMultiline]);
	};

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/MenuSplitGroup/MenuSplitGroup.js
/**
	* Layout wrapper that provides extra keyboard navigation behavior for two `MenuItem` components.
	*/ const MenuSplitGroup = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useMenuSplitGroup_unstable(props, ref);
		useMenuSplitGroupStyles_unstable(state);
		useCustomStyleHook("useMenuSplitGroupStyles_unstable")(state);
		return renderMenuSplitGroup_unstable(state, useMenuSplitGroupContextValues(state));
	});
	MenuSplitGroup.displayName = "MenuSplitGroup";

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/MenuTrigger/useMenuTrigger.js
	function noop$8() {}
	/**
	* Create the state required to render MenuTrigger.
	* Clones the only child component and adds necessary event handling behaviours to open a popup menu
	*
	* @param props - props from this instance of MenuTrigger
	*/ const useMenuTrigger_unstable = (props) => {
		const { children, disableButtonEnhancement = false } = props;
		const triggerRef = useMenuContext_unstable((context) => context.triggerRef);
		const menuPopoverRef = useMenuContext_unstable((context) => context.menuPopoverRef);
		const setOpen = useMenuContext_unstable((context) => context.setOpen);
		const open = useMenuContext_unstable((context) => context.open);
		const triggerId = useMenuContext_unstable((context) => context.triggerId);
		const openOnHover = useMenuContext_unstable((context) => context.openOnHover);
		const openOnContext = useMenuContext_unstable((context) => context.openOnContext);
		const isSubmenu = useIsSubmenu();
		const { findFirstFocusable } = useFocusFinders();
		const focusFirst = react.useCallback(() => {
			const firstFocusable = findFirstFocusable(menuPopoverRef.current);
			firstFocusable === null || firstFocusable === void 0 || firstFocusable.focus();
		}, [findFirstFocusable, menuPopoverRef]);
		const openedWithKeyboardRef = react.useRef(false);
		const openedViaSafeZoneRef = react.useRef(false);
		const hasMouseMovedRef = react.useRef(false);
		const { dir } = useFluent();
		const OpenArrowKey = dir === "ltr" ? ArrowRight : ArrowLeft;
		const child = getTriggerChild(children);
		const safeZoneHandlerRef = useOnMenuSafeZoneTimeout(useEventCallback(() => {
			if (isSubmenu) openedViaSafeZoneRef.current = true;
		}));
		const onContextMenu = (event) => {
			if (isTargetDisabled(event) || event.isDefaultPrevented()) return;
			if (openOnContext) {
				event.preventDefault();
				setOpen(event, {
					open: true,
					keyboard: false,
					type: "menuTriggerContextMenu",
					event
				});
			}
		};
		const onClick = (event) => {
			if (isTargetDisabled(event)) return;
			if (!openOnContext) {
				setOpen(event, {
					open: !open,
					keyboard: openedWithKeyboardRef.current,
					type: "menuTriggerClick",
					event
				});
				openedWithKeyboardRef.current = false;
			}
		};
		const onKeyDown = (event) => {
			if (isTargetDisabled(event) || event.isDefaultPrevented()) return;
			const key = event.key;
			if (!openOnContext && (isSubmenu && key === OpenArrowKey || !isSubmenu && key === ArrowDown)) setOpen(event, {
				open: true,
				keyboard: true,
				type: "menuTriggerKeyDown",
				event
			});
			if (key === Escape && !isSubmenu) setOpen(event, {
				open: false,
				keyboard: true,
				type: "menuTriggerKeyDown",
				event
			});
			if (open && key === OpenArrowKey && isSubmenu) focusFirst();
		};
		const onMouseOver = (event) => {
			if (isTargetDisabled(event)) return;
			if (openOnHover) {
				if (hasMouseMovedRef.current) setOpen(event, {
					open: true,
					keyboard: false,
					type: "menuTriggerMouseEnter",
					event
				});
				else if (openedViaSafeZoneRef.current) {
					setOpen(event, {
						open: true,
						keyboard: false,
						ignoreHoverDelay: true,
						type: "menuTriggerMouseEnter",
						event
					});
					openedViaSafeZoneRef.current = false;
				}
			}
		};
		const onMouseMove = (event) => {
			if (isTargetDisabled(event)) return;
			if (openOnHover && !hasMouseMovedRef.current) {
				setOpen(event, {
					open: true,
					keyboard: false,
					type: "menuTriggerMouseMove",
					event
				});
				hasMouseMovedRef.current = true;
			}
		};
		const onMouseLeave = (event) => {
			if (isTargetDisabled(event)) return;
			if (openOnHover) setOpen(event, {
				open: false,
				keyboard: false,
				type: "menuTriggerMouseLeave",
				event
			});
		};
		var _child_props_onMouseEnter;
		const contextMenuProps = {
			id: triggerId,
			...child === null || child === void 0 ? void 0 : child.props,
			ref: useMergedRefs(triggerRef, getReactElementRef(child), safeZoneHandlerRef),
			onMouseEnter: useEventCallback((_child_props_onMouseEnter = child === null || child === void 0 ? void 0 : child.props.onMouseEnter) !== null && _child_props_onMouseEnter !== void 0 ? _child_props_onMouseEnter : noop$8),
			onMouseLeave: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onMouseLeave, onMouseLeave)),
			onContextMenu: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onContextMenu, onContextMenu)),
			onMouseMove: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onMouseMove, onMouseMove)),
			onMouseOver: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onMouseOver, onMouseOver))
		};
		const triggerChildProps = {
			"aria-haspopup": "menu",
			"aria-expanded": !open && !isSubmenu ? void 0 : open,
			...contextMenuProps,
			onClick: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onClick, onClick)),
			onKeyDown: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onKeyDown, onKeyDown))
		};
		const ariaButtonTriggerChildProps = useARIAButtonProps((child === null || child === void 0 ? void 0 : child.type) === "button" || (child === null || child === void 0 ? void 0 : child.type) === "a" ? child.type : "div", triggerChildProps);
		return {
			isSubmenu,
			children: applyTriggerPropsToChildren(children, openOnContext ? contextMenuProps : disableButtonEnhancement ? triggerChildProps : ariaButtonTriggerChildProps)
		};
	};
	const isTargetDisabled = (event) => {
		const isDisabled = (el) => el.hasAttribute("disabled") || el.hasAttribute("aria-disabled") && el.getAttribute("aria-disabled") === "true";
		if (isHTMLElement(event.target) && isDisabled(event.target)) return true;
		return isHTMLElement(event.currentTarget) && isDisabled(event.currentTarget);
	};

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/MenuTrigger/renderMenuTrigger.js
/**
	* Render the final JSX of MenuTrigger
	*
	* Only renders children
	*/ const renderMenuTrigger_unstable = (state) => {
		return /* @__PURE__ */ react.createElement(MenuTriggerContextProvider, { value: state.isSubmenu }, state.children);
	};

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/MenuTrigger/MenuTrigger.js
/**
	* Wraps a trigger element as an only child
	* and adds the necessary event handling to open a popup menu
	*/ const MenuTrigger = (props) => {
		return renderMenuTrigger_unstable(useMenuTrigger_unstable(props));
	};
	MenuTrigger.displayName = "MenuTrigger";
	MenuTrigger.isFluentTriggerComponent = true;

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/MenuItemLink/useMenuItemLink.js
/**
	* Create the state required to render MenuItemLink.
	*
	* The returned state can be modified with hooks such as useMenuItemLinkStyles_unstable,
	* before being passed to renderMenuItemLink_unstable.
	*
	* @param props - props from this instance of MenuItemLink
	* @param ref - reference to root HTMLElement of MenuItemLink
	*/ const useMenuItemLink_unstable = (props, ref) => {
		const baseState = useMenuItem_unstable(props, null);
		const _props = {
			...props,
			...baseState.root,
			ref,
			tabIndex: props.tabIndex
		};
		return {
			...baseState,
			components: {
				...baseState.components,
				root: "a"
			},
			root: always(getIntrinsicElementProps("a", {
				role: "menuitem",
				..._props
			}), { elementType: "a" })
		};
	};

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/MenuItemLink/renderMenuItemLink.js
/**
	* Render the final JSX of MenuItemLink
	*/ const renderMenuItemLink_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(state.root, { children: [
			state.checkmark && /* @__PURE__ */ jsx(state.checkmark, {}),
			state.icon && /* @__PURE__ */ jsx(state.icon, {}),
			state.content && /* @__PURE__ */ jsx(state.content, {}),
			state.secondaryContent && /* @__PURE__ */ jsx(state.secondaryContent, {})
		] });
	};

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/MenuItemLink/useMenuItemLinkStyles.styles.js
	const menuItemLinkClassNames = {
		root: "fui-MenuItemLink",
		icon: "fui-MenuItemLink__icon",
		checkmark: "fui-MenuItemLink__checkmark",
		content: "fui-MenuItemLink__content",
		secondaryContent: "fui-MenuItemLink__secondaryContent"
	};
	/**
	* Styles for the root slot
	*/
	const useStyles$81 = /* @__PURE__ */ __styles({ resetLink: {
		w71qe1: "f1iuv45f",
		Bkioxbp: "f9pkogg",
		I8pafv: "foe20s3",
		dvvfom: "f1kn6jj"
	} }, { d: [
		".f1iuv45f{text-decoration-line:none;}",
		".f9pkogg{text-decoration-thickness:initial;}",
		".foe20s3{text-decoration-style:initial;}",
		".f1kn6jj{text-decoration-color:initial;}"
	] });
	/**
	* Apply styling to the MenuItemLink slots based on the state
	*/
	const useMenuItemLinkStyles_unstable = (state) => {
		"use no memo";
		useMenuItemStyles_unstable(state);
		const styles = useStyles$81();
		state.root.className = mergeClasses(menuItemLinkClassNames.root, styles.resetLink, state.root.className);
		if (state.icon) state.icon.className = mergeClasses(menuItemLinkClassNames.icon, state.icon.className);
		if (state.content) state.content.className = mergeClasses(menuItemLinkClassNames.content, state.content.className);
		if (state.secondaryContent) state.secondaryContent.className = mergeClasses(menuItemLinkClassNames.secondaryContent, state.secondaryContent.className);
		if (state.checkmark) state.checkmark.className = mergeClasses(menuItemLinkClassNames.checkmark, state.checkmark.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/MenuItemLink/MenuItemLink.js
/**
	* MenuItemLink component
	*/ const MenuItemLink = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useMenuItemLink_unstable(props, ref);
		useMenuItemLinkStyles_unstable(state);
		useCustomStyleHook("useMenuItemLinkStyles_unstable")(state);
		return renderMenuItemLink_unstable(state);
	});
	MenuItemLink.displayName = "MenuItemLink";

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/MenuItemSwitch/useMenuItemSwitchStyles.styles.js
	const menuItemSwitchClassNames = {
		root: "fui-MenuItemSwitch",
		icon: "fui-MenuItemSwitch__icon",
		content: "fui-MenuItemSwitch__content",
		secondaryContent: "fui-MenuItemSwitch__secondaryContent",
		switchIndicator: "fui-MenuItemSwitch__switchIndicator",
		subText: "fui-MenuItemSwitch__subText"
	};
	const circleFilledClassName = "fui-MenuItemSwitch__switchIndicator__circleFilled";
	const useSwitchIndicatorBaseClassName = /* @__PURE__ */ __resetStyles("r1x31n8g", "rsmcm5v", {
		r: [
			".r1x31n8g{border-radius:var(--borderRadiusCircular);border:var(--strokeWidthThin) solid var(--colorNeutralStrokeAccessible);line-height:0;box-sizing:border-box;fill:currentColor;flex-shrink:0;font-size:18px;height:20px;transition-duration:var(--durationNormal);transition-timing-function:var(--curveEasyEase);transition-property:background,border,color;width:40px;margin-right:var(--spacingHorizontalXS);color:var(--colorNeutralStrokeAccessible);}",
			".r1x31n8g:hover{color:var(--colorNeutralStrokeAccessibleHover);border-color:var(--colorNeutralStrokeAccessibleHover);}",
			".r1x31n8g:hover:active{color:var(--colorNeutralStrokeAccessiblePressed);border-color:var(--colorNeutralStrokeAccessiblePressed);}",
			".r1x31n8g .fui-MenuItemSwitch__switchIndicator__circleFilled{transition-duration:var(--durationNormal);transition-timing-function:var(--curveEasyEase);transition-property:transform;}",
			".rsmcm5v{border-radius:var(--borderRadiusCircular);border:var(--strokeWidthThin) solid var(--colorNeutralStrokeAccessible);line-height:0;box-sizing:border-box;fill:currentColor;flex-shrink:0;font-size:18px;height:20px;transition-duration:var(--durationNormal);transition-timing-function:var(--curveEasyEase);transition-property:background,border,color;width:40px;margin-left:var(--spacingHorizontalXS);color:var(--colorNeutralStrokeAccessible);}",
			".rsmcm5v:hover{color:var(--colorNeutralStrokeAccessibleHover);border-color:var(--colorNeutralStrokeAccessibleHover);}",
			".rsmcm5v:hover:active{color:var(--colorNeutralStrokeAccessiblePressed);border-color:var(--colorNeutralStrokeAccessiblePressed);}",
			".rsmcm5v .fui-MenuItemSwitch__switchIndicator__circleFilled{transition-duration:var(--durationNormal);transition-timing-function:var(--curveEasyEase);transition-property:transform;}"
		],
		s: [
			"@media screen and (prefers-reduced-motion: reduce){.r1x31n8g{transition-duration:0.01ms;}}",
			"@media screen and (prefers-reduced-motion: reduce){.r1x31n8g .fui-MenuItemSwitch__switchIndicator__circleFilled{transition-duration:0.01ms;}}",
			"@media screen and (prefers-reduced-motion: reduce){.rsmcm5v{transition-duration:0.01ms;}}",
			"@media screen and (prefers-reduced-motion: reduce){.rsmcm5v .fui-MenuItemSwitch__switchIndicator__circleFilled{transition-duration:0.01ms;}}"
		]
	});
	const useSwitchIndicatorStyles = /* @__PURE__ */ __styles({ checked: {
		G4r02d: ["fdca5i2", "fk0rr1z"],
		De3pzq: "ftywsgz",
		sj55zd: "fqpbvvt",
		g2u3we: "fghlq4f",
		h3c5rm: ["f1gn591s", "fjscplz"],
		B9xav0g: "fb073pr",
		zhjwy3: ["fjscplz", "f1gn591s"],
		Bi91k9c: "fz46y8r",
		Jwef8y: "f1kjrvvj",
		Bgoe8wy: "fpa59ij",
		Bwzppfd: ["f1rhln42", "f1l1ogpg"],
		oetu4i: "fz67qlh",
		gg5e9n: ["f1l1ogpg", "f1rhln42"],
		B2d53fq: "frlnr8d",
		iro3zm: "fle2s0s",
		b661bw: "f1j8ziw4",
		Bk6r4ia: ["f1xzu9i0", "f1jlpvxk"],
		B9zn80p: "f1i1ccxp",
		Bpld233: ["f1jlpvxk", "f1xzu9i0"]
	} }, {
		d: [
			".fdca5i2 .fui-MenuItemSwitch__switchIndicator__circleFilled{transform:translateX(20px);}",
			".fk0rr1z .fui-MenuItemSwitch__switchIndicator__circleFilled{transform:translateX(-20px);}",
			".ftywsgz{background-color:var(--colorCompoundBrandBackground);}",
			".fqpbvvt{color:var(--colorNeutralForegroundInverted);}",
			".fghlq4f{border-top-color:var(--colorTransparentStroke);}",
			".f1gn591s{border-right-color:var(--colorTransparentStroke);}",
			".fjscplz{border-left-color:var(--colorTransparentStroke);}",
			".fb073pr{border-bottom-color:var(--colorTransparentStroke);}"
		],
		h: [
			".fz46y8r:hover{color:var(--colorNeutralForegroundInverted);}",
			".f1kjrvvj:hover{background-color:var(--colorCompoundBrandBackgroundHover);}",
			".fpa59ij:hover{border-top-color:var(--colorTransparentStrokeInteractive);}",
			".f1rhln42:hover{border-right-color:var(--colorTransparentStrokeInteractive);}",
			".f1l1ogpg:hover{border-left-color:var(--colorTransparentStrokeInteractive);}",
			".fz67qlh:hover{border-bottom-color:var(--colorTransparentStrokeInteractive);}",
			".frlnr8d:hover:active{color:var(--colorNeutralForegroundInverted);}",
			".fle2s0s:hover:active{background-color:var(--colorCompoundBrandBackgroundPressed);}",
			".f1j8ziw4:hover:active{border-top-color:var(--colorTransparentStrokeInteractive);}",
			".f1xzu9i0:hover:active{border-right-color:var(--colorTransparentStrokeInteractive);}",
			".f1jlpvxk:hover:active{border-left-color:var(--colorTransparentStrokeInteractive);}",
			".f1i1ccxp:hover:active{border-bottom-color:var(--colorTransparentStrokeInteractive);}"
		]
	});
	const useMultilineStyles$1 = /* @__PURE__ */ __styles({ "switch": { qb2dma: "f7nlbp4" } }, { d: [".f7nlbp4{align-self:center;}"] });
	/**
	* Apply styling to the MenuItemSwitch slots based on the state
	*/
	const useMenuItemSwitchStyles_unstable = (state) => {
		"use no memo";
		const { checked, subText } = state;
		const multiline = !!subText;
		const switchIndicatorStyles = useSwitchIndicatorStyles();
		const switchIndicatorBaseStyles = useSwitchIndicatorBaseClassName();
		const multilineStyles = useMultilineStyles$1();
		state.root.className = mergeClasses(menuItemSwitchClassNames.root, state.root.className);
		if (state.content) state.content.className = mergeClasses(menuItemSwitchClassNames.content, state.content.className);
		if (state.secondaryContent) state.secondaryContent.className = mergeClasses(menuItemSwitchClassNames.secondaryContent, state.secondaryContent.className);
		if (state.icon) state.icon.className = mergeClasses(menuItemSwitchClassNames.icon, state.icon.className);
		if (state.subText) state.subText.className = mergeClasses(menuItemSwitchClassNames.subText, state.subText.className);
		if (state.switchIndicator) state.switchIndicator.className = mergeClasses(menuItemSwitchClassNames.switchIndicator, switchIndicatorBaseStyles, checked && switchIndicatorStyles.checked, state.switchIndicator.className, multiline && multilineStyles.switch);
		useMenuItemStyles_unstable({
			...state,
			components: {
				...state.components,
				checkmark: "span",
				submenuIndicator: "span"
			},
			checkmark: void 0,
			submenuIndicator: void 0,
			hasSubmenu: false,
			persistOnClick: true
		});
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/MenuItemSwitch/useMenuItemSwitch.js
/**
	* Create the state required to render MenuItemSwitch.
	*
	* The returned state can be modified with hooks such as useMenuItemSwitchStyles_unstable,
	* before being passed to renderMenuItemSwitch_unstable.
	*
	* @param props - props from this instance of MenuItemSwitch
	* @param ref - reference to root HTMLDivElement of MenuItemSwitch
	*/ const useMenuItemSwitch_unstable = (props, ref) => {
		const baseState = useMenuItemCheckbox_unstable(props, ref);
		return {
			...baseState,
			switchIndicator: optional(props.switchIndicator, {
				renderByDefault: true,
				elementType: "span",
				defaultProps: { children: /* @__PURE__ */ react.createElement(CircleFilled, { className: circleFilledClassName }) }
			}),
			components: {
				...baseState.components,
				switchIndicator: "span"
			}
		};
	};

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/MenuItemSwitch/renderMenuItemSwitch.js
/**
	* Function that renders the final JSX of the component
	*/ const renderMenuItemSwitch_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(state.root, { children: [
			state.icon && /* @__PURE__ */ jsx(state.icon, {}),
			state.content && /* @__PURE__ */ jsxs(state.content, { children: [state.content.children, state.subText && /* @__PURE__ */ jsx(state.subText, {})] }),
			state.secondaryContent && /* @__PURE__ */ jsx(state.secondaryContent, {}),
			state.switchIndicator && /* @__PURE__ */ jsx(state.switchIndicator, {})
		] });
	};

//#endregion
//#region node_modules/@fluentui/react-menu/lib/components/MenuItemSwitch/MenuItemSwitch.js
	const MenuItemSwitch = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useMenuItemSwitch_unstable(props, ref);
		useMenuItemSwitchStyles_unstable(state);
		useCustomStyleHook("useMenuItemSwitchStyles_unstable")(state);
		return renderMenuItemSwitch_unstable(state);
	});
	MenuItemSwitch.displayName = "MenuItemSwitch";

//#endregion
//#region node_modules/@fluentui/react-persona/lib/components/Persona/renderPersona.js
/**
	* Render the final JSX of Persona
	*/ const renderPersona_unstable = (state) => {
		const { presenceOnly, textPosition } = state;
		assertSlots(state);
		const coin = presenceOnly ? state.presence && /* @__PURE__ */ jsx(state.presence, {}) : state.avatar && /* @__PURE__ */ jsx(state.avatar, {});
		return /* @__PURE__ */ jsxs(state.root, { children: [
			(textPosition === "after" || textPosition === "below") && coin,
			state.primaryText && /* @__PURE__ */ jsx(state.primaryText, {}),
			state.secondaryText && /* @__PURE__ */ jsx(state.secondaryText, {}),
			state.tertiaryText && /* @__PURE__ */ jsx(state.tertiaryText, {}),
			state.quaternaryText && /* @__PURE__ */ jsx(state.quaternaryText, {}),
			textPosition === "before" && coin
		] });
	};

//#endregion
//#region node_modules/@fluentui/react-persona/lib/components/Persona/usePersona.js
/**
	* Create the state required to render Persona.
	*
	* The returned state can be modified with hooks such as usePersonaStyles_unstable,
	* before being passed to renderPersona_unstable.
	*
	* @param props - props from this instance of Persona
	* @param ref - reference to root HTMLElement of Persona
	*/ const usePersona_unstable = (props, ref) => {
		const { name, presenceOnly = false, size: size$2 = "medium", textAlignment = "start", textPosition = "after" } = props;
		const primaryText = optional(props.primaryText, {
			renderByDefault: true,
			defaultProps: { children: name },
			elementType: "span"
		});
		const secondaryText = optional(props.secondaryText, { elementType: "span" });
		const tertiaryText = optional(props.tertiaryText, { elementType: "span" });
		const quaternaryText = optional(props.quaternaryText, { elementType: "span" });
		return {
			numTextLines: [
				primaryText,
				secondaryText,
				tertiaryText,
				quaternaryText
			].filter(Boolean).length,
			presenceOnly,
			size: size$2,
			textAlignment,
			textPosition,
			components: {
				root: "div",
				avatar: Avatar,
				presence: PresenceBadge,
				primaryText: "span",
				secondaryText: "span",
				tertiaryText: "span",
				quaternaryText: "span"
			},
			root: always(getIntrinsicElementProps("div", {
				...props,
				ref
			}, ["name"]), { elementType: "div" }),
			avatar: !presenceOnly ? optional(props.avatar, {
				renderByDefault: true,
				defaultProps: {
					name,
					badge: props.presence,
					size: avatarSizes[size$2]
				},
				elementType: Avatar
			}) : void 0,
			presence: presenceOnly ? optional(props.presence, {
				defaultProps: { size: presenceSizes[size$2] },
				elementType: PresenceBadge
			}) : void 0,
			primaryText,
			secondaryText,
			tertiaryText,
			quaternaryText
		};
	};
	const presenceSizes = {
		"extra-small": "tiny",
		small: "extra-small",
		medium: "small",
		large: "medium",
		"extra-large": "large",
		huge: "large"
	};
	const avatarSizes = {
		"extra-small": 20,
		small: 28,
		medium: 32,
		large: 36,
		"extra-large": 40,
		huge: 56
	};

//#endregion
//#region node_modules/@fluentui/react-persona/lib/components/Persona/usePersonaStyles.styles.js
	const personaClassNames = {
		root: "fui-Persona",
		avatar: "fui-Persona__avatar",
		presence: "fui-Persona__presence",
		primaryText: "fui-Persona__primaryText",
		secondaryText: "fui-Persona__secondaryText",
		tertiaryText: "fui-Persona__tertiaryText",
		quaternaryText: "fui-Persona__quaternaryText"
	};
	const useRootClassName$3 = /* @__PURE__ */ __resetStyles("rlroi9i", null, [".rlroi9i{display:inline-grid;grid-auto-rows:max-content;grid-auto-flow:column;justify-items:start;grid-template-columns:max-content [middle] auto;}"]);
	/**
	* Styles for the root slot
	*/
	const useStyles$80 = /* @__PURE__ */ __styles({
		beforeAfterCenter: { wkccdc: "f1iantul" },
		after: {},
		before: {
			B7hvi0a: "f1tll2w5",
			Budl1dq: "ffvkwdr"
		},
		below: {
			Bxotwcr: "f1nkeedh",
			B7hvi0a: "f1oiokrs",
			Budl1dq: "f1emgwh2"
		},
		media: { Ijaq50: "f1hek2iy" },
		mediaBeforeAfterCenter: { Ijaq50: "fa4dipu" },
		start: { qb2dma: "f9h729m" },
		center: { qb2dma: "f7nlbp4" },
		afterAlignToPrimary: {
			qb2dma: "f7nlbp4",
			Ijaq50: "f1rnkkuc",
			Bw0ie65: "f1warjpf"
		},
		beforeAlignToPrimary: {
			qb2dma: "f7nlbp4",
			Ijaq50: "f1rnkkuc",
			Br312pm: "fwu52yu"
		},
		secondLineSpacing: { B6of3ja: "f1ryq6si" },
		primary: { Ijaq50: "f1q3ipgb" },
		secondary: { Ijaq50: "f3drtdk" },
		tertiary: { Ijaq50: "fa1o6s1" },
		quaternary: { Ijaq50: "f1tuwaia" }
	}, { d: [
		".f1iantul{grid-template-rows:1fr [primary] max-content [secondary] max-content [tertiary] max-content [quaternary] max-content 1fr;}",
		".f1tll2w5{justify-items:end;}",
		".ffvkwdr{grid-template-columns:auto [middle] max-content;}",
		".f1nkeedh{grid-auto-flow:unset;}",
		".f1oiokrs{justify-items:center;}",
		".f1emgwh2{grid-template-columns:unset;}",
		".f1hek2iy{grid-row-start:span 5;}",
		".fa4dipu{grid-row-start:span 6;}",
		".f9h729m{align-self:start;}",
		".f7nlbp4{align-self:center;}",
		".f1rnkkuc{grid-row-start:unset;}",
		".f1warjpf{grid-column-end:middle;}",
		".fwu52yu{grid-column-start:middle;}",
		".f1ryq6si{margin-top:-2px;}",
		".f1q3ipgb{grid-row-start:primary;}",
		".f3drtdk{grid-row-start:secondary;}",
		".fa1o6s1{grid-row-start:tertiary;}",
		".f1tuwaia{grid-row-start:quaternary;}"
	] });
	const useAvatarSpacingStyles = /* @__PURE__ */ __styles({
		"extra-small": { Bs1gm4r: "f1e48tse" },
		small: { Bs1gm4r: "f18q9vkd" },
		medium: { Bs1gm4r: "f18q9vkd" },
		large: { Bs1gm4r: "fx34bi6" },
		"extra-large": { Bs1gm4r: "fx34bi6" },
		huge: { Bs1gm4r: "f1o96qtm" },
		after: { t21cq0: ["f103ycu4", "f1tao51"] },
		below: { jrapky: "fbo7acy" },
		before: { Frg6f3: ["f1tao51", "f103ycu4"] }
	}, { d: [
		".f1e48tse{--fui-Persona__avatar--spacing:var(--spacingHorizontalSNudge);}",
		".f18q9vkd{--fui-Persona__avatar--spacing:var(--spacingHorizontalS);}",
		".fx34bi6{--fui-Persona__avatar--spacing:var(--spacingHorizontalMNudge);}",
		".f1o96qtm{--fui-Persona__avatar--spacing:var(--spacingHorizontalM);}",
		".f103ycu4{margin-right:var(--fui-Persona__avatar--spacing);}",
		".f1tao51{margin-left:var(--fui-Persona__avatar--spacing);}",
		".fbo7acy{margin-bottom:var(--fui-Persona__avatar--spacing);}"
	] });
	const usePresenceSpacingStyles = /* @__PURE__ */ __styles({ small: { Bs1gm4r: "f1e48tse" } }, { d: [".f1e48tse{--fui-Persona__avatar--spacing:var(--spacingHorizontalSNudge);}"] });
	/**
	* Apply styling to the Persona slots based on the state
	*/
	const usePersonaStyles_unstable = (state) => {
		"use no memo";
		const { presenceOnly, size: size$2, textAlignment, textPosition } = state;
		const alignToPrimary = presenceOnly && textAlignment === "start" && size$2 !== "extra-large" && size$2 !== "huge";
		const alignBeforeAfterCenter = textPosition !== "below" && textAlignment === "center";
		const { primaryTextClassName, optionalTextClassName } = useTextClassNames(state, alignToPrimary);
		const rootClassName = useRootClassName$3();
		const styles = useStyles$80();
		const avatarSpacingStyles = useAvatarSpacingStyles();
		const presenceSpacingStyles = {
			...avatarSpacingStyles,
			...usePresenceSpacingStyles()
		};
		state.root.className = mergeClasses(personaClassNames.root, rootClassName, alignBeforeAfterCenter && styles.beforeAfterCenter, styles[textPosition], state.root.className);
		if (state.avatar) state.avatar.className = mergeClasses(personaClassNames.avatar, textPosition !== "below" && styles.media, alignBeforeAfterCenter && styles.mediaBeforeAfterCenter, styles[textAlignment], avatarSpacingStyles[size$2], avatarSpacingStyles[textPosition], state.avatar.className);
		if (state.presence) state.presence.className = mergeClasses(personaClassNames.presence, textPosition !== "below" && styles.media, alignBeforeAfterCenter && styles.mediaBeforeAfterCenter, styles[textAlignment], presenceSpacingStyles[size$2], presenceSpacingStyles[textPosition], textPosition === "after" && alignToPrimary && styles.afterAlignToPrimary, textPosition === "before" && alignToPrimary && styles.beforeAlignToPrimary, state.presence.className);
		if (state.primaryText) state.primaryText.className = mergeClasses(personaClassNames.primaryText, alignBeforeAfterCenter && styles.primary, primaryTextClassName, state.primaryText.className);
		if (state.secondaryText) state.secondaryText.className = mergeClasses(personaClassNames.secondaryText, alignBeforeAfterCenter && styles.secondary, optionalTextClassName, styles.secondLineSpacing, state.secondaryText.className);
		if (state.tertiaryText) state.tertiaryText.className = mergeClasses(personaClassNames.tertiaryText, alignBeforeAfterCenter && styles.tertiary, optionalTextClassName, state.tertiaryText.className);
		if (state.quaternaryText) state.quaternaryText.className = mergeClasses(personaClassNames.quaternaryText, alignBeforeAfterCenter && styles.quaternary, optionalTextClassName, state.quaternaryText.className);
		return state;
	};
	const usePrimaryTextBaseClassName = /* @__PURE__ */ __resetStyles("rvj41k9", null, [".rvj41k9{display:block;color:var(--colorNeutralForeground1);font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase300);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase300);}"]);
	const useOptionalTextBaseClassName = /* @__PURE__ */ __resetStyles("rp1pf9e", null, [".rp1pf9e{display:block;color:var(--colorNeutralForeground2);font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase200);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase200);}"]);
	const useTextStyles = /* @__PURE__ */ __styles({
		beforeAlignToPrimary: { Bw0ie65: "f1warjpf" },
		afterAlignToPrimary: { Br312pm: "fwu52yu" },
		body1: {
			Bahqtrf: "fk6fouc",
			Be2twd7: "fkhj508",
			Bhrd7zp: "figsok6",
			Bg96gwp: "f1i3iumi"
		},
		caption1: {
			Bahqtrf: "fk6fouc",
			Be2twd7: "fy9rknc",
			Bhrd7zp: "figsok6",
			Bg96gwp: "fwrc4pm"
		},
		subtitle2: {
			Bahqtrf: "fk6fouc",
			Be2twd7: "fod5ikn",
			Bhrd7zp: "fl43uef",
			Bg96gwp: "faaz57k"
		}
	}, { d: [
		".f1warjpf{grid-column-end:middle;}",
		".fwu52yu{grid-column-start:middle;}",
		".fk6fouc{font-family:var(--fontFamilyBase);}",
		".fkhj508{font-size:var(--fontSizeBase300);}",
		".figsok6{font-weight:var(--fontWeightRegular);}",
		".f1i3iumi{line-height:var(--lineHeightBase300);}",
		".fy9rknc{font-size:var(--fontSizeBase200);}",
		".fwrc4pm{line-height:var(--lineHeightBase200);}",
		".fod5ikn{font-size:var(--fontSizeBase400);}",
		".fl43uef{font-weight:var(--fontWeightSemibold);}",
		".faaz57k{line-height:var(--lineHeightBase400);}"
	] });
	const useTextClassNames = (state, alignToPrimary) => {
		const { presenceOnly, size: size$2, textPosition } = state;
		const primaryTextBaseClassName = usePrimaryTextBaseClassName();
		const optionalTextBaseClassName = useOptionalTextBaseClassName();
		const textStyles = useTextStyles();
		let primaryTextSize;
		let alignToPrimaryClassName;
		if (presenceOnly) {
			if (size$2 === "extra-small") primaryTextSize = state.numTextLines <= 1 && textStyles.caption1;
			else if (size$2 === "extra-large" || size$2 === "huge") primaryTextSize = textStyles.subtitle2;
			if (alignToPrimary) {
				if (textPosition === "before") alignToPrimaryClassName = textStyles.beforeAlignToPrimary;
				else if (textPosition === "after") alignToPrimaryClassName = textStyles.afterAlignToPrimary;
			}
		} else if (size$2 === "huge") primaryTextSize = textStyles.subtitle2;
		else if (size$2 === "extra-large") primaryTextSize = textStyles.subtitle2;
		return {
			primaryTextClassName: mergeClasses(primaryTextBaseClassName, primaryTextSize, alignToPrimaryClassName),
			optionalTextClassName: mergeClasses(optionalTextBaseClassName, !presenceOnly && size$2 === "huge" && textStyles.body1, alignToPrimaryClassName)
		};
	};

//#endregion
//#region node_modules/@fluentui/react-persona/lib/components/Persona/Persona.js
/**
	* A Persona is a visual representation of a person or status that showcases an Avatar, PresenceBadge,
	* or an Avatar with a PresenceBadge.
	*/ const Persona = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = usePersona_unstable(props, ref);
		usePersonaStyles_unstable(state);
		useCustomStyleHook("usePersonaStyles_unstable")(state);
		return renderPersona_unstable(state);
	});
	Persona.displayName = "Persona";

//#endregion
//#region node_modules/@fluentui/react-radio/lib/contexts/RadioGroupContext.js
/**
	* RadioGroupContext is provided by RadioGroup, and is consumed by Radio to determine default values of some props.
	*/ const RadioGroupContext = react.createContext(void 0);
	const radioGroupContextDefaultValue = {};
	const RadioGroupProvider = RadioGroupContext.Provider;
	/**
	* Get the value of the RadioGroupContext.
	*/ const useRadioGroupContextValue_unstable = () => react.useContext(RadioGroupContext) || radioGroupContextDefaultValue;
	/**
	* @deprecated Use useRadioGroupContextValue_unstable instead.
	* RadioGroupContext is no longer a selector context, and no longer benefits from having a selector.
	*/ const useRadioGroupContext_unstable = (selector) => selector(useRadioGroupContextValue_unstable());

//#endregion
//#region node_modules/@fluentui/react-radio/lib/components/RadioGroup/renderRadioGroup.js
/**
	* Render the final JSX of RadioGroup
	*/ const renderRadioGroup_unstable = (state, contextValues) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(RadioGroupContext.Provider, {
			value: contextValues.radioGroup,
			children: /* @__PURE__ */ jsx(state.root, {})
		});
	};

//#endregion
//#region node_modules/@fluentui/react-radio/lib/components/RadioGroup/useRadioGroup.js
/**
	* Create the state required to render RadioGroup.
	*
	* The returned state can be modified with hooks such as useRadioGroupStyles_unstable,
	* before being passed to renderRadioGroup_unstable.
	*
	* @param props - props from this instance of RadioGroup
	* @param ref - reference to root HTMLElement of RadioGroup
	*/ const useRadioGroup_unstable = (props, ref) => {
		props = useFieldControlProps_unstable(props);
		const generatedName = useId("radiogroup-");
		const { name = generatedName, value, defaultValue, disabled, layout = "vertical", onChange, required } = props;
		return {
			layout,
			name,
			value,
			defaultValue,
			disabled,
			required,
			components: { root: "div" },
			root: {
				ref,
				role: "radiogroup",
				...always(getIntrinsicElementProps("div", props, ["onChange", "name"]), { elementType: "div" }),
				onChange: useEventCallback((ev) => {
					if (onChange && isHTMLElement(ev.target, { constructorName: "HTMLInputElement" }) && ev.target.type === "radio") onChange(ev, { value: ev.target.value });
				})
			}
		};
	};

//#endregion
//#region node_modules/@fluentui/react-radio/lib/components/RadioGroup/useRadioGroupStyles.styles.js
	const radioGroupClassNames = { root: "fui-RadioGroup" };
	const useStyles$79 = /* @__PURE__ */ __styles({
		root: {
			mc9l5x: "f22iagw",
			Bt984gj: "f6jr5hl"
		},
		vertical: { Beiy3e4: "f1vx9l62" }
	}, { d: [
		".f22iagw{display:flex;}",
		".f6jr5hl{align-items:flex-start;}",
		".f1vx9l62{flex-direction:column;}"
	] });
	/**
	* Apply styling to the RadioGroup slots based on the state
	*/
	const useRadioGroupStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$79();
		state.root.className = mergeClasses(radioGroupClassNames.root, styles.root, state.layout === "vertical" && styles.vertical, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-radio/lib/contexts/useRadioGroupContextValues.js
	const useRadioGroupContextValues = (state) => {
		const { name, value, defaultValue, disabled, layout, required } = state;
		const ariaDescribedBy = state.root["aria-describedby"];
		return { radioGroup: react.useMemo(() => ({
			name,
			value,
			defaultValue,
			disabled,
			layout,
			required,
			"aria-describedby": ariaDescribedBy
		}), [
			name,
			value,
			defaultValue,
			disabled,
			layout,
			required,
			ariaDescribedBy
		]) };
	};

//#endregion
//#region node_modules/@fluentui/react-radio/lib/components/RadioGroup/RadioGroup.js
/**
	* A RadioGroup component presents a set of options where only one option can be selected.
	*/ const RadioGroup = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useRadioGroup_unstable(props, ref);
		const contextValues = useRadioGroupContextValues(state);
		useRadioGroupStyles_unstable(state);
		useCustomStyleHook("useRadioGroupStyles_unstable")(state);
		return renderRadioGroup_unstable(state, contextValues);
	});
	RadioGroup.displayName = "RadioGroup";

//#endregion
//#region node_modules/@fluentui/react-radio/lib/components/Radio/renderRadio.js
/**
	* Render the final JSX of Radio
	*/ const renderRadio_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(state.root, { children: [
			/* @__PURE__ */ jsx(state.input, {}),
			/* @__PURE__ */ jsx(state.indicator, {}),
			state.label && /* @__PURE__ */ jsx(state.label, {})
		] });
	};

//#endregion
//#region node_modules/@fluentui/react-radio/lib/components/Radio/useRadio.js
/**
	* Create the state required to render Radio.
	*
	* The returned state can be modified with hooks such as useRadioStyles_unstable,
	* before being passed to renderRadio_unstable.
	*
	* @param props - props from this instance of Radio
	* @param ref - reference to `<input>` element of Radio
	*/ const useRadio_unstable = (props, ref) => {
		const group = useRadioGroupContextValue_unstable();
		const { name = group.name, checked = group.value !== void 0 ? group.value === props.value : void 0, defaultChecked = group.defaultValue !== void 0 ? group.defaultValue === props.value : void 0, labelPosition = group.layout === "horizontal-stacked" ? "below" : "after", disabled = group.disabled, required = group.required, "aria-describedby": ariaDescribedBy = group["aria-describedby"], onChange } = props;
		const nativeProps = getPartitionedNativeProps({
			props,
			primarySlotTagName: "input",
			excludedPropNames: [
				"checked",
				"defaultChecked",
				"onChange"
			]
		});
		const root = always(props.root, {
			defaultProps: {
				ref: useFocusWithin(),
				...nativeProps.root
			},
			elementType: "span"
		});
		const input = always(props.input, {
			defaultProps: {
				ref,
				type: "radio",
				id: useId("radio-", nativeProps.primary.id),
				name,
				checked,
				defaultChecked,
				disabled,
				required,
				"aria-describedby": ariaDescribedBy,
				...nativeProps.primary
			},
			elementType: "input"
		});
		input.onChange = mergeCallbacks(input.onChange, (ev) => onChange === null || onChange === void 0 ? void 0 : onChange(ev, { value: ev.currentTarget.value }));
		const label = optional(props.label, {
			defaultProps: {
				htmlFor: input.id,
				disabled: input.disabled
			},
			elementType: Label
		});
		const indicator = always(props.indicator, {
			defaultProps: { "aria-hidden": true },
			elementType: "div"
		});
		return {
			labelPosition,
			components: {
				root: "span",
				input: "input",
				label: Label,
				indicator: "div"
			},
			root,
			input,
			label,
			indicator
		};
	};

//#endregion
//#region node_modules/@fluentui/react-radio/lib/components/Radio/useRadioStyles.styles.js
	const radioClassNames = {
		root: "fui-Radio",
		indicator: "fui-Radio__indicator",
		input: "fui-Radio__input",
		label: "fui-Radio__label"
	};
	const useRootBaseClassName$10 = /* @__PURE__ */ __resetStyles("r1siqwd8", "rmnplyc", {
		r: [
			".r1siqwd8{display:inline-flex;position:relative;}",
			".r1siqwd8:focus{outline-style:none;}",
			".r1siqwd8:focus-visible{outline-style:none;}",
			".r1siqwd8[data-fui-focus-within]:focus-within{border-top-color:transparent;border-right-color:transparent;border-bottom-color:transparent;border-left-color:transparent;}",
			".r1siqwd8[data-fui-focus-within]:focus-within::after{content:\"\";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);right:calc(2px * -1);bottom:calc(2px * -1);left:calc(2px * -1);}",
			".rmnplyc{display:inline-flex;position:relative;}",
			".rmnplyc:focus{outline-style:none;}",
			".rmnplyc:focus-visible{outline-style:none;}",
			".rmnplyc[data-fui-focus-within]:focus-within{border-top-color:transparent;border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent;}",
			".rmnplyc[data-fui-focus-within]:focus-within::after{content:\"\";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);left:calc(2px * -1);bottom:calc(2px * -1);right:calc(2px * -1);}"
		],
		s: ["@media (forced-colors: active){.r1siqwd8[data-fui-focus-within]:focus-within::after{border-top-color:Highlight;border-right-color:Highlight;border-bottom-color:Highlight;border-left-color:Highlight;}}", "@media (forced-colors: active){.rmnplyc[data-fui-focus-within]:focus-within::after{border-top-color:Highlight;border-left-color:Highlight;border-bottom-color:Highlight;border-right-color:Highlight;}}"]
	});
	const useRootStyles$20 = /* @__PURE__ */ __styles({ vertical: {
		Beiy3e4: "f1vx9l62",
		Bt984gj: "f122n59"
	} }, { d: [".f1vx9l62{flex-direction:column;}", ".f122n59{align-items:center;}"] });
	const useInputBaseClassName$2 = /* @__PURE__ */ __resetStyles("rg1upok", "rzwdzb4", {
		r: [
			".rg1upok{position:absolute;left:0;top:0;width:calc(16px + 2 * var(--spacingHorizontalS));height:100%;box-sizing:border-box;margin:0;opacity:0;}",
			".rg1upok:enabled{cursor:pointer;}",
			".rg1upok:enabled~.fui-Radio__label{cursor:pointer;}",
			".rg1upok:enabled:not(:checked)~.fui-Radio__label{color:var(--colorNeutralForeground3);}",
			".rg1upok:enabled:not(:checked)~.fui-Radio__indicator{border-color:var(--colorNeutralStrokeAccessible);}",
			".rg1upok:enabled:not(:checked):hover~.fui-Radio__label{color:var(--colorNeutralForeground2);}",
			".rg1upok:enabled:not(:checked):hover~.fui-Radio__indicator{border-color:var(--colorNeutralStrokeAccessibleHover);}",
			".rg1upok:enabled:not(:checked):hover:active~.fui-Radio__label{color:var(--colorNeutralForeground1);}",
			".rg1upok:enabled:not(:checked):hover:active~.fui-Radio__indicator{border-color:var(--colorNeutralStrokeAccessiblePressed);}",
			".rg1upok:enabled:checked~.fui-Radio__label{color:var(--colorNeutralForeground1);}",
			".rg1upok:enabled:checked~.fui-Radio__indicator{border-color:var(--colorCompoundBrandStroke);color:var(--colorCompoundBrandForeground1);}",
			".rg1upok:enabled:checked:hover~.fui-Radio__indicator{border-color:var(--colorCompoundBrandStrokeHover);color:var(--colorCompoundBrandForeground1Hover);}",
			".rg1upok:enabled:checked:hover:active~.fui-Radio__indicator{border-color:var(--colorCompoundBrandStrokePressed);color:var(--colorCompoundBrandForeground1Pressed);}",
			".rg1upok:disabled~.fui-Radio__label{color:var(--colorNeutralForegroundDisabled);cursor:default;}",
			".rg1upok:disabled~.fui-Radio__indicator{border-color:var(--colorNeutralStrokeDisabled);color:var(--colorNeutralForegroundDisabled);}",
			".rzwdzb4{position:absolute;right:0;top:0;width:calc(16px + 2 * var(--spacingHorizontalS));height:100%;box-sizing:border-box;margin:0;opacity:0;}",
			".rzwdzb4:enabled{cursor:pointer;}",
			".rzwdzb4:enabled~.fui-Radio__label{cursor:pointer;}",
			".rzwdzb4:enabled:not(:checked)~.fui-Radio__label{color:var(--colorNeutralForeground3);}",
			".rzwdzb4:enabled:not(:checked)~.fui-Radio__indicator{border-color:var(--colorNeutralStrokeAccessible);}",
			".rzwdzb4:enabled:not(:checked):hover~.fui-Radio__label{color:var(--colorNeutralForeground2);}",
			".rzwdzb4:enabled:not(:checked):hover~.fui-Radio__indicator{border-color:var(--colorNeutralStrokeAccessibleHover);}",
			".rzwdzb4:enabled:not(:checked):hover:active~.fui-Radio__label{color:var(--colorNeutralForeground1);}",
			".rzwdzb4:enabled:not(:checked):hover:active~.fui-Radio__indicator{border-color:var(--colorNeutralStrokeAccessiblePressed);}",
			".rzwdzb4:enabled:checked~.fui-Radio__label{color:var(--colorNeutralForeground1);}",
			".rzwdzb4:enabled:checked~.fui-Radio__indicator{border-color:var(--colorCompoundBrandStroke);color:var(--colorCompoundBrandForeground1);}",
			".rzwdzb4:enabled:checked:hover~.fui-Radio__indicator{border-color:var(--colorCompoundBrandStrokeHover);color:var(--colorCompoundBrandForeground1Hover);}",
			".rzwdzb4:enabled:checked:hover:active~.fui-Radio__indicator{border-color:var(--colorCompoundBrandStrokePressed);color:var(--colorCompoundBrandForeground1Pressed);}",
			".rzwdzb4:disabled~.fui-Radio__label{color:var(--colorNeutralForegroundDisabled);cursor:default;}",
			".rzwdzb4:disabled~.fui-Radio__indicator{border-color:var(--colorNeutralStrokeDisabled);color:var(--colorNeutralForegroundDisabled);}"
		],
		s: [
			"@media (forced-colors: active){.rg1upok:enabled:not(:checked)~.fui-Radio__indicator{border-color:ButtonBorder;}}",
			"@media (forced-colors: active){.rg1upok:enabled:checked~.fui-Radio__indicator{border-color:Highlight;color:Highlight;}.rg1upok:enabled:checked~.fui-Radio__indicator::after{background-color:Highlight;}}",
			"@media (forced-colors: active){.rg1upok:disabled~.fui-Radio__label{color:GrayText;}}",
			"@media (forced-colors: active){.rg1upok:disabled~.fui-Radio__indicator{border-color:GrayText;color:GrayText;}.rg1upok:disabled~.fui-Radio__indicator::after{background-color:GrayText;}}",
			"@media (forced-colors: active){.rzwdzb4:enabled:not(:checked)~.fui-Radio__indicator{border-color:ButtonBorder;}}",
			"@media (forced-colors: active){.rzwdzb4:enabled:checked~.fui-Radio__indicator{border-color:Highlight;color:Highlight;}.rzwdzb4:enabled:checked~.fui-Radio__indicator::after{background-color:Highlight;}}",
			"@media (forced-colors: active){.rzwdzb4:disabled~.fui-Radio__label{color:GrayText;}}",
			"@media (forced-colors: active){.rzwdzb4:disabled~.fui-Radio__indicator{border-color:GrayText;color:GrayText;}.rzwdzb4:disabled~.fui-Radio__indicator::after{background-color:GrayText;}}"
		]
	});
	const useInputStyles$7 = /* @__PURE__ */ __styles({
		below: {
			a9b677: "fly5x3f",
			Bqenvij: "f1je6zif"
		},
		defaultIndicator: { Blbys7f: "f9ma1gx" },
		customIndicator: { Bj53wkj: "f12zxao0" }
	}, { d: [
		".fly5x3f{width:100%;}",
		".f1je6zif{height:calc(16px + 2 * var(--spacingVerticalS));}",
		".f9ma1gx:checked~.fui-Radio__indicator::after{content:\"\";}",
		".f12zxao0:not(:checked)~.fui-Radio__indicator>*{opacity:0;}"
	] });
	const useIndicatorBaseClassName$2 = /* @__PURE__ */ __resetStyles("rwtekvw", null, [".rwtekvw{position:relative;width:16px;height:16px;font-size:12px;box-sizing:border-box;flex-shrink:0;display:flex;align-items:center;justify-content:center;overflow:hidden;border:var(--strokeWidthThin) solid;border-radius:var(--borderRadiusCircular);margin:var(--spacingVerticalS) var(--spacingHorizontalS);fill:currentColor;pointer-events:none;}", ".rwtekvw::after{position:absolute;width:16px;height:16px;border-radius:var(--borderRadiusCircular);transform:scale(0.625);background-color:currentColor;}"]);
	const useLabelStyles$4 = /* @__PURE__ */ __styles({
		base: {
			qb2dma: "f7nlbp4",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f1f5q0n8"
		},
		after: {
			uwmqm3: ["fruq291", "f7x41pl"],
			B6of3ja: "fjzwpt6",
			jrapky: "fh6j2fo"
		},
		below: {
			z8tnut: "f1ywm7hm",
			fsow6f: "f17mccla"
		}
	}, { d: [
		".f7nlbp4{align-self:center;}",
		[".f1f5q0n8{padding:var(--spacingVerticalS) var(--spacingHorizontalS);}", { p: -1 }],
		".fruq291{padding-left:var(--spacingHorizontalXS);}",
		".f7x41pl{padding-right:var(--spacingHorizontalXS);}",
		".fjzwpt6{margin-top:calc((16px - var(--lineHeightBase300)) / 2);}",
		".fh6j2fo{margin-bottom:calc((16px - var(--lineHeightBase300)) / 2);}",
		".f1ywm7hm{padding-top:var(--spacingVerticalXS);}",
		".f17mccla{text-align:center;}"
	] });
	/**
	* Apply styling to the Radio slots based on the state
	*/
	const useRadioStyles_unstable = (state) => {
		"use no memo";
		const { labelPosition } = state;
		const rootBaseClassName = useRootBaseClassName$10();
		const rootStyles = useRootStyles$20();
		state.root.className = mergeClasses(radioClassNames.root, rootBaseClassName, labelPosition === "below" && rootStyles.vertical, state.root.className);
		const inputBaseClassName = useInputBaseClassName$2();
		const inputStyles = useInputStyles$7();
		state.input.className = mergeClasses(radioClassNames.input, inputBaseClassName, labelPosition === "below" && inputStyles.below, state.indicator.children ? inputStyles.customIndicator : inputStyles.defaultIndicator, state.input.className);
		const indicatorBaseClassName = useIndicatorBaseClassName$2();
		state.indicator.className = mergeClasses(radioClassNames.indicator, indicatorBaseClassName, state.indicator.className);
		const labelStyles = useLabelStyles$4();
		if (state.label) state.label.className = mergeClasses(radioClassNames.label, labelStyles.base, labelStyles[labelPosition], state.label.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-radio/lib/components/Radio/Radio.js
/**
	* Radio component is a wrapper for a radio button with a label.
	*/ const Radio = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useRadio_unstable(props, ref);
		useRadioStyles_unstable(state);
		useCustomStyleHook("useRadioStyles_unstable")(state);
		return renderRadio_unstable(state);
	});
	Radio.displayName = "Radio";

//#endregion
//#region node_modules/@fluentui/react-select/lib/components/Select/useSelect.js
/**
	* Create the state required to render Select.
	*
	* The returned state can be modified with hooks such as useSelectStyles,
	* before being passed to renderSelect.
	*
	* @param props - props from this instance of Select
	* @param ref - reference to the `<select>` element in Select
	*/ const useSelect_unstable = (props, ref) => {
		props = useFieldControlProps_unstable(props, {
			supportsLabelFor: true,
			supportsRequired: true,
			supportsSize: true
		});
		const overrides = useOverrides();
		var _overrides_inputDefaultAppearance;
		const { defaultValue, value, select, icon, root, appearance = (_overrides_inputDefaultAppearance = overrides.inputDefaultAppearance) !== null && _overrides_inputDefaultAppearance !== void 0 ? _overrides_inputDefaultAppearance : "outline", onChange, size: size$2 = "medium" } = props;
		const nativeProps = getPartitionedNativeProps({
			props,
			primarySlotTagName: "select",
			excludedPropNames: [
				"appearance",
				"defaultValue",
				"onChange",
				"size",
				"value"
			]
		});
		const state = {
			size: size$2,
			appearance,
			components: {
				root: "span",
				select: "select",
				icon: "span"
			},
			select: always(select, {
				defaultProps: {
					defaultValue,
					value,
					ref,
					...nativeProps.primary
				},
				elementType: "select"
			}),
			icon: optional(icon, {
				renderByDefault: true,
				defaultProps: { children: /* @__PURE__ */ react.createElement(ChevronDownRegular, null) },
				elementType: "span"
			}),
			root: always(root, {
				defaultProps: nativeProps.root,
				elementType: "span"
			})
		};
		state.select.onChange = useEventCallback((event) => {
			onChange === null || onChange === void 0 || onChange(event, { value: event.target.value });
		});
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-select/lib/components/Select/renderSelect.js
/**
	* Render the final JSX of Select
	*/ const renderSelect_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(state.root, { children: [/* @__PURE__ */ jsx(state.select, { children: state.select.children }), state.icon && /* @__PURE__ */ jsx(state.icon, {})] });
	};

//#endregion
//#region node_modules/@fluentui/react-select/lib/components/Select/useSelectStyles.styles.js
	const selectClassNames = {
		root: "fui-Select",
		select: "fui-Select__select",
		icon: "fui-Select__icon"
	};
	const iconSizes = {
		small: "16px",
		medium: "20px",
		large: "24px"
	};
	`${tokens.spacingHorizontalSNudge}${iconSizes.small}${tokens.spacingHorizontalXXS}${tokens.spacingHorizontalXXS}`, `${tokens.spacingHorizontalMNudge}${iconSizes.medium}${tokens.spacingHorizontalXXS}${tokens.spacingHorizontalXXS}`, `${tokens.spacingHorizontalM}${iconSizes.large}${tokens.spacingHorizontalSNudge}${tokens.spacingHorizontalSNudge}`;
	`${tokens.spacingHorizontalSNudge}${tokens.spacingHorizontalXXS}`, `${tokens.spacingHorizontalMNudge}${tokens.spacingHorizontalXXS}`, `${tokens.spacingHorizontalM}${tokens.spacingHorizontalSNudge}`;
	const useRootStyles$19 = /* @__PURE__ */ __styles({ base: {
		Bt984gj: "f122n59",
		B7ck84d: "f1ewtqcl",
		mc9l5x: "f22iagw",
		Eh141a: "flvyvdh",
		Bahqtrf: "fk6fouc",
		qhf8xq: "f10pi13n",
		h62rwi: "f7ll8cq",
		d9w3h3: 0,
		B3778ie: 0,
		B4j8arr: 0,
		Bl18szs: 0,
		Blrzh8d: "fe5s0lv",
		li1rpt: "f1gw3sf2",
		Bsft5z2: "f13zj6fq",
		Dlnsje: "fhwjr99",
		E3zdtr: "f1mdlcz9",
		By385i5: "fo72kxq",
		Eqx8gd: ["f1n6gb5g", "f15yvnhg"],
		B1piin3: ["f15yvnhg", "f1n6gb5g"],
		b1kco5: "f1yk9hq",
		Ba2ppi3: "fhwpy7i",
		F2fol1: "f14ee0xe",
		lck23g: "f1xhbsuh",
		wi16st: "fsrmcvb",
		ywj3b2: "f1t3k7v9",
		umuwi5: "fjw5xc1",
		Blcqepd: "f1xdyd5c",
		nplu4u: "fatpbeo",
		Bioka5o: "fb7uyps",
		Bnupc0a: "fx04xgm",
		bing71: "f1c7in40"
	} }, {
		d: [
			".f122n59{align-items:center;}",
			".f1ewtqcl{box-sizing:border-box;}",
			".f22iagw{display:flex;}",
			".flvyvdh{flex-wrap:nowrap;}",
			".fk6fouc{font-family:var(--fontFamilyBase);}",
			".f10pi13n{position:relative;}",
			".f7ll8cq::after{background-image:linear-gradient(\n        0deg,\n        var(--colorCompoundBrandStroke) 0%,\n        var(--colorCompoundBrandStroke) 50%,\n        transparent 50%,\n        transparent 100%\n      );}",
			[".fe5s0lv::after{border-radius:0 0 var(--borderRadiusMedium) var(--borderRadiusMedium);}", { p: -1 }],
			".f1gw3sf2::after{box-sizing:border-box;}",
			".f13zj6fq::after{content:\"\";}",
			".fhwjr99::after{height:var(--borderRadiusMedium);}",
			".f1mdlcz9::after{position:absolute;}",
			".fo72kxq::after{bottom:0;}",
			".f1n6gb5g::after{left:0;}",
			".f15yvnhg::after{right:0;}",
			".f1yk9hq::after{transform:scaleX(0);}",
			".fhwpy7i::after{transition-property:transform;}",
			".f14ee0xe::after{transition-duration:var(--durationUltraFast);}",
			".f1xhbsuh::after{transition-delay:var(--curveAccelerateMid);}"
		],
		m: [
			["@media screen and (prefers-reduced-motion: reduce){.fsrmcvb::after{transition-duration:0.01ms;}}", { m: "screen and (prefers-reduced-motion: reduce)" }],
			["@media screen and (prefers-reduced-motion: reduce){.f1t3k7v9::after{transition-delay:0.01ms;}}", { m: "screen and (prefers-reduced-motion: reduce)" }],
			["@media screen and (prefers-reduced-motion: reduce){.fx04xgm:focus-within::after{transition-duration:0.01ms;}}", { m: "screen and (prefers-reduced-motion: reduce)" }],
			["@media screen and (prefers-reduced-motion: reduce){.f1c7in40:focus-within::after{transition-delay:0.01ms;}}", { m: "screen and (prefers-reduced-motion: reduce)" }]
		],
		w: [
			".fjw5xc1:focus-within::after{transform:scaleX(1);}",
			".f1xdyd5c:focus-within::after{transition-property:transform;}",
			".fatpbeo:focus-within::after{transition-duration:var(--durationNormal);}",
			".fb7uyps:focus-within::after{transition-delay:var(--curveDecelerateMid);}"
		]
	});
	const useSelectStyles = /* @__PURE__ */ __styles({
		base: {
			Bowrso0: "fqrijq1",
			Bgfg5da: 0,
			B9xav0g: 0,
			oivjwe: 0,
			Bn0qgzm: 0,
			B4g9neb: 0,
			zhjwy3: 0,
			wvpqe5: 0,
			ibv6hh: 0,
			u1mtju: 0,
			h3c5rm: 0,
			vrafjx: 0,
			Bekrc4i: 0,
			i8vvqc: 0,
			g2u3we: 0,
			icvyot: 0,
			B4j52fo: 0,
			irswps: "faev5xe",
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "ft85np5",
			E5pizo: "f1couhl3",
			B7ck84d: "f1ewtqcl",
			sj55zd: "f19n0e5",
			Bceei9c: "f1k6fduh",
			Bh6795r: "fqerorx",
			B2u0y6b: "f6dzj5z",
			Byoj8tv: "f1qch9an",
			z8tnut: "f1g0x7ka",
			B3aqqti: "fatbyko",
			Brovlpu: "f1grzc83",
			Bxa1mx5: "f19shzzi"
		},
		disabled: {
			De3pzq: "f1c21dwh",
			g2u3we: "f1jj8ep1",
			h3c5rm: ["f15xbau", "fy0fskl"],
			B9xav0g: "f4ikngz",
			zhjwy3: ["fy0fskl", "f15xbau"],
			sj55zd: "f1s2aq7o",
			Bceei9c: "fdrzuqr",
			Bcq6wej: "f9dbb4x",
			Jcjdmf: ["f3qs60o", "f5u9ap2"],
			sc4o1m: "fwd1oij",
			Bosien3: ["f5u9ap2", "f3qs60o"]
		},
		disabledUnderline: {
			g2u3we: "fgig46g",
			h3c5rm: ["f1mxt3zg", "fziff3p"],
			B9xav0g: "f4ikngz",
			zhjwy3: ["fziff3p", "f1mxt3zg"]
		},
		small: {
			Bqenvij: "frvgh55",
			uwmqm3: ["f1xile11", "fqznh8f"],
			z189sj: ["fiqd4sw", "f11fkzut"],
			Bahqtrf: "fk6fouc",
			Be2twd7: "fy9rknc",
			Bhrd7zp: "figsok6",
			Bg96gwp: "fwrc4pm"
		},
		medium: {
			Bqenvij: "f1d2rq10",
			uwmqm3: ["f1e60jzv", "f135dnwl"],
			z189sj: ["f154vowv", "flqamny"],
			Bahqtrf: "fk6fouc",
			Be2twd7: "fkhj508",
			Bhrd7zp: "figsok6",
			Bg96gwp: "f1i3iumi"
		},
		large: {
			Bqenvij: "fbhnoac",
			uwmqm3: ["fnphzt9", "flt1dlf"],
			z189sj: ["f1xi5ia2", "f1xi1l47"],
			Bahqtrf: "fk6fouc",
			Be2twd7: "fod5ikn",
			Bhrd7zp: "figsok6",
			Bg96gwp: "faaz57k"
		},
		outline: {
			De3pzq: "fxugw4r",
			Bgfg5da: 0,
			B9xav0g: "f1c1zstj",
			oivjwe: 0,
			Bn0qgzm: 0,
			B4g9neb: 0,
			zhjwy3: 0,
			wvpqe5: 0,
			ibv6hh: 0,
			u1mtju: 0,
			h3c5rm: 0,
			vrafjx: 0,
			Bekrc4i: 0,
			i8vvqc: 0,
			g2u3we: 0,
			icvyot: 0,
			B4j52fo: 0,
			irswps: "fm9niy"
		},
		outlineInteractive: {
			Bgoe8wy: "fvcxoqz",
			Bwzppfd: ["f1ub3y4t", "f1m52nbi"],
			oetu4i: "flmw63s",
			gg5e9n: ["f1m52nbi", "f1ub3y4t"],
			B6oc9vd: "fvs00aa",
			ak43y8: ["f1assf6x", "f4ruux4"],
			wmxk5l: "fqhmt4z",
			B50zh58: ["f4ruux4", "f1assf6x"]
		},
		underline: {
			De3pzq: "f1c21dwh",
			B9xav0g: 0,
			oivjwe: 0,
			Bn0qgzm: 0,
			Bgfg5da: "fd91s9p",
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "fokr779",
			C8i20h: "fb77jct"
		},
		"filled-lighter": { De3pzq: "fxugw4r" },
		"filled-darker": { De3pzq: "f16xq7d1" },
		invalid: {
			tvckwq: "fs4k3qj",
			gk2u95: ["fcee079", "fmyw78r"],
			hhx65j: "f1fgmyf4",
			Bxowmz0: ["fmyw78r", "fcee079"]
		},
		invalidUnderline: { hhx65j: "f1fgmyf4" }
	}, {
		d: [
			".fqrijq1{-webkit-appearance:none;-moz-appearance:none;appearance:none;}",
			[".faev5xe{border:1px solid transparent;}", { p: -2 }],
			[".ft85np5{border-radius:var(--borderRadiusMedium);}", { p: -1 }],
			".f1couhl3{box-shadow:none;}",
			".f1ewtqcl{box-sizing:border-box;}",
			".f19n0e5{color:var(--colorNeutralForeground1);}",
			".f1k6fduh{cursor:pointer;}",
			".fqerorx{flex-grow:1;}",
			".f6dzj5z{max-width:100%;}",
			".f1qch9an{padding-bottom:0;}",
			".f1g0x7ka{padding-top:0;}",
			".f1c21dwh{background-color:var(--colorTransparentBackground);}",
			".f1jj8ep1{border-top-color:var(--colorNeutralStrokeDisabled);}",
			".f15xbau{border-right-color:var(--colorNeutralStrokeDisabled);}",
			".fy0fskl{border-left-color:var(--colorNeutralStrokeDisabled);}",
			".f4ikngz{border-bottom-color:var(--colorNeutralStrokeDisabled);}",
			".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}",
			".fdrzuqr{cursor:not-allowed;}",
			".fgig46g{border-top-color:var(--colorTransparentStrokeDisabled);}",
			".f1mxt3zg{border-right-color:var(--colorTransparentStrokeDisabled);}",
			".fziff3p{border-left-color:var(--colorTransparentStrokeDisabled);}",
			".frvgh55{height:24px;}",
			".f1xile11{padding-left:calc(var(--spacingHorizontalSNudge) + var(--spacingHorizontalXXS));}",
			".fqznh8f{padding-right:calc(var(--spacingHorizontalSNudge) + var(--spacingHorizontalXXS));}",
			".fiqd4sw{padding-right:calc(var(--spacingHorizontalSNudge)\n    + 16px\n    + var(--spacingHorizontalXXS)\n    + var(--spacingHorizontalXXS));}",
			".f11fkzut{padding-left:calc(var(--spacingHorizontalSNudge)\n    + 16px\n    + var(--spacingHorizontalXXS)\n    + var(--spacingHorizontalXXS));}",
			".fk6fouc{font-family:var(--fontFamilyBase);}",
			".fy9rknc{font-size:var(--fontSizeBase200);}",
			".figsok6{font-weight:var(--fontWeightRegular);}",
			".fwrc4pm{line-height:var(--lineHeightBase200);}",
			".f1d2rq10{height:32px;}",
			".f1e60jzv{padding-left:calc(var(--spacingHorizontalMNudge) + var(--spacingHorizontalXXS));}",
			".f135dnwl{padding-right:calc(var(--spacingHorizontalMNudge) + var(--spacingHorizontalXXS));}",
			".f154vowv{padding-right:calc(var(--spacingHorizontalMNudge)\n    + 20px\n    + var(--spacingHorizontalXXS)\n    + var(--spacingHorizontalXXS));}",
			".flqamny{padding-left:calc(var(--spacingHorizontalMNudge)\n    + 20px\n    + var(--spacingHorizontalXXS)\n    + var(--spacingHorizontalXXS));}",
			".fkhj508{font-size:var(--fontSizeBase300);}",
			".f1i3iumi{line-height:var(--lineHeightBase300);}",
			".fbhnoac{height:40px;}",
			".fnphzt9{padding-left:calc(var(--spacingHorizontalM) + var(--spacingHorizontalSNudge));}",
			".flt1dlf{padding-right:calc(var(--spacingHorizontalM) + var(--spacingHorizontalSNudge));}",
			".f1xi5ia2{padding-right:calc(var(--spacingHorizontalM)\n    + 24px\n    + var(--spacingHorizontalSNudge)\n    + var(--spacingHorizontalSNudge));}",
			".f1xi1l47{padding-left:calc(var(--spacingHorizontalM)\n    + 24px\n    + var(--spacingHorizontalSNudge)\n    + var(--spacingHorizontalSNudge));}",
			".fod5ikn{font-size:var(--fontSizeBase400);}",
			".faaz57k{line-height:var(--lineHeightBase400);}",
			".fxugw4r{background-color:var(--colorNeutralBackground1);}",
			[".fm9niy{border:1px solid var(--colorNeutralStroke1);}", { p: -2 }],
			".f1c1zstj{border-bottom-color:var(--colorNeutralStrokeAccessible);}",
			[".fd91s9p{border-bottom:1px solid var(--colorNeutralStrokeAccessible);}", { p: -1 }],
			[".fokr779{border-radius:0;}", { p: -1 }],
			".fb77jct option{background-color:var(--colorNeutralBackground1);}",
			".f16xq7d1{background-color:var(--colorNeutralBackground3);}",
			".fs4k3qj:not(:focus-within),.fs4k3qj:hover:not(:focus-within){border-top-color:var(--colorPaletteRedBorder2);}",
			".fcee079:not(:focus-within),.fcee079:hover:not(:focus-within){border-right-color:var(--colorPaletteRedBorder2);}",
			".fmyw78r:not(:focus-within),.fmyw78r:hover:not(:focus-within){border-left-color:var(--colorPaletteRedBorder2);}",
			".f1fgmyf4:not(:focus-within),.f1fgmyf4:hover:not(:focus-within){border-bottom-color:var(--colorPaletteRedBorder2);}"
		],
		f: [
			".fatbyko:focus{outline-width:2px;}",
			".f1grzc83:focus{outline-style:solid;}",
			".f19shzzi:focus{outline-color:transparent;}"
		],
		m: [
			["@media (forced-colors: active){.f9dbb4x{border-top-color:GrayText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f3qs60o{border-right-color:GrayText;}.f5u9ap2{border-left-color:GrayText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fwd1oij{border-bottom-color:GrayText;}}", { m: "(forced-colors: active)" }]
		],
		h: [
			".fvcxoqz:hover{border-top-color:var(--colorNeutralStroke1Hover);}",
			".f1ub3y4t:hover{border-right-color:var(--colorNeutralStroke1Hover);}",
			".f1m52nbi:hover{border-left-color:var(--colorNeutralStroke1Hover);}",
			".flmw63s:hover{border-bottom-color:var(--colorNeutralStrokeAccessible);}"
		],
		a: [
			".fvs00aa:active{border-top-color:var(--colorNeutralStroke1Pressed);}",
			".f1assf6x:active{border-right-color:var(--colorNeutralStroke1Pressed);}",
			".f4ruux4:active{border-left-color:var(--colorNeutralStroke1Pressed);}",
			".fqhmt4z:active{border-bottom-color:var(--colorNeutralStrokeAccessible);}"
		]
	});
	const useIconStyles$7 = /* @__PURE__ */ __styles({
		icon: {
			B7ck84d: "f1ewtqcl",
			sj55zd: "fxkbij4",
			mc9l5x: "ftgm304",
			qhf8xq: "f1euv43f",
			Bkecrkj: "f1aehjj5",
			Bo70h7d: "fvc9v3g"
		},
		disabled: {
			sj55zd: "f1s2aq7o",
			B7iucu3: "f1cyfu5x"
		},
		small: {
			Be2twd7: "f4ybsrx",
			Bqenvij: "fd461yt",
			j35jbq: ["f13lnp83", "f1i5nn0v"],
			a9b677: "fjw5fx7"
		},
		medium: {
			Be2twd7: "fe5j1ua",
			Bqenvij: "fjamq6b",
			j35jbq: ["fnyteob", "f1enpzzf"],
			a9b677: "f64fuq3"
		},
		large: {
			Be2twd7: "f1rt2boy",
			Bqenvij: "frvgh55",
			j35jbq: ["f8b87gs", "fedtrts"],
			a9b677: "fq4mcun"
		}
	}, {
		d: [
			".f1ewtqcl{box-sizing:border-box;}",
			".fxkbij4{color:var(--colorNeutralStrokeAccessible);}",
			".ftgm304{display:block;}",
			".f1euv43f{position:absolute;}",
			".f1aehjj5{pointer-events:none;}",
			".fvc9v3g svg{display:block;}",
			".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}",
			".f4ybsrx{font-size:16px;}",
			".fd461yt{height:16px;}",
			".f13lnp83{right:var(--spacingHorizontalSNudge);}",
			".f1i5nn0v{left:var(--spacingHorizontalSNudge);}",
			".fjw5fx7{width:16px;}",
			".fe5j1ua{font-size:20px;}",
			".fjamq6b{height:20px;}",
			".fnyteob{right:var(--spacingHorizontalMNudge);}",
			".f1enpzzf{left:var(--spacingHorizontalMNudge);}",
			".f64fuq3{width:20px;}",
			".f1rt2boy{font-size:24px;}",
			".frvgh55{height:24px;}",
			".f8b87gs{right:var(--spacingHorizontalM);}",
			".fedtrts{left:var(--spacingHorizontalM);}",
			".fq4mcun{width:24px;}"
		],
		m: [["@media (forced-colors: active){.f1cyfu5x{color:GrayText;}}", { m: "(forced-colors: active)" }]]
	});
	/**
	* Apply styling to the Select slots based on the state
	*/
	const useSelectStyles_unstable = (state) => {
		"use no memo";
		const { size: size$2, appearance } = state;
		const disabled = state.select.disabled;
		const invalid = `${state.select["aria-invalid"]}` === "true";
		const iconStyles = useIconStyles$7();
		const rootStyles = useRootStyles$19();
		const selectStyles = useSelectStyles();
		state.root.className = mergeClasses(selectClassNames.root, rootStyles.base, state.root.className);
		state.select.className = mergeClasses(selectClassNames.select, selectStyles.base, selectStyles[size$2], selectStyles[appearance], !disabled && appearance === "outline" && selectStyles.outlineInteractive, !disabled && invalid && appearance !== "underline" && selectStyles.invalid, !disabled && invalid && appearance === "underline" && selectStyles.invalidUnderline, disabled && selectStyles.disabled, disabled && appearance === "underline" && selectStyles.disabledUnderline, state.select.className);
		if (state.icon) state.icon.className = mergeClasses(selectClassNames.icon, iconStyles.icon, disabled && iconStyles.disabled, iconStyles[size$2], state.icon.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-select/lib/components/Select/Select.js
/**
	* Select component
	*/ const Select = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useSelect_unstable(props, ref);
		useSelectStyles_unstable(state);
		useCustomStyleHook("useSelectStyles_unstable")(state);
		return renderSelect_unstable(state);
	});
	Select.displayName = "Select";

//#endregion
//#region node_modules/@fluentui/react-skeleton/lib/contexts/SkeletonContext.js
	const SkeletonContext = react.createContext(void 0);
	const skeletonContextDefaultValue = {};
	const SkeletonContextProvider = SkeletonContext.Provider;
	const useSkeletonContext = () => {
		var _React_useContext;
		return (_React_useContext = react.useContext(SkeletonContext)) !== null && _React_useContext !== void 0 ? _React_useContext : skeletonContextDefaultValue;
	};

//#endregion
//#region node_modules/@fluentui/react-skeleton/lib/components/Skeleton/useSkeleton.js
/**
	* Create the state required to render Skeleton.
	*
	* The returned state can be modified with hooks such as useSkeletonStyles_unstable,
	* before being passed to renderSkeleton_unstable.
	*
	* @param props - props from this instance of Skeleton
	* @param ref - reference to root HTMLElement of Skeleton
	*/ const useSkeleton_unstable = (props, ref) => {
		const { animation: contextAnimation, appearance: contextAppearance } = useSkeletonContext();
		const { animation = contextAnimation !== null && contextAnimation !== void 0 ? contextAnimation : "wave", appearance = contextAppearance !== null && contextAppearance !== void 0 ? contextAppearance : "opaque" } = props;
		return {
			animation,
			appearance,
			components: { root: "div" },
			root: always(getIntrinsicElementProps("div", {
				ref,
				role: "progressbar",
				"aria-busy": true,
				...props
			}), { elementType: "div" })
		};
	};

//#endregion
//#region node_modules/@fluentui/react-skeleton/lib/components/Skeleton/renderSkeleton.js
/**
	* Render the final JSX of Skeleton
	*/ const renderSkeleton_unstable = (state, contextValues) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(SkeletonContextProvider, {
			value: contextValues.skeletonGroup,
			children: /* @__PURE__ */ jsx(state.root, {})
		});
	};

//#endregion
//#region node_modules/@fluentui/react-skeleton/lib/components/Skeleton/useSkeletonStyles.styles.js
	const skeletonClassNames = { root: "fui-Skeleton" };
	const useStyles$78 = /* @__PURE__ */ __styles({ blockStyling: { mc9l5x: "ftgm304" } }, { d: [".ftgm304{display:block;}"] });
	/**
	* Apply styling to the Skeleton slots based on the state
	*/
	const useSkeletonStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$78();
		state.root.className = mergeClasses(skeletonClassNames.root, state.root.as === "span" && styles.blockStyling, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-skeleton/lib/components/Skeleton/useSkeletonContextValues.js
	const useSkeletonContextValues = (state) => {
		const { animation, appearance } = state;
		return { skeletonGroup: react.useMemo(() => ({
			animation,
			appearance
		}), [animation, appearance]) };
	};

//#endregion
//#region node_modules/@fluentui/react-skeleton/lib/components/Skeleton/Skeleton.js
/**
	* Skeleton component - TODO: add more docs
	*/ const Skeleton = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useSkeleton_unstable(props, ref);
		const contextValues = useSkeletonContextValues(state);
		useSkeletonStyles_unstable(state);
		useCustomStyleHook("useSkeletonStyles_unstable")(state);
		return renderSkeleton_unstable(state, contextValues);
	});
	Skeleton.displayName = "Skeleton";

//#endregion
//#region node_modules/@fluentui/react-skeleton/lib/components/SkeletonItem/useSkeletonItem.js
/**
	* Create the state required to render SkeletonItem.
	*
	* The returned state can be modified with hooks such as useSkeletonItemStyles_unstable,
	* before being passed to renderSkeletonItem_unstable.
	*
	* @param props - props from this instance of SkeletonItem
	* @param ref - reference to root HTMLElement of SkeletonItem
	*/ const useSkeletonItem_unstable = (props, ref) => {
		const { animation: contextAnimation, appearance: contextAppearance } = useSkeletonContext();
		const { animation = contextAnimation !== null && contextAnimation !== void 0 ? contextAnimation : "wave", appearance = contextAppearance !== null && contextAppearance !== void 0 ? contextAppearance : "opaque", size: size$2 = 16, shape = "rectangle" } = props;
		return {
			appearance,
			animation,
			size: size$2,
			shape,
			components: { root: "div" },
			root: always(getIntrinsicElementProps("div", {
				ref,
				...props
			}), { elementType: "div" })
		};
	};

//#endregion
//#region node_modules/@fluentui/react-skeleton/lib/components/SkeletonItem/renderSkeletonItem.js
/**
	* Render the final JSX of SkeletonItem
	*/ const renderSkeletonItem_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, {});
	};

//#endregion
//#region node_modules/@fluentui/react-skeleton/lib/components/SkeletonItem/useSkeletonItemStyles.styles.js
	const skeletonItemClassNames = { root: "fui-SkeletonItem" };
	/**
	* Styles for the root slot
	*/
	const useStyles$77 = /* @__PURE__ */ __styles({
		root: {
			qhf8xq: "f10pi13n",
			B68tc82: 0,
			Bmxbyg5: 0,
			Bpg54ce: "f1a3p1vp",
			Bsft5z2: "f13zj6fq",
			ap17g6: "f2gz7yw",
			E3zdtr: "f1mdlcz9",
			By385i5: 0,
			Eqx8gd: 0,
			B1piin3: 0,
			bn5sak: 0,
			B58onuk: "f1nt53hs",
			s9ouvv: "f18xs7ez",
			xr36ep: "ffm3629",
			Bitv4sc: "f1f9zsvm",
			Gt9ir8: "f1evo4vk",
			Crt7la: "f18va1k3"
		},
		wave: {
			De3pzq: "f1gjxg63",
			Br128sd: ["f3fo419", "f6m9r4"],
			h62rwi: ["ftnv2js", "f12jzhyt"],
			b1kco5: ["fig1c6l", "f1rv5y9h"],
			Iqrfzq: "f1xjc3a9"
		},
		pulse: {
			Br128sd: "f171zwvm",
			xr36ep: "fs3pcyf",
			Bjyk6c5: "f1yu5riq"
		},
		translucent: {
			De3pzq: "f162mh4z",
			h62rwi: ["flvf4r0", "f1uek97b"]
		},
		translucentPulse: {
			De3pzq: "flu3bqm",
			Bjyk6c5: "fxucc0w"
		},
		blockStyling: { mc9l5x: "ftgm304" }
	}, {
		d: [
			".f10pi13n{position:relative;}",
			[".f1a3p1vp{overflow:hidden;}", { p: -1 }],
			".f13zj6fq::after{content:\"\";}",
			".f2gz7yw::after{display:block;}",
			".f1mdlcz9::after{position:absolute;}",
			[".f1nt53hs::after{inset:0;}", { p: -1 }],
			".f18xs7ez::after{animation-iteration-count:infinite;}",
			".ffm3629::after{animation-duration:3s;}",
			".f1f9zsvm::after{animation-timing-function:ease-in-out;}",
			".f1gjxg63{background-color:var(--colorNeutralStencil1);}",
			".f3fo419::after{animation-name:f1efwx7q;}",
			".f6m9r4::after{animation-name:f1kkgpz1;}",
			".ftnv2js::after{background-image:linear-gradient(\n        to right,\n        var(--colorNeutralStencil1) 0%,\n        var(--colorNeutralStencil2) 50%,\n        var(--colorNeutralStencil1) 100%);}",
			".f12jzhyt::after{background-image:linear-gradient(\n        to left,\n        var(--colorNeutralStencil1) 0%,\n        var(--colorNeutralStencil2) 50%,\n        var(--colorNeutralStencil1) 100%);}",
			".fig1c6l::after{transform:translate(-100%);}",
			".f1rv5y9h::after{transform:translate(100%);}",
			".f171zwvm::after{animation-name:f12o7gg6;}",
			".fs3pcyf::after{animation-duration:1s;}",
			".f1yu5riq::after{background-color:var(--colorNeutralStencil1);}",
			".f162mh4z{background-color:var(--colorNeutralStencil1Alpha);}",
			".flvf4r0::after{background-image:linear-gradient(\n      to right,\n      transparent 0%,\n      var(--colorNeutralStencil1Alpha) 50%,\n      transparent 100%);}",
			".f1uek97b::after{background-image:linear-gradient(\n      to left,\n      transparent 0%,\n      var(--colorNeutralStencil1Alpha) 50%,\n      transparent 100%);}",
			".flu3bqm{background-color:none;}",
			".fxucc0w::after{background-color:var(--colorNeutralStencil1Alpha);}",
			".ftgm304{display:block;}"
		],
		m: [
			["@media screen and (prefers-reduced-motion: reduce){.f1evo4vk::after{animation-duration:0.01ms;}}", { m: "screen and (prefers-reduced-motion: reduce)" }],
			["@media screen and (prefers-reduced-motion: reduce){.f18va1k3::after{animation-iteration-count:1;}}", { m: "screen and (prefers-reduced-motion: reduce)" }],
			["@media screen and (forced-colors: active){.f1xjc3a9::after{background-color:WindowText;}}", { m: "screen and (forced-colors: active)" }]
		],
		k: [
			"@keyframes f1efwx7q{to{transform:translate(100%);}}",
			"@keyframes f1kkgpz1{to{transform:translate(-100%);}}",
			"@keyframes f12o7gg6{0%{opacity:1;}50%{opacity:0.4;}100%{opacity:1;}}"
		]
	});
	const useRectangleStyles = /* @__PURE__ */ __styles({
		"8": { Bqenvij: "f1x82gua" },
		"12": { Bqenvij: "fvblgha" },
		"16": { Bqenvij: "fd461yt" },
		"20": { Bqenvij: "fjamq6b" },
		"24": { Bqenvij: "frvgh55" },
		"28": { Bqenvij: "fxldao9" },
		"32": { Bqenvij: "f1d2rq10" },
		"36": { Bqenvij: "f8ljn23" },
		"40": { Bqenvij: "fbhnoac" },
		"48": { Bqenvij: "ff2sm71" },
		"56": { Bqenvij: "fzki0ko" },
		"64": { Bqenvij: "f16k9i2m" },
		"72": { Bqenvij: "f1shusfg" },
		"96": { Bqenvij: "fypu0ge" },
		"120": { Bqenvij: "fjr5b71" },
		"128": { Bqenvij: "fele2au" },
		root: {
			a9b677: "fly5x3f",
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "ff3glw6"
		}
	}, { d: [
		".f1x82gua{height:8px;}",
		".fvblgha{height:12px;}",
		".fd461yt{height:16px;}",
		".fjamq6b{height:20px;}",
		".frvgh55{height:24px;}",
		".fxldao9{height:28px;}",
		".f1d2rq10{height:32px;}",
		".f8ljn23{height:36px;}",
		".fbhnoac{height:40px;}",
		".ff2sm71{height:48px;}",
		".fzki0ko{height:56px;}",
		".f16k9i2m{height:64px;}",
		".f1shusfg{height:72px;}",
		".fypu0ge{height:96px;}",
		".fjr5b71{height:120px;}",
		".fele2au{height:128px;}",
		".fly5x3f{width:100%;}",
		[".ff3glw6{border-radius:4px;}", { p: -1 }]
	] });
	const useSizeStyles$3 = /* @__PURE__ */ __styles({
		"8": {
			a9b677: "f1o3cbw4",
			Bqenvij: "f1x82gua"
		},
		"12": {
			a9b677: "frx94fk",
			Bqenvij: "fvblgha"
		},
		"16": {
			a9b677: "fjw5fx7",
			Bqenvij: "fd461yt"
		},
		"20": {
			a9b677: "f64fuq3",
			Bqenvij: "fjamq6b"
		},
		"24": {
			a9b677: "fq4mcun",
			Bqenvij: "frvgh55"
		},
		"28": {
			a9b677: "f1w9dchk",
			Bqenvij: "fxldao9"
		},
		"32": {
			a9b677: "f1szoe96",
			Bqenvij: "f1d2rq10"
		},
		"36": {
			a9b677: "fpdz1er",
			Bqenvij: "f8ljn23"
		},
		"40": {
			a9b677: "feqmc2u",
			Bqenvij: "fbhnoac"
		},
		"48": {
			a9b677: "f124akge",
			Bqenvij: "ff2sm71"
		},
		"56": {
			a9b677: "f1u66zr1",
			Bqenvij: "fzki0ko"
		},
		"64": {
			a9b677: "fa9ln6p",
			Bqenvij: "f16k9i2m"
		},
		"72": {
			a9b677: "fhcae8x",
			Bqenvij: "f1shusfg"
		},
		"96": {
			a9b677: "f1kyr2gn",
			Bqenvij: "fypu0ge"
		},
		"120": {
			a9b677: "fwfqyga",
			Bqenvij: "fjr5b71"
		},
		"128": {
			a9b677: "f1iksgmy",
			Bqenvij: "fele2au"
		}
	}, { d: [
		".f1o3cbw4{width:8px;}",
		".f1x82gua{height:8px;}",
		".frx94fk{width:12px;}",
		".fvblgha{height:12px;}",
		".fjw5fx7{width:16px;}",
		".fd461yt{height:16px;}",
		".f64fuq3{width:20px;}",
		".fjamq6b{height:20px;}",
		".fq4mcun{width:24px;}",
		".frvgh55{height:24px;}",
		".f1w9dchk{width:28px;}",
		".fxldao9{height:28px;}",
		".f1szoe96{width:32px;}",
		".f1d2rq10{height:32px;}",
		".fpdz1er{width:36px;}",
		".f8ljn23{height:36px;}",
		".feqmc2u{width:40px;}",
		".fbhnoac{height:40px;}",
		".f124akge{width:48px;}",
		".ff2sm71{height:48px;}",
		".f1u66zr1{width:56px;}",
		".fzki0ko{height:56px;}",
		".fa9ln6p{width:64px;}",
		".f16k9i2m{height:64px;}",
		".fhcae8x{width:72px;}",
		".f1shusfg{height:72px;}",
		".f1kyr2gn{width:96px;}",
		".fypu0ge{height:96px;}",
		".fwfqyga{width:120px;}",
		".fjr5b71{height:120px;}",
		".f1iksgmy{width:128px;}",
		".fele2au{height:128px;}"
	] });
	const useCircleSizeStyles = /* @__PURE__ */ __styles({ root: {
		Beyfa6y: 0,
		Bbmb7ep: 0,
		Btl43ni: 0,
		B7oj6ja: 0,
		Dimara: "f5q2cvs"
	} }, { d: [[".f5q2cvs{border-radius:50%;}", { p: -1 }]] });
	/**
	* Apply styling to the SkeletonItem slots based on the state
	*/
	const useSkeletonItemStyles_unstable = (state) => {
		"use no memo";
		const { animation, appearance, size: size$2, shape } = state;
		const rootStyles = useStyles$77();
		const rectStyles = useRectangleStyles();
		const sizeStyles = useSizeStyles$3();
		const circleStyles = useCircleSizeStyles();
		state.root.className = mergeClasses(skeletonItemClassNames.root, rootStyles.root, state.root.as === "span" && rootStyles.blockStyling, animation === "wave" && rootStyles.wave, animation === "pulse" && rootStyles.pulse, appearance === "translucent" && rootStyles.translucent, animation === "pulse" && appearance === "translucent" && rootStyles.translucentPulse, shape === "rectangle" && rectStyles.root, shape === "rectangle" && rectStyles[size$2], shape === "square" && sizeStyles[size$2], shape === "circle" && circleStyles.root, shape === "circle" && sizeStyles[size$2], state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-skeleton/lib/components/SkeletonItem/SkeletonItem.js
	const SkeletonItem = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useSkeletonItem_unstable(props, ref);
		useSkeletonItemStyles_unstable(state);
		useCustomStyleHook("useSkeletonItemStyles_unstable")(state);
		return renderSkeletonItem_unstable(state);
	});
	SkeletonItem.displayName = "SkeletonItem";

//#endregion
//#region node_modules/@fluentui/react-slider/lib/components/Slider/useSliderStyles.styles.js
	const sliderClassNames = {
		root: "fui-Slider",
		rail: "fui-Slider__rail",
		thumb: "fui-Slider__thumb",
		input: "fui-Slider__input"
	};
	const sliderCSSVars = {
		sliderDirectionVar: `--fui-Slider--direction`,
		sliderInnerThumbRadiusVar: `--fui-Slider__inner-thumb--radius`,
		sliderProgressVar: `--fui-Slider--progress`,
		sliderProgressColorVar: `--fui-Slider__progress--color`,
		sliderRailSizeVar: `--fui-Slider__rail--size`,
		sliderRailColorVar: `--fui-Slider__rail--color`,
		sliderStepsPercentVar: `--fui-Slider--steps-percent`,
		sliderThumbColorVar: `--fui-Slider__thumb--color`,
		sliderThumbSizeVar: `--fui-Slider__thumb--size`
	};
	const { sliderDirectionVar: sliderDirectionVar$1, sliderInnerThumbRadiusVar, sliderProgressVar: sliderProgressVar$1, sliderProgressColorVar, sliderRailSizeVar, sliderRailColorVar, sliderStepsPercentVar: sliderStepsPercentVar$1, sliderThumbColorVar, sliderThumbSizeVar } = sliderCSSVars;
	/**
	* Styles for the root slot
	*/
	const useRootStyles$18 = /* @__PURE__ */ __styles({
		root: {
			qhf8xq: "f10pi13n",
			mc9l5x: "fwk3njj",
			lpbzjs: "f1sdsnyy",
			Bt984gj: "f122n59",
			B7hvi0a: "f1oiokrs"
		},
		small: {
			Bi64ftq: "f1agqo6f",
			Bslxy2k: "f1mmvox9",
			Ba19x4e: "f1i7ztpd",
			sshi5w: "f1pha7fy"
		},
		medium: {
			Bi64ftq: "f1a78h9h",
			Bslxy2k: "fh1udnr",
			Ba19x4e: "fuok0yf",
			sshi5w: "f1nxs5xn"
		},
		horizontal: {
			Bf4jedk: "fyvtabn",
			wkccdc: "fgfd48t",
			Budl1dq: "f4t5rw1"
		},
		vertical: {
			sshi5w: "f1pzv1zu",
			wkccdc: "fktlcaf",
			Budl1dq: "fiadc6h"
		},
		enabled: {
			B7wi8oa: "f4l8x3l",
			B250r6j: "f671q34",
			Bpmy4es: "fvfzmw5",
			Buw9y6v: "faw1t00",
			Bq939m0: "fxdgx5",
			gjzr1t: "fii04fa",
			tg7hqu: "f36hzz8",
			qhf704: "fdjsfay",
			Blfvze: "f1fen33d",
			genz7u: "f1c6b0w1",
			Brgvh4e: "f1rq9b4z",
			Bsjyjqp: "f4xxiul"
		},
		disabled: {
			Bpmy4es: "foojseg",
			B7wi8oa: "f1lgdqhv",
			B250r6j: "f1veetlj",
			qhf704: "fn4acdm",
			Blfvze: "f4s8dx0",
			genz7u: "f1wil5xy"
		},
		focusIndicatorHorizontal: {
			Brovlpu: "ftqa4ok",
			B486eqv: "f2hkw1w",
			Bssx7fj: "f1b1k54r",
			uh7if5: ["f4ne723", "fqqcjud"],
			clntm0: "fh7aioi",
			Dlk2r6: ["fqqcjud", "f4ne723"],
			h6p2u: "f1ufm4qn",
			I6qiy5: ["f1qnwcb4", "fgrk5zm"],
			yzno9d: "fi52z01",
			By0wis0: ["fgrk5zm", "f1qnwcb4"],
			B2j2mmj: "ffht0p2",
			wigs8: "f1p0ul1q",
			pbfy6t: "f1c901ms",
			B0v4ure: "f1alokd7",
			Byrf0fs: 0,
			Bsiemmq: 0,
			Bwckmig: 0,
			skfxo0: 0,
			Iidy0u: 0,
			B98u21t: 0,
			Bvwlmkc: 0,
			jo1ztg: 0,
			Ba1iezr: 0,
			Blmvk6g: 0,
			B24cy0v: 0,
			Bil7v7r: 0,
			Br3gin4: 0,
			nr063g: 0,
			ghq09: 0,
			Bbgo44z: 0,
			Bseh09z: "fmj8fco",
			az1dzo: 0,
			Ba3ybja: 0,
			B6352mv: 0,
			vppk2z: 0,
			Biaj6j7: "f1iwowo3",
			B2pnrqr: "f1pffoy2",
			B29w5g4: ["f1dfga45", "f63jj3o"],
			Bhhzhcn: "fs6b7xr",
			Bec0n69: ["f63jj3o", "f1dfga45"]
		},
		focusIndicatorVertical: {
			Brovlpu: "ftqa4ok",
			B486eqv: "f2hkw1w",
			Bssx7fj: "f1b1k54r",
			uh7if5: ["f4ne723", "fqqcjud"],
			clntm0: "fh7aioi",
			Dlk2r6: ["fqqcjud", "f4ne723"],
			h6p2u: "f1ufm4qn",
			I6qiy5: ["f1qnwcb4", "fgrk5zm"],
			yzno9d: "fi52z01",
			By0wis0: ["fgrk5zm", "f1qnwcb4"],
			B2j2mmj: "ffht0p2",
			wigs8: "f1p0ul1q",
			pbfy6t: "f1c901ms",
			B0v4ure: "f1alokd7",
			Byrf0fs: 0,
			Bsiemmq: 0,
			Bwckmig: 0,
			skfxo0: 0,
			Iidy0u: 0,
			B98u21t: 0,
			Bvwlmkc: 0,
			jo1ztg: 0,
			Ba1iezr: 0,
			Blmvk6g: 0,
			B24cy0v: 0,
			Bil7v7r: 0,
			Br3gin4: 0,
			nr063g: 0,
			ghq09: 0,
			Bbgo44z: 0,
			Bseh09z: "fmj8fco",
			az1dzo: 0,
			Ba3ybja: 0,
			B6352mv: 0,
			vppk2z: 0,
			Biaj6j7: "f1iwowo3",
			B2pnrqr: "f1pffoy2",
			B29w5g4: ["fm5xmfm", "femsgmt"],
			Bhhzhcn: "fs6b7xr",
			Bec0n69: ["femsgmt", "fm5xmfm"]
		}
	}, {
		d: [
			".f10pi13n{position:relative;}",
			".fwk3njj{display:inline-grid;}",
			".f1sdsnyy{touch-action:none;}",
			".f122n59{align-items:center;}",
			".f1oiokrs{justify-items:center;}",
			".f1agqo6f{--fui-Slider__thumb--size:16px;}",
			".f1mmvox9{--fui-Slider__inner-thumb--radius:5px;}",
			".f1i7ztpd{--fui-Slider__rail--size:2px;}",
			".f1pha7fy{min-height:24px;}",
			".f1a78h9h{--fui-Slider__thumb--size:20px;}",
			".fh1udnr{--fui-Slider__inner-thumb--radius:6px;}",
			".fuok0yf{--fui-Slider__rail--size:4px;}",
			".f1nxs5xn{min-height:32px;}",
			".fyvtabn{min-width:120px;}",
			".fgfd48t{grid-template-rows:1fr var(--fui-Slider__thumb--size) 1fr;}",
			".f4t5rw1{grid-template-columns:1fr calc(100% - var(--fui-Slider__thumb--size)) 1fr;}",
			".f1pzv1zu{min-height:120px;}",
			".fktlcaf{grid-template-rows:1fr calc(100% - var(--fui-Slider__thumb--size)) 1fr;}",
			".fiadc6h{grid-template-columns:1fr var(--fui-Slider__thumb--size) 1fr;}",
			".f4l8x3l{--fui-Slider__rail--color:var(--colorNeutralStrokeAccessible);}",
			".f671q34{--fui-Slider__progress--color:var(--colorCompoundBrandBackground);}",
			".fvfzmw5{--fui-Slider__thumb--color:var(--colorCompoundBrandBackground);}",
			".foojseg{--fui-Slider__thumb--color:var(--colorNeutralForegroundDisabled);}",
			".f1lgdqhv{--fui-Slider__rail--color:var(--colorNeutralBackgroundDisabled);}",
			".f1veetlj{--fui-Slider__progress--color:var(--colorNeutralForegroundDisabled);}",
			".f1b1k54r[data-fui-focus-within]:focus-within{border-top-color:transparent;}",
			".f4ne723[data-fui-focus-within]:focus-within{border-right-color:transparent;}",
			".fqqcjud[data-fui-focus-within]:focus-within{border-left-color:transparent;}",
			".fh7aioi[data-fui-focus-within]:focus-within{border-bottom-color:transparent;}",
			".ffht0p2[data-fui-focus-within]:focus-within::after{content:\"\";}",
			".f1p0ul1q[data-fui-focus-within]:focus-within::after{position:absolute;}",
			".f1c901ms[data-fui-focus-within]:focus-within::after{pointer-events:none;}",
			".f1alokd7[data-fui-focus-within]:focus-within::after{z-index:1;}",
			[".fmj8fco[data-fui-focus-within]:focus-within::after{border:2px solid var(--colorStrokeFocus2);}", { p: -2 }],
			[".f1iwowo3[data-fui-focus-within]:focus-within::after{border-radius:var(--borderRadiusMedium);}", { p: -1 }],
			".f1pffoy2[data-fui-focus-within]:focus-within::after{top:calc(0px - 2px - -2px);}",
			".f1dfga45[data-fui-focus-within]:focus-within::after{right:calc(0px - 2px - -4px);}",
			".f63jj3o[data-fui-focus-within]:focus-within::after{left:calc(0px - 2px - -4px);}",
			".fs6b7xr[data-fui-focus-within]:focus-within::after{bottom:calc(0px - 2px - -2px);}",
			[".fmj8fco[data-fui-focus-within]:focus-within::after{border:2px solid var(--colorStrokeFocus2);}", { p: -2 }],
			[".f1iwowo3[data-fui-focus-within]:focus-within::after{border-radius:var(--borderRadiusMedium);}", { p: -1 }],
			".fm5xmfm[data-fui-focus-within]:focus-within::after{right:calc(0px - 2px - 4px);}",
			".femsgmt[data-fui-focus-within]:focus-within::after{left:calc(0px - 2px - 4px);}"
		],
		h: [".faw1t00:hover{--fui-Slider__thumb--color:var(--colorCompoundBrandBackgroundHover);}", ".fxdgx5:hover{--fui-Slider__progress--color:var(--colorCompoundBrandBackgroundHover);}"],
		a: [".fii04fa:active{--fui-Slider__thumb--color:var(--colorCompoundBrandBackgroundPressed);}", ".f36hzz8:active{--fui-Slider__progress--color:var(--colorCompoundBrandBackgroundPressed);}"],
		m: [
			["@media (forced-colors: active){.fdjsfay{--fui-Slider__rail--color:CanvasText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1fen33d{--fui-Slider__thumb--color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1c6b0w1{--fui-Slider__progress--color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1rq9b4z:hover{--fui-Slider__thumb--color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f4xxiul:hover{--fui-Slider__progress--color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fn4acdm{--fui-Slider__rail--color:GrayText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f4s8dx0{--fui-Slider__thumb--color:GrayText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1wil5xy{--fui-Slider__progress--color:GrayText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1ufm4qn[data-fui-focus-within]:focus-within::after{border-top-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1qnwcb4[data-fui-focus-within]:focus-within::after{border-right-color:Highlight;}.fgrk5zm[data-fui-focus-within]:focus-within::after{border-left-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fi52z01[data-fui-focus-within]:focus-within::after{border-bottom-color:Highlight;}}", { m: "(forced-colors: active)" }]
		],
		f: [".ftqa4ok:focus{outline-style:none;}"],
		i: [".f2hkw1w:focus-visible{outline-style:none;}"]
	});
	/**
	* Styles for the rail slot
	*/
	const useRailStyles$1 = /* @__PURE__ */ __styles({
		rail: {
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "f1kijzfu",
			Bkecrkj: "f1aehjj5",
			Ijaq50: "faunodf",
			nk6f5a: "f88nxoq",
			Br312pm: "fd46tj4",
			Bw0ie65: "f1e2fz10",
			qhf8xq: "f10pi13n",
			Bvjb7m6: "fdgv6k0",
			Bcmaq0h: "fizngqt",
			Bpd4iqm: "fpvhumw",
			oeaueh: "f1yog68k",
			Bw0xxkn: "f13sgyd8",
			Ftih45: "fzhtfnv",
			Brfgrao: "f1j7ml58",
			Bbn5juq: "fx36ao7",
			Bses4cn: "fddlh2i"
		},
		horizontal: {
			a9b677: "fly5x3f",
			Bqenvij: "f1cy86ho",
			Fbdkly: ["f1heqfse", "fkh49vu"],
			mdwyqc: ["fkh49vu", "f1heqfse"],
			Baz25je: "f16tdq4e"
		},
		vertical: {
			a9b677: "fqxfnkd",
			Bqenvij: "f1l02sjl",
			Ccq8qp: "f1rik0od",
			Bciustq: "f14xwovp",
			lawp4y: "fdehrcx"
		}
	}, {
		d: [
			[".f1kijzfu{border-radius:var(--borderRadiusXLarge);}", { p: -1 }],
			".f1aehjj5{pointer-events:none;}",
			".faunodf{grid-row-start:2;}",
			".f88nxoq{grid-row-end:2;}",
			".fd46tj4{grid-column-start:2;}",
			".f1e2fz10{grid-column-end:2;}",
			".f10pi13n{position:relative;}",
			".fdgv6k0{forced-color-adjust:none;}",
			".fizngqt{background-image:linear-gradient(\n      var(--fui-Slider--direction),\n      var(--fui-Slider__progress--color) 0%,\n      var(--fui-Slider__progress--color) var(--fui-Slider--progress),\n      var(--fui-Slider__rail--color) var(--fui-Slider--progress)\n    );}",
			".fpvhumw{outline-width:1px;}",
			".f1yog68k{outline-style:solid;}",
			".f13sgyd8{outline-color:var(--colorTransparentStroke);}",
			".fzhtfnv::before{content:'';}",
			".f1j7ml58::before{position:absolute;}",
			".fx36ao7::before{background-image:repeating-linear-gradient(\n        var(--fui-Slider--direction),\n        #0000 0%,\n        #0000 calc(var(--fui-Slider--steps-percent) - 1px),\n        var(--colorNeutralBackground1) calc(var(--fui-Slider--steps-percent) - 1px),\n        var(--colorNeutralBackground1) var(--fui-Slider--steps-percent)\n      );}",
			".fly5x3f{width:100%;}",
			".f1cy86ho{height:var(--fui-Slider__rail--size);}",
			".f1heqfse::before{left:-1px;}",
			".fkh49vu::before{right:-1px;}",
			".f16tdq4e::before{height:var(--fui-Slider__rail--size);}",
			".fqxfnkd{width:var(--fui-Slider__rail--size);}",
			".f1l02sjl{height:100%;}",
			".f1rik0od::before{width:var(--fui-Slider__rail--size);}",
			".f14xwovp::before{top:-1px;}",
			".fdehrcx::before{bottom:-1px;}"
		],
		m: [["@media (forced-colors: active){.fddlh2i::before{background-image:repeating-linear-gradient(\n          var(--fui-Slider--direction),\n          #0000 0%,\n          #0000 calc(var(--fui-Slider--steps-percent) - 1px),\n          HighlightText calc(var(--fui-Slider--steps-percent) - 1px),\n          HighlightText var(--fui-Slider--steps-percent)\n        );}}", { m: "(forced-colors: active)" }]]
	});
	/**
	* Styles for the thumb slot
	*/
	const useThumbStyles$3 = /* @__PURE__ */ __styles({
		thumb: {
			B2lzsem: "ftx3jue",
			Ijaq50: "faunodf",
			nk6f5a: "f88nxoq",
			Br312pm: "fd46tj4",
			Bw0ie65: "f1e2fz10",
			qhf8xq: "f1euv43f",
			a9b677: "f174ca62",
			Bqenvij: "f1yfdkfd",
			Bkecrkj: "f1aehjj5",
			oeaueh: "f1s6fcnf",
			Bvjb7m6: "fdgv6k0",
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "f44lkw9",
			E5pizo: "fof7hq0",
			De3pzq: "foksa45",
			Brfgrao: "f1j7ml58",
			Bciustq: "f14u7mkt",
			Fbdkly: ["f5zrw40", "f1ks5ppg"],
			lawp4y: "fto0uou",
			mdwyqc: ["f1ks5ppg", "f5zrw40"],
			r59vdv: 0,
			Budzafs: 0,
			ck0cow: 0,
			n07z76: 0,
			Gng75u: "fielpny",
			Bcvre1j: "fyl8oag",
			Ftih45: "fzhtfnv",
			Bcgcnre: 0,
			Bqjgrrk: 0,
			qa3bma: 0,
			y0oebl: 0,
			Biqmznv: 0,
			Bm6vgfq: 0,
			Bbv0w2i: 0,
			uvfttm: 0,
			eqrjj: 0,
			Bk5zm6e: 0,
			m598lv: 0,
			B4f6apu: 0,
			ydt019: 0,
			Bq4z7u6: 0,
			Bdkvgpv: 0,
			B0qfbqy: 0,
			kj8mxx: "f1fsco4d"
		},
		disabled: {
			Bcgcnre: 0,
			Bqjgrrk: 0,
			qa3bma: 0,
			y0oebl: 0,
			Biqmznv: 0,
			Bm6vgfq: 0,
			Bbv0w2i: 0,
			uvfttm: 0,
			eqrjj: 0,
			Bk5zm6e: 0,
			m598lv: 0,
			B4f6apu: 0,
			ydt019: 0,
			Bq4z7u6: 0,
			Bdkvgpv: 0,
			B0qfbqy: 0,
			kj8mxx: "f1pv9hn4"
		},
		horizontal: {
			Bz10aip: ["f13gfj74", "f1nfknbn"],
			oyh7mz: ["foa2ioz", "fjmilum"]
		},
		vertical: {
			Bz10aip: "f5cv5a3",
			B5kzvoi: "f1k2fpdo"
		}
	}, { d: [
		".ftx3jue{--fui-Slider__thumb--position:clamp(var(--fui-Slider__inner-thumb--radius), var(--fui-Slider--progress), calc(100% - var(--fui-Slider__inner-thumb--radius)));}",
		".faunodf{grid-row-start:2;}",
		".f88nxoq{grid-row-end:2;}",
		".fd46tj4{grid-column-start:2;}",
		".f1e2fz10{grid-column-end:2;}",
		".f1euv43f{position:absolute;}",
		".f174ca62{width:var(--fui-Slider__thumb--size);}",
		".f1yfdkfd{height:var(--fui-Slider__thumb--size);}",
		".f1aehjj5{pointer-events:none;}",
		".f1s6fcnf{outline-style:none;}",
		".fdgv6k0{forced-color-adjust:none;}",
		[".f44lkw9{border-radius:var(--borderRadiusCircular);}", { p: -1 }],
		".fof7hq0{box-shadow:0 0 0 calc(var(--fui-Slider__thumb--size) * .2) var(--colorNeutralBackground1) inset;}",
		".foksa45{background-color:var(--fui-Slider__thumb--color);}",
		".f1j7ml58::before{position:absolute;}",
		".f14u7mkt::before{top:0px;}",
		".f5zrw40::before{left:0px;}",
		".f1ks5ppg::before{right:0px;}",
		".fto0uou::before{bottom:0px;}",
		[".fielpny::before{border-radius:var(--borderRadiusCircular);}", { p: -1 }],
		".fyl8oag::before{box-sizing:border-box;}",
		".fzhtfnv::before{content:'';}",
		[".f1fsco4d::before{border:calc(var(--fui-Slider__thumb--size) * .05) solid var(--colorNeutralStroke1);}", { p: -2 }],
		[".f1pv9hn4::before{border:calc(var(--fui-Slider__thumb--size) * .05) solid var(--colorNeutralForegroundDisabled);}", { p: -2 }],
		".f13gfj74{transform:translateX(-50%);}",
		".f1nfknbn{transform:translateX(50%);}",
		".foa2ioz{left:var(--fui-Slider__thumb--position);}",
		".fjmilum{right:var(--fui-Slider__thumb--position);}",
		".f5cv5a3{transform:translateY(50%);}",
		".f1k2fpdo{bottom:var(--fui-Slider__thumb--position);}"
	] });
	/**
	* Styles for the Input slot
	*/
	const useInputStyles$6 = /* @__PURE__ */ __styles({
		input: {
			Bceei9c: "f1k6fduh",
			abs64n: "fk73vx1",
			Ijaq50: "f16hsg94",
			nk6f5a: "f1nzqi2z",
			Br312pm: "fwpfdsa",
			Bw0ie65: "fuur7zz",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f1mk8lai",
			jrapky: 0,
			Frg6f3: 0,
			t21cq0: 0,
			B6of3ja: 0,
			B74szlk: "f1s184ao"
		},
		disabled: { Bceei9c: "f158kwzp" },
		horizontal: {
			Bqenvij: "f1yfdkfd",
			a9b677: "fly5x3f"
		},
		vertical: {
			Bqenvij: "f1l02sjl",
			a9b677: "f174ca62",
			wtfg9d: "f135tqni",
			By3ymbm: ["f114o3fk", "f1o9w1zd"],
			B1e78rk: "f1jr0wcp"
		}
	}, {
		d: [
			".f1k6fduh{cursor:pointer;}",
			".fk73vx1{opacity:0;}",
			".f16hsg94{grid-row-start:1;}",
			".f1nzqi2z{grid-row-end:-1;}",
			".fwpfdsa{grid-column-start:1;}",
			".fuur7zz{grid-column-end:-1;}",
			[".f1mk8lai{padding:0;}", { p: -1 }],
			[".f1s184ao{margin:0;}", { p: -1 }],
			".f158kwzp{cursor:default;}",
			".f1yfdkfd{height:var(--fui-Slider__thumb--size);}",
			".fly5x3f{width:100%;}",
			".f1l02sjl{height:100%;}",
			".f174ca62{width:var(--fui-Slider__thumb--size);}"
		],
		t: [
			"@supports (writing-mode: sideways-lr){.f135tqni{writing-mode:vertical-lr;}}",
			"@supports (writing-mode: sideways-lr){.f114o3fk{direction:rtl;}.f1o9w1zd{direction:ltr;}}",
			"@supports not (writing-mode: sideways-lr){.f1jr0wcp{-webkit-appearance:slider-vertical;}}"
		]
	});
	/**
	* Apply styling to the Slider slots based on the state
	*/
	const useSliderStyles_unstable = (state) => {
		"use no memo";
		const rootStyles = useRootStyles$18();
		const railStyles = useRailStyles$1();
		const thumbStyles = useThumbStyles$3();
		const inputStyles = useInputStyles$6();
		const isVertical = state.vertical;
		state.root.className = mergeClasses(sliderClassNames.root, rootStyles.root, isVertical ? rootStyles.focusIndicatorVertical : rootStyles.focusIndicatorHorizontal, rootStyles[state.size], isVertical ? rootStyles.vertical : rootStyles.horizontal, state.disabled ? rootStyles.disabled : rootStyles.enabled, state.root.className);
		state.rail.className = mergeClasses(sliderClassNames.rail, railStyles.rail, isVertical ? railStyles.vertical : railStyles.horizontal, state.rail.className);
		state.thumb.className = mergeClasses(sliderClassNames.thumb, thumbStyles.thumb, isVertical ? thumbStyles.vertical : thumbStyles.horizontal, state.disabled && thumbStyles.disabled, state.thumb.className);
		state.input.className = mergeClasses(sliderClassNames.input, inputStyles.input, isVertical ? inputStyles.vertical : inputStyles.horizontal, state.disabled && inputStyles.disabled, state.input.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-slider/lib/components/Slider/useSliderState.js
	const { sliderStepsPercentVar, sliderProgressVar, sliderDirectionVar } = sliderCSSVars;
	const getPercent$1 = (value, min$1, max$1) => {
		return max$1 === min$1 ? 0 : (value - min$1) / (max$1 - min$1) * 100;
	};
	const useSliderState_unstable = (state, props) => {
		"use no memo";
		const { min: min$1 = 0, max: max$1 = 100, step } = props;
		const { dir } = useFluent();
		const [currentValue, setCurrentValue] = useControllableState({
			state: props.value,
			defaultState: props.defaultValue,
			initialState: 0
		});
		const clampedValue = clamp$2(currentValue, min$1, max$1);
		const valuePercent = getPercent$1(clampedValue, min$1, max$1);
		const inputOnChange = state.input.onChange;
		const propsOnChange = props.onChange;
		const onChange = useEventCallback((ev) => {
			const newValue = Number(ev.target.value);
			setCurrentValue(clamp$2(newValue, min$1, max$1));
			if (inputOnChange && inputOnChange !== propsOnChange) inputOnChange(ev);
			else if (propsOnChange) propsOnChange(ev, { value: newValue });
		});
		const stepPercent = step && step > 0 ? `${step * 100 / (max$1 - min$1)}%` : void 0;
		const rootVariables = {
			[sliderDirectionVar]: state.vertical ? "0deg" : dir === "ltr" ? "90deg" : "270deg",
			[sliderProgressVar]: `${valuePercent}%`,
			...stepPercent !== void 0 && { [sliderStepsPercentVar]: stepPercent }
		};
		state.root.style = {
			...rootVariables,
			...state.root.style
		};
		state.input.value = clampedValue;
		state.input.onChange = onChange;
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-slider/lib/components/Slider/useSlider.js
	const useSlider_unstable = (props, ref) => {
		props = useFieldControlProps_unstable(props, { supportsLabelFor: true });
		const nativeProps = getPartitionedNativeProps({
			props,
			primarySlotTagName: "input",
			excludedPropNames: ["onChange", "size"]
		});
		const { disabled, vertical, size: size$2 = "medium", root, input, rail, thumb } = props;
		const state = {
			disabled,
			size: size$2,
			vertical,
			components: {
				input: "input",
				rail: "div",
				root: "div",
				thumb: "div"
			},
			root: always(root, {
				defaultProps: nativeProps.root,
				elementType: "div"
			}),
			input: always(input, {
				defaultProps: {
					id: useId("slider-", props.id),
					ref,
					...nativeProps.primary,
					type: "range",
					orient: vertical ? "vertical" : void 0
				},
				elementType: "input"
			}),
			rail: always(rail, { elementType: "div" }),
			thumb: always(thumb, { elementType: "div" })
		};
		state.root.ref = useMergedRefs(state.root.ref, useFocusWithin());
		useSliderState_unstable(state, props);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-slider/lib/components/Slider/renderSlider.js
/**
	* Render the final JSX of Slider
	*/ const renderSlider_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(state.root, { children: [
			/* @__PURE__ */ jsx(state.input, {}),
			/* @__PURE__ */ jsx(state.rail, {}),
			/* @__PURE__ */ jsx(state.thumb, {})
		] });
	};

//#endregion
//#region node_modules/@fluentui/react-slider/lib/components/Slider/Slider.js
/**
	* The Slider component allows users to quickly select a value by dragging a thumb across a rail.
	*/ const Slider = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useSlider_unstable(props, ref);
		useSliderStyles_unstable(state);
		useCustomStyleHook("useSliderStyles_unstable")(state);
		return renderSlider_unstable(state);
	});
	Slider.displayName = "Slider";

//#endregion
//#region node_modules/@fluentui/react-spinbutton/lib/utils/clamp.js
	const clamp = (value, min$1, max$1) => {
		let nextValue = value;
		if (min$1 !== void 0) {
			if (max$1 !== void 0 && min$1 > max$1) {
				const error = /* @__PURE__ */ new Error();
				console.error([
					`"min" value "${min$1}" is greater than "max" value "${max$1}".`,
					"\"min\" must be less than or equal to \"max\".",
					`Returning value "${value}".`,
					error.stack
				].join());
				return value;
			}
			nextValue = Math.max(min$1, nextValue);
		}
		if (max$1 !== void 0) nextValue = Math.min(max$1, nextValue);
		return nextValue;
	};

//#endregion
//#region node_modules/@fluentui/react-spinbutton/lib/utils/getBound.js
	const getBound = (value, min$1, max$1) => {
		if (min$1 !== void 0 && value === min$1) {
			if (max$1 === min$1) return "both";
			return "min";
		} else if (max$1 !== void 0 && value === max$1) return "max";
		return "none";
	};

//#endregion
//#region node_modules/@fluentui/react-spinbutton/lib/utils/precision.js
/**
	* Calculates a number's precision based on the number of trailing
	* zeros if the number does not have a decimal indicated by a negative
	* precision. Otherwise, it calculates the number of digits after
	* the decimal point indicated by a positive precision.
	* @param value - the value to determine the precision of
	*/ function calculatePrecision(value) {
		/**
		* Group 1:
		* [1-9]([0]+$) matches trailing zeros
		* Group 2:
		* \.([0-9]*) matches all digits after a decimal point.
		*/ const groups = /[1-9]([0]+$)|\.([0-9]*)/.exec(String(value));
		if (!groups) return 0;
		if (groups[1]) return -groups[1].length;
		if (groups[2]) return groups[2].length;
		return 0;
	}
	/**
	* Rounds a number to a certain level of precision. Accepts negative precision.
	* @param value - The value that is being rounded.
	* @param precision - The number of decimal places to round the number to
	*/ function precisionRound(value, precision, base = 10) {
		const exp = base ** precision;
		return Math.round(value * exp) / exp;
	}

//#endregion
//#region node_modules/@fluentui/react-spinbutton/lib/components/SpinButton/useSpinButton.js
	const DEFAULT_SPIN_DELAY_MS = 150;
	const MIN_SPIN_DELAY_MS = 80;
	const MAX_SPIN_TIME_MS = 1e3;
	const lerp = (start, end, percent) => start + (end - start) * percent;
	/**
	* Create the state required to render SpinButton.
	*
	* The returned state can be modified with hooks such as useSpinButtonStyles_unstable,
	* before being passed to renderSpinButton_unstable.
	*
	* @param props - props from this instance of SpinButton
	* @param ref - reference to root HTMLElement of SpinButton
	*/ const useSpinButton_unstable = (props, ref) => {
		props = useFieldControlProps_unstable(props, {
			supportsLabelFor: true,
			supportsRequired: true
		});
		const nativeProps = getPartitionedNativeProps({
			props,
			primarySlotTagName: "input",
			excludedPropNames: [
				"defaultValue",
				"max",
				"min",
				"onChange",
				"size",
				"value"
			]
		});
		const overrides = useOverrides();
		var _overrides_inputDefaultAppearance;
		const { value, displayValue, defaultValue, min: min$1, max: max$1, step = 1, stepPage = 1, precision: precisionFromProps, onChange, size: size$2 = "medium", appearance = (_overrides_inputDefaultAppearance = overrides.inputDefaultAppearance) !== null && _overrides_inputDefaultAppearance !== void 0 ? _overrides_inputDefaultAppearance : "outline", root, input, incrementButton, decrementButton } = props;
		const precision = react.useMemo(() => {
			return precisionFromProps !== null && precisionFromProps !== void 0 ? precisionFromProps : Math.max(calculatePrecision(step), 0);
		}, [precisionFromProps, step]);
		const [currentValue, setCurrentValue] = useControllableState({
			state: value,
			defaultState: defaultValue,
			initialState: 0
		});
		const inputRef = react.useRef(null);
		const isControlled = value !== void 0;
		const [textValue, setTextValue] = react.useState(void 0);
		const [keyboardSpinState, setKeyboardSpinState] = react.useState("rest");
		const internalState = react.useRef({
			value: currentValue,
			spinState: "rest",
			spinTime: 0,
			spinDelay: DEFAULT_SPIN_DELAY_MS,
			atBound: currentValue !== null ? getBound(precisionRound(currentValue, precision), min$1, max$1) : "none"
		});
		const [setStepTimeout, clearStepTimeout] = useTimeout();
		const stepValue = (e, direction, startFrom) => {
			let startValue = internalState.current.value;
			if (startFrom) {
				const num = parseFloat(startFrom);
				if (!isNaN(num)) startValue = num;
			}
			const val = startValue;
			const dir = direction === "up" || direction === "upPage" ? 1 : -1;
			const stepSize = direction === "upPage" || direction === "downPage" ? stepPage : step;
			if (val === null) {
				commit(e, clamp((min$1 === void 0 ? 0 : min$1) + stepSize * dir, min$1, max$1));
				return;
			}
			let newValue = val + stepSize * dir;
			if (!Number.isNaN(newValue)) newValue = clamp(newValue, min$1, max$1);
			commit(e, newValue);
			if (internalState.current.spinState !== "rest") setStepTimeout(() => {
				internalState.current.spinTime += internalState.current.spinDelay;
				internalState.current.spinDelay = lerp(DEFAULT_SPIN_DELAY_MS, MIN_SPIN_DELAY_MS, internalState.current.spinTime / MAX_SPIN_TIME_MS);
				stepValue(e, direction);
			}, internalState.current.spinDelay);
		};
		const handleInputChange = (e) => {
			if (!internalState.current.previousTextValue) internalState.current.previousTextValue = textValue !== null && textValue !== void 0 ? textValue : String(currentValue);
			const newValue = e.target.value;
			setTextValue(newValue);
			if (inputRef.current) inputRef.current.ariaValueNow = newValue;
		};
		const handleIncrementMouseDown = (e) => {
			commit(e, currentValue, textValue);
			internalState.current.spinState = "up";
			stepValue(e, "up");
		};
		const handleDecrementMouseDown = (e) => {
			commit(e, currentValue, textValue);
			internalState.current.spinState = "down";
			stepValue(e, "down");
		};
		const handleStepMouseUpOrLeave = (e) => {
			clearStepTimeout();
			internalState.current.spinState = "rest";
			internalState.current.spinDelay = DEFAULT_SPIN_DELAY_MS;
			internalState.current.spinTime = 0;
		};
		const handleBlur = (e) => {
			commit(e, currentValue, textValue);
			internalState.current.previousTextValue = void 0;
		};
		const handleKeyDown = (e) => {
			let nextKeyboardSpinState = "rest";
			if (e.key === ArrowUp) {
				stepValue(e, "up", textValue);
				nextKeyboardSpinState = "up";
			} else if (e.key === ArrowDown) {
				stepValue(e, "down", textValue);
				nextKeyboardSpinState = "down";
			} else if (e.key === PageUp) {
				e.preventDefault();
				stepValue(e, "upPage", textValue);
				nextKeyboardSpinState = "up";
			} else if (e.key === PageDown) {
				e.preventDefault();
				stepValue(e, "downPage", textValue);
				nextKeyboardSpinState = "down";
			} else if (!e.shiftKey && e.key === Home && min$1 !== void 0) {
				commit(e, min$1);
				nextKeyboardSpinState = "down";
			} else if (!e.shiftKey && e.key === End && max$1 !== void 0) {
				commit(e, max$1);
				nextKeyboardSpinState = "up";
			} else if (e.key === Enter) {
				commit(e, currentValue, textValue);
				internalState.current.previousTextValue = void 0;
			} else if (e.key === Escape) {
				if (internalState.current.previousTextValue) {
					setTextValue(void 0);
					internalState.current.previousTextValue = void 0;
				}
			}
			if (keyboardSpinState !== nextKeyboardSpinState) setKeyboardSpinState(nextKeyboardSpinState);
		};
		const handleKeyUp = (e) => {
			if (keyboardSpinState !== "rest") {
				setKeyboardSpinState("rest");
				internalState.current.spinState = "rest";
			}
		};
		const commit = (e, newValue, newDisplayValue) => {
			const valueChanged = newValue !== void 0 && currentValue !== newValue;
			const displayValueChanged = newDisplayValue !== void 0 && internalState.current.previousTextValue !== void 0 && internalState.current.previousTextValue !== newDisplayValue;
			let roundedValue;
			if (valueChanged) {
				roundedValue = precisionRound(newValue, precision);
				setCurrentValue(roundedValue);
				internalState.current.value = roundedValue;
			} else if (displayValueChanged && !isControlled) {
				const nextValue = parseFloat(newDisplayValue);
				if (!isNaN(nextValue)) {
					setCurrentValue(precisionRound(nextValue, precision));
					internalState.current.value = precisionRound(nextValue, precision);
				}
			}
			if (valueChanged || displayValueChanged) onChange === null || onChange === void 0 || onChange(e, {
				value: roundedValue,
				displayValue: newDisplayValue
			});
			setTextValue(void 0);
		};
		let valueToDisplay;
		if (textValue !== void 0) valueToDisplay = textValue;
		else if (value === null || currentValue === null) {
			valueToDisplay = displayValue !== null && displayValue !== void 0 ? displayValue : "";
			internalState.current.value = null;
			internalState.current.atBound = "none";
		} else {
			const roundedValue = precisionRound(currentValue, precision);
			internalState.current.value = roundedValue;
			internalState.current.atBound = getBound(roundedValue, min$1, max$1);
			if (isControlled) valueToDisplay = displayValue !== null && displayValue !== void 0 ? displayValue : String(roundedValue);
			else valueToDisplay = String(roundedValue);
		}
		const state = {
			size: size$2,
			appearance,
			spinState: keyboardSpinState,
			atBound: internalState.current.atBound,
			components: {
				root: "span",
				input: "input",
				incrementButton: "button",
				decrementButton: "button"
			},
			root: always(root, {
				defaultProps: nativeProps.root,
				elementType: "span"
			}),
			input: always(input, {
				defaultProps: {
					autoComplete: "off",
					role: "spinbutton",
					appearance,
					type: "text",
					...nativeProps.primary
				},
				elementType: "input"
			}),
			incrementButton: always(incrementButton, {
				defaultProps: {
					tabIndex: -1,
					children: /* @__PURE__ */ react.createElement(ChevronUp16Regular, null),
					disabled: nativeProps.primary.disabled || internalState.current.atBound === "max" || internalState.current.atBound === "both",
					"aria-label": "Increment value",
					type: "button"
				},
				elementType: "button"
			}),
			decrementButton: always(decrementButton, {
				defaultProps: {
					tabIndex: -1,
					children: /* @__PURE__ */ react.createElement(ChevronDown16Regular, null),
					disabled: nativeProps.primary.disabled || internalState.current.atBound === "min" || internalState.current.atBound === "both",
					"aria-label": "Decrement value",
					type: "button"
				},
				elementType: "button"
			})
		};
		state.input.value = valueToDisplay;
		state.input.ref = useMergedRefs(inputRef, ref);
		state.input["aria-valuemin"] = min$1;
		state.input["aria-valuemax"] = max$1;
		var _internalState_current_value;
		state.input["aria-valuenow"] = (_internalState_current_value = internalState.current.value) !== null && _internalState_current_value !== void 0 ? _internalState_current_value : void 0;
		var _state_input_ariavaluetext;
		state.input["aria-valuetext"] = (_state_input_ariavaluetext = state.input["aria-valuetext"]) !== null && _state_input_ariavaluetext !== void 0 ? _state_input_ariavaluetext : value !== void 0 && displayValue || void 0;
		state.input.onChange = mergeCallbacks(state.input.onChange, handleInputChange);
		state.input.onInput = mergeCallbacks(state.input.onInput, handleInputChange);
		state.input.onBlur = mergeCallbacks(state.input.onBlur, handleBlur);
		state.input.onKeyDown = mergeCallbacks(state.input.onKeyDown, handleKeyDown);
		state.input.onKeyUp = mergeCallbacks(state.input.onKeyUp, handleKeyUp);
		state.incrementButton.onMouseDown = mergeCallbacks(handleIncrementMouseDown, state.incrementButton.onMouseDown);
		state.incrementButton.onMouseUp = mergeCallbacks(state.incrementButton.onMouseUp, handleStepMouseUpOrLeave);
		state.incrementButton.onMouseLeave = mergeCallbacks(state.incrementButton.onMouseLeave, handleStepMouseUpOrLeave);
		state.decrementButton.onMouseDown = mergeCallbacks(handleDecrementMouseDown, state.decrementButton.onMouseDown);
		state.decrementButton.onMouseUp = mergeCallbacks(state.decrementButton.onMouseUp, handleStepMouseUpOrLeave);
		state.decrementButton.onMouseLeave = mergeCallbacks(state.decrementButton.onMouseLeave, handleStepMouseUpOrLeave);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-spinbutton/lib/components/SpinButton/renderSpinButton.js
/**
	* Render the final JSX of SpinButton
	*/ const renderSpinButton_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(state.root, { children: [
			/* @__PURE__ */ jsx(state.input, {}),
			/* @__PURE__ */ jsx(state.incrementButton, {}),
			/* @__PURE__ */ jsx(state.decrementButton, {})
		] });
	};

//#endregion
//#region node_modules/@fluentui/react-spinbutton/lib/components/SpinButton/useSpinButtonStyles.styles.js
	const spinButtonClassNames = {
		root: "fui-SpinButton",
		input: "fui-SpinButton__input",
		incrementButton: "fui-SpinButton__incrementButton",
		decrementButton: "fui-SpinButton__decrementButton"
	};
	const spinButtonExtraClassNames = { buttonActive: "fui-SpinButton__button_active" };
	const useRootClassName$2 = /* @__PURE__ */ __resetStyles("r109xulx", "r1h2jnch", {
		r: [
			".r109xulx{display:inline-grid;grid-template-columns:1fr 24px;grid-template-rows:1fr 1fr;column-gap:var(--spacingHorizontalXS);row-gap:0;position:relative;isolation:isolate;vertical-align:middle;background-color:var(--colorNeutralBackground1);min-height:32px;padding:0 0 0 var(--spacingHorizontalMNudge);border-radius:var(--borderRadiusMedium);}",
			".r109xulx::before{content:\"\";box-sizing:border-box;position:absolute;top:0;right:0;bottom:0;left:0;pointer-events:none;z-index:10;border:1px solid var(--colorNeutralStroke1);border-bottom-color:var(--colorNeutralStrokeAccessible);border-radius:var(--borderRadiusMedium);}",
			".r109xulx::after{box-sizing:border-box;content:\"\";position:absolute;right:0;bottom:0;left:0;z-index:20;height:max(2px, var(--borderRadiusMedium));border-bottom-left-radius:var(--borderRadiusMedium);border-bottom-right-radius:var(--borderRadiusMedium);border-bottom:2px solid var(--colorCompoundBrandStroke);clip-path:inset(calc(100% - 2px) 0 0 0);transform:scaleX(0);transition-property:transform;transition-duration:var(--durationUltraFast);transition-delay:var(--curveAccelerateMid);}",
			".r109xulx:focus-within::after{transform:scaleX(1);transition-property:transform;transition-duration:var(--durationNormal);transition-delay:var(--curveDecelerateMid);}",
			".r109xulx:focus-within:active::after{border-bottom-color:var(--colorCompoundBrandStrokePressed);}",
			".r109xulx:focus-within{outline:2px solid transparent;}",
			".r1h2jnch{display:inline-grid;grid-template-columns:1fr 24px;grid-template-rows:1fr 1fr;column-gap:var(--spacingHorizontalXS);row-gap:0;position:relative;isolation:isolate;vertical-align:middle;background-color:var(--colorNeutralBackground1);min-height:32px;padding:0 var(--spacingHorizontalMNudge) 0 0;border-radius:var(--borderRadiusMedium);}",
			".r1h2jnch::before{content:\"\";box-sizing:border-box;position:absolute;top:0;left:0;bottom:0;right:0;pointer-events:none;z-index:10;border:1px solid var(--colorNeutralStroke1);border-bottom-color:var(--colorNeutralStrokeAccessible);border-radius:var(--borderRadiusMedium);}",
			".r1h2jnch::after{box-sizing:border-box;content:\"\";position:absolute;left:0;bottom:0;right:0;z-index:20;height:max(2px, var(--borderRadiusMedium));border-bottom-right-radius:var(--borderRadiusMedium);border-bottom-left-radius:var(--borderRadiusMedium);border-bottom:2px solid var(--colorCompoundBrandStroke);clip-path:inset(calc(100% - 2px) 0 0 0);transform:scaleX(0);transition-property:transform;transition-duration:var(--durationUltraFast);transition-delay:var(--curveAccelerateMid);}",
			".r1h2jnch:focus-within::after{transform:scaleX(1);transition-property:transform;transition-duration:var(--durationNormal);transition-delay:var(--curveDecelerateMid);}",
			".r1h2jnch:focus-within:active::after{border-bottom-color:var(--colorCompoundBrandStrokePressed);}",
			".r1h2jnch:focus-within{outline:2px solid transparent;}"
		],
		s: [
			"@media screen and (prefers-reduced-motion: reduce){.r109xulx::after{transition-duration:0.01ms;transition-delay:0.01ms;}}",
			"@media screen and (prefers-reduced-motion: reduce){.r109xulx:focus-within::after{transition-duration:0.01ms;transition-delay:0.01ms;}}",
			"@media screen and (prefers-reduced-motion: reduce){.r1h2jnch::after{transition-duration:0.01ms;transition-delay:0.01ms;}}",
			"@media screen and (prefers-reduced-motion: reduce){.r1h2jnch:focus-within::after{transition-duration:0.01ms;transition-delay:0.01ms;}}"
		]
	});
	const useRootStyles$17 = /* @__PURE__ */ __styles({
		small: {
			sshi5w: "f1pha7fy",
			Bahqtrf: "fk6fouc",
			Be2twd7: "fy9rknc",
			Bhrd7zp: "figsok6",
			Bg96gwp: "fwrc4pm",
			uwmqm3: ["f1f5gg8d", "f1vdfbxk"]
		},
		medium: {},
		outline: {},
		outlineInteractive: {
			Bo3r8zu: "f1w2y1rc",
			Hpvxnh: ["f1gofhvl", "f18htlvq"],
			Bx11ytk: "ffcnd28",
			B1rg0w0: ["f18htlvq", "f1gofhvl"],
			Bsg1tlv: "f6lmxco",
			Brjw370: ["fcoc0mf", "f15r4wkl"],
			xcfy85: "f1ipdth8",
			Bcc6kan: ["f15r4wkl", "fcoc0mf"]
		},
		underline: {
			B0qfbqy: "f1o236ok",
			B4f6apu: ["faeg28l", "f64aojp"],
			y0oebl: "fdw6hkg",
			uvfttm: ["f64aojp", "faeg28l"],
			r59vdv: 0,
			Budzafs: 0,
			ck0cow: 0,
			n07z76: 0,
			Gng75u: "f1xyh2jw"
		},
		underlineInteractive: {
			Bx11ytk: "ffcnd28",
			xcfy85: "f1ipdth8",
			d9w3h3: 0,
			B3778ie: 0,
			B4j8arr: 0,
			Bl18szs: 0,
			Blrzh8d: "fkp7w9h"
		},
		filled: {
			Bcgcnre: 0,
			Bqjgrrk: 0,
			qa3bma: 0,
			y0oebl: 0,
			Biqmznv: 0,
			Bm6vgfq: 0,
			Bbv0w2i: 0,
			uvfttm: 0,
			eqrjj: 0,
			Bk5zm6e: 0,
			m598lv: 0,
			B4f6apu: 0,
			ydt019: 0,
			Bq4z7u6: 0,
			Bdkvgpv: 0,
			B0qfbqy: 0,
			kj8mxx: "f1kc0wz4"
		},
		"filled-darker": { De3pzq: "f16xq7d1" },
		"filled-lighter": { De3pzq: "fxugw4r" },
		filledInteractive: {
			B05mzqr: "f1xqt08",
			tb9y6h: ["fzt5lgo", "f8tv3r9"],
			jcehpj: "fyhrops",
			B23o0hn: ["f8tv3r9", "fzt5lgo"]
		},
		invalid: {
			emecyz: "fl48pg9",
			lz0pba: ["f1a168p3", "f1pvdymy"],
			Bo1k74p: "f11knvgl",
			Ba322q7: ["f1pvdymy", "f1a168p3"]
		},
		disabled: {
			Bceei9c: "fdrzuqr",
			De3pzq: "f1c21dwh",
			Bq4z7u6: "f1a0lfh7",
			Bk5zm6e: ["f1p2ejm6", "fmzytvz"],
			Bqjgrrk: "fas2e61",
			Bm6vgfq: ["fmzytvz", "f1p2ejm6"],
			Bvljrlq: "f1p5b8em",
			Cqojjj: ["fs6f9xf", "f11b7h5x"],
			G3zxag: "f1vrn6tw",
			H8270r: ["f11b7h5x", "fs6f9xf"]
		}
	}, {
		d: [
			".f1pha7fy{min-height:24px;}",
			".fk6fouc{font-family:var(--fontFamilyBase);}",
			".fy9rknc{font-size:var(--fontSizeBase200);}",
			".figsok6{font-weight:var(--fontWeightRegular);}",
			".fwrc4pm{line-height:var(--lineHeightBase200);}",
			".f1f5gg8d{padding-left:var(--spacingHorizontalS);}",
			".f1vdfbxk{padding-right:var(--spacingHorizontalS);}",
			".f1o236ok::before{border-top-width:0;}",
			".faeg28l::before{border-right-width:0;}",
			".f64aojp::before{border-left-width:0;}",
			".fdw6hkg::before{border-bottom-width:1px;}",
			[".f1xyh2jw::before{border-radius:var(--borderRadiusNone);}", { p: -1 }],
			[".fkp7w9h::after{border-radius:var(--borderRadiusNone);}", { p: -1 }],
			[".f1kc0wz4::before{border:1px solid var(--colorTransparentStroke);}", { p: -2 }],
			".f16xq7d1{background-color:var(--colorNeutralBackground3);}",
			".fxugw4r{background-color:var(--colorNeutralBackground1);}",
			".fl48pg9:not(:focus-within)::before,.fl48pg9:hover:not(:focus-within)::before{border-top-color:var(--colorPaletteRedBorder2);}",
			".f1a168p3:not(:focus-within)::before,.f1a168p3:hover:not(:focus-within)::before{border-right-color:var(--colorPaletteRedBorder2);}",
			".f1pvdymy:not(:focus-within)::before,.f1pvdymy:hover:not(:focus-within)::before{border-left-color:var(--colorPaletteRedBorder2);}",
			".f11knvgl:not(:focus-within)::before,.f11knvgl:hover:not(:focus-within)::before{border-bottom-color:var(--colorPaletteRedBorder2);}",
			".fdrzuqr{cursor:not-allowed;}",
			".f1c21dwh{background-color:var(--colorTransparentBackground);}",
			".f1a0lfh7::before{border-top-color:var(--colorNeutralStrokeDisabled);}",
			".f1p2ejm6::before{border-right-color:var(--colorNeutralStrokeDisabled);}",
			".fmzytvz::before{border-left-color:var(--colorNeutralStrokeDisabled);}",
			".fas2e61::before{border-bottom-color:var(--colorNeutralStrokeDisabled);}"
		],
		h: [
			".f1w2y1rc:hover::before{border-top-color:var(--colorNeutralStroke1Hover);}",
			".f1gofhvl:hover::before{border-right-color:var(--colorNeutralStroke1Hover);}",
			".f18htlvq:hover::before{border-left-color:var(--colorNeutralStroke1Hover);}",
			".ffcnd28:hover::before{border-bottom-color:var(--colorNeutralStrokeAccessibleHover);}",
			".f1xqt08:hover::before,.f1xqt08:focus-within::before{border-top-color:var(--colorTransparentStrokeInteractive);}",
			".fzt5lgo:hover::before,.fzt5lgo:focus-within::before{border-right-color:var(--colorTransparentStrokeInteractive);}",
			".f8tv3r9:hover::before,.f8tv3r9:focus-within::before{border-left-color:var(--colorTransparentStrokeInteractive);}",
			".fyhrops:hover::before,.fyhrops:focus-within::before{border-bottom-color:var(--colorTransparentStrokeInteractive);}"
		],
		a: [
			".f6lmxco:active::before,.f6lmxco:focus-within::before{border-top-color:var(--colorNeutralStroke1Pressed);}",
			".fcoc0mf:active::before,.fcoc0mf:focus-within::before{border-right-color:var(--colorNeutralStroke1Pressed);}",
			".f15r4wkl:active::before,.f15r4wkl:focus-within::before{border-left-color:var(--colorNeutralStroke1Pressed);}",
			".f1ipdth8:active::before,.f1ipdth8:focus-within::before{border-bottom-color:var(--colorNeutralStrokeAccessiblePressed);}"
		],
		m: [
			["@media (forced-colors: active){.f1p5b8em::before{border-top-color:GrayText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f11b7h5x::before{border-left-color:GrayText;}.fs6f9xf::before{border-right-color:GrayText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1vrn6tw::before{border-bottom-color:GrayText;}}", { m: "(forced-colors: active)" }]
		]
	});
	const useInputClassName = /* @__PURE__ */ __resetStyles("r1ljrqje", null, [
		".r1ljrqje{grid-column-start:1;grid-column-end:2;grid-row-start:1;grid-row-end:3;outline-style:none;border:0;padding:0;color:var(--colorNeutralForeground1);background-color:transparent;font-family:inherit;font-size:inherit;font-weight:inherit;line-height:inherit;width:100%;}",
		".r1ljrqje::-webkit-input-placeholder{color:var(--colorNeutralForeground4);opacity:1;}",
		".r1ljrqje::-moz-placeholder{color:var(--colorNeutralForeground4);opacity:1;}",
		".r1ljrqje::placeholder{color:var(--colorNeutralForeground4);opacity:1;}"
	]);
	const useInputStyles$5 = /* @__PURE__ */ __styles({ disabled: {
		sj55zd: "f1s2aq7o",
		Bceei9c: "fdrzuqr",
		De3pzq: "f1c21dwh",
		yvdlaj: "fahhnxm"
	} }, { d: [
		".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}",
		".fdrzuqr{cursor:not-allowed;}",
		".f1c21dwh{background-color:var(--colorTransparentBackground);}",
		".fahhnxm::-webkit-input-placeholder{color:var(--colorNeutralForegroundDisabled);}",
		".fahhnxm::-moz-placeholder{color:var(--colorNeutralForegroundDisabled);}"
	] });
	const useBaseButtonClassName = /* @__PURE__ */ __resetStyles("r1g4chgs", null, [
		".r1g4chgs{display:inline-flex;width:24px;align-items:center;justify-content:center;border:0;position:absolute;outline-style:none;height:16px;background-color:transparent;color:var(--colorNeutralForeground3);grid-column-start:2;border-radius:0;padding:0 5px 0 5px;}",
		".r1g4chgs:active{outline-style:none;}",
		".r1g4chgs:enabled:hover{cursor:pointer;color:var(--colorNeutralForeground3Hover);background-color:var(--colorSubtleBackgroundHover);}",
		".r1g4chgs:enabled:active{color:var(--colorNeutralForeground3Pressed);background-color:var(--colorSubtleBackgroundPressed);}",
		".r1g4chgs:enabled.fui-SpinButton__button_active{color:var(--colorNeutralForeground3Pressed);background-color:var(--colorSubtleBackgroundPressed);}",
		".r1g4chgs:disabled{cursor:not-allowed;color:var(--colorNeutralForegroundDisabled);}"
	]);
	const useButtonStyles$1 = /* @__PURE__ */ __styles({
		increment: {
			Ijaq50: "f16hsg94",
			B7oj6ja: ["f1jar5jt", "fyu767a"],
			z8tnut: "f10ra9hq",
			Byoj8tv: "f1brlhvm"
		},
		decrement: {
			Ijaq50: "faunodf",
			Bbmb7ep: ["f1aa9q02", "f16jpd5f"],
			z8tnut: "f1sl3k7w",
			Byoj8tv: "f1y2xyjm"
		},
		incrementButtonSmall: {
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: ["f4lv8q1", "fm3uwd2"],
			Bqenvij: "fvblgha"
		},
		decrementButtonSmall: {
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: ["f1q86st8", "frkrfqj"],
			Bqenvij: "fvblgha"
		},
		outline: {},
		underline: {
			De3pzq: "f3rmtva",
			sj55zd: "f11d4kpn",
			r4wkhp: "f1no7wuu",
			B95qlz1: "f1bifk9c",
			p743kt: "fp1zg4s",
			B7xitij: "fo6hitd",
			B6siaa6: "f1wiab75",
			Ba9qmo4: "fj9zm5z",
			Dyrjrp: "f1cqwcg4"
		},
		"filled-darker": {
			De3pzq: "f3rmtva",
			sj55zd: "f11d4kpn",
			r4wkhp: "f1no7wuu",
			B95qlz1: "fwwxidx",
			p743kt: "fp1zg4s",
			B7xitij: "f14i52sd",
			B6siaa6: "f1wiab75",
			Ba9qmo4: "fwry2ka",
			Dyrjrp: "f1cqwcg4"
		},
		"filled-lighter": {
			De3pzq: "f3rmtva",
			sj55zd: "f11d4kpn",
			r4wkhp: "f1no7wuu",
			B95qlz1: "f1yywxnv",
			drw0cw: "fzaa11h",
			idzz8t: "f4fpmm9",
			Dyrjrp: "f1cqwcg4"
		}
	}, { d: [
		".f16hsg94{grid-row-start:1;}",
		".f1jar5jt{border-top-right-radius:var(--borderRadiusMedium);}",
		".fyu767a{border-top-left-radius:var(--borderRadiusMedium);}",
		".f10ra9hq{padding-top:4px;}",
		".f1brlhvm{padding-bottom:1px;}",
		".faunodf{grid-row-start:2;}",
		".f1aa9q02{border-bottom-right-radius:var(--borderRadiusMedium);}",
		".f16jpd5f{border-bottom-left-radius:var(--borderRadiusMedium);}",
		".f1sl3k7w{padding-top:1px;}",
		".f1y2xyjm{padding-bottom:4px;}",
		[".f4lv8q1{padding:3px 6px 0px 4px;}", { p: -1 }],
		[".fm3uwd2{padding:3px 4px 0px 6px;}", { p: -1 }],
		".fvblgha{height:12px;}",
		[".f1q86st8{padding:0px 6px 3px 4px;}", { p: -1 }],
		[".frkrfqj{padding:0px 4px 3px 6px;}", { p: -1 }],
		".f3rmtva{background-color:transparent;}",
		".f11d4kpn{color:var(--colorNeutralForeground3);}",
		".f1no7wuu:enabled:hover{color:var(--colorNeutralForeground3Hover);}",
		".f1bifk9c:enabled:hover{background-color:var(--colorSubtleBackgroundHover);}",
		".fp1zg4s:enabled:active{color:var(--colorNeutralForeground3Pressed);}",
		".fo6hitd:enabled:active{background-color:var(--colorSubtleBackgroundPressed);}",
		".f1wiab75:enabled.fui-SpinButton__button_active{color:var(--colorNeutralForeground3Pressed);}",
		".fj9zm5z:enabled.fui-SpinButton__button_active{background-color:var(--colorSubtleBackgroundPressed);}",
		".f1cqwcg4:disabled{color:var(--colorNeutralForegroundDisabled);}",
		".fwwxidx:enabled:hover{background-color:var(--colorNeutralBackground3Hover);}",
		".f14i52sd:enabled:active{background-color:var(--colorNeutralBackground3Pressed);}",
		".fwry2ka:enabled.fui-SpinButton__button_active{background-color:var(--colorNeutralBackground3Pressed);}",
		".f1yywxnv:enabled:hover{background-color:var(--colorNeutralBackground1Hover);}",
		".fzaa11h:enabled:active,.fzaa11h:enabled.fui-SpinButton__button_active{color:var(--colorNeutralForeground3Pressed);}",
		".f4fpmm9:enabled:active,.f4fpmm9:enabled.fui-SpinButton__button_active{background-color:var(--colorNeutralBackground1Pressed);}"
	] });
	/**
	* Apply styling to the SpinButton slots based on the state
	*/
	const useSpinButtonStyles_unstable = (state) => {
		"use no memo";
		const { appearance, spinState, size: size$2 } = state;
		const disabled = state.input.disabled;
		const invalid = `${state.input["aria-invalid"]}` === "true";
		const filled = appearance.startsWith("filled");
		const rootStyles = useRootStyles$17();
		const buttonStyles = useButtonStyles$1();
		const inputStyles = useInputStyles$5();
		state.root.className = mergeClasses(spinButtonClassNames.root, useRootClassName$2(), rootStyles[size$2], rootStyles[appearance], filled && rootStyles.filled, !disabled && appearance === "outline" && rootStyles.outlineInteractive, !disabled && appearance === "underline" && rootStyles.underlineInteractive, !disabled && filled && rootStyles.filledInteractive, !disabled && invalid && rootStyles.invalid, disabled && rootStyles.disabled, state.root.className);
		state.incrementButton.className = mergeClasses(spinButtonClassNames.incrementButton, spinState === "up" && `${spinButtonExtraClassNames.buttonActive}`, useBaseButtonClassName(), buttonStyles.increment, buttonStyles[appearance], size$2 === "small" && buttonStyles.incrementButtonSmall, state.incrementButton.className);
		state.decrementButton.className = mergeClasses(spinButtonClassNames.decrementButton, spinState === "down" && `${spinButtonExtraClassNames.buttonActive}`, useBaseButtonClassName(), buttonStyles.decrement, buttonStyles[appearance], size$2 === "small" && buttonStyles.decrementButtonSmall, state.decrementButton.className);
		state.input.className = mergeClasses(spinButtonClassNames.input, useInputClassName(), disabled && inputStyles.disabled, state.input.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-spinbutton/lib/components/SpinButton/SpinButton.js
/**
	* A SpinButton allows someone to incrementally adjust a value in small steps.
	*/ const SpinButton = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useSpinButton_unstable(props, ref);
		useSpinButtonStyles_unstable(state);
		useCustomStyleHook("useSpinButtonStyles_unstable")(state);
		return renderSpinButton_unstable(state);
	});
	SpinButton.displayName = "SpinButton";

//#endregion
//#region node_modules/@fluentui/react-spinner/lib/contexts/SpinnerContext.js
	const SpinnerContext = react.createContext(void 0);
	const SpinnerContextDefaultValue = {};
	/**
	* @internal
	*/ const SpinnerContextProvider = SpinnerContext.Provider;
	/**
	* @internal
	*/ const useSpinnerContext = () => {
		var _React_useContext;
		return (_React_useContext = react.useContext(SpinnerContext)) !== null && _React_useContext !== void 0 ? _React_useContext : SpinnerContextDefaultValue;
	};

//#endregion
//#region node_modules/@fluentui/react-spinner/lib/components/Spinner/useSpinner.js
/**
	* Create the state required to render Spinner.
	*
	* The returned state can be modified with hooks such as useSpinnerStyles_unstable,
	* before being passed to renderSpinner_unstable.
	*
	* @param props - props from this instance of Spinner
	* @param ref - reference to root HTMLElement of Spinner
	*/ const useSpinner_unstable = (props, ref) => {
		const { size: contextSize } = useSpinnerContext();
		const { appearance = "primary", labelPosition = "after", size: size$2 = contextSize !== null && contextSize !== void 0 ? contextSize : "medium", delay = 0 } = props;
		const baseId = useId("spinner");
		const { role = "progressbar", ...rest } = props;
		const nativeRoot = always(getIntrinsicElementProps("div", {
			ref,
			role,
			...rest
		}, ["size"]), { elementType: "div" });
		const [isShownAfterDelay, setIsShownAfterDelay] = react.useState(false);
		const [setDelayTimeout, clearDelayTimeout] = useTimeout();
		react.useEffect(() => {
			if (delay <= 0) return;
			setDelayTimeout(() => {
				setIsShownAfterDelay(true);
			}, delay);
			return () => {
				clearDelayTimeout();
			};
		}, [
			setDelayTimeout,
			clearDelayTimeout,
			delay
		]);
		const labelShorthand = optional(props.label, {
			defaultProps: { id: baseId },
			renderByDefault: false,
			elementType: Label
		});
		const spinnerShortHand = optional(props.spinner, {
			renderByDefault: true,
			elementType: "span"
		});
		if (labelShorthand && nativeRoot && !nativeRoot["aria-labelledby"]) nativeRoot["aria-labelledby"] = labelShorthand.id;
		return {
			appearance,
			delay,
			labelPosition,
			size: size$2,
			shouldRenderSpinner: !delay || isShownAfterDelay,
			components: {
				root: "div",
				spinner: "span",
				spinnerTail: "span",
				label: Label
			},
			root: nativeRoot,
			spinner: spinnerShortHand,
			spinnerTail: always(props.spinnerTail, { elementType: "span" }),
			label: labelShorthand
		};
	};

//#endregion
//#region node_modules/@fluentui/react-spinner/lib/components/Spinner/renderSpinner.js
/**
	* Render the final JSX of Spinner
	*/ const renderSpinner_unstable = (state) => {
		assertSlots(state);
		const { labelPosition, shouldRenderSpinner } = state;
		return /* @__PURE__ */ jsxs(state.root, { children: [
			state.label && shouldRenderSpinner && (labelPosition === "above" || labelPosition === "before") && /* @__PURE__ */ jsx(state.label, {}),
			state.spinner && shouldRenderSpinner && /* @__PURE__ */ jsx(state.spinner, { children: state.spinnerTail && /* @__PURE__ */ jsx(state.spinnerTail, {}) }),
			state.label && shouldRenderSpinner && (labelPosition === "below" || labelPosition === "after") && /* @__PURE__ */ jsx(state.label, {})
		] });
	};

//#endregion
//#region node_modules/@fluentui/react-spinner/lib/components/Spinner/useSpinnerStyles.styles.js
	const spinnerClassNames = {
		root: "fui-Spinner",
		spinner: "fui-Spinner__spinner",
		spinnerTail: "fui-Spinner__spinnerTail",
		label: "fui-Spinner__label"
	};
	const useRootBaseClassName$9 = /* @__PURE__ */ __resetStyles("rpp59a7", null, [".rpp59a7{display:flex;align-items:center;justify-content:center;line-height:0;gap:8px;overflow:hidden;min-width:min-content;}"]);
	const useRootStyles$16 = /* @__PURE__ */ __styles({ vertical: { Beiy3e4: "f1vx9l62" } }, { d: [".f1vx9l62{flex-direction:column;}"] });
	const useSpinnerBaseClassName = /* @__PURE__ */ __resetStyles("rvgcg50", "r15nd2jo", {
		r: [
			".rvgcg50{position:relative;flex-shrink:0;-webkit-mask-image:radial-gradient(closest-side, transparent calc(100% - var(--fui-Spinner--strokeWidth) - 1px), white calc(100% - var(--fui-Spinner--strokeWidth)) calc(100% - 1px), transparent 100%);mask-image:radial-gradient(closest-side, transparent calc(100% - var(--fui-Spinner--strokeWidth) - 1px), white calc(100% - var(--fui-Spinner--strokeWidth)) calc(100% - 1px), transparent 100%);background-color:var(--colorBrandStroke2Contrast);color:var(--colorBrandStroke1);animation-duration:1.5s;animation-iteration-count:infinite;animation-timing-function:linear;animation-name:rb7n1on;}",
			"@keyframes rb7n1on{0%{transform:rotate(0deg);}100%{transform:rotate(360deg);}}",
			".r15nd2jo{position:relative;flex-shrink:0;-webkit-mask-image:radial-gradient(closest-side, transparent calc(100% - var(--fui-Spinner--strokeWidth) - 1px), white calc(100% - var(--fui-Spinner--strokeWidth)) calc(100% - 1px), transparent 100%);mask-image:radial-gradient(closest-side, transparent calc(100% - var(--fui-Spinner--strokeWidth) - 1px), white calc(100% - var(--fui-Spinner--strokeWidth)) calc(100% - 1px), transparent 100%);background-color:var(--colorBrandStroke2Contrast);color:var(--colorBrandStroke1);animation-duration:1.5s;animation-iteration-count:infinite;animation-timing-function:linear;animation-name:r1gx3jof;}",
			"@keyframes r1gx3jof{0%{transform:rotate(0deg);}100%{transform:rotate(-360deg);}}"
		],
		s: [
			"@media screen and (forced-colors: active){.rvgcg50{background-color:HighlightText;color:Highlight;forced-color-adjust:none;}}",
			"@media screen and (prefers-reduced-motion: reduce){.rvgcg50{animation-duration:1.8s;}}",
			"@media screen and (forced-colors: active){.r15nd2jo{background-color:HighlightText;color:Highlight;forced-color-adjust:none;}}",
			"@media screen and (prefers-reduced-motion: reduce){.r15nd2jo{animation-duration:1.8s;}}"
		]
	});
	const useSpinnerTailBaseClassName = /* @__PURE__ */ __resetStyles("rxov3xa", "r1o544mv", {
		r: [
			".rxov3xa{position:absolute;display:block;width:100%;height:100%;-webkit-mask-image:conic-gradient(transparent 105deg, white 105deg);mask-image:conic-gradient(transparent 105deg, white 105deg);animation-duration:1.5s;animation-iteration-count:infinite;animation-timing-function:var(--curveEasyEase);animation-name:r15mim6k;}",
			".rxov3xa::before,.rxov3xa::after{content:\"\";position:absolute;display:block;width:100%;height:100%;animation:inherit;background-image:conic-gradient(currentcolor 135deg, transparent 135deg);}",
			"@keyframes r15mim6k{0%{transform:rotate(-135deg);}50%{transform:rotate(0deg);}100%{transform:rotate(225deg);}}",
			".rxov3xa::before{animation-name:r18vhmn8;}",
			"@keyframes r18vhmn8{0%{transform:rotate(0deg);}50%{transform:rotate(105deg);}100%{transform:rotate(0deg);}}",
			".rxov3xa::after{animation-name:rkgrvoi;}",
			"@keyframes rkgrvoi{0%{transform:rotate(0deg);}50%{transform:rotate(225deg);}100%{transform:rotate(0deg);}}",
			".r1o544mv{position:absolute;display:block;width:100%;height:100%;-webkit-mask-image:conic-gradient(transparent 105deg, white 105deg);mask-image:conic-gradient(transparent 105deg, white 105deg);animation-duration:1.5s;animation-iteration-count:infinite;animation-timing-function:var(--curveEasyEase);animation-name:r109gmi5;}",
			".r1o544mv::before,.r1o544mv::after{content:\"\";position:absolute;display:block;width:100%;height:100%;animation:inherit;background-image:conic-gradient(currentcolor 135deg, transparent 135deg);}",
			"@keyframes r109gmi5{0%{transform:rotate(135deg);}50%{transform:rotate(0deg);}100%{transform:rotate(-225deg);}}",
			".r1o544mv::before{animation-name:r17whflh;}",
			"@keyframes r17whflh{0%{transform:rotate(0deg);}50%{transform:rotate(-105deg);}100%{transform:rotate(0deg);}}",
			".r1o544mv::after{animation-name:re4odhl;}",
			"@keyframes re4odhl{0%{transform:rotate(0deg);}50%{transform:rotate(-225deg);}100%{transform:rotate(0deg);}}"
		],
		s: ["@media screen and (prefers-reduced-motion: reduce){.rxov3xa{animation-iteration-count:0;background-image:conic-gradient(transparent 120deg, currentcolor 360deg);}.rxov3xa::before,.rxov3xa::after{content:none;}}", "@media screen and (prefers-reduced-motion: reduce){.r1o544mv{animation-iteration-count:0;background-image:conic-gradient(transparent 120deg, currentcolor 360deg);}.r1o544mv::before,.r1o544mv::after{content:none;}}"]
	});
	const useSpinnerStyles = /* @__PURE__ */ __styles({
		inverted: {
			De3pzq: "fr407j0",
			sj55zd: "f1f7voed"
		},
		rtlTail: {
			btxmck: "f179dep3",
			gb5jj2: "fbz9ihp",
			Bdya8wy: "f1pme1qz"
		},
		"extra-tiny": {
			Bqenvij: "fd461yt",
			a9b677: "fjw5fx7",
			qmp6fs: "f1v3ph3m"
		},
		tiny: {
			Bqenvij: "fjamq6b",
			a9b677: "f64fuq3",
			qmp6fs: "f1v3ph3m"
		},
		"extra-small": {
			Bqenvij: "frvgh55",
			a9b677: "fq4mcun",
			qmp6fs: "f1v3ph3m"
		},
		small: {
			Bqenvij: "fxldao9",
			a9b677: "f1w9dchk",
			qmp6fs: "f1v3ph3m"
		},
		medium: {
			Bqenvij: "f1d2rq10",
			a9b677: "f1szoe96",
			qmp6fs: "fb52u90"
		},
		large: {
			Bqenvij: "f8ljn23",
			a9b677: "fpdz1er",
			qmp6fs: "fb52u90"
		},
		"extra-large": {
			Bqenvij: "fbhnoac",
			a9b677: "feqmc2u",
			qmp6fs: "fb52u90"
		},
		huge: {
			Bqenvij: "f1ft4266",
			a9b677: "fksc0bp",
			qmp6fs: "fa3u9ii"
		}
	}, {
		d: [
			".fr407j0{background-color:var(--colorNeutralStrokeAlpha2);}",
			".f1f7voed{color:var(--colorNeutralStrokeOnBrand2);}",
			".f179dep3{-webkit-mask-image:conic-gradient(white 255deg, transparent 255deg);mask-image:conic-gradient(white 255deg, transparent 255deg);}",
			".fbz9ihp::before,.fbz9ihp::after{background-image:conic-gradient(transparent 225deg, currentcolor 225deg);}",
			".fd461yt{height:16px;}",
			".fjw5fx7{width:16px;}",
			".f1v3ph3m{--fui-Spinner--strokeWidth:var(--strokeWidthThick);}",
			".fjamq6b{height:20px;}",
			".f64fuq3{width:20px;}",
			".frvgh55{height:24px;}",
			".fq4mcun{width:24px;}",
			".fxldao9{height:28px;}",
			".f1w9dchk{width:28px;}",
			".f1d2rq10{height:32px;}",
			".f1szoe96{width:32px;}",
			".fb52u90{--fui-Spinner--strokeWidth:var(--strokeWidthThicker);}",
			".f8ljn23{height:36px;}",
			".fpdz1er{width:36px;}",
			".fbhnoac{height:40px;}",
			".feqmc2u{width:40px;}",
			".f1ft4266{height:44px;}",
			".fksc0bp{width:44px;}",
			".fa3u9ii{--fui-Spinner--strokeWidth:var(--strokeWidthThickest);}"
		],
		m: [["@media screen and (prefers-reduced-motion: reduce){.f1pme1qz{background-image:conic-gradient(currentcolor 0deg, transparent 240deg);}}", { m: "screen and (prefers-reduced-motion: reduce)" }]]
	});
	const useLabelStyles$3 = /* @__PURE__ */ __styles({
		inverted: { sj55zd: "fonrgv7" },
		"extra-tiny": {
			Bahqtrf: "fk6fouc",
			Be2twd7: "fkhj508",
			Bhrd7zp: "figsok6",
			Bg96gwp: "f1i3iumi"
		},
		tiny: {
			Bahqtrf: "fk6fouc",
			Be2twd7: "fkhj508",
			Bhrd7zp: "figsok6",
			Bg96gwp: "f1i3iumi"
		},
		"extra-small": {
			Bahqtrf: "fk6fouc",
			Be2twd7: "fkhj508",
			Bhrd7zp: "figsok6",
			Bg96gwp: "f1i3iumi"
		},
		small: {
			Bahqtrf: "fk6fouc",
			Be2twd7: "fkhj508",
			Bhrd7zp: "figsok6",
			Bg96gwp: "f1i3iumi"
		},
		medium: {
			Bahqtrf: "fk6fouc",
			Be2twd7: "fod5ikn",
			Bhrd7zp: "fl43uef",
			Bg96gwp: "faaz57k"
		},
		large: {
			Bahqtrf: "fk6fouc",
			Be2twd7: "fod5ikn",
			Bhrd7zp: "fl43uef",
			Bg96gwp: "faaz57k"
		},
		"extra-large": {
			Bahqtrf: "fk6fouc",
			Be2twd7: "fod5ikn",
			Bhrd7zp: "fl43uef",
			Bg96gwp: "faaz57k"
		},
		huge: {
			Bahqtrf: "fk6fouc",
			Be2twd7: "f1pp30po",
			Bhrd7zp: "fl43uef",
			Bg96gwp: "f106mvju"
		}
	}, { d: [
		".fonrgv7{color:var(--colorNeutralForegroundStaticInverted);}",
		".fk6fouc{font-family:var(--fontFamilyBase);}",
		".fkhj508{font-size:var(--fontSizeBase300);}",
		".figsok6{font-weight:var(--fontWeightRegular);}",
		".f1i3iumi{line-height:var(--lineHeightBase300);}",
		".fod5ikn{font-size:var(--fontSizeBase400);}",
		".fl43uef{font-weight:var(--fontWeightSemibold);}",
		".faaz57k{line-height:var(--lineHeightBase400);}",
		".f1pp30po{font-size:var(--fontSizeBase500);}",
		".f106mvju{line-height:var(--lineHeightBase500);}"
	] });
	/**
	* Apply styling to the Spinner slots based on the state
	*/
	const useSpinnerStyles_unstable = (state) => {
		"use no memo";
		const { labelPosition, size: size$2, appearance } = state;
		const { dir } = useFluent();
		const rootBaseClassName = useRootBaseClassName$9();
		const rootStyles = useRootStyles$16();
		const spinnerBaseClassName = useSpinnerBaseClassName();
		const spinnerStyles = useSpinnerStyles();
		const spinnerTailBaseClassName = useSpinnerTailBaseClassName();
		const labelStyles = useLabelStyles$3();
		state.root.className = mergeClasses(spinnerClassNames.root, rootBaseClassName, (labelPosition === "above" || labelPosition === "below") && rootStyles.vertical, state.root.className);
		if (state.spinner) state.spinner.className = mergeClasses(spinnerClassNames.spinner, spinnerBaseClassName, spinnerStyles[size$2], appearance === "inverted" && spinnerStyles.inverted, state.spinner.className);
		if (state.spinnerTail) state.spinnerTail.className = mergeClasses(spinnerClassNames.spinnerTail, spinnerTailBaseClassName, dir === "rtl" && spinnerStyles.rtlTail, state.spinnerTail.className);
		if (state.label) state.label.className = mergeClasses(spinnerClassNames.label, labelStyles[size$2], appearance === "inverted" && labelStyles.inverted, state.label.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-spinner/lib/components/Spinner/Spinner.js
/**
	* Converged Spinner component for the fluentui repo
	*/ const Spinner = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useSpinner_unstable(props, ref);
		useSpinnerStyles_unstable(state);
		useCustomStyleHook("useSpinnerStyles_unstable")(state);
		return renderSpinner_unstable(state);
	});
	Spinner.displayName = "Spinner";

//#endregion
//#region node_modules/@fluentui/react-switch/lib/components/Switch/useSwitch.js
/**
	* Create the state required to render Switch.
	*
	* The returned state can be modified with hooks such as useSwitchStyles_unstable,
	* before being passed to renderSwitch_unstable.
	*
	* @param props - props from this instance of Switch
	* @param ref - reference to `<input>` element of Switch
	*/ const useSwitch_unstable = (props, ref) => {
		props = useFieldControlProps_unstable(props, {
			supportsLabelFor: true,
			supportsRequired: true
		});
		const { checked, defaultChecked, disabled, labelPosition = "after", size: size$2 = "medium", onChange, required } = props;
		const nativeProps = getPartitionedNativeProps({
			props,
			primarySlotTagName: "input",
			excludedPropNames: [
				"checked",
				"defaultChecked",
				"onChange",
				"size"
			]
		});
		const id = useId("switch-", nativeProps.primary.id);
		const root = always(props.root, {
			defaultProps: {
				ref: useFocusWithin(),
				...nativeProps.root
			},
			elementType: "div"
		});
		const indicator = always(props.indicator, {
			defaultProps: {
				"aria-hidden": true,
				children: /* @__PURE__ */ react.createElement(CircleFilled, null)
			},
			elementType: "div"
		});
		const input = always(props.input, {
			defaultProps: {
				checked,
				defaultChecked,
				id,
				ref,
				role: "switch",
				type: "checkbox",
				...nativeProps.primary
			},
			elementType: "input"
		});
		input.onChange = mergeCallbacks(input.onChange, (ev) => onChange === null || onChange === void 0 ? void 0 : onChange(ev, { checked: ev.currentTarget.checked }));
		const label = optional(props.label, {
			defaultProps: {
				disabled,
				htmlFor: id,
				required,
				size: "medium"
			},
			elementType: Label
		});
		return {
			labelPosition,
			components: {
				root: "div",
				indicator: "div",
				input: "input",
				label: Label
			},
			root,
			indicator,
			input,
			label,
			size: size$2
		};
	};

//#endregion
//#region node_modules/@fluentui/react-switch/lib/components/Switch/renderSwitch.js
/**
	* Render a Switch component by passing the state defined props to the appropriate slots.
	*/ const renderSwitch_unstable = (state) => {
		assertSlots(state);
		const { labelPosition } = state;
		return /* @__PURE__ */ jsxs(state.root, { children: [
			/* @__PURE__ */ jsx(state.input, {}),
			labelPosition !== "after" && state.label && /* @__PURE__ */ jsx(state.label, {}),
			/* @__PURE__ */ jsx(state.indicator, {}),
			labelPosition === "after" && state.label && /* @__PURE__ */ jsx(state.label, {})
		] });
	};

//#endregion
//#region node_modules/@fluentui/react-switch/lib/components/Switch/useSwitchStyles.styles.js
	const switchClassNames = {
		root: "fui-Switch",
		indicator: "fui-Switch__indicator",
		input: "fui-Switch__input",
		label: "fui-Switch__label"
	};
	/**
	* @deprecated Use `switchClassNames.root` instead.
	*/
	const switchClassName = switchClassNames.root;
	const spaceBetweenThumbAndTrack = 2;
	20 - spaceBetweenThumbAndTrack;
	16 - spaceBetweenThumbAndTrack;
	const useRootBaseClassName$8 = /* @__PURE__ */ __resetStyles("r2i81i2", "rofhmb8", {
		r: [
			".r2i81i2{align-items:flex-start;box-sizing:border-box;display:inline-flex;position:relative;}",
			".r2i81i2:focus{outline-style:none;}",
			".r2i81i2:focus-visible{outline-style:none;}",
			".r2i81i2[data-fui-focus-within]:focus-within{border-top-color:transparent;border-right-color:transparent;border-bottom-color:transparent;border-left-color:transparent;}",
			".r2i81i2[data-fui-focus-within]:focus-within::after{content:\"\";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);right:calc(2px * -1);bottom:calc(2px * -1);left:calc(2px * -1);}",
			".rofhmb8{align-items:flex-start;box-sizing:border-box;display:inline-flex;position:relative;}",
			".rofhmb8:focus{outline-style:none;}",
			".rofhmb8:focus-visible{outline-style:none;}",
			".rofhmb8[data-fui-focus-within]:focus-within{border-top-color:transparent;border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent;}",
			".rofhmb8[data-fui-focus-within]:focus-within::after{content:\"\";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);left:calc(2px * -1);bottom:calc(2px * -1);right:calc(2px * -1);}"
		],
		s: ["@media (forced-colors: active){.r2i81i2[data-fui-focus-within]:focus-within::after{border-top-color:Highlight;border-right-color:Highlight;border-bottom-color:Highlight;border-left-color:Highlight;}}", "@media (forced-colors: active){.rofhmb8[data-fui-focus-within]:focus-within::after{border-top-color:Highlight;border-left-color:Highlight;border-bottom-color:Highlight;border-right-color:Highlight;}}"]
	});
	const useRootStyles$15 = /* @__PURE__ */ __styles({ vertical: { Beiy3e4: "f1vx9l62" } }, { d: [".f1vx9l62{flex-direction:column;}"] });
	const useIndicatorBaseClassName$1 = /* @__PURE__ */ __resetStyles("r1c3hft5", null, {
		r: [".r1c3hft5{border-radius:var(--borderRadiusCircular);border:1px solid;line-height:0;box-sizing:border-box;fill:currentColor;flex-shrink:0;font-size:18px;height:20px;margin:var(--spacingVerticalS) var(--spacingHorizontalS);pointer-events:none;transition-duration:var(--durationNormal);transition-timing-function:var(--curveEasyEase);transition-property:background,border,color;width:40px;}", ".r1c3hft5>*{transition-duration:var(--durationNormal);transition-timing-function:var(--curveEasyEase);transition-property:transform;}"],
		s: [
			"@media screen and (prefers-reduced-motion: reduce){.r1c3hft5{transition-duration:0.01ms;}}",
			"@media (forced-colors: active){.r1c3hft5{color:CanvasText;}.r1c3hft5>i{forced-color-adjust:none;}}",
			"@media screen and (prefers-reduced-motion: reduce){.r1c3hft5>*{transition-duration:0.01ms;}}"
		]
	});
	const useIndicatorStyles$2 = /* @__PURE__ */ __styles({
		labelAbove: { B6of3ja: "f1hu3pq6" },
		sizeSmall: {
			Be2twd7: "fses1vf",
			Bqenvij: "fd461yt",
			a9b677: "f1szoe96"
		}
	}, { d: [
		".f1hu3pq6{margin-top:0;}",
		".fses1vf{font-size:14px;}",
		".fd461yt{height:16px;}",
		".f1szoe96{width:32px;}"
	] });
	const useInputBaseClassName$1 = /* @__PURE__ */ __resetStyles("rsji9ng", "r15xih98", {
		r: [
			".rsji9ng{box-sizing:border-box;cursor:pointer;height:100%;margin:0;opacity:0;position:absolute;width:calc(40px + 2 * var(--spacingHorizontalS));}",
			".rsji9ng:checked~.fui-Switch__indicator>*{transform:translateX(20px);}",
			".rsji9ng:disabled{cursor:default;}",
			".rsji9ng:disabled~.fui-Switch__indicator{color:var(--colorNeutralForegroundDisabled);}",
			".rsji9ng:disabled~.fui-Switch__label{cursor:default;color:var(--colorNeutralForegroundDisabled);}",
			".rsji9ng:enabled:not(:checked)~.fui-Switch__indicator{color:var(--colorNeutralStrokeAccessible);border-color:var(--colorNeutralStrokeAccessible);}",
			".rsji9ng:enabled:not(:checked)~.fui-Switch__label{color:var(--colorNeutralForeground1);}",
			".rsji9ng:enabled:not(:checked):hover~.fui-Switch__indicator{color:var(--colorNeutralStrokeAccessibleHover);border-color:var(--colorNeutralStrokeAccessibleHover);}",
			".rsji9ng:enabled:not(:checked):hover:active~.fui-Switch__indicator{color:var(--colorNeutralStrokeAccessiblePressed);border-color:var(--colorNeutralStrokeAccessiblePressed);}",
			".rsji9ng:enabled:checked~.fui-Switch__indicator{background-color:var(--colorCompoundBrandBackground);color:var(--colorNeutralForegroundInverted);border-color:var(--colorTransparentStroke);}",
			".rsji9ng:enabled:checked:hover~.fui-Switch__indicator{background-color:var(--colorCompoundBrandBackgroundHover);border-color:var(--colorTransparentStrokeInteractive);}",
			".rsji9ng:enabled:checked:hover:active~.fui-Switch__indicator{background-color:var(--colorCompoundBrandBackgroundPressed);border-color:var(--colorTransparentStrokeInteractive);}",
			".rsji9ng:disabled:not(:checked)~.fui-Switch__indicator{border-color:var(--colorNeutralStrokeDisabled);}",
			".rsji9ng:disabled:checked~.fui-Switch__indicator{background-color:var(--colorNeutralBackgroundDisabled);border-color:var(--colorTransparentStrokeDisabled);}",
			".r15xih98{box-sizing:border-box;cursor:pointer;height:100%;margin:0;opacity:0;position:absolute;width:calc(40px + 2 * var(--spacingHorizontalS));}",
			".r15xih98:checked~.fui-Switch__indicator>*{transform:translateX(-20px);}",
			".r15xih98:disabled{cursor:default;}",
			".r15xih98:disabled~.fui-Switch__indicator{color:var(--colorNeutralForegroundDisabled);}",
			".r15xih98:disabled~.fui-Switch__label{cursor:default;color:var(--colorNeutralForegroundDisabled);}",
			".r15xih98:enabled:not(:checked)~.fui-Switch__indicator{color:var(--colorNeutralStrokeAccessible);border-color:var(--colorNeutralStrokeAccessible);}",
			".r15xih98:enabled:not(:checked)~.fui-Switch__label{color:var(--colorNeutralForeground1);}",
			".r15xih98:enabled:not(:checked):hover~.fui-Switch__indicator{color:var(--colorNeutralStrokeAccessibleHover);border-color:var(--colorNeutralStrokeAccessibleHover);}",
			".r15xih98:enabled:not(:checked):hover:active~.fui-Switch__indicator{color:var(--colorNeutralStrokeAccessiblePressed);border-color:var(--colorNeutralStrokeAccessiblePressed);}",
			".r15xih98:enabled:checked~.fui-Switch__indicator{background-color:var(--colorCompoundBrandBackground);color:var(--colorNeutralForegroundInverted);border-color:var(--colorTransparentStroke);}",
			".r15xih98:enabled:checked:hover~.fui-Switch__indicator{background-color:var(--colorCompoundBrandBackgroundHover);border-color:var(--colorTransparentStrokeInteractive);}",
			".r15xih98:enabled:checked:hover:active~.fui-Switch__indicator{background-color:var(--colorCompoundBrandBackgroundPressed);border-color:var(--colorTransparentStrokeInteractive);}",
			".r15xih98:disabled:not(:checked)~.fui-Switch__indicator{border-color:var(--colorNeutralStrokeDisabled);}",
			".r15xih98:disabled:checked~.fui-Switch__indicator{background-color:var(--colorNeutralBackgroundDisabled);border-color:var(--colorTransparentStrokeDisabled);}"
		],
		s: ["@media (forced-colors: active){.rsji9ng:disabled~.fui-Switch__indicator{color:GrayText;border-color:GrayText;}.rsji9ng:disabled~.fui-Switch__label{color:GrayText;}.rsji9ng:hover{color:CanvasText;}.rsji9ng:hover:active{color:CanvasText;}.rsji9ng:enabled:checked:hover~.fui-Switch__indicator{background-color:Highlight;color:Canvas;}.rsji9ng:enabled:checked:hover:active~.fui-Switch__indicator{background-color:Highlight;color:Canvas;}.rsji9ng:enabled:checked~.fui-Switch__indicator{background-color:Highlight;color:Canvas;}}", "@media (forced-colors: active){.r15xih98:disabled~.fui-Switch__indicator{color:GrayText;border-color:GrayText;}.r15xih98:disabled~.fui-Switch__label{color:GrayText;}.r15xih98:hover{color:CanvasText;}.r15xih98:hover:active{color:CanvasText;}.r15xih98:enabled:checked:hover~.fui-Switch__indicator{background-color:Highlight;color:Canvas;}.r15xih98:enabled:checked:hover:active~.fui-Switch__indicator{background-color:Highlight;color:Canvas;}.r15xih98:enabled:checked~.fui-Switch__indicator{background-color:Highlight;color:Canvas;}}"]
	});
	const useInputStyles$4 = /* @__PURE__ */ __styles({
		before: {
			j35jbq: ["f1e31b4d", "f1vgc2s3"],
			Bhzewxz: "f15twtuk"
		},
		after: {
			oyh7mz: ["f1vgc2s3", "f1e31b4d"],
			Bhzewxz: "f15twtuk"
		},
		above: {
			B5kzvoi: "f1yab3r1",
			Bqenvij: "f1aar7gd",
			a9b677: "fly5x3f"
		},
		sizeSmall: {
			a9b677: "f83td6f",
			oedwrj: ["f1t5zc5r", "fmy58zi"]
		}
	}, { d: [
		".f1e31b4d{right:0;}",
		".f1vgc2s3{left:0;}",
		".f15twtuk{top:0;}",
		".f1yab3r1{bottom:0;}",
		".f1aar7gd{height:calc(20px + var(--spacingVerticalS));}",
		".fly5x3f{width:100%;}",
		".f83td6f{width:calc(32px + 2 * var(--spacingHorizontalS));}",
		".f1t5zc5r:checked~.fui-Switch__indicator>*{transform:translateX(16px);}",
		".fmy58zi:checked~.fui-Switch__indicator>*{transform:translateX(-16px);}"
	] });
	const useLabelStyles$2 = /* @__PURE__ */ __styles({
		base: {
			Bceei9c: "f1k6fduh",
			jrapky: "f49ad5g",
			B6of3ja: "f1xlvstr",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f1f5q0n8"
		},
		sizeSmall: {
			Be2twd7: "fy9rknc",
			Bg96gwp: "fwrc4pm",
			jrapky: "f1suqah5",
			B6of3ja: "f26bnac"
		},
		above: {
			z8tnut: "f1ywm7hm",
			Byoj8tv: "f14wxoun",
			a9b677: "fly5x3f"
		},
		after: { uwmqm3: ["fruq291", "f7x41pl"] },
		before: { z189sj: ["f7x41pl", "fruq291"] }
	}, { d: [
		".f1k6fduh{cursor:pointer;}",
		".f49ad5g{margin-bottom:calc((20px - var(--lineHeightBase300)) / 2);}",
		".f1xlvstr{margin-top:calc((20px - var(--lineHeightBase300)) / 2);}",
		[".f1f5q0n8{padding:var(--spacingVerticalS) var(--spacingHorizontalS);}", { p: -1 }],
		".fy9rknc{font-size:var(--fontSizeBase200);}",
		".fwrc4pm{line-height:var(--lineHeightBase200);}",
		".f1suqah5{margin-bottom:calc((16px - var(--lineHeightBase200)) / 2);}",
		".f26bnac{margin-top:calc((16px - var(--lineHeightBase200)) / 2);}",
		".f1ywm7hm{padding-top:var(--spacingVerticalXS);}",
		".f14wxoun{padding-bottom:var(--spacingVerticalXS);}",
		".fly5x3f{width:100%;}",
		".fruq291{padding-left:var(--spacingHorizontalXS);}",
		".f7x41pl{padding-right:var(--spacingHorizontalXS);}"
	] });
	/**
	* Apply styling to the Switch slots based on the state
	*/
	const useSwitchStyles_unstable = (state) => {
		"use no memo";
		const rootBaseClassName = useRootBaseClassName$8();
		const rootStyles = useRootStyles$15();
		const indicatorBaseClassName = useIndicatorBaseClassName$1();
		const indicatorStyles = useIndicatorStyles$2();
		const inputBaseClassName = useInputBaseClassName$1();
		const inputStyles = useInputStyles$4();
		const labelStyles = useLabelStyles$2();
		const { label, labelPosition, size: size$2 } = state;
		state.root.className = mergeClasses(switchClassNames.root, rootBaseClassName, labelPosition === "above" && rootStyles.vertical, state.root.className);
		state.indicator.className = mergeClasses(switchClassNames.indicator, indicatorBaseClassName, label && labelPosition === "above" && indicatorStyles.labelAbove, size$2 === "small" && indicatorStyles.sizeSmall, state.indicator.className);
		state.input.className = mergeClasses(switchClassNames.input, inputBaseClassName, label && inputStyles[labelPosition], size$2 === "small" && inputStyles.sizeSmall, state.input.className);
		if (state.label) state.label.className = mergeClasses(switchClassNames.label, labelStyles.base, labelStyles[labelPosition], size$2 === "small" && labelStyles.sizeSmall, state.label.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-switch/lib/components/Switch/Switch.js
/**
	* Switches enable users to trigger an option on or off through pressing the component.
	*/ const Switch = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useSwitch_unstable(props, ref);
		useSwitchStyles_unstable(state);
		useCustomStyleHook("useSwitchStyles_unstable")(state);
		return renderSwitch_unstable(state);
	});
	Switch.displayName = "Switch";

//#endregion
//#region node_modules/@fluentui/react-tabs/lib/components/TabList/TabListContext.js
	const tabListContextDefaultValue = {
		appearance: "transparent",
		reserveSelectedTabSpace: true,
		selectTabOnFocus: false,
		disabled: false,
		selectedValue: void 0,
		onRegister: () => {},
		onUnregister: () => {},
		onSelect: () => {},
		getRegisteredTabs: () => {
			return { registeredTabs: {} };
		},
		size: "medium",
		vertical: false
	};
	const TabListContext = createContext(void 0);
	const TabListProvider = TabListContext.Provider;
	const useTabListContext_unstable = (selector) => useContextSelector(TabListContext, (ctx = tabListContextDefaultValue) => selector(ctx));

//#endregion
//#region node_modules/@fluentui/react-tabs/lib/components/Tab/useTab.js
/**
	* Create the state required to render Tab.
	*
	* The returned state can be modified with hooks such as useTabStyles_unstable,
	* before being passed to renderTab_unstable.
	*
	* @param props - props from this instance of Tab
	* @param ref - reference to root HTMLElement of Tab
	*/ const useTab_unstable = (props, ref) => {
		const { content, disabled: tabDisabled = false, icon, onClick, onFocus, value } = props;
		const appearance = useTabListContext_unstable((ctx) => ctx.appearance);
		const reserveSelectedTabSpace = useTabListContext_unstable((ctx) => ctx.reserveSelectedTabSpace);
		const selectTabOnFocus = useTabListContext_unstable((ctx) => ctx.selectTabOnFocus);
		const listDisabled = useTabListContext_unstable((ctx) => ctx.disabled);
		const selected = useTabListContext_unstable((ctx) => ctx.selectedValue === value);
		const onRegister = useTabListContext_unstable((ctx) => ctx.onRegister);
		const onUnregister = useTabListContext_unstable((ctx) => ctx.onUnregister);
		const onSelect = useTabListContext_unstable((ctx) => ctx.onSelect);
		const size$2 = useTabListContext_unstable((ctx) => ctx.size);
		const vertical = useTabListContext_unstable((ctx) => !!ctx.vertical);
		const disabled = listDisabled || tabDisabled;
		const innerRef = react.useRef(null);
		const onSelectCallback = (event) => onSelect(event, { value });
		const onTabClick = useEventCallback(mergeCallbacks(onClick, onSelectCallback));
		const onTabFocus = useEventCallback(mergeCallbacks(onFocus, onSelectCallback));
		const focusProps = useTabsterAttributes({ focusable: { isDefault: selected } });
		react.useEffect(() => {
			onRegister({
				value,
				ref: innerRef
			});
			return () => {
				onUnregister({
					value,
					ref: innerRef
				});
			};
		}, [
			onRegister,
			onUnregister,
			innerRef,
			value
		]);
		const iconSlot = optional(icon, { elementType: "span" });
		const contentSlot = always(content, {
			defaultProps: { children: props.children },
			elementType: "span"
		});
		const contentReservedSpace = content && typeof content === "object" ? omit(content, ["ref"]) : content;
		const iconOnly = Boolean((iconSlot === null || iconSlot === void 0 ? void 0 : iconSlot.children) && !contentSlot.children);
		return {
			components: {
				root: "button",
				icon: "span",
				content: "span",
				contentReservedSpace: "span"
			},
			root: always(getIntrinsicElementProps("button", {
				ref: useMergedRefs(ref, innerRef),
				role: "tab",
				type: "button",
				"aria-selected": disabled ? void 0 : `${selected}`,
				...focusProps,
				...props,
				disabled,
				onClick: onTabClick,
				onFocus: selectTabOnFocus ? onTabFocus : onFocus
			}), { elementType: "button" }),
			icon: iconSlot,
			iconOnly,
			content: contentSlot,
			contentReservedSpace: optional(contentReservedSpace, {
				renderByDefault: !selected && !iconOnly && reserveSelectedTabSpace,
				defaultProps: { children: props.children },
				elementType: "span"
			}),
			appearance,
			disabled,
			selected,
			size: size$2,
			value,
			vertical
		};
	};

//#endregion
//#region node_modules/@fluentui/react-tabs/lib/components/Tab/renderTab.js
/**
	* Render the final JSX of Tab
	*/ const renderTab_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(state.root, { children: [
			state.icon && /* @__PURE__ */ jsx(state.icon, {}),
			!state.iconOnly && /* @__PURE__ */ jsx(state.content, {}),
			state.contentReservedSpace && /* @__PURE__ */ jsx(state.contentReservedSpace, {})
		] });
	};

//#endregion
//#region node_modules/@fluentui/react-tabs/lib/components/Tab/useTabAnimatedIndicator.styles.js
	const tabIndicatorCssVars_unstable = {
		offsetVar: "--fui-Tab__indicator--offset",
		scaleVar: "--fui-Tab__indicator--scale"
	};
	const useActiveIndicatorStyles$1 = /* @__PURE__ */ __styles({
		base: {
			B68tc82: 0,
			Bmxbyg5: 0,
			Bpg54ce: "f1gl81tg"
		},
		animated: {
			Ba2ppi3: "fhwpy7i",
			F2fol1: "f6zz20j",
			B1dyfl9: "f1ai4sc1",
			Bu93a1u: "f1rnm8gg",
			Bdasjez: "f1x3cmqg"
		},
		horizontal: {
			sjv3b2: ["fug4aj8", "f1i5xzg7"],
			b1kco5: "f1q7ujh"
		},
		vertical: {
			sjv3b2: "f1hqboyk",
			b1kco5: "f1dxupa6"
		}
	}, {
		d: [
			[".f1gl81tg{overflow:visible;}", { p: -1 }],
			".fhwpy7i::after{transition-property:transform;}",
			".f6zz20j::after{transition-duration:var(--durationSlow);}",
			".f1ai4sc1::after{transition-timing-function:var(--curveDecelerateMax);}",
			".fug4aj8::after{transform-origin:left;}",
			".f1i5xzg7::after{transform-origin:right;}",
			".f1q7ujh::after{transform:translateX(var(--fui-Tab__indicator--offset)) scaleX(var(--fui-Tab__indicator--scale));}",
			".f1hqboyk::after{transform-origin:top;}",
			".f1dxupa6::after{transform:translateY(var(--fui-Tab__indicator--offset)) scaleY(var(--fui-Tab__indicator--scale));}"
		],
		m: [["@media (prefers-reduced-motion: reduce){.f1rnm8gg::after{transition-property:none;}}", { m: "(prefers-reduced-motion: reduce)" }], ["@media (prefers-reduced-motion: reduce){.f1x3cmqg::after{transition-duration:0.01ms;}}", { m: "(prefers-reduced-motion: reduce)" }]]
	});
	const calculateTabRect = (element) => {
		if (element) {
			var _element_parentElement;
			const parentRect = ((_element_parentElement = element.parentElement) === null || _element_parentElement === void 0 ? void 0 : _element_parentElement.getBoundingClientRect()) || {
				x: 0,
				y: 0,
				width: 0,
				height: 0
			};
			const tabRect = element.getBoundingClientRect();
			return {
				x: tabRect.x - parentRect.x,
				y: tabRect.y - parentRect.y,
				width: tabRect.width,
				height: tabRect.height
			};
		}
	};
	const getRegisteredTabRect = (registeredTabs, value) => {
		var _registeredTabs_JSON_stringify;
		const element = isValueDefined(value) ? (_registeredTabs_JSON_stringify = registeredTabs[JSON.stringify(value)]) === null || _registeredTabs_JSON_stringify === void 0 ? void 0 : _registeredTabs_JSON_stringify.ref.current : void 0;
		return element ? calculateTabRect(element) : void 0;
	};
	const isValueDefined = (value) => value != null;
	/**
	* Adds additional styling to the active tab selection indicator to create a sliding animation.
	*/
	const useTabAnimatedIndicatorStyles_unstable = (state) => {
		const { disabled, selected, vertical } = state;
		const activeIndicatorStyles = useActiveIndicatorStyles$1();
		const [lastAnimatedFrom, setLastAnimatedFrom] = react.useState();
		const [animationValues, setAnimationValues] = react.useState({
			offset: 0,
			scale: 1
		});
		const getRegisteredTabs = useTabListContext_unstable((ctx) => ctx.getRegisteredTabs);
		const [requestAnimationFrame$1] = useAnimationFrame();
		if (selected) {
			const { previousSelectedValue, selectedValue, registeredTabs } = getRegisteredTabs();
			if (isValueDefined(previousSelectedValue) && lastAnimatedFrom !== previousSelectedValue) {
				const previousSelectedTabRect = getRegisteredTabRect(registeredTabs, previousSelectedValue);
				const selectedTabRect = getRegisteredTabRect(registeredTabs, selectedValue);
				if (selectedTabRect && previousSelectedTabRect) {
					setAnimationValues({
						offset: vertical ? previousSelectedTabRect.y - selectedTabRect.y : previousSelectedTabRect.x - selectedTabRect.x,
						scale: vertical ? previousSelectedTabRect.height / selectedTabRect.height : previousSelectedTabRect.width / selectedTabRect.width
					});
					setLastAnimatedFrom(previousSelectedValue);
					requestAnimationFrame$1(() => setAnimationValues({
						offset: 0,
						scale: 1
					}));
				}
			}
		} else if (isValueDefined(lastAnimatedFrom)) setLastAnimatedFrom(void 0);
		if (disabled) return state;
		const animating = animationValues.offset === 0 && animationValues.scale === 1;
		state.root.className = mergeClasses(state.root.className, selected && activeIndicatorStyles.base, selected && animating && activeIndicatorStyles.animated, selected && (vertical ? activeIndicatorStyles.vertical : activeIndicatorStyles.horizontal));
		const rootCssVars = {
			[tabIndicatorCssVars_unstable.offsetVar]: `${animationValues.offset}px`,
			[tabIndicatorCssVars_unstable.scaleVar]: `${animationValues.scale}`
		};
		state.root.style = {
			...rootCssVars,
			...state.root.style
		};
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-tabs/lib/components/Tab/useTabStyles.styles.js
	const tabClassNames = {
		root: "fui-Tab",
		icon: "fui-Tab__icon",
		content: "fui-Tab__content"
	};
	const tabReservedSpaceClassNames = { content: "fui-Tab__content--reserved-space" };
	/**
	* Styles for the root slot
	*/
	const useRootStyles$14 = /* @__PURE__ */ __styles({
		root: {
			Bt984gj: "f122n59",
			mc9l5x: "f13qh94s",
			Bnnss6s: "fi64zpg",
			Bxotwcr: "f1u07yai",
			Budl1dq: "frn2hmy",
			wkccdc: "f1olsevy",
			oeaueh: "f1s6fcnf",
			qhf8xq: "f10pi13n"
		},
		button: {
			Bt984gj: "f122n59",
			Bgfg5da: 0,
			B9xav0g: 0,
			oivjwe: 0,
			Bn0qgzm: 0,
			B4g9neb: 0,
			zhjwy3: 0,
			wvpqe5: 0,
			ibv6hh: 0,
			u1mtju: 0,
			h3c5rm: 0,
			vrafjx: 0,
			Bekrc4i: 0,
			i8vvqc: 0,
			g2u3we: 0,
			icvyot: 0,
			B4j52fo: 0,
			irswps: "f3bhgqh",
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "ft85np5",
			Bceei9c: "f1k6fduh",
			mc9l5x: "f13qh94s",
			Bnnss6s: "fi64zpg",
			Bxotwcr: "f1u07yai",
			Budl1dq: "frn2hmy",
			wkccdc: "f1olsevy",
			Bahqtrf: "fk6fouc",
			Bg96gwp: "f1i3iumi",
			oeaueh: "f1s6fcnf",
			qhf8xq: "f10pi13n",
			B68tc82: 0,
			Bmxbyg5: 0,
			Bpg54ce: "f1a3p1vp",
			B9bfxx9: "f1cxpek8"
		},
		horizontal: { Brf1p80: "f4d9j23" },
		vertical: { Brf1p80: "f1s9ku6b" },
		smallHorizontal: {
			i8kkvl: "f14mj54c",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f1wmopi4"
		},
		smallVertical: {
			i8kkvl: "f14mj54c",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f12or63q"
		},
		mediumHorizontal: {
			i8kkvl: "f1rjii52",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f1w08f2p"
		},
		mediumVertical: {
			i8kkvl: "f1rjii52",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "fymxs25"
		},
		largeHorizontal: {
			i8kkvl: "f1rjii52",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f1ssfvub"
		},
		largeVertical: {
			i8kkvl: "f1rjii52",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "fwkd1rq"
		},
		transparent: {
			De3pzq: "f1c21dwh",
			B95qlz1: "f9rvdkv",
			B7xitij: "f1051ucx",
			Bptxc3x: "fmmjozx",
			Bwqhzpy: "fqhzt5g",
			iyk698: "f7l5cgy",
			cl4aha: "fpkze5g",
			B0q3jbp: "f1iywnoi",
			Be9ayug: "f9n45c4"
		},
		subtle: {
			De3pzq: "fhovq9v",
			B95qlz1: "f1bifk9c",
			B7xitij: "fo6hitd",
			Bptxc3x: "fmmjozx",
			Bwqhzpy: "fqhzt5g",
			iyk698: "f7l5cgy",
			cl4aha: "fpkze5g",
			B0q3jbp: "f1iywnoi",
			Be9ayug: "f9n45c4"
		},
		disabledCursor: { Bceei9c: "fdrzuqr" },
		disabled: {
			De3pzq: "f1c21dwh",
			Bptxc3x: "fato7r6",
			cl4aha: "fao1bnu"
		},
		selected: {
			Bptxc3x: "f1cadz5z",
			Bwqhzpy: "fwhdxxj",
			iyk698: "fintccb",
			cl4aha: "ffplhdr",
			B0q3jbp: "fjo17wb",
			Be9ayug: "f148789c"
		}
	}, { d: [
		".f122n59{align-items:center;}",
		".f13qh94s{display:grid;}",
		".fi64zpg{flex-shrink:0;}",
		".f1u07yai{grid-auto-flow:column;}",
		".frn2hmy{grid-template-columns:auto;}",
		".f1olsevy{grid-template-rows:auto;}",
		".f1s6fcnf{outline-style:none;}",
		".f10pi13n{position:relative;}",
		[".f3bhgqh{border:none;}", { p: -2 }],
		[".ft85np5{border-radius:var(--borderRadiusMedium);}", { p: -1 }],
		".f1k6fduh{cursor:pointer;}",
		".fk6fouc{font-family:var(--fontFamilyBase);}",
		".f1i3iumi{line-height:var(--lineHeightBase300);}",
		[".f1a3p1vp{overflow:hidden;}", { p: -1 }],
		".f1cxpek8{text-transform:none;}",
		".f4d9j23{justify-content:center;}",
		".f1s9ku6b{justify-content:start;}",
		".f14mj54c{column-gap:var(--spacingHorizontalXXS);}",
		[".f1wmopi4{padding:var(--spacingVerticalSNudge) var(--spacingHorizontalSNudge);}", { p: -1 }],
		[".f12or63q{padding:var(--spacingVerticalXXS) var(--spacingHorizontalSNudge);}", { p: -1 }],
		".f1rjii52{column-gap:var(--spacingHorizontalSNudge);}",
		[".f1w08f2p{padding:var(--spacingVerticalM) var(--spacingHorizontalMNudge);}", { p: -1 }],
		[".fymxs25{padding:var(--spacingVerticalSNudge) var(--spacingHorizontalMNudge);}", { p: -1 }],
		[".f1ssfvub{padding:var(--spacingVerticalL) var(--spacingHorizontalMNudge);}", { p: -1 }],
		[".fwkd1rq{padding:var(--spacingVerticalS) var(--spacingHorizontalMNudge);}", { p: -1 }],
		".f1c21dwh{background-color:var(--colorTransparentBackground);}",
		".f9rvdkv:enabled:hover{background-color:var(--colorTransparentBackgroundHover);}",
		".f1051ucx:enabled:active{background-color:var(--colorTransparentBackgroundPressed);}",
		".fmmjozx .fui-Tab__icon{color:var(--colorNeutralForeground2);}",
		".fqhzt5g:enabled:hover .fui-Tab__icon{color:var(--colorNeutralForeground2Hover);}",
		".f7l5cgy:enabled:active .fui-Tab__icon{color:var(--colorNeutralForeground2Pressed);}",
		".fpkze5g .fui-Tab__content{color:var(--colorNeutralForeground2);}",
		".f1iywnoi:enabled:hover .fui-Tab__content{color:var(--colorNeutralForeground2Hover);}",
		".f9n45c4:enabled:active .fui-Tab__content{color:var(--colorNeutralForeground2Pressed);}",
		".fhovq9v{background-color:var(--colorSubtleBackground);}",
		".f1bifk9c:enabled:hover{background-color:var(--colorSubtleBackgroundHover);}",
		".fo6hitd:enabled:active{background-color:var(--colorSubtleBackgroundPressed);}",
		".fdrzuqr{cursor:not-allowed;}",
		".fato7r6 .fui-Tab__icon{color:var(--colorNeutralForegroundDisabled);}",
		".fao1bnu .fui-Tab__content{color:var(--colorNeutralForegroundDisabled);}",
		".f1cadz5z .fui-Tab__icon{color:var(--colorCompoundBrandForeground1);}",
		".fwhdxxj:enabled:hover .fui-Tab__icon{color:var(--colorCompoundBrandForeground1Hover);}",
		".fintccb:enabled:active .fui-Tab__icon{color:var(--colorCompoundBrandForeground1Pressed);}",
		".ffplhdr .fui-Tab__content{color:var(--colorNeutralForeground1);}",
		".fjo17wb:enabled:hover .fui-Tab__content{color:var(--colorNeutralForeground1Hover);}",
		".f148789c:enabled:active .fui-Tab__content{color:var(--colorNeutralForeground1Pressed);}"
	] });
	const useCircularAppearanceStyles = /* @__PURE__ */ __styles({
		base: {
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "f44lkw9",
			Bgfg5da: 0,
			B9xav0g: 0,
			oivjwe: 0,
			Bn0qgzm: 0,
			B4g9neb: 0,
			zhjwy3: 0,
			wvpqe5: 0,
			ibv6hh: 0,
			u1mtju: 0,
			h3c5rm: 0,
			vrafjx: 0,
			Bekrc4i: 0,
			i8vvqc: 0,
			g2u3we: 0,
			icvyot: 0,
			B4j52fo: 0,
			irswps: "fp7rvkm",
			Bptxc3x: "ftorr8m",
			cl4aha: "f16lqpmv"
		},
		small: {
			Dbcxam: 0,
			rjzwhg: 0,
			Bblux5w: "fzklhed"
		},
		medium: {
			Dbcxam: 0,
			rjzwhg: 0,
			Bblux5w: "f1j721cc"
		},
		large: {
			Dbcxam: 0,
			rjzwhg: 0,
			Bblux5w: "frx9knr"
		},
		subtle: {
			De3pzq: "fhovq9v",
			sj55zd: "fkfq4zb",
			B95qlz1: "f1bifk9c",
			Eo63ln: 0,
			r9osk6: 0,
			Itrz8y: 0,
			zeg6vx: 0,
			l65xgk: 0,
			Bw4olcx: 0,
			Folb0i: 0,
			I2h8y4: 0,
			Bgxgoyi: 0,
			Bvlkotb: 0,
			Fwyncl: 0,
			Byh5edv: 0,
			Becqvjq: 0,
			uumbiq: 0,
			B73q3dg: 0,
			Bblwbaf: 0,
			B0ezav: "ft57sj0",
			r4wkhp: "f1fcoy83",
			B7xitij: "fo6hitd",
			d3wsvi: 0,
			Hdqn7s: 0,
			zu5y1p: 0,
			owqphb: 0,
			g9c53k: 0,
			Btmu08z: 0,
			Bthxvy6: 0,
			gluvuq: 0,
			tb88gp: 0,
			wns6jk: 0,
			kdfdk4: 0,
			Bbw008l: 0,
			Bayi1ib: 0,
			B1kkfu3: 0,
			J1oqyp: 0,
			kem6az: 0,
			goa3yj: "fhn220o",
			p743kt: "f15qf7sh",
			wmvzou: 0,
			sc4o1m: 0,
			wymq9i: 0,
			u9orzk: 0,
			puiv5t: 0,
			Bosien3: 0,
			b2z72d: 0,
			Beulxaw: 0,
			B57pkaw: 0,
			Jcjdmf: 0,
			B8qgbzl: 0,
			Bbmb0sr: 0,
			B14q8qp: 0,
			Bcq6wej: 0,
			Byz1pjr: 0,
			kr9cjb: 0,
			Ff9ifp: "f1mljprk"
		},
		subtleSelected: {
			De3pzq: "f16xkysk",
			Bgfg5da: 0,
			B9xav0g: 0,
			oivjwe: 0,
			Bn0qgzm: 0,
			B4g9neb: 0,
			zhjwy3: 0,
			wvpqe5: 0,
			ibv6hh: 0,
			u1mtju: 0,
			h3c5rm: 0,
			vrafjx: 0,
			Bekrc4i: 0,
			i8vvqc: 0,
			g2u3we: 0,
			icvyot: 0,
			B4j52fo: 0,
			irswps: "f1c2pc3t",
			sj55zd: "faj9fo0",
			B95qlz1: "fsm7zmf",
			Eo63ln: 0,
			r9osk6: 0,
			Itrz8y: 0,
			zeg6vx: 0,
			l65xgk: 0,
			Bw4olcx: 0,
			Folb0i: 0,
			I2h8y4: 0,
			Bgxgoyi: 0,
			Bvlkotb: 0,
			Fwyncl: 0,
			Byh5edv: 0,
			Becqvjq: 0,
			uumbiq: 0,
			B73q3dg: 0,
			Bblwbaf: 0,
			B0ezav: "f1wo0sfq",
			r4wkhp: "f1afuynh",
			B7xitij: "f94ddyl",
			d3wsvi: 0,
			Hdqn7s: 0,
			zu5y1p: 0,
			owqphb: 0,
			g9c53k: 0,
			Btmu08z: 0,
			Bthxvy6: 0,
			gluvuq: 0,
			tb88gp: 0,
			wns6jk: 0,
			kdfdk4: 0,
			Bbw008l: 0,
			Bayi1ib: 0,
			B1kkfu3: 0,
			J1oqyp: 0,
			kem6az: 0,
			goa3yj: "fmle6oo",
			p743kt: "f1d3itm4",
			wmvzou: 0,
			sc4o1m: 0,
			wymq9i: 0,
			u9orzk: 0,
			puiv5t: 0,
			Bosien3: 0,
			b2z72d: 0,
			Beulxaw: 0,
			B57pkaw: 0,
			Jcjdmf: 0,
			B8qgbzl: 0,
			Bbmb0sr: 0,
			B14q8qp: 0,
			Bcq6wej: 0,
			Byz1pjr: 0,
			kr9cjb: 0,
			Ff9ifp: "f1e9l2u"
		},
		subtleDisabled: {
			De3pzq: "fhovq9v",
			sj55zd: "f1s2aq7o"
		},
		subtleDisabledSelected: {
			De3pzq: "f1bg9a2p",
			Bgfg5da: 0,
			B9xav0g: 0,
			oivjwe: 0,
			Bn0qgzm: 0,
			B4g9neb: 0,
			zhjwy3: 0,
			wvpqe5: 0,
			ibv6hh: 0,
			u1mtju: 0,
			h3c5rm: 0,
			vrafjx: 0,
			Bekrc4i: 0,
			i8vvqc: 0,
			g2u3we: 0,
			icvyot: 0,
			B4j52fo: 0,
			irswps: "fegtqic",
			sj55zd: "f1s2aq7o"
		},
		filled: {
			De3pzq: "f16xq7d1",
			sj55zd: "fkfq4zb",
			B95qlz1: "fwwxidx",
			r4wkhp: "f1fcoy83",
			B7xitij: "f14i52sd",
			p743kt: "f15qf7sh",
			Hhssn: "f1cpi5f4",
			uaurb9: "f6pj1s0",
			B401qx7: "f12sz5kj",
			Buyp1jb: "f17588c3",
			gsp74p: "fnthgdt"
		},
		filledSelected: {
			De3pzq: "ffp7eso",
			sj55zd: "f1phragk",
			B95qlz1: "f1lm9dni",
			r4wkhp: "f1mn5ei1",
			B7xitij: "f1g6ncd0",
			p743kt: "fl71aob",
			Gedr8k: "f14zl92z",
			Bm69vlq: "f16zy3eu",
			Bodipah: "f1gdgb7p",
			B5kpen0: "f1tua9ng"
		},
		filledDisabled: {
			De3pzq: "f1bg9a2p",
			sj55zd: "f1s2aq7o"
		},
		filledDisabledSelected: {
			De3pzq: "f1bg9a2p",
			Bgfg5da: 0,
			B9xav0g: 0,
			oivjwe: 0,
			Bn0qgzm: 0,
			B4g9neb: 0,
			zhjwy3: 0,
			wvpqe5: 0,
			ibv6hh: 0,
			u1mtju: 0,
			h3c5rm: 0,
			vrafjx: 0,
			Bekrc4i: 0,
			i8vvqc: 0,
			g2u3we: 0,
			icvyot: 0,
			B4j52fo: 0,
			irswps: "fegtqic",
			sj55zd: "f1s2aq7o"
		}
	}, {
		d: [
			[".f44lkw9{border-radius:var(--borderRadiusCircular);}", { p: -1 }],
			[".fp7rvkm{border:solid var(--strokeWidthThin) var(--colorTransparentStroke);}", { p: -2 }],
			".ftorr8m .fui-Tab__icon{color:inherit;}",
			".f16lqpmv .fui-Tab__content{color:inherit;}",
			[".fzklhed{padding-block:calc(var(--spacingVerticalXXS) - var(--strokeWidthThin));}", { p: -1 }],
			[".f1j721cc{padding-block:calc(var(--spacingVerticalSNudge) - var(--strokeWidthThin));}", { p: -1 }],
			[".frx9knr{padding-block:calc(var(--spacingVerticalS) - var(--strokeWidthThin));}", { p: -1 }],
			".fhovq9v{background-color:var(--colorSubtleBackground);}",
			".fkfq4zb{color:var(--colorNeutralForeground2);}",
			".f1bifk9c:enabled:hover{background-color:var(--colorSubtleBackgroundHover);}",
			[".ft57sj0:enabled:hover{border:solid var(--strokeWidthThin) var(--colorNeutralStroke1Hover);}", { p: -2 }],
			".f1fcoy83:enabled:hover{color:var(--colorNeutralForeground2Hover);}",
			".fo6hitd:enabled:active{background-color:var(--colorSubtleBackgroundPressed);}",
			[".fhn220o:enabled:active{border:solid var(--strokeWidthThin) var(--colorNeutralStroke1Pressed);}", { p: -2 }],
			".f15qf7sh:enabled:active{color:var(--colorNeutralForeground2Pressed);}",
			".f16xkysk{background-color:var(--colorBrandBackground2);}",
			[".f1c2pc3t{border:solid var(--strokeWidthThin) var(--colorCompoundBrandStroke);}", { p: -2 }],
			".faj9fo0{color:var(--colorBrandForeground2);}",
			".fsm7zmf:enabled:hover{background-color:var(--colorBrandBackground2Hover);}",
			[".f1wo0sfq:enabled:hover{border:solid var(--strokeWidthThin) var(--colorCompoundBrandStrokeHover);}", { p: -2 }],
			".f1afuynh:enabled:hover{color:var(--colorBrandForeground2Hover);}",
			".f94ddyl:enabled:active{background-color:var(--colorBrandBackground2Pressed);}",
			[".fmle6oo:enabled:active{border:solid var(--strokeWidthThin) var(--colorCompoundBrandStrokePressed);}", { p: -2 }],
			".f1d3itm4:enabled:active{color:var(--colorBrandForeground2Pressed);}",
			".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}",
			".f1bg9a2p{background-color:var(--colorNeutralBackgroundDisabled);}",
			[".fegtqic{border:solid var(--strokeWidthThin) var(--colorNeutralStrokeDisabled);}", { p: -2 }],
			".f16xq7d1{background-color:var(--colorNeutralBackground3);}",
			".fwwxidx:enabled:hover{background-color:var(--colorNeutralBackground3Hover);}",
			".f14i52sd:enabled:active{background-color:var(--colorNeutralBackground3Pressed);}",
			".ffp7eso{background-color:var(--colorBrandBackground);}",
			".f1phragk{color:var(--colorNeutralForegroundOnBrand);}",
			".f1lm9dni:enabled:hover{background-color:var(--colorBrandBackgroundHover);}",
			".f1mn5ei1:enabled:hover{color:var(--colorNeutralForegroundOnBrand);}",
			".f1g6ncd0:enabled:active{background-color:var(--colorBrandBackgroundPressed);}",
			".fl71aob:enabled:active{color:var(--colorNeutralForegroundOnBrand);}",
			[".fegtqic{border:solid var(--strokeWidthThin) var(--colorNeutralStrokeDisabled);}", { p: -2 }]
		],
		m: [
			["@media (forced-colors: active){.f1mljprk{border:solid var(--strokeWidthThin) Canvas;}}", {
				p: -2,
				m: "(forced-colors: active)"
			}],
			["@media (forced-colors: active){.f1e9l2u{border:solid var(--strokeWidthThin) Highlight;}}", {
				p: -2,
				m: "(forced-colors: active)"
			}],
			["@media (forced-colors: active){.f1cpi5f4:enabled:hover{background-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f6pj1s0:enabled:hover{forced-color-adjust:none;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f12sz5kj:enabled:hover .fui-Tab__content{color:HighlightText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f17588c3:enabled:hover .fui-Icon-filled{color:HighlightText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fnthgdt:enabled:hover .fui-Icon-regular{color:HighlightText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f14zl92z:enabled{background-color:ButtonText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f16zy3eu:enabled .fui-Tab__content{color:ButtonFace;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1gdgb7p:enabled .fui-Tab__content{forced-color-adjust:none;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1tua9ng:enabled .fui-Tab__icon{color:ButtonFace;}}", { m: "(forced-colors: active)" }]
		]
	});
	/**
	* Focus styles for the root slot
	*/
	const useFocusStyles = /* @__PURE__ */ __styles({
		base: {
			B8q5s1w: "f8hki3x",
			Bci5o5g: ["f1d2448m", "ffh67wi"],
			n8qw10: "f1bjia2o",
			Bdrgwmp: ["ffh67wi", "f1d2448m"],
			Bn4voq9: "f1p7hgxw",
			Bfpq7zp: "f1way5bb",
			g9k6zt: "f9znhxp",
			j6ew2k: ["fqa318h", "fqa318h"],
			Bhxq17a: "f1vjpng2"
		},
		circular: {
			B8q5s1w: "f8hki3x",
			Bci5o5g: ["f1d2448m", "ffh67wi"],
			n8qw10: "f1bjia2o",
			Bdrgwmp: ["ffh67wi", "f1d2448m"],
			Bn4voq9: "f1p7hgxw",
			Bfpq7zp: "f1way5bb",
			g9k6zt: "f9znhxp",
			j6ew2k: ["fzgyhws", "fqxug60"],
			Bhxq17a: "f1vjpng2"
		}
	}, { d: [
		".f8hki3x[data-fui-focus-visible]{border-top-color:transparent;}",
		".f1d2448m[data-fui-focus-visible]{border-right-color:transparent;}",
		".ffh67wi[data-fui-focus-visible]{border-left-color:transparent;}",
		".f1bjia2o[data-fui-focus-visible]{border-bottom-color:transparent;}",
		".f1p7hgxw[data-fui-focus-visible]{outline-width:var(--strokeWidthThick);}",
		".f1way5bb[data-fui-focus-visible]{outline-color:transparent;}",
		".f9znhxp[data-fui-focus-visible]{outline-style:solid;}",
		".fqa318h[data-fui-focus-visible]{box-shadow:var(--shadow4),0 0 0 var(--strokeWidthThick) var(--colorStrokeFocus2);}",
		".f1vjpng2[data-fui-focus-visible]{z-index:1;}",
		".fzgyhws[data-fui-focus-visible]{box-shadow:var(--shadow4),0 0 0 var(--strokeWidthThick) var(--colorStrokeFocus2),0 0 0 var(--strokeWidthThin) var(--colorNeutralStrokeOnBrand) inset;}",
		".fqxug60[data-fui-focus-visible]{box-shadow:var(--shadow4),0 0 0 var(--strokeWidthThick) var(--colorStrokeFocus2),0 0 0 var(--strokeWidthThin) var(--colorNeutralStrokeOnBrand) inset;}"
	] });
	/** Indicator styles for when pending selection */
	const usePendingIndicatorStyles = /* @__PURE__ */ __styles({
		base: {
			az7l2e: "fhw179n",
			vqofr: 0,
			Bv4n3vi: 0,
			Bgqb9hq: 0,
			B0uxbk8: 0,
			Bf3jju6: "fg9j5n4",
			amg5m6: "f1kmhr4c",
			zkfqfm: "fl1ydde",
			Bkydozb: "f1y7maxz",
			Bka2azo: 0,
			vzq8l0: 0,
			csmgbd: 0,
			Br4ovkg: 0,
			aelrif: "fceyvr4",
			y36c18: "f16cxu0",
			B1ctymy: "f1nwgacf",
			xzc5d: "fm6alxz",
			h5yqg8: "fhx32z1"
		},
		disabled: {
			az7l2e: "f1ut20fw",
			Bkydozb: "fhrzcfn",
			xzc5d: "fw15awd",
			h5yqg8: "faqmq51"
		},
		smallHorizontal: {
			lawp4y: "fchca7p",
			Baz25je: "f1r53b5e",
			Fbdkly: ["f1s6rxz5", "fo35v8s"],
			mdwyqc: ["fo35v8s", "f1s6rxz5"]
		},
		smallVertical: {
			lawp4y: "fze4zud",
			Fbdkly: ["f1fzr1x6", "f1f351id"],
			Bciustq: "fdp32p8",
			Ccq8qp: "f1aij3q"
		},
		mediumHorizontal: {
			lawp4y: "fchca7p",
			Baz25je: "f1s2r9ax",
			Fbdkly: ["f1o0nnkk", "fxb7rol"],
			mdwyqc: ["fxb7rol", "f1o0nnkk"]
		},
		mediumVertical: {
			lawp4y: "f17jracn",
			Fbdkly: ["f1fzr1x6", "f1f351id"],
			Bciustq: "f117lcb2",
			Ccq8qp: "f1aij3q"
		},
		largeHorizontal: {
			lawp4y: "fchca7p",
			Baz25je: "f1s2r9ax",
			Fbdkly: ["f1o0nnkk", "fxb7rol"],
			mdwyqc: ["fxb7rol", "f1o0nnkk"]
		},
		largeVertical: {
			lawp4y: "fel9d3z",
			Fbdkly: ["f1fzr1x6", "f1f351id"],
			Bciustq: "f6vqlre",
			Ccq8qp: "f1aij3q"
		}
	}, {
		h: [
			".fhw179n:hover::before{background-color:var(--colorNeutralStroke1Hover);}",
			[".fg9j5n4:hover::before{border-radius:var(--borderRadiusCircular);}", { p: -1 }],
			".f1kmhr4c:hover::before{content:\"\";}",
			".fl1ydde:hover::before{position:absolute;}",
			".f1ut20fw:hover::before{background-color:var(--colorTransparentStroke);}"
		],
		a: [
			".f1y7maxz:active::before{background-color:var(--colorNeutralStroke1Pressed);}",
			[".fceyvr4:active::before{border-radius:var(--borderRadiusCircular);}", { p: -1 }],
			".f16cxu0:active::before{content:\"\";}",
			".f1nwgacf:active::before{position:absolute;}",
			".fhrzcfn:active::before{background-color:var(--colorTransparentStroke);}"
		],
		m: [
			["@media (forced-colors: active){.fm6alxz:hover::before{background-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fhx32z1:active::before{background-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fw15awd:hover::before{background-color:transparent;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.faqmq51:active::before{background-color:transparent;}}", { m: "(forced-colors: active)" }]
		],
		d: [
			".fchca7p::before{bottom:0;}",
			".f1r53b5e::before{height:var(--strokeWidthThick);}",
			".f1s6rxz5::before{left:var(--spacingHorizontalSNudge);}",
			".fo35v8s::before{right:var(--spacingHorizontalSNudge);}",
			".fze4zud::before{bottom:var(--spacingVerticalXS);}",
			".f1fzr1x6::before{left:0;}",
			".f1f351id::before{right:0;}",
			".fdp32p8::before{top:var(--spacingVerticalXS);}",
			".f1aij3q::before{width:var(--strokeWidthThicker);}",
			".f1s2r9ax::before{height:var(--strokeWidthThicker);}",
			".f1o0nnkk::before{left:var(--spacingHorizontalM);}",
			".fxb7rol::before{right:var(--spacingHorizontalM);}",
			".f17jracn::before{bottom:var(--spacingVerticalS);}",
			".f117lcb2::before{top:var(--spacingVerticalS);}",
			".fel9d3z::before{bottom:var(--spacingVerticalMNudge);}",
			".f6vqlre::before{top:var(--spacingVerticalMNudge);}"
		]
	});
	const useActiveIndicatorStyles = /* @__PURE__ */ __styles({
		base: {
			Bjyk6c5: "f1rp0jgh",
			d9w3h3: 0,
			B3778ie: 0,
			B4j8arr: 0,
			Bl18szs: 0,
			Blrzh8d: "f3b9emi",
			Bsft5z2: "f13zj6fq",
			E3zdtr: "f1mdlcz9"
		},
		selected: {
			Bjyk6c5: "f1ksivud",
			Bej4dhw: "f1476jrx",
			B7wqxwa: "f18q216b",
			Hwb57: "f1wf6u82",
			Beg08s0: "f1xwit7m",
			Bo27r1v: "f1ksfgwi"
		},
		disabled: { Bjyk6c5: "f13lkzet" },
		smallHorizontal: {
			By385i5: "fo72kxq",
			Dlnsje: "f9bb2ob",
			Eqx8gd: ["f1q70ajw", "f18rbzdx"],
			B1piin3: ["f18rbzdx", "f1q70ajw"]
		},
		smallVertical: {
			By385i5: "fqbue9b",
			Eqx8gd: ["f1n6gb5g", "f15yvnhg"],
			bn5sak: "fk1klkt",
			a2br6o: "f1o25lip"
		},
		mediumHorizontal: {
			By385i5: "fo72kxq",
			Dlnsje: "f1vx7lu8",
			Eqx8gd: ["fna7m5n", "f1oxpfwv"],
			B1piin3: ["f1oxpfwv", "fna7m5n"]
		},
		mediumVertical: {
			By385i5: "fipylg0",
			Eqx8gd: ["f1n6gb5g", "f15yvnhg"],
			bn5sak: "fqchiol",
			a2br6o: "f1o25lip"
		},
		largeHorizontal: {
			By385i5: "fo72kxq",
			Dlnsje: "f1vx7lu8",
			Eqx8gd: ["fna7m5n", "f1oxpfwv"],
			B1piin3: ["f1oxpfwv", "fna7m5n"]
		},
		largeVertical: {
			By385i5: "f1w7dm5g",
			Eqx8gd: ["f1n6gb5g", "f15yvnhg"],
			bn5sak: "f1p6em4m",
			a2br6o: "f1o25lip"
		}
	}, {
		d: [
			".f1rp0jgh::after{background-color:var(--colorTransparentStroke);}",
			[".f3b9emi::after{border-radius:var(--borderRadiusCircular);}", { p: -1 }],
			".f13zj6fq::after{content:\"\";}",
			".f1mdlcz9::after{position:absolute;}",
			".f1ksivud::after{background-color:var(--colorCompoundBrandStroke);}",
			".f1476jrx:enabled:hover::after{background-color:var(--colorCompoundBrandStrokeHover);}",
			".f18q216b:enabled:active::after{background-color:var(--colorCompoundBrandStrokePressed);}",
			".f13lkzet::after{background-color:var(--colorNeutralForegroundDisabled);}",
			".fo72kxq::after{bottom:0;}",
			".f9bb2ob::after{height:var(--strokeWidthThick);}",
			".f1q70ajw::after{left:var(--spacingHorizontalSNudge);}",
			".f18rbzdx::after{right:var(--spacingHorizontalSNudge);}",
			".fqbue9b::after{bottom:var(--spacingVerticalXS);}",
			".f1n6gb5g::after{left:0;}",
			".f15yvnhg::after{right:0;}",
			".fk1klkt::after{top:var(--spacingVerticalXS);}",
			".f1o25lip::after{width:var(--strokeWidthThicker);}",
			".f1vx7lu8::after{height:var(--strokeWidthThicker);}",
			".fna7m5n::after{left:var(--spacingHorizontalM);}",
			".f1oxpfwv::after{right:var(--spacingHorizontalM);}",
			".fipylg0::after{bottom:var(--spacingVerticalS);}",
			".fqchiol::after{top:var(--spacingVerticalS);}",
			".f1w7dm5g::after{bottom:var(--spacingVerticalMNudge);}",
			".f1p6em4m::after{top:var(--spacingVerticalMNudge);}"
		],
		m: [
			["@media (forced-colors: active){.f1wf6u82::after{background-color:ButtonText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1xwit7m:enabled:hover::after{background-color:ButtonText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1ksfgwi:enabled:active::after{background-color:ButtonText;}}", { m: "(forced-colors: active)" }]
		]
	});
	/**
	* Styles for the icon slot.
	*/
	const useIconStyles$6 = /* @__PURE__ */ __styles({
		base: {
			Br312pm: "fwpfdsa",
			Ijaq50: "f16hsg94",
			Bt984gj: "f122n59",
			mc9l5x: "ftuwxu6",
			Brf1p80: "f4d9j23",
			B68tc82: 0,
			Bmxbyg5: 0,
			Bpg54ce: "f1a3p1vp",
			D0sxk3: "f16u1re",
			t6yez3: "f8bsbmo"
		},
		small: {
			Be2twd7: "fe5j1ua",
			Bqenvij: "fjamq6b",
			a9b677: "f64fuq3"
		},
		medium: {
			Be2twd7: "fe5j1ua",
			Bqenvij: "fjamq6b",
			a9b677: "f64fuq3"
		},
		large: {
			Be2twd7: "f1rt2boy",
			Bqenvij: "frvgh55",
			a9b677: "fq4mcun"
		},
		selected: {
			D0sxk3: "fxoiby5",
			t6yez3: "f15q0o9g"
		}
	}, { d: [
		".fwpfdsa{grid-column-start:1;}",
		".f16hsg94{grid-row-start:1;}",
		".f122n59{align-items:center;}",
		".ftuwxu6{display:inline-flex;}",
		".f4d9j23{justify-content:center;}",
		[".f1a3p1vp{overflow:hidden;}", { p: -1 }],
		".f16u1re .fui-Icon-filled{display:none;}",
		".f8bsbmo .fui-Icon-regular{display:inline;}",
		".fe5j1ua{font-size:20px;}",
		".fjamq6b{height:20px;}",
		".f64fuq3{width:20px;}",
		".f1rt2boy{font-size:24px;}",
		".frvgh55{height:24px;}",
		".fq4mcun{width:24px;}",
		".fxoiby5 .fui-Icon-filled{display:inline;}",
		".f15q0o9g .fui-Icon-regular{display:none;}"
	] });
	/**
	* Styles for the content slot (children)
	*/
	const useContentStyles$1 = /* @__PURE__ */ __styles({
		base: {
			Bahqtrf: "fk6fouc",
			Be2twd7: "fkhj508",
			Bhrd7zp: "figsok6",
			Bg96gwp: "f1i3iumi",
			B68tc82: 0,
			Bmxbyg5: 0,
			Bpg54ce: "f1a3p1vp",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f1bwptpd"
		},
		selected: {
			Bahqtrf: "fk6fouc",
			Be2twd7: "fkhj508",
			Bhrd7zp: "fl43uef",
			Bg96gwp: "f1i3iumi"
		},
		large: {
			Bahqtrf: "fk6fouc",
			Be2twd7: "fod5ikn",
			Bhrd7zp: "figsok6",
			Bg96gwp: "faaz57k"
		},
		largeSelected: {
			Bahqtrf: "fk6fouc",
			Be2twd7: "fod5ikn",
			Bhrd7zp: "fl43uef",
			Bg96gwp: "faaz57k"
		},
		noIconBefore: {
			Br312pm: "fwpfdsa",
			Ijaq50: "f16hsg94"
		},
		iconBefore: {
			Br312pm: "fd46tj4",
			Ijaq50: "f16hsg94"
		},
		placeholder: { Bcdw1i0: "fd7fpy0" }
	}, { d: [
		".fk6fouc{font-family:var(--fontFamilyBase);}",
		".fkhj508{font-size:var(--fontSizeBase300);}",
		".figsok6{font-weight:var(--fontWeightRegular);}",
		".f1i3iumi{line-height:var(--lineHeightBase300);}",
		[".f1a3p1vp{overflow:hidden;}", { p: -1 }],
		[".f1bwptpd{padding:var(--spacingVerticalNone) var(--spacingHorizontalXXS);}", { p: -1 }],
		".fl43uef{font-weight:var(--fontWeightSemibold);}",
		".fod5ikn{font-size:var(--fontSizeBase400);}",
		".faaz57k{line-height:var(--lineHeightBase400);}",
		".fwpfdsa{grid-column-start:1;}",
		".f16hsg94{grid-row-start:1;}",
		".fd46tj4{grid-column-start:2;}",
		".fd7fpy0{visibility:hidden;}"
	] });
	/**
	* Apply styling to the Tab slots based on the state
	*/
	const useTabStyles_unstable = (state) => {
		"use no memo";
		useTabIndicatorStyles_unstable(state);
		useTabButtonStyles_unstable(state, state.root);
		useTabContentStyles_unstable(state);
		return state;
	};
	/**
	* Applies styles for the Tab indicator based on its current state.
	*
	* This hook is typically used internally by `useTabStyles_unstable`. You should
	* only use it directly if you're creating a custom `Tab` component.
	*
	* @param state - The `Tab` component's current state
	* @returns The state object with updated button styles
	*/
	const useTabIndicatorStyles_unstable = (state) => {
		"use no memo";
		const rootStyles = useRootStyles$14();
		const pendingIndicatorStyles = usePendingIndicatorStyles();
		const activeIndicatorStyles = useActiveIndicatorStyles();
		const { appearance, disabled, selected, size: size$2, vertical } = state;
		const classes = [tabClassNames.root, rootStyles.root];
		if (appearance !== "subtle-circular" && appearance !== "filled-circular") classes.push(pendingIndicatorStyles.base, size$2 === "small" && (vertical ? pendingIndicatorStyles.smallVertical : pendingIndicatorStyles.smallHorizontal), size$2 === "medium" && (vertical ? pendingIndicatorStyles.mediumVertical : pendingIndicatorStyles.mediumHorizontal), size$2 === "large" && (vertical ? pendingIndicatorStyles.largeVertical : pendingIndicatorStyles.largeHorizontal), disabled && pendingIndicatorStyles.disabled, selected && activeIndicatorStyles.base, selected && !disabled && activeIndicatorStyles.selected, selected && size$2 === "small" && (vertical ? activeIndicatorStyles.smallVertical : activeIndicatorStyles.smallHorizontal), selected && size$2 === "medium" && (vertical ? activeIndicatorStyles.mediumVertical : activeIndicatorStyles.mediumHorizontal), selected && size$2 === "large" && (vertical ? activeIndicatorStyles.largeVertical : activeIndicatorStyles.largeHorizontal), selected && disabled && activeIndicatorStyles.disabled);
		state.root.className = mergeClasses(...classes, state.root.className);
		useTabAnimatedIndicatorStyles_unstable(state);
		return state;
	};
	/**
	* Applies styles to the Tab button slot based on its current state.
	*
	* This hook is typically used internally by `useTabStyles_unstable`. You should
	* only use it directly if you're creating a custom `Tab` component.
	*
	* @param state - The Tab component's current state
	* @param slot - The button slot of the Tab component
	* @returns The state object with updated button styles
	*/
	const useTabButtonStyles_unstable = (state, slot) => {
		"use no memo";
		const rootStyles = useRootStyles$14();
		const focusStyles = useFocusStyles();
		const circularStyles = useCircularAppearanceStyles();
		const { appearance, disabled, selected, size: size$2, vertical } = state;
		const isSubtleCircular = appearance === "subtle-circular";
		const isFilledCircular = appearance === "filled-circular";
		const isCircular = isSubtleCircular || isFilledCircular;
		const circularAppearance = [
			circularStyles.base,
			focusStyles.circular,
			size$2 === "small" && circularStyles.small,
			size$2 === "medium" && circularStyles.medium,
			size$2 === "large" && circularStyles.large,
			isSubtleCircular && circularStyles.subtle,
			selected && isSubtleCircular && circularStyles.subtleSelected,
			disabled && isSubtleCircular && circularStyles.subtleDisabled,
			selected && disabled && isSubtleCircular && circularStyles.subtleDisabledSelected,
			isFilledCircular && circularStyles.filled,
			selected && isFilledCircular && circularStyles.filledSelected,
			disabled && isFilledCircular && circularStyles.filledDisabled,
			selected && disabled && isFilledCircular && circularStyles.filledDisabledSelected
		];
		const regularAppearance = [
			focusStyles.base,
			!disabled && appearance === "subtle" && rootStyles.subtle,
			!disabled && appearance === "transparent" && rootStyles.transparent,
			!disabled && selected && rootStyles.selected,
			disabled && rootStyles.disabled
		];
		slot.className = mergeClasses(rootStyles.button, vertical ? rootStyles.vertical : rootStyles.horizontal, size$2 === "small" && (vertical ? rootStyles.smallVertical : rootStyles.smallHorizontal), size$2 === "medium" && (vertical ? rootStyles.mediumVertical : rootStyles.mediumHorizontal), size$2 === "large" && (vertical ? rootStyles.largeVertical : rootStyles.largeHorizontal), ...isCircular ? circularAppearance : regularAppearance, disabled && rootStyles.disabledCursor, slot.className);
		return state;
	};
	/**
	* Applies styles to the Tab content slot based on its current state.
	*
	* This hook is typically used internally by `useTabStyles_unstable`. You should
	* only use it directly if you're creating a custom `Tab` component.
	*
	* @param state - The Tab component's current state
	* @returns The state object with updated content styles
	*/
	const useTabContentStyles_unstable = (state) => {
		"use no memo";
		const iconStyles = useIconStyles$6();
		const contentStyles = useContentStyles$1();
		const { selected, size: size$2 } = state;
		if (state.icon) state.icon.className = mergeClasses(tabClassNames.icon, iconStyles.base, iconStyles[size$2], selected && iconStyles.selected, state.icon.className);
		if (state.contentReservedSpace) {
			state.contentReservedSpace.className = mergeClasses(tabReservedSpaceClassNames.content, contentStyles.base, size$2 === "large" ? contentStyles.largeSelected : contentStyles.selected, state.icon ? contentStyles.iconBefore : contentStyles.noIconBefore, contentStyles.placeholder, state.content.className);
			state.contentReservedSpaceClassName = state.contentReservedSpace.className;
		}
		state.content.className = mergeClasses(tabClassNames.content, contentStyles.base, size$2 === "large" && contentStyles.large, selected && (size$2 === "large" ? contentStyles.largeSelected : contentStyles.selected), state.icon ? contentStyles.iconBefore : contentStyles.noIconBefore, state.content.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-tabs/lib/components/Tab/Tab.js
/**
	* A tab provides a selectable item in a tab list.
	*/ const Tab = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useTab_unstable(props, ref);
		useTabStyles_unstable(state);
		useCustomStyleHook("useTabStyles_unstable")(state);
		return renderTab_unstable(state);
	});
	Tab.displayName = "Tab";

//#endregion
//#region node_modules/@fluentui/react-tabs/lib/components/TabList/useTabList.js
/**
	* Create the state required to render TabList.
	*
	* The returned state can be modified with hooks such as useTabListStyles_unstable,
	* before being passed to renderTabList_unstable.
	*
	* @param props - props from this instance of TabList
	* @param ref - reference to root HTMLElement of TabList
	*/ const useTabList_unstable = (props, ref) => {
		const { appearance = "transparent", reserveSelectedTabSpace = true, disabled = false, onTabSelect, selectTabOnFocus = false, size: size$2 = "medium", vertical = false } = props;
		const innerRef = react.useRef(null);
		const focusAttributes = useArrowNavigationGroup({
			circular: true,
			axis: vertical ? "vertical" : "horizontal",
			memorizeCurrent: false,
			unstable_hasDefault: true
		});
		const [selectedValue, setSelectedValue] = useControllableState({
			state: props.selectedValue,
			defaultState: props.defaultSelectedValue,
			initialState: void 0
		});
		const currentSelectedValue = react.useRef(void 0);
		const previousSelectedValue = react.useRef(void 0);
		react.useEffect(() => {
			previousSelectedValue.current = currentSelectedValue.current;
			currentSelectedValue.current = selectedValue;
		}, [selectedValue]);
		const onSelect = useEventCallback((event, data) => {
			setSelectedValue(data.value);
			onTabSelect === null || onTabSelect === void 0 || onTabSelect(event, data);
		});
		const registeredTabs = react.useRef({});
		const onRegister = useEventCallback((data) => {
			const key = JSON.stringify(data.value);
			if (!key && true) console.error([
				`[@fluentui/react-tabs] The value "${data.value}" cannot be serialized to JSON string.`,
				"Tab component requires serializable values.",
				"Please provide a primitive value (string, number, boolean),",
				`or a plain object/array that doesn't contain functions, symbols, or circular references.`
			].join(" "));
			registeredTabs.current[key] = data;
		});
		const onUnregister = useEventCallback((data) => {
			delete registeredTabs.current[JSON.stringify(data.value)];
		});
		const getRegisteredTabs = react.useCallback(() => {
			return {
				selectedValue: currentSelectedValue.current,
				previousSelectedValue: previousSelectedValue.current,
				registeredTabs: registeredTabs.current
			};
		}, []);
		return {
			components: { root: "div" },
			root: always(getIntrinsicElementProps("div", {
				ref: useMergedRefs(ref, innerRef),
				role: "tablist",
				"aria-orientation": vertical ? "vertical" : "horizontal",
				...focusAttributes,
				...props
			}), { elementType: "div" }),
			appearance,
			reserveSelectedTabSpace,
			disabled,
			selectTabOnFocus,
			selectedValue,
			size: size$2,
			vertical,
			onRegister,
			onUnregister,
			onSelect,
			getRegisteredTabs
		};
	};

//#endregion
//#region node_modules/@fluentui/react-tabs/lib/components/TabList/renderTabList.js
/**
	* Render the final JSX of TabList
	*/ const renderTabList_unstable = (state, contextValues) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, { children: /* @__PURE__ */ jsx(TabListProvider, {
			value: contextValues.tabList,
			children: state.root.children
		}) });
	};

//#endregion
//#region node_modules/@fluentui/react-tabs/lib/components/TabList/useTabListStyles.styles.js
	const tabListClassNames = { root: "fui-TabList" };
	/**
	* Styles for the root slot
	*/
	const useStyles$76 = /* @__PURE__ */ __styles({
		root: {
			mc9l5x: "f22iagw",
			Beiy3e4: "f1063pyq",
			Bnnss6s: "fi64zpg",
			Eh141a: "flvyvdh",
			qhf8xq: "f10pi13n"
		},
		horizontal: {
			Bt984gj: "f1q9h2pe",
			Beiy3e4: "f1063pyq"
		},
		vertical: {
			Bt984gj: "f1q9h2pe",
			Beiy3e4: "f1vx9l62"
		},
		roundedSmall: {
			i8kkvl: 0,
			Belr9w4: 0,
			rmohyg: "f1eyhf9v"
		},
		rounded: {
			i8kkvl: 0,
			Belr9w4: 0,
			rmohyg: "faqewft"
		}
	}, { d: [
		".f22iagw{display:flex;}",
		".f1063pyq{flex-direction:row;}",
		".fi64zpg{flex-shrink:0;}",
		".flvyvdh{flex-wrap:nowrap;}",
		".f10pi13n{position:relative;}",
		".f1q9h2pe{align-items:stretch;}",
		".f1vx9l62{flex-direction:column;}",
		[".f1eyhf9v{gap:var(--spacingHorizontalSNudge);}", { p: -1 }],
		[".faqewft{gap:var(--spacingHorizontalS);}", { p: -1 }]
	] });
	/**
	* Apply styling to the TabList slots based on the state
	*/
	const useTabListStyles_unstable = (state) => {
		"use no memo";
		const { appearance, vertical, size: size$2 } = state;
		const styles = useStyles$76();
		const isRounded = appearance === "subtle-circular" || appearance === "filled-circular";
		state.root.className = mergeClasses(tabListClassNames.root, styles.root, vertical ? styles.vertical : styles.horizontal, isRounded && (size$2 === "small" ? styles.roundedSmall : styles.rounded), state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-tabs/lib/components/TabList/useTabListContextValues.js
	function useTabListContextValues_unstable(state) {
		const { appearance, reserveSelectedTabSpace, disabled, selectTabOnFocus, selectedValue: selectedKey, onRegister, onUnregister, onSelect, getRegisteredTabs, size: size$2, vertical } = state;
		return { tabList: {
			appearance,
			reserveSelectedTabSpace,
			disabled,
			selectTabOnFocus,
			selectedValue: selectedKey,
			onSelect,
			onRegister,
			onUnregister,
			getRegisteredTabs,
			size: size$2,
			vertical
		} };
	}

//#endregion
//#region node_modules/@fluentui/react-tabs/lib/components/TabList/TabList.js
/**
	* A tab list provides single selection from a set of tabs.
	*/ const TabList = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useTabList_unstable(props, ref);
		const contextValues = useTabListContextValues_unstable(state);
		useTabListStyles_unstable(state);
		useCustomStyleHook("useTabListStyles_unstable")(state);
		return renderTabList_unstable(state, contextValues);
	});
	TabList.displayName = "TabList";

//#endregion
//#region node_modules/@fluentui/react-text/lib/components/Text/useText.js
/**
	* Create the state required to render Text.
	*
	* The returned state can be modified with hooks such as useTextStyles_unstable,
	* before being passed to renderText_unstable.
	*
	* @param props - props from this instance of Text
	* @param ref - reference to root HTMLElement of Text
	*/ const useText_unstable = (props, ref) => {
		const { wrap, truncate, block, italic, underline, strikethrough, size: size$2, font, weight, align } = props;
		return {
			align: align !== null && align !== void 0 ? align : "start",
			block: block !== null && block !== void 0 ? block : false,
			font: font !== null && font !== void 0 ? font : "base",
			italic: italic !== null && italic !== void 0 ? italic : false,
			size: size$2 !== null && size$2 !== void 0 ? size$2 : 300,
			strikethrough: strikethrough !== null && strikethrough !== void 0 ? strikethrough : false,
			truncate: truncate !== null && truncate !== void 0 ? truncate : false,
			underline: underline !== null && underline !== void 0 ? underline : false,
			weight: weight !== null && weight !== void 0 ? weight : "regular",
			wrap: wrap !== null && wrap !== void 0 ? wrap : true,
			components: { root: "span" },
			root: always(getIntrinsicElementProps("span", {
				ref,
				...props
			}), { elementType: "span" })
		};
	};

//#endregion
//#region node_modules/@fluentui/react-text/lib/components/Text/renderText.js
/**
	* Render the final JSX of Text
	*/ const renderText_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, {});
	};

//#endregion
//#region node_modules/@fluentui/react-text/lib/components/Text/useTextStyles.styles.js
	const textClassNames = { root: "fui-Text" };
	/**
	* Styles for the root slot
	*/
	const useStyles$75 = /* @__PURE__ */ __styles({
		root: {
			Bahqtrf: "fk6fouc",
			Be2twd7: "fkhj508",
			Bg96gwp: "f1i3iumi",
			Bhrd7zp: "figsok6",
			fsow6f: "fpgzoln",
			mc9l5x: "f1w7gpdv",
			Huce71: "f6juhto",
			B68tc82: 0,
			Bmxbyg5: 0,
			Bpg54ce: "f1gl81tg",
			ygn44y: "f2jf649"
		},
		nowrap: {
			Huce71: "fz5stix",
			B68tc82: 0,
			Bmxbyg5: 0,
			Bpg54ce: "f1a3p1vp"
		},
		truncate: { ygn44y: "f1cmbuwj" },
		block: { mc9l5x: "ftgm304" },
		italic: { B80ckks: "f1j4dglz" },
		underline: { w71qe1: "f13mvf36" },
		strikethrough: { w71qe1: "fv5q2k7" },
		strikethroughUnderline: { w71qe1: "f1drk4o6" },
		base100: {
			Be2twd7: "f13mqy1h",
			Bg96gwp: "fcpl73t"
		},
		base200: {
			Be2twd7: "fy9rknc",
			Bg96gwp: "fwrc4pm"
		},
		base400: {
			Be2twd7: "fod5ikn",
			Bg96gwp: "faaz57k"
		},
		base500: {
			Be2twd7: "f1pp30po",
			Bg96gwp: "f106mvju"
		},
		base600: {
			Be2twd7: "f1x0m3f5",
			Bg96gwp: "fb86gi6"
		},
		hero700: {
			Be2twd7: "fojgt09",
			Bg96gwp: "fcen8rp"
		},
		hero800: {
			Be2twd7: "fccw675",
			Bg96gwp: "f1ebx5kk"
		},
		hero900: {
			Be2twd7: "f15afnhw",
			Bg96gwp: "fr3w3wp"
		},
		hero1000: {
			Be2twd7: "fpyltcb",
			Bg96gwp: "f1ivgwrt"
		},
		monospace: { Bahqtrf: "f1fedwem" },
		numeric: { Bahqtrf: "f1uq0ln5" },
		weightMedium: { Bhrd7zp: "fdj6btp" },
		weightSemibold: { Bhrd7zp: "fl43uef" },
		weightBold: { Bhrd7zp: "flh3ekv" },
		alignCenter: { fsow6f: "f17mccla" },
		alignEnd: { fsow6f: "f12ymhq5" },
		alignJustify: { fsow6f: "f1j59e10" }
	}, { d: [
		".fk6fouc{font-family:var(--fontFamilyBase);}",
		".fkhj508{font-size:var(--fontSizeBase300);}",
		".f1i3iumi{line-height:var(--lineHeightBase300);}",
		".figsok6{font-weight:var(--fontWeightRegular);}",
		".fpgzoln{text-align:start;}",
		".f1w7gpdv{display:inline;}",
		".f6juhto{white-space:normal;}",
		[".f1gl81tg{overflow:visible;}", { p: -1 }],
		".f2jf649{text-overflow:clip;}",
		".fz5stix{white-space:nowrap;}",
		[".f1a3p1vp{overflow:hidden;}", { p: -1 }],
		".f1cmbuwj{text-overflow:ellipsis;}",
		".ftgm304{display:block;}",
		".f1j4dglz{font-style:italic;}",
		".f13mvf36{text-decoration-line:underline;}",
		".fv5q2k7{text-decoration-line:line-through;}",
		".f1drk4o6{text-decoration-line:line-through underline;}",
		".f13mqy1h{font-size:var(--fontSizeBase100);}",
		".fcpl73t{line-height:var(--lineHeightBase100);}",
		".fy9rknc{font-size:var(--fontSizeBase200);}",
		".fwrc4pm{line-height:var(--lineHeightBase200);}",
		".fod5ikn{font-size:var(--fontSizeBase400);}",
		".faaz57k{line-height:var(--lineHeightBase400);}",
		".f1pp30po{font-size:var(--fontSizeBase500);}",
		".f106mvju{line-height:var(--lineHeightBase500);}",
		".f1x0m3f5{font-size:var(--fontSizeBase600);}",
		".fb86gi6{line-height:var(--lineHeightBase600);}",
		".fojgt09{font-size:var(--fontSizeHero700);}",
		".fcen8rp{line-height:var(--lineHeightHero700);}",
		".fccw675{font-size:var(--fontSizeHero800);}",
		".f1ebx5kk{line-height:var(--lineHeightHero800);}",
		".f15afnhw{font-size:var(--fontSizeHero900);}",
		".fr3w3wp{line-height:var(--lineHeightHero900);}",
		".fpyltcb{font-size:var(--fontSizeHero1000);}",
		".f1ivgwrt{line-height:var(--lineHeightHero1000);}",
		".f1fedwem{font-family:var(--fontFamilyMonospace);}",
		".f1uq0ln5{font-family:var(--fontFamilyNumeric);}",
		".fdj6btp{font-weight:var(--fontWeightMedium);}",
		".fl43uef{font-weight:var(--fontWeightSemibold);}",
		".flh3ekv{font-weight:var(--fontWeightBold);}",
		".f17mccla{text-align:center;}",
		".f12ymhq5{text-align:end;}",
		".f1j59e10{text-align:justify;}"
	] });
	/**
	* Apply styling to the Text slots based on the state
	*/
	const useTextStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$75();
		state.root.className = mergeClasses(textClassNames.root, styles.root, state.wrap === false && styles.nowrap, state.truncate && styles.truncate, state.block && styles.block, state.italic && styles.italic, state.underline && styles.underline, state.strikethrough && styles.strikethrough, state.underline && state.strikethrough && styles.strikethroughUnderline, state.size === 100 && styles.base100, state.size === 200 && styles.base200, state.size === 400 && styles.base400, state.size === 500 && styles.base500, state.size === 600 && styles.base600, state.size === 700 && styles.hero700, state.size === 800 && styles.hero800, state.size === 900 && styles.hero900, state.size === 1e3 && styles.hero1000, state.font === "monospace" && styles.monospace, state.font === "numeric" && styles.numeric, state.weight === "medium" && styles.weightMedium, state.weight === "semibold" && styles.weightSemibold, state.weight === "bold" && styles.weightBold, state.align === "center" && styles.alignCenter, state.align === "end" && styles.alignEnd, state.align === "justify" && styles.alignJustify, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-text/lib/components/Text/Text.js
/**
	* Typography and styling abstraction component used to ensure consistency of text.
	*/ const Text = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useText_unstable(props, ref);
		useTextStyles_unstable(state);
		useCustomStyleHook("useTextStyles_unstable")(state);
		return renderText_unstable(state);
	});
	Text.displayName = "Text";

//#endregion
//#region node_modules/@fluentui/react-text/lib/components/presets/createPreset.js
	function createPreset(options) {
		const { useStyles: useStyles$108, className, displayName } = options;
		const Wrapper = react.forwardRef((props, ref) => {
			"use no memo";
			const styles = useStyles$108();
			const state = useText_unstable(props, ref);
			useTextStyles_unstable(state);
			state.root.className = mergeClasses(className, state.root.className, styles.root, props.className);
			return renderText_unstable(state);
		});
		Wrapper.displayName = displayName;
		return Wrapper;
	}

//#endregion
//#region node_modules/@fluentui/react-text/lib/components/presets/Body1/useBody1Styles.styles.js
	const body1ClassNames = { root: "fui-Body1" };
	/**
	* Styles for the root slot
	*/
	const useBody1Styles = /* @__PURE__ */ __styles({ root: {
		Bahqtrf: "fk6fouc",
		Be2twd7: "fkhj508",
		Bhrd7zp: "figsok6",
		Bg96gwp: "f1i3iumi"
	} }, { d: [
		".fk6fouc{font-family:var(--fontFamilyBase);}",
		".fkhj508{font-size:var(--fontSizeBase300);}",
		".figsok6{font-weight:var(--fontWeightRegular);}",
		".f1i3iumi{line-height:var(--lineHeightBase300);}"
	] });

//#endregion
//#region node_modules/@fluentui/react-text/lib/components/presets/Body1/Body1.js
/**
	* Text preset component for the Body1 typography variant
	*/ const Body1 = createPreset({
		useStyles: useBody1Styles,
		className: body1ClassNames.root,
		displayName: "Body1"
	});

//#endregion
//#region node_modules/@fluentui/react-text/lib/components/presets/Body1Strong/useBody1StrongStyles.styles.js
	const body1StrongClassNames = { root: "fui-Body1Strong" };
	/**
	* Styles for the root slot
	*/
	const useBody1StrongStyles = /* @__PURE__ */ __styles({ root: {
		Bahqtrf: "fk6fouc",
		Be2twd7: "fkhj508",
		Bhrd7zp: "fl43uef",
		Bg96gwp: "f1i3iumi"
	} }, { d: [
		".fk6fouc{font-family:var(--fontFamilyBase);}",
		".fkhj508{font-size:var(--fontSizeBase300);}",
		".fl43uef{font-weight:var(--fontWeightSemibold);}",
		".f1i3iumi{line-height:var(--lineHeightBase300);}"
	] });

//#endregion
//#region node_modules/@fluentui/react-text/lib/components/presets/Body1Strong/Body1Strong.js
/**
	* Text preset component for the Body1Strong typography variant
	*/ const Body1Strong = createPreset({
		useStyles: useBody1StrongStyles,
		className: body1StrongClassNames.root,
		displayName: "Body1Strong"
	});

//#endregion
//#region node_modules/@fluentui/react-text/lib/components/presets/Body1Stronger/useBody1StrongerStyles.styles.js
	const body1StrongerClassNames = { root: "fui-Body1Stronger" };
	/**
	* Styles for the root slot
	*/
	const useBody1StrongerStyles = /* @__PURE__ */ __styles({ root: {
		Bahqtrf: "fk6fouc",
		Be2twd7: "fkhj508",
		Bhrd7zp: "flh3ekv",
		Bg96gwp: "f1i3iumi"
	} }, { d: [
		".fk6fouc{font-family:var(--fontFamilyBase);}",
		".fkhj508{font-size:var(--fontSizeBase300);}",
		".flh3ekv{font-weight:var(--fontWeightBold);}",
		".f1i3iumi{line-height:var(--lineHeightBase300);}"
	] });

//#endregion
//#region node_modules/@fluentui/react-text/lib/components/presets/Body1Stronger/Body1Stronger.js
/**
	* Text preset component for the Body1Stronger typography variant
	*/ const Body1Stronger = createPreset({
		useStyles: useBody1StrongerStyles,
		className: body1StrongerClassNames.root,
		displayName: "Body1Stronger"
	});

//#endregion
//#region node_modules/@fluentui/react-text/lib/components/presets/Body2/useBody2Styles.styles.js
	const body2ClassNames = { root: "fui-Body2" };
	/**
	* Styles for the root slot
	*/
	const useBody2Styles = /* @__PURE__ */ __styles({ root: {
		Bahqtrf: "fk6fouc",
		Be2twd7: "fod5ikn",
		Bhrd7zp: "figsok6",
		Bg96gwp: "faaz57k"
	} }, { d: [
		".fk6fouc{font-family:var(--fontFamilyBase);}",
		".fod5ikn{font-size:var(--fontSizeBase400);}",
		".figsok6{font-weight:var(--fontWeightRegular);}",
		".faaz57k{line-height:var(--lineHeightBase400);}"
	] });

//#endregion
//#region node_modules/@fluentui/react-text/lib/components/presets/Body2/Body2.js
/**
	* Text preset component for the Body2 typography variant
	*/ const Body2 = createPreset({
		useStyles: useBody2Styles,
		className: body2ClassNames.root,
		displayName: "Body2"
	});

//#endregion
//#region node_modules/@fluentui/react-text/lib/components/presets/Caption1/useCaption1Styles.styles.js
	const caption1ClassNames = { root: "fui-Caption1" };
	/**
	* Styles for the root slot
	*/
	const useCaption1Styles = /* @__PURE__ */ __styles({ root: {
		Bahqtrf: "fk6fouc",
		Be2twd7: "fy9rknc",
		Bhrd7zp: "figsok6",
		Bg96gwp: "fwrc4pm"
	} }, { d: [
		".fk6fouc{font-family:var(--fontFamilyBase);}",
		".fy9rknc{font-size:var(--fontSizeBase200);}",
		".figsok6{font-weight:var(--fontWeightRegular);}",
		".fwrc4pm{line-height:var(--lineHeightBase200);}"
	] });

//#endregion
//#region node_modules/@fluentui/react-text/lib/components/presets/Caption1/Caption1.js
/**
	* Text preset component for the Caption1 typography variant
	*/ const Caption1 = createPreset({
		useStyles: useCaption1Styles,
		className: caption1ClassNames.root,
		displayName: "Caption1"
	});

//#endregion
//#region node_modules/@fluentui/react-text/lib/components/presets/Caption1Strong/useCaption1StrongStyles.styles.js
	const caption1StrongClassNames = { root: "fui-Caption1Strong" };
	/**
	* Styles for the root slot
	*/
	const useCaption1StrongStyles = /* @__PURE__ */ __styles({ root: {
		Bahqtrf: "fk6fouc",
		Be2twd7: "fy9rknc",
		Bhrd7zp: "fl43uef",
		Bg96gwp: "fwrc4pm"
	} }, { d: [
		".fk6fouc{font-family:var(--fontFamilyBase);}",
		".fy9rknc{font-size:var(--fontSizeBase200);}",
		".fl43uef{font-weight:var(--fontWeightSemibold);}",
		".fwrc4pm{line-height:var(--lineHeightBase200);}"
	] });

//#endregion
//#region node_modules/@fluentui/react-text/lib/components/presets/Caption1Strong/Caption1Strong.js
/**
	* Text preset component for the Caption1Strong typography variant
	*/ const Caption1Strong = createPreset({
		useStyles: useCaption1StrongStyles,
		className: caption1StrongClassNames.root,
		displayName: "Caption1Strong"
	});

//#endregion
//#region node_modules/@fluentui/react-text/lib/components/presets/Caption1Stronger/useCaption1Stronger.styles.js
	const caption1StrongerClassNames = { root: "fui-Caption1Stronger" };
	/**
	* Styles for the root slot
	*/
	const useCaption1StrongerStyles = /* @__PURE__ */ __styles({ root: {
		Bahqtrf: "fk6fouc",
		Be2twd7: "fy9rknc",
		Bhrd7zp: "flh3ekv",
		Bg96gwp: "fwrc4pm"
	} }, { d: [
		".fk6fouc{font-family:var(--fontFamilyBase);}",
		".fy9rknc{font-size:var(--fontSizeBase200);}",
		".flh3ekv{font-weight:var(--fontWeightBold);}",
		".fwrc4pm{line-height:var(--lineHeightBase200);}"
	] });

//#endregion
//#region node_modules/@fluentui/react-text/lib/components/presets/Caption1Stronger/Caption1Stronger.js
/**
	* Text preset component for the Caption1Stronger typography variant
	*/ const Caption1Stronger = createPreset({
		useStyles: useCaption1StrongerStyles,
		className: caption1StrongerClassNames.root,
		displayName: "Caption1Stronger"
	});

//#endregion
//#region node_modules/@fluentui/react-text/lib/components/presets/Caption2/useCaption2Styles.styles.js
	const caption2ClassNames = { root: "fui-Caption2" };
	/**
	* Styles for the root slot
	*/
	const useCaption2Styles = /* @__PURE__ */ __styles({ root: {
		Bahqtrf: "fk6fouc",
		Be2twd7: "f13mqy1h",
		Bhrd7zp: "figsok6",
		Bg96gwp: "fcpl73t"
	} }, { d: [
		".fk6fouc{font-family:var(--fontFamilyBase);}",
		".f13mqy1h{font-size:var(--fontSizeBase100);}",
		".figsok6{font-weight:var(--fontWeightRegular);}",
		".fcpl73t{line-height:var(--lineHeightBase100);}"
	] });

//#endregion
//#region node_modules/@fluentui/react-text/lib/components/presets/Caption2/Caption2.js
/**
	* Text preset component for the Caption2 typography variant
	*/ const Caption2 = createPreset({
		useStyles: useCaption2Styles,
		className: caption2ClassNames.root,
		displayName: "Caption2"
	});

//#endregion
//#region node_modules/@fluentui/react-text/lib/components/presets/Caption2Strong/useCaption2StrongStyles.styles.js
	const caption2StrongClassNames = { root: "fui-Caption2Strong" };
	/**
	* Styles for the root slot
	*/
	const useCaption2StrongStyles = /* @__PURE__ */ __styles({ root: {
		Bahqtrf: "fk6fouc",
		Be2twd7: "f13mqy1h",
		Bhrd7zp: "fl43uef",
		Bg96gwp: "fcpl73t"
	} }, { d: [
		".fk6fouc{font-family:var(--fontFamilyBase);}",
		".f13mqy1h{font-size:var(--fontSizeBase100);}",
		".fl43uef{font-weight:var(--fontWeightSemibold);}",
		".fcpl73t{line-height:var(--lineHeightBase100);}"
	] });

//#endregion
//#region node_modules/@fluentui/react-text/lib/components/presets/Caption2Strong/Caption2Strong.js
/**
	* Text preset component for the Caption2Strong typography variant
	*/ const Caption2Strong = createPreset({
		useStyles: useCaption2StrongStyles,
		className: caption2StrongClassNames.root,
		displayName: "Caption2Strong"
	});

//#endregion
//#region node_modules/@fluentui/react-text/lib/components/presets/Display/useDisplayStyles.styles.js
	const displayClassNames = { root: "fui-Display" };
	/**
	* Styles for the root slot
	*/
	const useDisplayStyles = /* @__PURE__ */ __styles({ root: {
		Bahqtrf: "fk6fouc",
		Be2twd7: "fpyltcb",
		Bhrd7zp: "fl43uef",
		Bg96gwp: "f1ivgwrt"
	} }, { d: [
		".fk6fouc{font-family:var(--fontFamilyBase);}",
		".fpyltcb{font-size:var(--fontSizeHero1000);}",
		".fl43uef{font-weight:var(--fontWeightSemibold);}",
		".f1ivgwrt{line-height:var(--lineHeightHero1000);}"
	] });

//#endregion
//#region node_modules/@fluentui/react-text/lib/components/presets/Display/Display.js
/**
	* Text preset component for the Display typography variant
	*/ const Display = createPreset({
		useStyles: useDisplayStyles,
		className: displayClassNames.root,
		displayName: "Display"
	});

//#endregion
//#region node_modules/@fluentui/react-text/lib/components/presets/LargeTitle/useLargeTitleStyles.styles.js
	const largeTitleClassNames = { root: "fui-LargeTitle" };
	/**
	* Styles for the root slot
	*/
	const useLargeTitleStyles = /* @__PURE__ */ __styles({ root: {
		Bahqtrf: "fk6fouc",
		Be2twd7: "f15afnhw",
		Bhrd7zp: "fl43uef",
		Bg96gwp: "fr3w3wp"
	} }, { d: [
		".fk6fouc{font-family:var(--fontFamilyBase);}",
		".f15afnhw{font-size:var(--fontSizeHero900);}",
		".fl43uef{font-weight:var(--fontWeightSemibold);}",
		".fr3w3wp{line-height:var(--lineHeightHero900);}"
	] });

//#endregion
//#region node_modules/@fluentui/react-text/lib/components/presets/LargeTitle/LargeTitle.js
/**
	* Text preset component for the Large Title typography variant
	*/ const LargeTitle = createPreset({
		useStyles: useLargeTitleStyles,
		className: largeTitleClassNames.root,
		displayName: "LargeTitle"
	});

//#endregion
//#region node_modules/@fluentui/react-text/lib/components/presets/Subtitle1/useSubtitle1Styles.styles.js
	const subtitle1ClassNames = { root: "fui-Subtitle1" };
	/**
	* Styles for the root slot
	*/
	const useSubtitle1Styles = /* @__PURE__ */ __styles({ root: {
		Bahqtrf: "fk6fouc",
		Be2twd7: "f1pp30po",
		Bhrd7zp: "fl43uef",
		Bg96gwp: "f106mvju"
	} }, { d: [
		".fk6fouc{font-family:var(--fontFamilyBase);}",
		".f1pp30po{font-size:var(--fontSizeBase500);}",
		".fl43uef{font-weight:var(--fontWeightSemibold);}",
		".f106mvju{line-height:var(--lineHeightBase500);}"
	] });

//#endregion
//#region node_modules/@fluentui/react-text/lib/components/presets/Subtitle1/Subtitle1.js
/**
	* Text preset component for the Subtitle1 typography variant
	*/ const Subtitle1 = createPreset({
		useStyles: useSubtitle1Styles,
		className: subtitle1ClassNames.root,
		displayName: "Subtitle1"
	});

//#endregion
//#region node_modules/@fluentui/react-text/lib/components/presets/Subtitle2/useSubtitle2Styles.styles.js
	const subtitle2ClassNames = { root: "fui-Subtitle2" };
	/**
	* Styles for the root slot
	*/
	const useSubtitle2Styles = /* @__PURE__ */ __styles({ root: {
		Bahqtrf: "fk6fouc",
		Be2twd7: "fod5ikn",
		Bhrd7zp: "fl43uef",
		Bg96gwp: "faaz57k"
	} }, { d: [
		".fk6fouc{font-family:var(--fontFamilyBase);}",
		".fod5ikn{font-size:var(--fontSizeBase400);}",
		".fl43uef{font-weight:var(--fontWeightSemibold);}",
		".faaz57k{line-height:var(--lineHeightBase400);}"
	] });

//#endregion
//#region node_modules/@fluentui/react-text/lib/components/presets/Subtitle2/Subtitle2.js
/**
	* Text preset component for the Subtitle2 typography variant
	*/ const Subtitle2 = createPreset({
		useStyles: useSubtitle2Styles,
		className: subtitle2ClassNames.root,
		displayName: "Subtitle2"
	});

//#endregion
//#region node_modules/@fluentui/react-text/lib/components/presets/Subtitle2Stronger/useSubtitle2Stronger.styles.js
	const subtitle2StrongerClassNames = { root: "fui-Subtitle2Stronger" };
	/**
	* Styles for the root slot
	*/
	const useSubtitle2StrongerStyles = /* @__PURE__ */ __styles({ root: {
		Bahqtrf: "fk6fouc",
		Be2twd7: "fod5ikn",
		Bhrd7zp: "flh3ekv",
		Bg96gwp: "faaz57k"
	} }, { d: [
		".fk6fouc{font-family:var(--fontFamilyBase);}",
		".fod5ikn{font-size:var(--fontSizeBase400);}",
		".flh3ekv{font-weight:var(--fontWeightBold);}",
		".faaz57k{line-height:var(--lineHeightBase400);}"
	] });

//#endregion
//#region node_modules/@fluentui/react-text/lib/components/presets/Subtitle2Stronger/Subtitle2Stronger.js
/**
	* Text preset component for the Subtitle2Stronger typography variant
	*/ const Subtitle2Stronger = createPreset({
		useStyles: useSubtitle2StrongerStyles,
		className: subtitle2StrongerClassNames.root,
		displayName: "Subtitle2Stronger"
	});

//#endregion
//#region node_modules/@fluentui/react-text/lib/components/presets/Title1/useTitle1Styles.styles.js
	const title1ClassNames = { root: "fui-Title1" };
	/**
	* Styles for the root slot
	*/
	const useTitle1Styles = /* @__PURE__ */ __styles({ root: {
		Bahqtrf: "fk6fouc",
		Be2twd7: "fccw675",
		Bhrd7zp: "fl43uef",
		Bg96gwp: "f1ebx5kk"
	} }, { d: [
		".fk6fouc{font-family:var(--fontFamilyBase);}",
		".fccw675{font-size:var(--fontSizeHero800);}",
		".fl43uef{font-weight:var(--fontWeightSemibold);}",
		".f1ebx5kk{line-height:var(--lineHeightHero800);}"
	] });

//#endregion
//#region node_modules/@fluentui/react-text/lib/components/presets/Title1/Title1.js
/**
	* Text preset component for the Title 1 typography variant
	*/ const Title1 = createPreset({
		useStyles: useTitle1Styles,
		className: title1ClassNames.root,
		displayName: "Title1"
	});

//#endregion
//#region node_modules/@fluentui/react-text/lib/components/presets/Title2/useTitle2Styles.styles.js
	const title2ClassNames = { root: "fui-Title2" };
	/**
	* Styles for the root slot
	*/
	const useTitle2Styles = /* @__PURE__ */ __styles({ root: {
		Bahqtrf: "fk6fouc",
		Be2twd7: "fojgt09",
		Bhrd7zp: "fl43uef",
		Bg96gwp: "fcen8rp"
	} }, { d: [
		".fk6fouc{font-family:var(--fontFamilyBase);}",
		".fojgt09{font-size:var(--fontSizeHero700);}",
		".fl43uef{font-weight:var(--fontWeightSemibold);}",
		".fcen8rp{line-height:var(--lineHeightHero700);}"
	] });

//#endregion
//#region node_modules/@fluentui/react-text/lib/components/presets/Title2/Title2.js
/**
	* Text preset component for the Title 2 typography variant
	*/ const Title2 = createPreset({
		useStyles: useTitle2Styles,
		className: title2ClassNames.root,
		displayName: "Title2"
	});

//#endregion
//#region node_modules/@fluentui/react-text/lib/components/presets/Title3/useTitle3Styles.styles.js
	const title3ClassNames = { root: "fui-Title3" };
	/**
	* Styles for the root slot
	*/
	const useTitle3Styles = /* @__PURE__ */ __styles({ root: {
		Bahqtrf: "fk6fouc",
		Be2twd7: "f1x0m3f5",
		Bhrd7zp: "fl43uef",
		Bg96gwp: "fb86gi6"
	} }, { d: [
		".fk6fouc{font-family:var(--fontFamilyBase);}",
		".f1x0m3f5{font-size:var(--fontSizeBase600);}",
		".fl43uef{font-weight:var(--fontWeightSemibold);}",
		".fb86gi6{line-height:var(--lineHeightBase600);}"
	] });

//#endregion
//#region node_modules/@fluentui/react-text/lib/components/presets/Title3/Title3.js
/**
	* Text preset component for the Title 3 typography variant
	*/ const Title3 = createPreset({
		useStyles: useTitle3Styles,
		className: title3ClassNames.root,
		displayName: "Title3"
	});

//#endregion
//#region node_modules/@fluentui/react-textarea/lib/components/Textarea/renderTextarea.js
/**
	* Render the final JSX of Textarea
	*/ const renderTextarea_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, { children: /* @__PURE__ */ jsx(state.textarea, {}) });
	};

//#endregion
//#region node_modules/@fluentui/react-textarea/lib/components/Textarea/useTextarea.js
/**
	* Create the state required to render Textarea.
	*
	* The returned state can be modified with hooks such as useTextareaStyles_unstable,
	* before being passed to renderTextarea_unstable.
	*
	* @param props - props from this instance of Textarea
	* @param ref - reference to root HTMLElement of Textarea
	*/ const useTextarea_unstable = (props, ref) => {
		props = useFieldControlProps_unstable(props, {
			supportsLabelFor: true,
			supportsRequired: true,
			supportsSize: true
		});
		const overrides = useOverrides();
		var _overrides_inputDefaultAppearance;
		const { size: size$2 = "medium", appearance = (_overrides_inputDefaultAppearance = overrides.inputDefaultAppearance) !== null && _overrides_inputDefaultAppearance !== void 0 ? _overrides_inputDefaultAppearance : "outline", resize = "none", onChange } = props;
		if (appearance === "filled-darker-shadow" || appearance === "filled-lighter-shadow") console.error("The 'filled-darker-shadow' and 'filled-lighter-shadow' appearances are deprecated and will be removed in the future.");
		const [value, setValue] = useControllableState({
			state: props.value,
			defaultState: props.defaultValue,
			initialState: void 0
		});
		const nativeProps = getPartitionedNativeProps({
			props,
			primarySlotTagName: "textarea",
			excludedPropNames: [
				"onChange",
				"value",
				"defaultValue"
			]
		});
		const state = {
			size: size$2,
			appearance,
			resize,
			components: {
				root: "span",
				textarea: "textarea"
			},
			textarea: always(props.textarea, {
				defaultProps: {
					ref,
					...nativeProps.primary
				},
				elementType: "textarea"
			}),
			root: always(props.root, {
				defaultProps: nativeProps.root,
				elementType: "span"
			})
		};
		state.textarea.value = value;
		state.textarea.onChange = useEventCallback((ev) => {
			const newValue = ev.target.value;
			onChange === null || onChange === void 0 || onChange(ev, { value: newValue });
			setValue(newValue);
		});
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-textarea/lib/components/Textarea/useTextareaStyles.styles.js
	const textareaClassNames = {
		root: "fui-Textarea",
		textarea: "fui-Textarea__textarea"
	};
	/**
	* Styles for the root(wrapper) slot
	*/
	const useRootStyles$13 = /* @__PURE__ */ __styles({
		base: {
			mc9l5x: "ftuwxu6",
			B7ck84d: "f1ewtqcl",
			qhf8xq: "f10pi13n",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f1yiegib",
			jrapky: 0,
			Frg6f3: 0,
			t21cq0: 0,
			B6of3ja: 0,
			B74szlk: "f1s184ao",
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "ft85np5",
			ha4doy: "f12kltsn"
		},
		disabled: {
			De3pzq: "f1c21dwh",
			Bgfg5da: 0,
			B9xav0g: 0,
			oivjwe: 0,
			Bn0qgzm: 0,
			B4g9neb: 0,
			zhjwy3: 0,
			wvpqe5: 0,
			ibv6hh: 0,
			u1mtju: 0,
			h3c5rm: 0,
			vrafjx: 0,
			Bekrc4i: 0,
			i8vvqc: 0,
			g2u3we: 0,
			icvyot: 0,
			B4j52fo: 0,
			irswps: "ff3nzm7",
			Bcq6wej: "f9dbb4x",
			Jcjdmf: ["f3qs60o", "f5u9ap2"],
			sc4o1m: "fwd1oij",
			Bosien3: ["f5u9ap2", "f3qs60o"]
		},
		interactive: {
			li1rpt: "f1gw3sf2",
			Bsft5z2: "f13zj6fq",
			E3zdtr: "f1mdlcz9",
			Eqx8gd: ["f1a7op3", "f1cjjd47"],
			By385i5: "f1gboi2j",
			B1piin3: ["f1cjjd47", "f1a7op3"],
			Dlnsje: "ffyw7fx",
			d9w3h3: ["f1kp91vd", "f1ibwz09"],
			B3778ie: ["f1ibwz09", "f1kp91vd"],
			B1q35kw: 0,
			Bw17bha: 0,
			Bcgy8vk: 0,
			Bjuhk93: "f1mnjydx",
			Gjdm7m: "fj2g8qd",
			b1kco5: "f1yk9hq",
			Ba2ppi3: "fhwpy7i",
			F2fol1: "f14ee0xe",
			lck23g: "f1xhbsuh",
			wi16st: "fsrmcvb",
			ywj3b2: "f1t3k7v9",
			umuwi5: "fjw5xc1",
			Blcqepd: "f1xdyd5c",
			nplu4u: "fatpbeo",
			Bioka5o: "fb7uyps",
			Bnupc0a: "fx04xgm",
			bing71: "f1c7in40",
			Bercvud: "f1ibeo51",
			Bbr2w1p: "f1vnc8sk",
			Bduesf4: "f3e99gv",
			Bpq79vn: "fhljsf7"
		},
		filled: {
			Bgfg5da: 0,
			B9xav0g: 0,
			oivjwe: 0,
			Bn0qgzm: 0,
			B4g9neb: 0,
			zhjwy3: 0,
			wvpqe5: 0,
			ibv6hh: 0,
			u1mtju: 0,
			h3c5rm: 0,
			vrafjx: 0,
			Bekrc4i: 0,
			i8vvqc: 0,
			g2u3we: 0,
			icvyot: 0,
			B4j52fo: 0,
			irswps: "f88035w",
			q7v0qe: "ftmjh5b",
			kmh5ft: ["f17blpuu", "fsrcdbj"],
			nagaa4: "f1tpwn32",
			B1yhkcb: ["fsrcdbj", "f17blpuu"]
		},
		"filled-darker": { De3pzq: "f16xq7d1" },
		"filled-lighter": { De3pzq: "fxugw4r" },
		"filled-darker-shadow": {
			De3pzq: "f16xq7d1",
			Bgfg5da: 0,
			B9xav0g: 0,
			oivjwe: 0,
			Bn0qgzm: 0,
			B4g9neb: 0,
			zhjwy3: 0,
			wvpqe5: 0,
			ibv6hh: 0,
			u1mtju: 0,
			h3c5rm: 0,
			vrafjx: 0,
			Bekrc4i: 0,
			i8vvqc: 0,
			g2u3we: 0,
			icvyot: 0,
			B4j52fo: 0,
			irswps: "f1gmd7mu",
			E5pizo: "fyed02w"
		},
		"filled-lighter-shadow": {
			De3pzq: "fxugw4r",
			Bgfg5da: 0,
			B9xav0g: 0,
			oivjwe: 0,
			Bn0qgzm: 0,
			B4g9neb: 0,
			zhjwy3: 0,
			wvpqe5: 0,
			ibv6hh: 0,
			u1mtju: 0,
			h3c5rm: 0,
			vrafjx: 0,
			Bekrc4i: 0,
			i8vvqc: 0,
			g2u3we: 0,
			icvyot: 0,
			B4j52fo: 0,
			irswps: "f1gmd7mu",
			E5pizo: "fyed02w"
		},
		outline: {
			De3pzq: "fxugw4r",
			Bgfg5da: 0,
			B9xav0g: "f1c1zstj",
			oivjwe: 0,
			Bn0qgzm: 0,
			B4g9neb: 0,
			zhjwy3: 0,
			wvpqe5: 0,
			ibv6hh: 0,
			u1mtju: 0,
			h3c5rm: 0,
			vrafjx: 0,
			Bekrc4i: 0,
			i8vvqc: 0,
			g2u3we: 0,
			icvyot: 0,
			B4j52fo: 0,
			irswps: "fhz96rm"
		},
		outlineInteractive: {
			kzujx5: 0,
			oetu4i: "f1l4zc64",
			gvrnp0: 0,
			xv9156: 0,
			jek2p4: 0,
			gg5e9n: 0,
			Beu9t3s: 0,
			dt87k2: 0,
			Bt1vbvt: 0,
			Bwzppfd: 0,
			Bop6t4b: 0,
			B2zwrfe: 0,
			Bwp2tzp: 0,
			Bgoe8wy: 0,
			Bf40cpq: 0,
			ckks6v: 0,
			Baalond: "f9mts5e",
			v2iqwr: 0,
			wmxk5l: "f1z0osm6",
			Bj33j0h: 0,
			Bs0cc2w: 0,
			qwjtx1: 0,
			B50zh58: 0,
			f7epvg: 0,
			e1hlit: 0,
			B7mkhst: 0,
			ak43y8: 0,
			Bbcopvn: 0,
			Bvecx4l: 0,
			lwioe0: 0,
			B6oc9vd: 0,
			e2sjt0: 0,
			uqwnxt: 0,
			asj8p9: "f1acnei2",
			Br8fjdy: 0,
			zoxjo1: "f1so894s",
			Bt3ojkv: 0,
			B7pmvfx: 0,
			Bfht2n1: 0,
			an54nd: 0,
			t1ykpo: 0,
			Belqbek: 0,
			bbt1vd: 0,
			Brahy3i: 0,
			r7b1zc: 0,
			rexu52: 0,
			ovtnii: 0,
			Bvq3b66: 0,
			Bawrxx6: 0,
			Bbs6y8j: 0,
			B2qpgjt: "f19ezbcq"
		},
		invalid: {
			tvckwq: "fs4k3qj",
			gk2u95: ["fcee079", "fmyw78r"],
			hhx65j: "f1fgmyf4",
			Bxowmz0: ["fmyw78r", "fcee079"]
		}
	}, {
		d: [
			".ftuwxu6{display:inline-flex;}",
			".f1ewtqcl{box-sizing:border-box;}",
			".f10pi13n{position:relative;}",
			[".f1yiegib{padding:0 0 var(--strokeWidthThick) 0;}", { p: -1 }],
			[".f1s184ao{margin:0;}", { p: -1 }],
			[".ft85np5{border-radius:var(--borderRadiusMedium);}", { p: -1 }],
			".f12kltsn{vertical-align:top;}",
			".f1c21dwh{background-color:var(--colorTransparentBackground);}",
			[".ff3nzm7{border:var(--strokeWidthThin) solid var(--colorNeutralStrokeDisabled);}", { p: -2 }],
			".f1gw3sf2::after{box-sizing:border-box;}",
			".f13zj6fq::after{content:\"\";}",
			".f1mdlcz9::after{position:absolute;}",
			".f1a7op3::after{left:-1px;}",
			".f1cjjd47::after{right:-1px;}",
			".f1gboi2j::after{bottom:-1px;}",
			".ffyw7fx::after{height:max(var(--strokeWidthThick), var(--borderRadiusMedium));}",
			".f1kp91vd::after{border-bottom-left-radius:var(--borderRadiusMedium);}",
			".f1ibwz09::after{border-bottom-right-radius:var(--borderRadiusMedium);}",
			[".f1mnjydx::after{border-bottom:var(--strokeWidthThick) solid var(--colorCompoundBrandStroke);}", { p: -1 }],
			".fj2g8qd::after{clip-path:inset(calc(100% - var(--strokeWidthThick)) 0 0 0);}",
			".f1yk9hq::after{transform:scaleX(0);}",
			".fhwpy7i::after{transition-property:transform;}",
			".f14ee0xe::after{transition-duration:var(--durationUltraFast);}",
			".f1xhbsuh::after{transition-delay:var(--curveAccelerateMid);}",
			[".f88035w{border:var(--strokeWidthThin) solid var(--colorTransparentStroke);}", { p: -2 }],
			".f16xq7d1{background-color:var(--colorNeutralBackground3);}",
			".fxugw4r{background-color:var(--colorNeutralBackground1);}",
			[".f1gmd7mu{border:var(--strokeWidthThin) solid var(--colorTransparentStrokeInteractive);}", { p: -2 }],
			".fyed02w{box-shadow:var(--shadow2);}",
			[".f1gmd7mu{border:var(--strokeWidthThin) solid var(--colorTransparentStrokeInteractive);}", { p: -2 }],
			[".fhz96rm{border:var(--strokeWidthThin) solid var(--colorNeutralStroke1);}", { p: -2 }],
			".f1c1zstj{border-bottom-color:var(--colorNeutralStrokeAccessible);}",
			".fs4k3qj:not(:focus-within),.fs4k3qj:hover:not(:focus-within){border-top-color:var(--colorPaletteRedBorder2);}",
			".fcee079:not(:focus-within),.fcee079:hover:not(:focus-within){border-right-color:var(--colorPaletteRedBorder2);}",
			".fmyw78r:not(:focus-within),.fmyw78r:hover:not(:focus-within){border-left-color:var(--colorPaletteRedBorder2);}",
			".f1fgmyf4:not(:focus-within),.f1fgmyf4:hover:not(:focus-within){border-bottom-color:var(--colorPaletteRedBorder2);}"
		],
		m: [
			["@media (forced-colors: active){.f9dbb4x{border-top-color:GrayText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f3qs60o{border-right-color:GrayText;}.f5u9ap2{border-left-color:GrayText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fwd1oij{border-bottom-color:GrayText;}}", { m: "(forced-colors: active)" }],
			["@media screen and (prefers-reduced-motion: reduce){.fsrmcvb::after{transition-duration:0.01ms;}}", { m: "screen and (prefers-reduced-motion: reduce)" }],
			["@media screen and (prefers-reduced-motion: reduce){.f1t3k7v9::after{transition-delay:0.01ms;}}", { m: "screen and (prefers-reduced-motion: reduce)" }],
			["@media screen and (prefers-reduced-motion: reduce){.fx04xgm:focus-within::after{transition-duration:0.01ms;}}", { m: "screen and (prefers-reduced-motion: reduce)" }],
			["@media screen and (prefers-reduced-motion: reduce){.f1c7in40:focus-within::after{transition-delay:0.01ms;}}", { m: "screen and (prefers-reduced-motion: reduce)" }]
		],
		w: [
			".fjw5xc1:focus-within::after{transform:scaleX(1);}",
			".f1xdyd5c:focus-within::after{transition-property:transform;}",
			".fatpbeo:focus-within::after{transition-duration:var(--durationNormal);}",
			".fb7uyps:focus-within::after{transition-delay:var(--curveDecelerateMid);}",
			".f1ibeo51:focus-within:active::after{border-bottom-color:var(--colorCompoundBrandStrokePressed);}",
			".f1vnc8sk:focus-within{outline-width:var(--strokeWidthThick);}",
			".f3e99gv:focus-within{outline-style:solid;}",
			".fhljsf7:focus-within{outline-color:transparent;}",
			[".f19ezbcq:focus-within{border:var(--strokeWidthThin) solid var(--colorNeutralStroke1Pressed);}", { p: -2 }],
			".f1so894s:focus-within{border-bottom-color:var(--colorCompoundBrandStroke);}"
		],
		h: [
			".ftmjh5b:hover,.ftmjh5b:focus-within{border-top-color:var(--colorTransparentStrokeInteractive);}",
			".f17blpuu:hover,.f17blpuu:focus-within{border-right-color:var(--colorTransparentStrokeInteractive);}",
			".fsrcdbj:hover,.fsrcdbj:focus-within{border-left-color:var(--colorTransparentStrokeInteractive);}",
			".f1tpwn32:hover,.f1tpwn32:focus-within{border-bottom-color:var(--colorTransparentStrokeInteractive);}",
			[".f9mts5e:hover{border:var(--strokeWidthThin) solid var(--colorNeutralStroke1Hover);}", { p: -2 }],
			".f1l4zc64:hover{border-bottom-color:var(--colorNeutralStrokeAccessibleHover);}"
		],
		a: [[".f1acnei2:active{border:var(--strokeWidthThin) solid var(--colorNeutralStroke1Pressed);}", { p: -2 }], ".f1z0osm6:active{border-bottom-color:var(--colorNeutralStrokeAccessiblePressed);}"]
	});
	/**
	* Styles for the textarea slot
	*/
	const useTextareaStyles = /* @__PURE__ */ __styles({
		base: {
			icvyot: "f1ern45e",
			vrafjx: ["f1n71otn", "f1deefiw"],
			oivjwe: "f1h8hb77",
			wvpqe5: ["f1deefiw", "f1n71otn"],
			jrapky: 0,
			Frg6f3: 0,
			t21cq0: 0,
			B6of3ja: 0,
			B74szlk: "f1s184ao",
			De3pzq: "f3rmtva",
			B7ck84d: "f1ewtqcl",
			sj55zd: "f19n0e5",
			Bh6795r: "fqerorx",
			Bahqtrf: "fk6fouc",
			Bqenvij: "f1l02sjl",
			yvdlaj: "fwyc1cq",
			B3o7kgh: "f13ta7ih",
			oeaueh: "f1s6fcnf"
		},
		disabled: {
			sj55zd: "f1s2aq7o",
			Bceei9c: "fdrzuqr",
			yvdlaj: "fahhnxm"
		},
		small: {
			sshi5w: "f1w5jphr",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f1pnffij",
			Bxyxcbc: "f192z54u",
			Bahqtrf: "fk6fouc",
			Be2twd7: "fy9rknc",
			Bhrd7zp: "figsok6",
			Bg96gwp: "fwrc4pm"
		},
		medium: {
			sshi5w: "fvmd9f",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f1ww82xo",
			Bxyxcbc: "f1if7ixc",
			Bahqtrf: "fk6fouc",
			Be2twd7: "fkhj508",
			Bhrd7zp: "figsok6",
			Bg96gwp: "f1i3iumi"
		},
		large: {
			sshi5w: "f1kfson",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f15hvtkj",
			Bxyxcbc: "f3kip1f",
			Bahqtrf: "fk6fouc",
			Be2twd7: "fod5ikn",
			Bhrd7zp: "figsok6",
			Bg96gwp: "faaz57k"
		}
	}, { d: [
		".f1ern45e{border-top-style:none;}",
		".f1n71otn{border-right-style:none;}",
		".f1deefiw{border-left-style:none;}",
		".f1h8hb77{border-bottom-style:none;}",
		[".f1s184ao{margin:0;}", { p: -1 }],
		".f3rmtva{background-color:transparent;}",
		".f1ewtqcl{box-sizing:border-box;}",
		".f19n0e5{color:var(--colorNeutralForeground1);}",
		".fqerorx{flex-grow:1;}",
		".fk6fouc{font-family:var(--fontFamilyBase);}",
		".f1l02sjl{height:100%;}",
		".fwyc1cq::-webkit-input-placeholder{color:var(--colorNeutralForeground4);}",
		".fwyc1cq::-moz-placeholder{color:var(--colorNeutralForeground4);}",
		".f13ta7ih::-webkit-input-placeholder{opacity:1;}",
		".f13ta7ih::-moz-placeholder{opacity:1;}",
		".f1s6fcnf{outline-style:none;}",
		".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}",
		".fdrzuqr{cursor:not-allowed;}",
		".fahhnxm::-webkit-input-placeholder{color:var(--colorNeutralForegroundDisabled);}",
		".fahhnxm::-moz-placeholder{color:var(--colorNeutralForegroundDisabled);}",
		".f1w5jphr{min-height:40px;}",
		[".f1pnffij{padding:var(--spacingVerticalXS) calc(var(--spacingHorizontalSNudge) + var(--spacingHorizontalXXS));}", { p: -1 }],
		".f192z54u{max-height:200px;}",
		".fy9rknc{font-size:var(--fontSizeBase200);}",
		".figsok6{font-weight:var(--fontWeightRegular);}",
		".fwrc4pm{line-height:var(--lineHeightBase200);}",
		".fvmd9f{min-height:52px;}",
		[".f1ww82xo{padding:var(--spacingVerticalSNudge) calc(var(--spacingHorizontalMNudge) + var(--spacingHorizontalXXS));}", { p: -1 }],
		".f1if7ixc{max-height:260px;}",
		".fkhj508{font-size:var(--fontSizeBase300);}",
		".f1i3iumi{line-height:var(--lineHeightBase300);}",
		".f1kfson{min-height:64px;}",
		[".f15hvtkj{padding:var(--spacingVerticalS) calc(var(--spacingHorizontalM) + var(--spacingHorizontalXXS));}", { p: -1 }],
		".f3kip1f{max-height:320px;}",
		".fod5ikn{font-size:var(--fontSizeBase400);}",
		".faaz57k{line-height:var(--lineHeightBase400);}"
	] });
	/**
	* Styles for the textarea's resize property
	*/
	const useTextareaResizeStyles = /* @__PURE__ */ __styles({
		none: { B3rzk8w: "f1o1s39h" },
		both: { B3rzk8w: "f1pxm0xe" },
		horizontal: { B3rzk8w: "fq6nmtn" },
		vertical: { B3rzk8w: "f1f5ktr4" }
	}, { d: [
		".f1o1s39h{resize:none;}",
		".f1pxm0xe{resize:both;}",
		".fq6nmtn{resize:horizontal;}",
		".f1f5ktr4{resize:vertical;}"
	] });
	/**
	* Apply styling to the Textarea slots based on the state
	*/
	const useTextareaStyles_unstable = (state) => {
		"use no memo";
		const { size: size$2, appearance, resize } = state;
		const disabled = state.textarea.disabled;
		const invalid = `${state.textarea["aria-invalid"]}` === "true";
		const filled = appearance.startsWith("filled");
		const rootStyles = useRootStyles$13();
		state.root.className = mergeClasses(textareaClassNames.root, rootStyles.base, disabled && rootStyles.disabled, !disabled && filled && rootStyles.filled, !disabled && rootStyles[appearance], !disabled && rootStyles.interactive, !disabled && appearance === "outline" && rootStyles.outlineInteractive, !disabled && invalid && rootStyles.invalid, state.root.className);
		const textareaStyles = useTextareaStyles();
		const textareaResizeStyles = useTextareaResizeStyles();
		state.textarea.className = mergeClasses(textareaClassNames.textarea, textareaStyles.base, textareaStyles[size$2], textareaResizeStyles[resize], disabled && textareaStyles.disabled, state.textarea.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-textarea/lib/components/Textarea/Textarea.js
/**
	* The Textarea component allows the user to enter and edit text in multiple lines.
	*/ const Textarea = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useTextarea_unstable(props, ref);
		useTextareaStyles_unstable(state);
		useCustomStyleHook("useTextareaStyles_unstable")(state);
		return renderTextarea_unstable(state);
	});
	Textarea.displayName = "Textarea";

//#endregion
//#region node_modules/@fluentui/react-dialog/lib/utils/useDisableBodyScroll.styles.js
	const useHTMLNoScrollStyles = /* @__PURE__ */ __resetStyles("r6pzz3z", null, [".r6pzz3z{overflow-y:hidden;overflow-y:clip;scrollbar-gutter:stable;}"]);
	const useBodyNoScrollStyles = /* @__PURE__ */ __resetStyles("r144vlu9", null, [".r144vlu9{overflow-y:hidden;}"]);

//#endregion
//#region node_modules/@fluentui/react-dialog/lib/utils/useDisableBodyScroll.js
/**
	* @internal
	* A React *hook* that disables body scrolling through `overflowY: hidden` CSS property
	*/ function useDisableBodyScroll() {
		const htmlNoScrollStyles = useHTMLNoScrollStyles();
		const bodyNoScrollStyles = useBodyNoScrollStyles();
		const { targetDocument } = useFluent();
		return {
			disableBodyScroll: react.useCallback(() => {
				var _targetDocument_defaultView;
				if (!targetDocument) return;
				var _targetDocument_defaultView_innerHeight;
				if (!(Math.floor(targetDocument.body.getBoundingClientRect().height) > ((_targetDocument_defaultView_innerHeight = (_targetDocument_defaultView = targetDocument.defaultView) === null || _targetDocument_defaultView === void 0 ? void 0 : _targetDocument_defaultView.innerHeight) !== null && _targetDocument_defaultView_innerHeight !== void 0 ? _targetDocument_defaultView_innerHeight : 0))) return;
				targetDocument.documentElement.classList.add(htmlNoScrollStyles);
				targetDocument.body.classList.add(bodyNoScrollStyles);
			}, [
				targetDocument,
				htmlNoScrollStyles,
				bodyNoScrollStyles
			]),
			enableBodyScroll: react.useCallback(() => {
				if (!targetDocument) return;
				targetDocument.documentElement.classList.remove(htmlNoScrollStyles);
				targetDocument.body.classList.remove(bodyNoScrollStyles);
			}, [
				targetDocument,
				htmlNoScrollStyles,
				bodyNoScrollStyles
			])
		};
	}

//#endregion
//#region node_modules/@fluentui/react-dialog/lib/utils/useFocusFirstElement.js
/**
	* Focus first element on content when dialog is opened,
	*/ function useFocusFirstElement(open, modalType) {
		const { findFirstFocusable } = useFocusFinders();
		const { targetDocument } = useFluent();
		const dialogRef = react.useRef(null);
		react.useEffect(() => {
			if (!open) return;
			const element = dialogRef.current && findFirstFocusable(dialogRef.current);
			if (element) element.focus();
			else {
				var _dialogRef_current;
				(_dialogRef_current = dialogRef.current) === null || _dialogRef_current === void 0 || _dialogRef_current.focus();
				console.warn(`@fluentui/react-dialog [useFocusFirstElement]:
A Dialog should have at least one focusable element inside DialogSurface.
Please add at least a close button either on \`DialogTitle\` action slot or inside \`DialogActions\``);
			}
		}, [
			findFirstFocusable,
			open,
			modalType,
			targetDocument
		]);
		return dialogRef;
	}

//#endregion
//#region node_modules/@fluentui/react-dialog/lib/contexts/dialogContext.js
	const defaultContextValue$3 = {
		open: false,
		inertTrapFocus: false,
		modalType: "modal",
		isNestedDialog: false,
		unmountOnClose: true,
		dialogRef: { current: null },
		requestOpenChange() {}
	};
	const DialogContext = createContext(void 0);
	const DialogProvider = DialogContext.Provider;
	const useDialogContext_unstable = (selector) => useContextSelector(DialogContext, (ctx = defaultContextValue$3) => selector(ctx));

//#endregion
//#region node_modules/@fluentui/react-dialog/lib/contexts/dialogSurfaceContext.js
	const defaultContextValue$2 = false;
	const DialogSurfaceContext = react.createContext(void 0);
	const DialogSurfaceProvider = DialogSurfaceContext.Provider;
	const useDialogSurfaceContext_unstable = () => {
		var _React_useContext;
		return (_React_useContext = react.useContext(DialogSurfaceContext)) !== null && _React_useContext !== void 0 ? _React_useContext : defaultContextValue$2;
	};

//#endregion
//#region node_modules/@fluentui/react-dialog/lib/components/DialogSurfaceMotion.js
	const DialogSurfaceMotion = createPresenceComponentVariant(Scale, {
		fromScale: .85,
		easing: motionTokens.curveDecelerateMid,
		duration: motionTokens.durationGentle,
		exitEasing: motionTokens.curveAccelerateMin,
		exitDuration: motionTokens.durationGentle
	});

//#endregion
//#region node_modules/@fluentui/react-dialog/lib/components/Dialog/useDialog.js
/**
	* Create the state required to render Dialog.
	*
	* The returned state can be modified with hooks such as useDialogStyles_unstable,
	* before being passed to renderDialog_unstable.
	*
	* @param props - props from this instance of Dialog
	*/ const useDialog_unstable = (props) => {
		const { children, modalType = "modal", onOpenChange, inertTrapFocus = false, unmountOnClose = true } = props;
		const dialogTitleId = useId("dialog-title-");
		const [trigger, content] = childrenToTriggerAndContent(children);
		const [open, setOpen] = useControllableState({
			state: props.open,
			defaultState: props.defaultOpen,
			initialState: false
		});
		const requestOpenChange = useEventCallback((data) => {
			onOpenChange === null || onOpenChange === void 0 || onOpenChange(data.event, data);
			if (!data.event.isDefaultPrevented()) setOpen(data.open);
		});
		const dialogRef = useFocusFirstElement(open, modalType);
		const { modalAttributes, triggerAttributes } = useModalAttributes({
			trapFocus: modalType !== "non-modal",
			legacyTrapFocus: !inertTrapFocus
		});
		const isNestedDialog = useHasParentContext(DialogContext);
		return {
			components: { surfaceMotion: DialogSurfaceMotion },
			inertTrapFocus,
			open,
			modalType,
			content,
			trigger,
			requestOpenChange,
			dialogTitleId,
			isNestedDialog,
			unmountOnClose,
			dialogRef,
			modalAttributes,
			triggerAttributes,
			surfaceMotion: presenceMotionSlot(props.surfaceMotion, {
				elementType: DialogSurfaceMotion,
				defaultProps: {
					visible: open,
					appear: unmountOnClose,
					unmountOnExit: unmountOnClose
				}
			})
		};
	};
	/**
	* Extracts trigger and content from children
	*/ function childrenToTriggerAndContent(children) {
		const childrenArray = react.Children.toArray(children);
		if (childrenArray.length !== 1 && childrenArray.length !== 2) console.warn(`@fluentui/react-dialog [useDialog]:
Dialog must contain at least one child <DialogSurface/>,
and at most two children <DialogTrigger/> <DialogSurface/> (in this order).`);
		switch (childrenArray.length) {
			case 2: return childrenArray;
			case 1: return [void 0, childrenArray[0]];
			default: return [void 0, void 0];
		}
	}

//#endregion
//#region node_modules/@fluentui/react-dialog/lib/components/MotionRefForwarder.js
	const MotionRefForwarderContext$1 = /* @__PURE__ */ react.createContext(void 0);
	/**
	* @internal
	*/ function useMotionForwardedRef$1() {
		return react.useContext(MotionRefForwarderContext$1);
	}
	/**
	* A component that forwards a ref to its children via a React context.
	*
	* @internal
	*/ const MotionRefForwarder$1 = /* @__PURE__ */ react.forwardRef((props, ref) => {
		return /* @__PURE__ */ react.createElement(MotionRefForwarderContext$1.Provider, { value: ref }, props.children);
	});

//#endregion
//#region node_modules/@fluentui/react-dialog/lib/components/Dialog/renderDialog.js
/**
	* Render the final JSX of Dialog
	*/ const renderDialog_unstable = (state, contextValues) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(DialogProvider, {
			value: contextValues.dialog,
			children: /* @__PURE__ */ jsxs(DialogSurfaceProvider, {
				value: contextValues.dialogSurface,
				children: [state.trigger, state.content && /* @__PURE__ */ jsx(state.surfaceMotion, { children: /* @__PURE__ */ jsx(MotionRefForwarder$1, { children: state.content }) })]
			})
		});
	};

//#endregion
//#region node_modules/@fluentui/react-dialog/lib/components/Dialog/useDialogContextValues.js
	function useDialogContextValues_unstable(state) {
		const { modalType, open, dialogRef, dialogTitleId, isNestedDialog, inertTrapFocus, requestOpenChange, modalAttributes, triggerAttributes, unmountOnClose } = state;
		return {
			dialog: {
				open,
				modalType,
				dialogRef,
				dialogTitleId,
				isNestedDialog,
				inertTrapFocus,
				modalAttributes,
				triggerAttributes,
				unmountOnClose,
				requestOpenChange
			},
			dialogSurface: false
		};
	}

//#endregion
//#region node_modules/@fluentui/react-dialog/lib/components/Dialog/Dialog.js
/**
	* The `Dialog` root level component serves as an interface for interaction with all possible behaviors exposed.
	* It provides context down the hierarchy to `children` compound components to allow functionality.
	* This component expects to receive as children either a `DialogSurface` or a `DialogTrigger`
	* and a `DialogSurface` (or some component that will eventually render one of those compound components)
	* in this specific order
	*/ const Dialog = /* @__PURE__ */ react.memo((props) => {
		const state = useDialog_unstable(props);
		return renderDialog_unstable(state, useDialogContextValues_unstable(state));
	});
	Dialog.displayName = "Dialog";

//#endregion
//#region node_modules/@fluentui/react-dialog/lib/components/DialogTrigger/useDialogTrigger.js
/**
	* Create the state required to render DialogTrigger.
	* Clones the only child component and adds necessary event handling behaviours to open a popup Dialog
	*
	* @param props - props from this instance of DialogTrigger
	*/ const useDialogTrigger_unstable = (props) => {
		const isInsideSurfaceDialog = useDialogSurfaceContext_unstable();
		const { children, disableButtonEnhancement = false, action = isInsideSurfaceDialog ? "close" : "open" } = props;
		const child = getTriggerChild(children);
		const requestOpenChange = useDialogContext_unstable((ctx) => ctx.requestOpenChange);
		const { triggerAttributes } = useModalAttributes();
		const handleClick = useEventCallback((event) => {
			var _child_props_onClick, _child_props;
			child === null || child === void 0 || (_child_props_onClick = (_child_props = child.props).onClick) == null || _child_props_onClick.call(_child_props, event);
			if (!event.isDefaultPrevented()) requestOpenChange({
				event,
				type: "triggerClick",
				open: action === "open"
			});
		});
		const triggerChildProps = {
			...child === null || child === void 0 ? void 0 : child.props,
			ref: getReactElementRef(child),
			onClick: handleClick,
			...triggerAttributes
		};
		const ariaButtonTriggerChildProps = useARIAButtonProps((child === null || child === void 0 ? void 0 : child.type) === "button" || (child === null || child === void 0 ? void 0 : child.type) === "a" ? child.type : "div", {
			...triggerChildProps,
			type: "button"
		});
		return { children: applyTriggerPropsToChildren(children, disableButtonEnhancement ? triggerChildProps : ariaButtonTriggerChildProps) };
	};

//#endregion
//#region node_modules/@fluentui/react-dialog/lib/components/DialogTrigger/renderDialogTrigger.js
/**
	* Render the final JSX of MenuTrigger
	*
	* Only renders children
	*/ const renderDialogTrigger_unstable = (state) => state.children;

//#endregion
//#region node_modules/@fluentui/react-dialog/lib/components/DialogTrigger/DialogTrigger.js
/**
	* A non-visual component that wraps its child
	* and configures them to be the trigger that will open or close a `Dialog`.
	* This component should only accept one child.
	*
	* This component sole purpose is to avoid opting out of the internal controlled open state of a `Dialog`
	* Besides being a trigger that opens/close a dialog through context this component doesn't do much,
	* making it basically unnecessary in cases where the trigger is outside of the `Dialog` component.
	*/ const DialogTrigger = (props) => {
		return renderDialogTrigger_unstable(useDialogTrigger_unstable(props));
	};
	DialogTrigger.displayName = "DialogTrigger";
	DialogTrigger.isFluentTriggerComponent = true;

//#endregion
//#region node_modules/@fluentui/react-dialog/lib/components/DialogActions/useDialogActions.js
/**
	* Create the state required to render DialogActions.
	*
	* The returned state can be modified with hooks such as useDialogActionsStyles_unstable,
	* before being passed to renderDialogActions_unstable.
	*
	* @param props - props from this instance of DialogActions
	* @param ref - reference to root HTMLElement of DialogActions
	*/ const useDialogActions_unstable = (props, ref) => {
		const { position: position$1 = "end", fluid = false } = props;
		return {
			components: { root: "div" },
			root: always(getIntrinsicElementProps("div", {
				ref,
				...props
			}), { elementType: "div" }),
			position: position$1,
			fluid
		};
	};

//#endregion
//#region node_modules/@fluentui/react-dialog/lib/components/DialogActions/renderDialogActions.js
/**
	* Render the final JSX of DialogActions
	*/ const renderDialogActions_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, {});
	};

//#endregion
//#region node_modules/@fluentui/react-dialog/lib/components/DialogActions/useDialogActionsStyles.styles.js
	const dialogActionsClassNames = { root: "fui-DialogActions" };
	/**
	* Styles for the root slot
	*/
	const useResetStyles$4 = /* @__PURE__ */ __resetStyles("rhfpeu0", null, {
		r: [".rhfpeu0{gap:8px;height:fit-content;box-sizing:border-box;display:flex;grid-row-start:3;grid-row-end:3;}"],
		s: ["@media screen and (max-width: 480px){.rhfpeu0{flex-direction:column;justify-self:stretch;}}"]
	});
	const useStyles$74 = /* @__PURE__ */ __styles({
		gridPositionEnd: {
			Bdqf98w: "f1a7i8kp",
			Br312pm: "fd46tj4",
			Bw0ie65: "fsyjsko",
			Btsd7tp: "f1n00o3b",
			ufxxby: "f1mvsp37",
			Bq5p579: "flbz1vp"
		},
		gridPositionStart: {
			Bdqf98w: "fsxvdwy",
			Br312pm: "fwpfdsa",
			Bw0ie65: "f1e2fz10",
			Ew0qkd: "f119phc2",
			ufxxby: "f1j719yo",
			Bq5p579: "flbz1vp"
		},
		fluidStart: { Bw0ie65: "fsyjsko" },
		fluidEnd: { Br312pm: "fwpfdsa" }
	}, {
		d: [
			".f1a7i8kp{justify-self:end;}",
			".fd46tj4{grid-column-start:2;}",
			".fsyjsko{grid-column-end:4;}",
			".fsxvdwy{justify-self:start;}",
			".fwpfdsa{grid-column-start:1;}",
			".f1e2fz10{grid-column-end:2;}"
		],
		m: [
			["@media screen and (max-width: 480px){.f1n00o3b{grid-column-start:1;}}", { m: "screen and (max-width: 480px)" }],
			["@media screen and (max-width: 480px){.f1mvsp37{grid-row-start:4;}}", { m: "screen and (max-width: 480px)" }],
			["@media screen and (max-width: 480px){.flbz1vp{grid-row-end:auto;}}", { m: "screen and (max-width: 480px)" }],
			["@media screen and (max-width: 480px){.f119phc2{grid-column-end:4;}}", { m: "screen and (max-width: 480px)" }],
			["@media screen and (max-width: 480px){.f1j719yo{grid-row-start:3;}}", { m: "screen and (max-width: 480px)" }]
		]
	});
	/**
	* Apply styling to the DialogActions slots based on the state
	*/
	const useDialogActionsStyles_unstable = (state) => {
		"use no memo";
		const resetStyles = useResetStyles$4();
		const styles = useStyles$74();
		state.root.className = mergeClasses(dialogActionsClassNames.root, resetStyles, state.position === "start" && styles.gridPositionStart, state.position === "end" && styles.gridPositionEnd, state.fluid && state.position === "start" && styles.fluidStart, state.fluid && state.position === "end" && styles.fluidEnd, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-dialog/lib/components/DialogActions/DialogActions.js
/**
	* `DialogActions` is a container for the actions of the dialog.
	* Apart from styling, this component does not have other behavior.
	*/ const DialogActions = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useDialogActions_unstable(props, ref);
		useDialogActionsStyles_unstable(state);
		useCustomStyleHook("useDialogActionsStyles_unstable")(state);
		return renderDialogActions_unstable(state);
	});
	DialogActions.displayName = "DialogActions";

//#endregion
//#region node_modules/@fluentui/react-dialog/lib/components/DialogBody/useDialogBody.js
/**
	* Create the state required to render DialogBody.
	*
	* The returned state can be modified with hooks such as useDialogBodyStyles_unstable,
	* before being passed to renderDialogBody_unstable.
	*
	* @param props - props from this instance of DialogBody
	* @param ref - reference to root HTMLElement of DialogBody
	*/ const useDialogBody_unstable = (props, ref) => {
		var _props_as;
		return {
			components: { root: "div" },
			root: always(getIntrinsicElementProps((_props_as = props.as) !== null && _props_as !== void 0 ? _props_as : "div", {
				ref,
				...props
			}), { elementType: "div" })
		};
	};

//#endregion
//#region node_modules/@fluentui/react-dialog/lib/components/DialogBody/renderDialogBody.js
/**
	* Render the final JSX of DialogBody
	*/ const renderDialogBody_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, {});
	};

//#endregion
//#region node_modules/@fluentui/react-dialog/lib/components/DialogBody/useDialogBodyStyles.styles.js
	const dialogBodyClassNames = { root: "fui-DialogBody" };
	/**
	* Styles for the root slot
	*/
	const useResetStyles$3 = /* @__PURE__ */ __resetStyles("rhwx3p8", null, {
		r: [".rhwx3p8{overflow:unset;gap:8px;display:grid;max-height:calc(100vh - 2 * 24px);max-height:calc(100dvh - 2 * 24px);box-sizing:border-box;grid-template-rows:auto 1fr;grid-template-columns:1fr 1fr auto;}"],
		s: ["@media screen and (max-width: 480px){.rhwx3p8{max-width:100vw;grid-template-rows:auto 1fr auto;}}", "@media screen and (max-height: 359px){.rhwx3p8{max-height:unset;}}"]
	});
	/**
	* Apply styling to the DialogBody slots based on the state
	*/
	const useDialogBodyStyles_unstable = (state) => {
		"use no memo";
		const resetStyles = useResetStyles$3();
		state.root.className = mergeClasses(dialogBodyClassNames.root, resetStyles, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-dialog/lib/components/DialogBody/DialogBody.js
/**
	* The `DialogBody` is a container where the content of the dialog is rendered.
	* Apart from styling, this component does not have other behavior.
	*/ const DialogBody = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useDialogBody_unstable(props, ref);
		useDialogBodyStyles_unstable(state);
		useCustomStyleHook("useDialogBodyStyles_unstable")(state);
		return renderDialogBody_unstable(state);
	});
	DialogBody.displayName = "DialogBody";

//#endregion
//#region node_modules/@fluentui/react-dialog/lib/components/DialogTitle/useDialogTitleStyles.styles.js
	const dialogTitleClassNames = {
		root: "fui-DialogTitle",
		action: "fui-DialogTitle__action"
	};
	/**
	* Styles for the root slot
	*/
	const useRootResetStyles = /* @__PURE__ */ __resetStyles("rxjm636", null, [".rxjm636{font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase500);font-weight:var(--fontWeightSemibold);line-height:var(--lineHeightBase500);margin:0;grid-row-start:1;grid-row-end:1;grid-column-start:1;grid-column-end:3;}"]);
	const useStyles$73 = /* @__PURE__ */ __styles({ rootWithoutAction: { Bw0ie65: "fsyjsko" } }, { d: [".fsyjsko{grid-column-end:4;}"] });
	/**
	* Styles for the action slot
	*/
	const useActionResetStyles = /* @__PURE__ */ __resetStyles("r13kcrze", null, [".r13kcrze{grid-row-start:1;grid-row-end:1;grid-column-start:3;justify-self:end;align-self:start;}"]);
	/**
	* Styles to be applied on internal elements used by default action on non-modal Dialog
	* @internal
	*/
	const useDialogTitleInternalStyles = /* @__PURE__ */ __resetStyles("r2avt6e", "roj2bbc", {
		r: [
			".r2avt6e{overflow:visible;padding:0;border-style:none;position:relative;box-sizing:content-box;background-color:inherit;color:inherit;font-family:inherit;font-size:inherit;cursor:pointer;line-height:0;-webkit-appearance:button;text-align:unset;}",
			".r2avt6e:focus{outline-style:none;}",
			".r2avt6e:focus-visible{outline-style:none;}",
			".r2avt6e[data-fui-focus-visible]{border-top-color:transparent;border-right-color:transparent;border-bottom-color:transparent;border-left-color:transparent;}",
			".r2avt6e[data-fui-focus-visible]::after{content:\"\";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);right:calc(2px * -1);bottom:calc(2px * -1);left:calc(2px * -1);}",
			".roj2bbc{overflow:visible;padding:0;border-style:none;position:relative;box-sizing:content-box;background-color:inherit;color:inherit;font-family:inherit;font-size:inherit;cursor:pointer;line-height:0;-webkit-appearance:button;text-align:unset;}",
			".roj2bbc:focus{outline-style:none;}",
			".roj2bbc:focus-visible{outline-style:none;}",
			".roj2bbc[data-fui-focus-visible]{border-top-color:transparent;border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent;}",
			".roj2bbc[data-fui-focus-visible]::after{content:\"\";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);left:calc(2px * -1);bottom:calc(2px * -1);right:calc(2px * -1);}"
		],
		s: ["@media (forced-colors: active){.r2avt6e[data-fui-focus-visible]::after{border-top-color:Highlight;border-right-color:Highlight;border-bottom-color:Highlight;border-left-color:Highlight;}}", "@media (forced-colors: active){.roj2bbc[data-fui-focus-visible]::after{border-top-color:Highlight;border-left-color:Highlight;border-bottom-color:Highlight;border-right-color:Highlight;}}"]
	});
	/**
	* Apply styling to the DialogTitle slots based on the state
	*/
	const useDialogTitleStyles_unstable = (state) => {
		"use no memo";
		const rootResetStyles = useRootResetStyles();
		const actionResetStyles = useActionResetStyles();
		const styles = useStyles$73();
		state.root.className = mergeClasses(dialogTitleClassNames.root, rootResetStyles, !state.action && styles.rootWithoutAction, state.root.className);
		if (state.action) state.action.className = mergeClasses(dialogTitleClassNames.action, actionResetStyles, state.action.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-dialog/lib/components/DialogTitle/useDialogTitle.js
/**
	* Create the state required to render DialogTitle.
	*
	* The returned state can be modified with hooks such as useDialogTitleStyles_unstable,
	* before being passed to renderDialogTitle_unstable.
	*
	* @param props - props from this instance of DialogTitle
	* @param ref - reference to root HTMLElement of DialogTitle
	*/ const useDialogTitle_unstable = (props, ref) => {
		const { action } = props;
		const modalType = useDialogContext_unstable((ctx) => ctx.modalType);
		const internalStyles = useDialogTitleInternalStyles();
		return {
			components: {
				root: "h2",
				action: "div"
			},
			root: always(getIntrinsicElementProps("h2", {
				ref,
				id: useDialogContext_unstable((ctx) => ctx.dialogTitleId),
				...props
			}), { elementType: "h2" }),
			action: optional(action, {
				renderByDefault: modalType === "non-modal",
				defaultProps: { children: /* @__PURE__ */ react.createElement(DialogTrigger, {
					disableButtonEnhancement: true,
					action: "close"
				}, /* @__PURE__ */ react.createElement("button", {
					type: "button",
					className: internalStyles,
					"aria-label": "close"
				}, /* @__PURE__ */ react.createElement(Dismiss20Regular, null))) },
				elementType: "div"
			})
		};
	};

//#endregion
//#region node_modules/@fluentui/react-dialog/lib/components/DialogTitle/renderDialogTitle.js
/**
	* Render the final JSX of DialogTitle
	*/ const renderDialogTitle_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(react.Fragment, { children: [/* @__PURE__ */ jsx(state.root, { children: state.root.children }), state.action && /* @__PURE__ */ jsx(state.action, {})] });
	};

//#endregion
//#region node_modules/@fluentui/react-dialog/lib/components/DialogTitle/DialogTitle.js
/**
	* The `DialogTitle` component expects to have a title/header
	* and when `Dialog` is `non-modal` a close (X icon) button is provided through `action` slot by default.
	*/ const DialogTitle = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useDialogTitle_unstable(props, ref);
		useDialogTitleStyles_unstable(state);
		useCustomStyleHook("useDialogTitleStyles_unstable")(state);
		return renderDialogTitle_unstable(state);
	});
	DialogTitle.displayName = "DialogTitle";

//#endregion
//#region node_modules/@fluentui/react-dialog/lib/components/DialogBackdropMotion.js
	const DialogBackdropMotion = FadeRelaxed;

//#endregion
//#region node_modules/@fluentui/react-dialog/lib/components/DialogSurface/useDialogSurface.js
/**
	* Create the state required to render DialogSurface.
	*
	* The returned state can be modified with hooks such as useDialogSurfaceStyles_unstable,
	* before being passed to renderDialogSurface_unstable.
	*
	* @param props - props from this instance of DialogSurface
	* @param ref - reference to root HTMLElement of DialogSurface
	*/ const useDialogSurface_unstable = (props, ref) => {
		const contextRef = useMotionForwardedRef$1();
		const modalType = useDialogContext_unstable((ctx) => ctx.modalType);
		const isNestedDialog = useDialogContext_unstable((ctx) => ctx.isNestedDialog);
		const modalAttributes = useDialogContext_unstable((ctx) => ctx.modalAttributes);
		const dialogRef = useDialogContext_unstable((ctx) => ctx.dialogRef);
		const requestOpenChange = useDialogContext_unstable((ctx) => ctx.requestOpenChange);
		const dialogTitleID = useDialogContext_unstable((ctx) => ctx.dialogTitleId);
		const open = useDialogContext_unstable((ctx) => ctx.open);
		const unmountOnClose = useDialogContext_unstable((ctx) => ctx.unmountOnClose);
		const handledBackdropClick = useEventCallback((event) => {
			if (isResolvedShorthand(props.backdrop)) {
				var _props_backdrop_onClick, _props_backdrop;
				(_props_backdrop_onClick = (_props_backdrop = props.backdrop).onClick) === null || _props_backdrop_onClick === void 0 || _props_backdrop_onClick.call(_props_backdrop, event);
			}
			if (modalType === "modal" && !event.isDefaultPrevented()) requestOpenChange({
				event,
				open: false,
				type: "backdropClick"
			});
		});
		const handleKeyDown = useEventCallback((event) => {
			var _props_onKeyDown;
			(_props_onKeyDown = props.onKeyDown) === null || _props_onKeyDown === void 0 || _props_onKeyDown.call(props, event);
			if (event.key === Escape && !event.isDefaultPrevented()) {
				requestOpenChange({
					event,
					open: false,
					type: "escapeKeyDown"
				});
				event.preventDefault();
			}
		});
		const backdrop = optional(props.backdrop, {
			renderByDefault: modalType !== "non-modal",
			defaultProps: { "aria-hidden": "true" },
			elementType: "div"
		});
		if (backdrop) backdrop.onClick = handledBackdropClick;
		const { disableBodyScroll, enableBodyScroll } = useDisableBodyScroll();
		useIsomorphicLayoutEffect(() => {
			if (!open) {
				enableBodyScroll();
				return;
			}
			if (isNestedDialog || modalType === "non-modal") return;
			disableBodyScroll();
			return () => enableBodyScroll();
		}, [
			open,
			modalType,
			isNestedDialog,
			disableBodyScroll,
			enableBodyScroll
		]);
		return {
			components: {
				backdrop: "div",
				root: "div",
				backdropMotion: DialogBackdropMotion
			},
			open,
			backdrop,
			isNestedDialog,
			unmountOnClose,
			mountNode: props.mountNode,
			root: always(getIntrinsicElementProps("div", {
				tabIndex: -1,
				role: modalType === "alert" ? "alertdialog" : "dialog",
				"aria-modal": modalType !== "non-modal",
				"aria-labelledby": props["aria-label"] ? void 0 : dialogTitleID,
				"aria-hidden": !unmountOnClose && !open ? true : void 0,
				...props,
				...modalAttributes,
				onKeyDown: handleKeyDown,
				ref: useMergedRefs(ref, contextRef, dialogRef)
			}), { elementType: "div" }),
			backdropMotion: presenceMotionSlot(props.backdropMotion, {
				elementType: DialogBackdropMotion,
				defaultProps: {
					appear: unmountOnClose,
					visible: open
				}
			}),
			transitionStatus: void 0
		};
	};

//#endregion
//#region node_modules/@fluentui/react-dialog/lib/components/DialogSurface/renderDialogSurface.js
/**
	* Render the final JSX of DialogSurface
	*/ const renderDialogSurface_unstable = (state, contextValues) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(Portal, {
			mountNode: state.mountNode,
			children: [state.backdrop && state.backdropMotion && /* @__PURE__ */ jsx(state.backdropMotion, { children: /* @__PURE__ */ jsx(state.backdrop, {}) }), /* @__PURE__ */ jsx(DialogSurfaceProvider, {
				value: contextValues.dialogSurface,
				children: /* @__PURE__ */ jsx(state.root, {})
			})]
		});
	};

//#endregion
//#region node_modules/@fluentui/react-dialog/lib/components/DialogSurface/useDialogSurfaceStyles.styles.js
	const dialogSurfaceClassNames = {
		root: "fui-DialogSurface",
		backdrop: "fui-DialogSurface__backdrop"
	};
	/**
	* Styles for the root slot
	*/
	const useRootBaseStyle$1 = /* @__PURE__ */ __resetStyles("r1u3t6p6", "r5coedp", {
		r: [
			".r1u3t6p6{inset:0;padding:24px;margin:auto;border-style:none;overflow:unset;border:1px solid var(--colorTransparentStroke);border-radius:var(--borderRadiusXLarge);display:block;-webkit-user-select:unset;-moz-user-select:unset;user-select:unset;visibility:unset;position:fixed;height:fit-content;max-width:600px;max-height:100vh;max-height:100dvh;box-sizing:border-box;background-color:var(--colorNeutralBackground1);color:var(--colorNeutralForeground1);box-shadow:var(--shadow64);}",
			".r1u3t6p6:focus{outline-style:none;}",
			".r1u3t6p6:focus-visible{outline-style:none;}",
			".r1u3t6p6[data-fui-focus-visible]{border-top-color:transparent;border-right-color:transparent;border-bottom-color:transparent;border-left-color:transparent;}",
			".r1u3t6p6[data-fui-focus-visible]::after{content:\"\";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);right:calc(2px * -1);bottom:calc(2px * -1);left:calc(2px * -1);}",
			".r5coedp{inset:0;padding:24px;margin:auto;border-style:none;overflow:unset;border:1px solid var(--colorTransparentStroke);border-radius:var(--borderRadiusXLarge);display:block;-webkit-user-select:unset;-moz-user-select:unset;user-select:unset;visibility:unset;position:fixed;height:fit-content;max-width:600px;max-height:100vh;max-height:100dvh;box-sizing:border-box;background-color:var(--colorNeutralBackground1);color:var(--colorNeutralForeground1);box-shadow:var(--shadow64);}",
			".r5coedp:focus{outline-style:none;}",
			".r5coedp:focus-visible{outline-style:none;}",
			".r5coedp[data-fui-focus-visible]{border-top-color:transparent;border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent;}",
			".r5coedp[data-fui-focus-visible]::after{content:\"\";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);left:calc(2px * -1);bottom:calc(2px * -1);right:calc(2px * -1);}"
		],
		s: [
			"@media (forced-colors: active){.r1u3t6p6[data-fui-focus-visible]::after{border-top-color:Highlight;border-right-color:Highlight;border-bottom-color:Highlight;border-left-color:Highlight;}}",
			"@media screen and (max-width: 480px){.r1u3t6p6{max-width:100vw;}}",
			"@media screen and (max-height: 359px){.r1u3t6p6{overflow-y:auto;padding-right:calc(24px - 4px);border-right-width:4px;border-top-width:4px;border-bottom-width:4px;}}",
			"@media (forced-colors: active){.r5coedp[data-fui-focus-visible]::after{border-top-color:Highlight;border-left-color:Highlight;border-bottom-color:Highlight;border-right-color:Highlight;}}",
			"@media screen and (max-width: 480px){.r5coedp{max-width:100vw;}}",
			"@media screen and (max-height: 359px){.r5coedp{overflow-y:auto;padding-left:calc(24px - 4px);border-left-width:4px;border-top-width:4px;border-bottom-width:4px;}}"
		]
	});
	const useBackdropBaseStyle = /* @__PURE__ */ __resetStyles("r1e18s3l", null, [".r1e18s3l{inset:0px;background-color:var(--colorBackgroundOverlay);position:fixed;}"]);
	const useStyles$72 = /* @__PURE__ */ __styles({
		nestedDialogBackdrop: { De3pzq: "f1c21dwh" },
		dialogHidden: { Bkecrkj: "f1aehjj5" }
	}, { d: [".f1c21dwh{background-color:var(--colorTransparentBackground);}", ".f1aehjj5{pointer-events:none;}"] });
	/**
	* Apply styling to the DialogSurface slots based on the state
	*/
	const useDialogSurfaceStyles_unstable = (state) => {
		"use no memo";
		const { isNestedDialog, root, backdrop, open, unmountOnClose } = state;
		const rootBaseStyle = useRootBaseStyle$1();
		const backdropBaseStyle = useBackdropBaseStyle();
		const styles = useStyles$72();
		const mountedAndClosed = !unmountOnClose && !open;
		root.className = mergeClasses(dialogSurfaceClassNames.root, rootBaseStyle, mountedAndClosed && styles.dialogHidden, root.className);
		if (backdrop) backdrop.className = mergeClasses(dialogSurfaceClassNames.backdrop, backdropBaseStyle, isNestedDialog && styles.nestedDialogBackdrop, mountedAndClosed && styles.dialogHidden, backdrop.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-dialog/lib/components/DialogSurface/useDialogSurfaceContextValues.js
	function useDialogSurfaceContextValues_unstable(state) {
		return { dialogSurface: true };
	}

//#endregion
//#region node_modules/@fluentui/react-dialog/lib/components/DialogSurface/DialogSurface.js
/**
	* DialogSurface component represents the visual part of a `Dialog` as a whole,
	* it contains everything that should be visible.
	*/ const DialogSurface = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useDialogSurface_unstable(props, ref);
		const contextValues = useDialogSurfaceContextValues_unstable(state);
		useDialogSurfaceStyles_unstable(state);
		useCustomStyleHook("useDialogSurfaceStyles_unstable")(state);
		return renderDialogSurface_unstable(state, contextValues);
	});
	DialogSurface.displayName = "DialogSurface";

//#endregion
//#region node_modules/@fluentui/react-dialog/lib/components/DialogContent/useDialogContent.js
/**
	* Create the state required to render DialogBody.
	*
	* The returned state can be modified with hooks such as useDialogBodyStyles_unstable,
	* before being passed to renderDialogBody_unstable.
	*
	* @param props - props from this instance of DialogBody
	* @param ref - reference to root HTMLElement of DialogBody
	*/ const useDialogContent_unstable = (props, ref) => {
		var _props_as;
		return {
			components: { root: "div" },
			root: always(getIntrinsicElementProps((_props_as = props.as) !== null && _props_as !== void 0 ? _props_as : "div", {
				ref,
				...props
			}), { elementType: "div" })
		};
	};

//#endregion
//#region node_modules/@fluentui/react-dialog/lib/components/DialogContent/renderDialogContent.js
/**
	* Render the final JSX of DialogContent
	*/ const renderDialogContent_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, {});
	};

//#endregion
//#region node_modules/@fluentui/react-dialog/lib/components/DialogContent/useDialogContentStyles.styles.js
	const dialogContentClassNames = { root: "fui-DialogContent" };
	/**
	* Styles for the root slot
	*/
	const useStyles$71 = /* @__PURE__ */ __resetStyles("r1v5zwsm", null, {
		r: [".r1v5zwsm{padding:var(--strokeWidthThick);margin:calc(var(--strokeWidthThick) * -1);font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase300);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase300);overflow-y:auto;min-height:32px;box-sizing:border-box;grid-row-start:2;grid-row-end:2;grid-column-start:1;grid-column-end:4;}"],
		s: ["@media screen and (max-height: 359px){.r1v5zwsm{overflow-y:unset;}}"]
	});
	/**
	* Apply styling to the DialogContent slots based on the state
	*/
	const useDialogContentStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$71();
		state.root.className = mergeClasses(dialogContentClassNames.root, styles, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-dialog/lib/components/DialogContent/DialogContent.js
/**
	* The `DialogContent` is a container where the content of the dialog is rendered.
	* Apart from styling, this component does not have other behavior.
	*/ const DialogContent = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useDialogContent_unstable(props, ref);
		useDialogContentStyles_unstable(state);
		useCustomStyleHook("useDialogContentStyles_unstable")(state);
		return renderDialogContent_unstable(state);
	});
	DialogContent.displayName = "DialogContent";

//#endregion
//#region node_modules/@fluentui/react-progress/lib/utils/clampMax.js
	const clampMax = (max$1) => {
		const internalMax = max$1 <= 0 ? 1 : max$1;
		if (max$1 <= 0) console.error(`The prop 'max' must be greater than 0. Received max: ${max$1}`);
		return internalMax;
	};

//#endregion
//#region node_modules/@fluentui/react-progress/lib/utils/clampValue.js
	const clampValue$1 = (value, max$1) => {
		if (value === void 0) return value;
		const internalValue = value < 0 ? 0 : value > max$1 ? max$1 : value;
		if (value < 0) console.error(`The prop 'value' must be greater than or equal to zero. Received value: ${value}`);
		if (value > max$1) console.error(`The prop 'value' must be less than or equal to 'max'. Received value: ${value}, max: ${max$1}`);
		return internalValue;
	};

//#endregion
//#region node_modules/@fluentui/react-progress/lib/components/ProgressBar/useProgressBar.js
/**
	* Create the state required to render ProgressBar.
	*
	* The returned state can be modified with hooks such as useProgressBarStyles_unstable,
	* before being passed to renderProgressBar_unstable.
	*
	* @param props - props from this instance of ProgressBar
	* @param ref - reference to root HTMLElement of ProgressBar
	*/ const useProgressBar_unstable = (props, ref) => {
		const field = useFieldContext_unstable();
		const fieldState = field === null || field === void 0 ? void 0 : field.validationState;
		const { color: color$1 = fieldState === "error" || fieldState === "warning" || fieldState === "success" ? fieldState : "brand", shape = "rounded", thickness = "medium" } = props;
		var _props_max;
		const max$1 = clampMax((_props_max = props.max) !== null && _props_max !== void 0 ? _props_max : 1);
		const value = clampValue$1(props.value, max$1);
		const root = always(getIntrinsicElementProps("div", {
			ref,
			role: "progressbar",
			"aria-valuemin": value !== void 0 ? 0 : void 0,
			"aria-valuemax": value !== void 0 ? max$1 : void 0,
			"aria-valuenow": value,
			"aria-labelledby": field === null || field === void 0 ? void 0 : field.labelId,
			...props
		}), { elementType: "div" });
		if (field && (field.validationMessageId || field.hintId)) root["aria-describedby"] = [
			field === null || field === void 0 ? void 0 : field.validationMessageId,
			field === null || field === void 0 ? void 0 : field.hintId,
			root["aria-describedby"]
		].filter(Boolean).join(" ");
		return {
			color: color$1,
			max: max$1,
			shape,
			thickness,
			value,
			components: {
				root: "div",
				bar: "div"
			},
			root,
			bar: always(props.bar, { elementType: "div" })
		};
	};

//#endregion
//#region node_modules/@fluentui/react-progress/lib/components/ProgressBar/renderProgressBar.js
/**
	* Render the final JSX of ProgressBar
	*/ const renderProgressBar_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, { children: state.bar && /* @__PURE__ */ jsx(state.bar, {}) });
	};

//#endregion
//#region node_modules/@fluentui/react-progress/lib/components/ProgressBar/useProgressBarStyles.styles.js
	const progressBarClassNames = {
		root: "fui-ProgressBar",
		bar: "fui-ProgressBar__bar"
	};
	const ZERO_THRESHOLD = .01;
	/**
	* Styles for the root slot
	*/
	const useRootStyles$12 = /* @__PURE__ */ __styles({
		root: {
			mc9l5x: "ftgm304",
			De3pzq: "f18f03hv",
			a9b677: "fly5x3f",
			B68tc82: 0,
			Bmxbyg5: 0,
			Bpg54ce: "f1a3p1vp",
			Bomf52o: "f1skxd4g"
		},
		rounded: {
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "ft85np5"
		},
		square: {
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "f1fabniw"
		},
		medium: { Bqenvij: "f4t8t6x" },
		large: { Bqenvij: "f6ywr7j" }
	}, {
		d: [
			".ftgm304{display:block;}",
			".f18f03hv{background-color:var(--colorNeutralBackground6);}",
			".fly5x3f{width:100%;}",
			[".f1a3p1vp{overflow:hidden;}", { p: -1 }],
			[".ft85np5{border-radius:var(--borderRadiusMedium);}", { p: -1 }],
			[".f1fabniw{border-radius:var(--borderRadiusNone);}", { p: -1 }],
			".f4t8t6x{height:2px;}",
			".f6ywr7j{height:4px;}"
		],
		m: [["@media screen and (forced-colors: active){.f1skxd4g{background-color:CanvasText;}}", { m: "screen and (forced-colors: active)" }]]
	});
	/**
	* Styles for the ProgressBar bar
	*/
	const useBarStyles = /* @__PURE__ */ __styles({
		base: {
			Bomf52o: "f1tnpuu0",
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "f12b9xdw",
			Bqenvij: "f1l02sjl"
		},
		nonZeroDeterminate: {
			Bmy1vo4: "fjt6zfz",
			B3o57yi: "f1wofebd",
			Bkqvd7p: "fv71qf3"
		},
		indeterminate: {
			B2u0y6b: "fa0wk36",
			qhf8xq: "f10pi13n",
			Bcmaq0h: ["fpo0yib", "f1u5hf6c"],
			Bv12yb3: ["fwd2bol", "f14gig94"],
			vin17d: "f1a27w2r",
			Ezkn3b: "f452v7t",
			w3vfg9: "f1cpbl36",
			jpy9cc: "f3z2g5w",
			Bqo2lbl: "fz5izi4",
			B6plc1d: "fv40pdu",
			I82g5a: "f1uj6jbf"
		},
		brand: { De3pzq: "ftywsgz" },
		error: { De3pzq: "fdl5y0r" },
		warning: { De3pzq: "f1s438gw" },
		success: { De3pzq: "flxk52p" }
	}, {
		m: [
			["@media screen and (forced-colors: active){.f1tnpuu0{background-color:Highlight;}}", { m: "screen and (forced-colors: active)" }],
			["@media screen and (prefers-reduced-motion: reduce){.f3z2g5w{max-width:100%;}}", { m: "screen and (prefers-reduced-motion: reduce)" }],
			["@media screen and (prefers-reduced-motion: reduce){.fz5izi4{animation-iteration-count:infinite;}}", { m: "screen and (prefers-reduced-motion: reduce)" }],
			["@media screen and (prefers-reduced-motion: reduce){.fv40pdu{animation-duration:3s;}}", { m: "screen and (prefers-reduced-motion: reduce)" }],
			["@media screen and (prefers-reduced-motion: reduce){.f1uj6jbf{animation-name:ftc26vs;}}", { m: "screen and (prefers-reduced-motion: reduce)" }]
		],
		d: [
			[".f12b9xdw{border-radius:inherit;}", { p: -1 }],
			".f1l02sjl{height:100%;}",
			".fjt6zfz{transition-property:width;}",
			".f1wofebd{transition-duration:0.3s;}",
			".fv71qf3{transition-timing-function:ease;}",
			".fa0wk36{max-width:33%;}",
			".f10pi13n{position:relative;}",
			".fpo0yib{background-image:linear-gradient(\n      to right,\n      var(--colorNeutralBackground6) 0%,\n      var(--colorTransparentBackground) 50%,\n      var(--colorNeutralBackground6) 100%\n    );}",
			".f1u5hf6c{background-image:linear-gradient(\n      to left,\n      var(--colorNeutralBackground6) 0%,\n      var(--colorTransparentBackground) 50%,\n      var(--colorNeutralBackground6) 100%\n    );}",
			".fwd2bol{animation-name:f1keuaan;}",
			".f14gig94{animation-name:f10x8f8u;}",
			".f1a27w2r{animation-duration:3s;}",
			".f452v7t{animation-timing-function:linear;}",
			".f1cpbl36{animation-iteration-count:infinite;}",
			".ftywsgz{background-color:var(--colorCompoundBrandBackground);}",
			".fdl5y0r{background-color:var(--colorPaletteRedBackground3);}",
			".f1s438gw{background-color:var(--colorPaletteDarkOrangeBackground3);}",
			".flxk52p{background-color:var(--colorPaletteGreenBackground3);}"
		],
		k: [
			"@keyframes f1keuaan{0%{left:-33%;}100%{left:100%;}}",
			"@keyframes f10x8f8u{0%{right:-33%;}100%{right:100%;}}",
			"@keyframes ftc26vs{0%{opacity:.2;}50%{opacity:1;}100%{opacity:.2;}}"
		]
	});
	/**
	* Apply styling to the ProgressBar slots based on the state
	*/
	const useProgressBarStyles_unstable = (state) => {
		"use no memo";
		const { color: color$1, max: max$1, shape, thickness, value } = state;
		const rootStyles = useRootStyles$12();
		const barStyles = useBarStyles();
		state.root.className = mergeClasses(progressBarClassNames.root, rootStyles.root, rootStyles[shape], rootStyles[thickness], state.root.className);
		if (state.bar) state.bar.className = mergeClasses(progressBarClassNames.bar, barStyles.base, barStyles.brand, value === void 0 && barStyles.indeterminate, value !== void 0 && value > ZERO_THRESHOLD && barStyles.nonZeroDeterminate, color$1 && value !== void 0 && barStyles[color$1], state.bar.className);
		if (state.bar && value !== void 0) state.bar.style = {
			width: Math.min(100, Math.max(0, value / max$1 * 100)) + "%",
			...state.bar.style
		};
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-progress/lib/components/ProgressBar/ProgressBar.js
/**
	* A ProgressBar bar shows the progression of a task.
	*/ const ProgressBar = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useProgressBar_unstable(props, ref);
		useProgressBarStyles_unstable(state);
		useCustomStyleHook("useProgressBarStyles_unstable")(state);
		return renderProgressBar_unstable(state);
	});
	ProgressBar.displayName = "ProgressBar";

//#endregion
//#region node_modules/@fluentui/react-overflow/lib/overflowContext.js
	const OverflowContext = createContext(void 0);
	const overflowContextDefaultValue = {
		itemVisibility: {},
		groupVisibility: {},
		hasOverflow: false,
		registerItem: () => () => null,
		updateOverflow: () => null,
		registerOverflowMenu: () => () => null,
		registerDivider: () => () => null
	};
	/**
	* @internal
	*/ const useOverflowContext = (selector) => useContextSelector(OverflowContext, (ctx = overflowContextDefaultValue) => selector(ctx));

//#endregion
//#region node_modules/@fluentui/priority-overflow/lib/consts.js
	const DATA_OVERFLOWING$1 = "data-overflowing";
	const DATA_OVERFLOW_GROUP = "data-overflow-group";

//#endregion
//#region node_modules/@fluentui/priority-overflow/lib/createResizeObserver.js
/**
	* Helper function that creates a resize observer in the element's own window global
	* @param elementToObserve - Uses the element's window global to create the resize observer
	* @param callback
	* @returns function to cleanup the resize observer
	*/ function observeResize(elementToObserve, callback) {
		var _elementToObserve_ownerDocument_defaultView;
		const GlobalResizeObserver = (_elementToObserve_ownerDocument_defaultView = elementToObserve.ownerDocument.defaultView) === null || _elementToObserve_ownerDocument_defaultView === void 0 ? void 0 : _elementToObserve_ownerDocument_defaultView.ResizeObserver;
		if (!GlobalResizeObserver) {
			console.error("@fluentui/priority-overflow", "ResizeObserver does not exist on container window");
			return () => null;
		}
		let resizeObserver = new GlobalResizeObserver(callback);
		resizeObserver.observe(elementToObserve);
		return () => {
			resizeObserver === null || resizeObserver === void 0 || resizeObserver.disconnect();
			resizeObserver = void 0;
		};
	}

//#endregion
//#region node_modules/@fluentui/priority-overflow/lib/debounce.js
/**
	* Microtask debouncer
	* https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide
	* @param fn - Function to debounce
	* @returns debounced function
	*/ function debounce(fn) {
		let pending;
		return () => {
			if (!pending) {
				pending = true;
				queueMicrotask(() => {
					pending = false;
					fn();
				});
			}
		};
	}

//#endregion
//#region node_modules/@fluentui/priority-overflow/lib/priorityQueue.js
/**
	* @param compare - comparison function for items
	* @returns Priority queue implemented with a min heap
	*/ function createPriorityQueue(compare) {
		const arr = [];
		let size$2 = 0;
		const left$1 = (i) => {
			return 2 * i + 1;
		};
		const right$1 = (i) => {
			return 2 * i + 2;
		};
		const parent$1 = (i) => {
			return Math.floor((i - 1) / 2);
		};
		const swap = (a, b) => {
			const tmp = arr[a];
			arr[a] = arr[b];
			arr[b] = tmp;
		};
		const heapify = (i) => {
			let smallest = i;
			const l = left$1(i);
			const r = right$1(i);
			if (l < size$2 && compare(arr[l], arr[smallest]) < 0) smallest = l;
			if (r < size$2 && compare(arr[r], arr[smallest]) < 0) smallest = r;
			if (smallest !== i) {
				swap(smallest, i);
				heapify(smallest);
			}
		};
		const dequeue = () => {
			if (size$2 === 0) throw new Error("Priority queue empty");
			const res = arr[0];
			arr[0] = arr[--size$2];
			heapify(0);
			return res;
		};
		const peek$1 = () => {
			if (size$2 === 0) return null;
			return arr[0];
		};
		const enqueue = (item) => {
			arr[size$2++] = item;
			let i = size$2 - 1;
			let p = parent$1(i);
			while (i > 0 && compare(arr[p], arr[i]) > 0) {
				swap(p, i);
				i = p;
				p = parent$1(i);
			}
		};
		const contains = (item) => {
			const index = arr.indexOf(item);
			return index >= 0 && index < size$2;
		};
		const remove = (item) => {
			const i = arr.indexOf(item);
			if (i === -1 || i >= size$2) return;
			arr[i] = arr[--size$2];
			heapify(i);
		};
		const clear = () => {
			size$2 = 0;
		};
		const all = () => {
			return arr.slice(0, size$2);
		};
		return {
			all,
			clear,
			contains,
			dequeue,
			enqueue,
			peek: peek$1,
			remove,
			size: () => size$2
		};
	}

//#endregion
//#region node_modules/@fluentui/priority-overflow/lib/overflowManager.js
/**
	* @internal
	* @returns overflow manager instance
	*/ function createOverflowManager() {
		const sizeCache = /* @__PURE__ */ new Map();
		let container;
		let overflowMenu;
		let observing = false;
		let forceDispatch = true;
		const options = {
			padding: 10,
			overflowAxis: "horizontal",
			overflowDirection: "end",
			minimumVisible: 0,
			onUpdateItemVisibility: () => void 0,
			onUpdateOverflow: () => void 0,
			hasHiddenItems: false
		};
		const overflowItems = {};
		const overflowDividers = {};
		let disposeResizeObserver = () => null;
		const getNextItem = (queueToDequeue, queueToEnqueue) => {
			const nextItem = queueToDequeue.dequeue();
			queueToEnqueue.enqueue(nextItem);
			return overflowItems[nextItem];
		};
		const groupManager = createGroupManager();
		function compareItems(lt, rt) {
			if (!lt || !rt) return 0;
			const lte = overflowItems[lt];
			const rte = overflowItems[rt];
			if (!lte || !rte) return lte ? 1 : -1;
			if (lte.priority !== rte.priority) return lte.priority > rte.priority ? 1 : -1;
			const positionStatusBit = options.overflowDirection === "end" ? 4 : 2;
			return lte.element.compareDocumentPosition(rte.element) & positionStatusBit ? 1 : -1;
		}
		function getElementAxisSize(horizontal, vertical, el) {
			if (!sizeCache.has(el)) sizeCache.set(el, options.overflowAxis === "horizontal" ? el[horizontal] : el[vertical]);
			return sizeCache.get(el);
		}
		const getOffsetSize = getElementAxisSize.bind(null, "offsetWidth", "offsetHeight");
		const getClientSize = getElementAxisSize.bind(null, "clientWidth", "clientHeight");
		const invisibleItemQueue = createPriorityQueue((a, b) => -1 * compareItems(a, b));
		const visibleItemQueue = createPriorityQueue(compareItems);
		function occupiedSize() {
			const totalItemSize = visibleItemQueue.all().map((id) => overflowItems[id].element).map(getOffsetSize).reduce((prev$1, current) => prev$1 + current, 0);
			const totalDividerSize = Object.entries(groupManager.groupVisibility()).reduce((acc, [id, state]) => acc + (state !== "hidden" && overflowDividers[id] ? getOffsetSize(overflowDividers[id].element) : 0), 0);
			const overflowMenuSize = (invisibleItemQueue.size() > 0 || options.hasHiddenItems) && overflowMenu ? getOffsetSize(overflowMenu) : 0;
			return totalItemSize + totalDividerSize + overflowMenuSize;
		}
		const showItem = () => {
			const item = getNextItem(invisibleItemQueue, visibleItemQueue);
			options.onUpdateItemVisibility({
				item,
				visible: true
			});
			if (item.groupId) {
				groupManager.showItem(item.id, item.groupId);
				if (groupManager.isSingleItemVisible(item.id, item.groupId)) {
					var _overflowDividers_item_groupId;
					(_overflowDividers_item_groupId = overflowDividers[item.groupId]) === null || _overflowDividers_item_groupId === void 0 || _overflowDividers_item_groupId.element.removeAttribute(DATA_OVERFLOWING$1);
				}
			}
		};
		const hideItem = () => {
			const item = getNextItem(visibleItemQueue, invisibleItemQueue);
			options.onUpdateItemVisibility({
				item,
				visible: false
			});
			if (item.groupId) {
				if (groupManager.isSingleItemVisible(item.id, item.groupId)) {
					var _overflowDividers_item_groupId;
					(_overflowDividers_item_groupId = overflowDividers[item.groupId]) === null || _overflowDividers_item_groupId === void 0 || _overflowDividers_item_groupId.element.setAttribute(DATA_OVERFLOWING$1, "");
				}
				groupManager.hideItem(item.id, item.groupId);
			}
		};
		const dispatchOverflowUpdate = () => {
			const visibleItemIds = visibleItemQueue.all();
			const invisibleItemIds = invisibleItemQueue.all();
			const visibleItems = visibleItemIds.map((itemId) => overflowItems[itemId]);
			const invisibleItems = invisibleItemIds.map((itemId) => overflowItems[itemId]);
			options.onUpdateOverflow({
				visibleItems,
				invisibleItems,
				groupVisibility: groupManager.groupVisibility()
			});
		};
		const processOverflowItems = () => {
			if (!container) return false;
			sizeCache.clear();
			const availableSize = getClientSize(container) - options.padding;
			const visibleTop = visibleItemQueue.peek();
			const invisibleTop = invisibleItemQueue.peek();
			while (compareItems(invisibleItemQueue.peek(), visibleItemQueue.peek()) > 0) hideItem();
			for (let i = 0; i < 2; i++) {
				while (occupiedSize() < availableSize && invisibleItemQueue.size() > 0 || invisibleItemQueue.size() === 1) showItem();
				while (occupiedSize() > availableSize && visibleItemQueue.size() > options.minimumVisible) hideItem();
			}
			return visibleItemQueue.peek() !== visibleTop || invisibleItemQueue.peek() !== invisibleTop;
		};
		const forceUpdate = () => {
			if (processOverflowItems() || forceDispatch) {
				forceDispatch = false;
				dispatchOverflowUpdate();
			}
		};
		const update = debounce(forceUpdate);
		const observe = (observedContainer, userOptions) => {
			Object.assign(options, userOptions);
			observing = true;
			Object.values(overflowItems).forEach((item) => visibleItemQueue.enqueue(item.id));
			container = observedContainer;
			disposeResizeObserver = observeResize(container, (entries) => {
				if (!entries[0] || !container) return;
				update();
			});
		};
		const addItem = (item) => {
			if (overflowItems[item.id]) return;
			overflowItems[item.id] = item;
			if (observing) {
				forceDispatch = true;
				visibleItemQueue.enqueue(item.id);
			}
			if (item.groupId) {
				groupManager.addItem(item.id, item.groupId);
				item.element.setAttribute(DATA_OVERFLOW_GROUP, item.groupId);
			}
			update();
		};
		const addOverflowMenu = (el) => {
			overflowMenu = el;
		};
		const addDivider = (divider) => {
			if (!divider.groupId || overflowDividers[divider.groupId]) return;
			divider.element.setAttribute(DATA_OVERFLOW_GROUP, divider.groupId);
			overflowDividers[divider.groupId] = divider;
		};
		const removeOverflowMenu = () => {
			overflowMenu = void 0;
		};
		const removeDivider = (groupId) => {
			if (!overflowDividers[groupId]) return;
			const divider = overflowDividers[groupId];
			if (divider.groupId) {
				delete overflowDividers[groupId];
				divider.element.removeAttribute(DATA_OVERFLOW_GROUP);
			}
		};
		const removeItem = (itemId) => {
			if (!overflowItems[itemId]) return;
			if (observing) forceDispatch = true;
			const item = overflowItems[itemId];
			visibleItemQueue.remove(itemId);
			invisibleItemQueue.remove(itemId);
			if (item.groupId) {
				groupManager.removeItem(item.id, item.groupId);
				item.element.removeAttribute(DATA_OVERFLOW_GROUP);
			}
			sizeCache.delete(item.element);
			delete overflowItems[itemId];
			update();
		};
		const disconnect = () => {
			disposeResizeObserver();
			container = void 0;
			observing = false;
			forceDispatch = true;
			Object.keys(overflowItems).forEach((itemId) => removeItem(itemId));
			Object.keys(overflowDividers).forEach((dividerId) => removeDivider(dividerId));
			removeOverflowMenu();
			sizeCache.clear();
		};
		return {
			addItem,
			disconnect,
			forceUpdate,
			observe,
			removeItem,
			update,
			addOverflowMenu,
			removeOverflowMenu,
			addDivider,
			removeDivider
		};
	}
	const createGroupManager = () => {
		const groupVisibility = {};
		const groups = {};
		function updateGroupVisibility(groupId) {
			const group = groups[groupId];
			if (group.invisibleItemIds.size && group.visibleItemIds.size) groupVisibility[groupId] = "overflow";
			else if (group.visibleItemIds.size === 0) groupVisibility[groupId] = "hidden";
			else groupVisibility[groupId] = "visible";
		}
		function isGroupVisible(groupId) {
			return groupVisibility[groupId] === "visible" || groupVisibility[groupId] === "overflow";
		}
		return {
			groupVisibility: () => groupVisibility,
			isSingleItemVisible(itemId, groupId) {
				return isGroupVisible(groupId) && groups[groupId].visibleItemIds.has(itemId) && groups[groupId].visibleItemIds.size === 1;
			},
			addItem(itemId, groupId) {
				var _groups, _groupId;
				var _;
				(_ = (_groups = groups)[_groupId = groupId]) !== null && _ !== void 0 || (_groups[_groupId] = {
					visibleItemIds: /* @__PURE__ */ new Set(),
					invisibleItemIds: /* @__PURE__ */ new Set()
				});
				groups[groupId].visibleItemIds.add(itemId);
				updateGroupVisibility(groupId);
			},
			removeItem(itemId, groupId) {
				groups[groupId].invisibleItemIds.delete(itemId);
				groups[groupId].visibleItemIds.delete(itemId);
				updateGroupVisibility(groupId);
			},
			showItem(itemId, groupId) {
				groups[groupId].invisibleItemIds.delete(itemId);
				groups[groupId].visibleItemIds.add(itemId);
				updateGroupVisibility(groupId);
			},
			hideItem(itemId, groupId) {
				groups[groupId].invisibleItemIds.add(itemId);
				groups[groupId].visibleItemIds.delete(itemId);
				updateGroupVisibility(groupId);
			}
		};
	};

//#endregion
//#region node_modules/@fluentui/react-overflow/lib/constants.js
	const DATA_OVERFLOWING = "data-overflowing";
	const DATA_OVERFLOW_ITEM = "data-overflow-item";
	const DATA_OVERFLOW_MENU = "data-overflow-menu";
	const DATA_OVERFLOW_DIVIDER = "data-overflow-divider";

//#endregion
//#region node_modules/@fluentui/react-overflow/lib/useOverflowContainer.js
	const noop$7 = () => null;
	/**
	* @internal
	* @param update - Callback when overflow state changes
	* @param options - Options to configure the overflow container
	* @returns - ref to attach to an intrinsic HTML element and imperative functions
	*/ const useOverflowContainer = (update, options) => {
		"use no memo";
		const { overflowAxis = "horizontal", overflowDirection = "end", padding: padding$1 = 10, minimumVisible = 0, onUpdateItemVisibility = noop$7, hasHiddenItems = false } = options;
		const onUpdateOverflow = useEventCallback(update);
		const overflowOptions = react.useMemo(() => ({
			overflowAxis,
			overflowDirection,
			padding: padding$1,
			minimumVisible,
			onUpdateItemVisibility,
			onUpdateOverflow,
			hasHiddenItems
		}), [
			minimumVisible,
			onUpdateItemVisibility,
			overflowAxis,
			overflowDirection,
			padding$1,
			onUpdateOverflow,
			hasHiddenItems
		]);
		const firstMount = useFirstMount();
		const containerRef = react.useRef(null);
		const [overflowManager, setOverflowManager] = react.useState(() => canUseDOM() ? createOverflowManager() : null);
		useIsomorphicLayoutEffect(() => {
			if (firstMount && containerRef.current) overflowManager === null || overflowManager === void 0 || overflowManager.observe(containerRef.current, overflowOptions);
		}, [
			firstMount,
			overflowManager,
			overflowOptions
		]);
		useIsomorphicLayoutEffect(() => {
			if (!containerRef.current || !canUseDOM() || firstMount) return;
			const newOverflowManager = createOverflowManager();
			newOverflowManager.observe(containerRef.current, overflowOptions);
			setOverflowManager(newOverflowManager);
		}, [overflowOptions]);
		react.useEffect(() => () => {
			overflowManager === null || overflowManager === void 0 || overflowManager.disconnect();
		}, [overflowManager]);
		return {
			registerItem: react.useCallback((item) => {
				overflowManager === null || overflowManager === void 0 || overflowManager.addItem(item);
				item.element.setAttribute(DATA_OVERFLOW_ITEM, "");
				return () => {
					item.element.removeAttribute(DATA_OVERFLOWING);
					item.element.removeAttribute(DATA_OVERFLOW_ITEM);
					overflowManager === null || overflowManager === void 0 || overflowManager.removeItem(item.id);
				};
			}, [overflowManager]),
			registerDivider: react.useCallback((divider) => {
				const el = divider.element;
				overflowManager === null || overflowManager === void 0 || overflowManager.addDivider(divider);
				el.setAttribute(DATA_OVERFLOW_DIVIDER, "");
				return () => {
					divider.groupId && (overflowManager === null || overflowManager === void 0 || overflowManager.removeDivider(divider.groupId));
					el.removeAttribute(DATA_OVERFLOW_DIVIDER);
				};
			}, [overflowManager]),
			registerOverflowMenu: react.useCallback((el) => {
				overflowManager === null || overflowManager === void 0 || overflowManager.addOverflowMenu(el);
				el.setAttribute(DATA_OVERFLOW_MENU, "");
				return () => {
					overflowManager === null || overflowManager === void 0 || overflowManager.removeOverflowMenu();
					el.removeAttribute(DATA_OVERFLOW_MENU);
				};
			}, [overflowManager]),
			updateOverflow: react.useCallback(() => {
				overflowManager === null || overflowManager === void 0 || overflowManager.update();
			}, [overflowManager]),
			containerRef
		};
	};
	const updateVisibilityAttribute = ({ item, visible }) => {
		if (visible) item.element.removeAttribute(DATA_OVERFLOWING);
		else item.element.setAttribute(DATA_OVERFLOWING, "");
	};

//#endregion
//#region node_modules/@fluentui/react-overflow/lib/components/useOverflowStyles.styles.js
	const useOverflowStyles = /* @__PURE__ */ __styles({
		overflowMenu: { Brvla84: "fyfkpbf" },
		overflowingItems: { zb22lx: "f10570jf" }
	}, { d: [".fyfkpbf [data-overflow-menu]{flex-shrink:0;}", ".f10570jf [data-overflowing]{display:none;}"] });

//#endregion
//#region node_modules/@fluentui/react-overflow/lib/components/Overflow.js
/**
	* Provides an OverflowContext for OverflowItem descendants.
	*/ const Overflow = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const styles = useOverflowStyles();
		const { children, minimumVisible, overflowAxis = "horizontal", overflowDirection, padding: padding$1, onOverflowChange, hasHiddenItems } = props;
		const [overflowState, setOverflowState] = react.useState({
			hasOverflow: false,
			itemVisibility: {},
			groupVisibility: {}
		});
		const update = (data) => {
			const { visibleItems, invisibleItems, groupVisibility } = data;
			const itemVisibility = {};
			visibleItems.forEach((item) => {
				itemVisibility[item.id] = true;
			});
			invisibleItems.forEach((x) => itemVisibility[x.id] = false);
			const newState = {
				hasOverflow: data.invisibleItems.length > 0,
				itemVisibility,
				groupVisibility
			};
			onOverflowChange === null || onOverflowChange === void 0 || onOverflowChange(null, { ...newState });
			setOverflowState(newState);
		};
		const { containerRef, registerItem, updateOverflow, registerOverflowMenu, registerDivider } = useOverflowContainer(update, {
			overflowDirection,
			overflowAxis,
			padding: padding$1,
			minimumVisible,
			hasHiddenItems,
			onUpdateItemVisibility: updateVisibilityAttribute
		});
		const child = getTriggerChild(children);
		const clonedChild = applyTriggerPropsToChildren(children, {
			ref: useMergedRefs(containerRef, ref, getReactElementRef(child)),
			className: mergeClasses("fui-Overflow", styles.overflowMenu, styles.overflowingItems, child === null || child === void 0 ? void 0 : child.props.className)
		});
		return /* @__PURE__ */ react.createElement(OverflowContext.Provider, { value: {
			itemVisibility: overflowState.itemVisibility,
			groupVisibility: overflowState.groupVisibility,
			hasOverflow: overflowState.hasOverflow,
			registerItem,
			updateOverflow,
			registerOverflowMenu,
			registerDivider
		} }, clonedChild);
	});

//#endregion
//#region node_modules/@fluentui/react-overflow/lib/useIsOverflowGroupVisible.js
/**
	* @param id - unique identifier for a group of overflow items
	* @returns visibility state of the group
	*/ function useIsOverflowGroupVisible(id) {
		return useOverflowContext((ctx) => ctx.groupVisibility[id]);
	}

//#endregion
//#region node_modules/@fluentui/react-overflow/lib/useIsOverflowItemVisible.js
/**
	* @param id - unique identifier for the item used by the overflow manager
	* @returns visibility state of an overflow item
	*/ function useIsOverflowItemVisible(id) {
		return !!useOverflowContext((ctx) => ctx.itemVisibility[id]);
	}

//#endregion
//#region node_modules/@fluentui/react-overflow/lib/useOverflowCount.js
/**
	* @returns Number of items that are overflowing
	*/ const useOverflowCount = () => useOverflowContext((v) => {
		return Object.entries(v.itemVisibility).reduce((acc, [id, visible]) => {
			if (!visible) acc++;
			return acc;
		}, 0);
	});

//#endregion
//#region node_modules/@fluentui/react-overflow/lib/useOverflowItem.js
/**
	* @internal
	* Registers an overflow item
	* @param id - unique identifier for the item used by the overflow manager
	* @param priority - higher priority means the item overflows later
	* @param groupId - assigns the item to a group, group visibility can be watched
	* @returns ref to assign to an intrinsic HTML element
	*/ function useOverflowItem(id, priority, groupId) {
		const ref = react.useRef(null);
		const registerItem = useOverflowContext((v) => v.registerItem);
		useIsomorphicLayoutEffect(() => {
			if (ref.current) return registerItem({
				element: ref.current,
				id,
				priority: priority !== null && priority !== void 0 ? priority : 0,
				groupId
			});
		}, [
			id,
			priority,
			registerItem,
			groupId
		]);
		return ref;
	}

//#endregion
//#region node_modules/@fluentui/react-overflow/lib/useOverflowMenu.js
	function useOverflowMenu(id) {
		const elementId = useId("overflow-menu", id);
		const overflowCount = useOverflowCount();
		const registerOverflowMenu = useOverflowContext((v) => v.registerOverflowMenu);
		const updateOverflow = useOverflowContext((v) => v.updateOverflow);
		const ref = react.useRef(null);
		const isOverflowing = overflowCount > 0;
		useIsomorphicLayoutEffect(() => {
			if (ref.current) return registerOverflowMenu(ref.current);
		}, [
			registerOverflowMenu,
			isOverflowing,
			elementId
		]);
		useIsomorphicLayoutEffect(() => {
			if (isOverflowing) updateOverflow();
		}, [
			isOverflowing,
			updateOverflow,
			ref
		]);
		return {
			ref,
			overflowCount,
			isOverflowing
		};
	}

//#endregion
//#region node_modules/@fluentui/react-overflow/lib/useOverflowDivider.js
/**
	* @internal
	* Registers an overflow item
	* @param groupId - assigns the item to a group, group visibility can be watched
	* @returns ref to assign to an intrinsic HTML element
	*/ function useOverflowDivider(groupId) {
		const ref = react.useRef(null);
		const registerDivider = useOverflowContext((v) => v.registerDivider);
		useIsomorphicLayoutEffect(() => {
			if (ref.current && groupId) return registerDivider({
				element: ref.current,
				groupId
			});
		}, [registerDivider, groupId]);
		return ref;
	}

//#endregion
//#region node_modules/@fluentui/react-overflow/lib/useOverflowVisibility.js
/**
	* A hook that returns the visibility status of all items and groups.
	*
	*  Heads up!
	*
	* This hook will cause the component it is in to re-render for every single time an item overflows or becomes
	* visible - use with caution
	* @returns visibility status of all items and groups
	*/ function useOverflowVisibility() {
		const itemVisibility = useOverflowContext((ctx) => ctx.itemVisibility);
		const groupVisibility = useOverflowContext((ctx) => ctx.groupVisibility);
		return react.useMemo(() => ({
			itemVisibility,
			groupVisibility
		}), [itemVisibility, groupVisibility]);
	}

//#endregion
//#region node_modules/@fluentui/react-overflow/lib/components/OverflowItem/OverflowItem.js
/**
	* Attaches overflow item behavior to its child registered with the OverflowContext.
	* It does not render an element of its own.
	*
	* Behaves similarly to other `*Trigger` components in Fluent UI React.
	*/ const OverflowItem = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const { id, groupId, priority, children } = props;
		return applyTriggerPropsToChildren(children, { ref: useMergedRefs(useOverflowItem(id, priority, groupId), ref, getReactElementRef(getTriggerChild(children))) });
	});
	OverflowItem.isFluentTriggerComponent = true;

//#endregion
//#region node_modules/@fluentui/react-overflow/lib/components/OverflowDivider/OverflowDivider.js
/**
	* Attaches overflow item behavior to its child registered with the OverflowContext.
	* It does not render an element of its own.
	*/ const OverflowDivider = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const { groupId, children } = props;
		return applyTriggerPropsToChildren(children, { ref: useMergedRefs(useOverflowDivider(groupId), ref) });
	});

//#endregion
//#region node_modules/@fluentui/react-toolbar/lib/components/Toolbar/useToolbar.js
/**
	* Create the state required to render Toolbar.
	*
	* The returned state can be modified with hooks such as useToolbarStyles_unstable,
	* before being passed to renderToolbar_unstable.
	*
	* @param props - props from this instance of Toolbar
	* @param ref - reference to root HTMLElement of Toolbar
	*/ const useToolbar_unstable = (props, ref) => {
		const { size: size$2 = "medium", vertical = false } = props;
		const arrowNavigationProps = useArrowNavigationGroup({
			circular: true,
			axis: "both"
		});
		const initialState = {
			size: size$2,
			vertical,
			components: { root: "div" },
			root: always(getIntrinsicElementProps("div", {
				role: "toolbar",
				ref,
				...vertical && { "aria-orientation": "vertical" },
				...arrowNavigationProps,
				...props
			}), { elementType: "div" })
		};
		const [checkedValues, onCheckedValueChange] = useToolbarSelectableState({
			checkedValues: props.checkedValues,
			defaultCheckedValues: props.defaultCheckedValues,
			onCheckedValueChange: props.onCheckedValueChange
		});
		const handleToggleButton = useEventCallback((e, name, value, checked) => {
			if (name && value) {
				const newCheckedItems = [...(checkedValues === null || checkedValues === void 0 ? void 0 : checkedValues[name]) || []];
				if (checked) newCheckedItems.splice(newCheckedItems.indexOf(value), 1);
				else newCheckedItems.push(value);
				onCheckedValueChange === null || onCheckedValueChange === void 0 || onCheckedValueChange(e, {
					name,
					checkedItems: newCheckedItems
				});
			}
		});
		const handleRadio = useEventCallback((e, name, value, checked) => {
			if (name && value) onCheckedValueChange === null || onCheckedValueChange === void 0 || onCheckedValueChange(e, {
				name,
				checkedItems: [value]
			});
		});
		return {
			...initialState,
			handleToggleButton,
			handleRadio,
			checkedValues: checkedValues !== null && checkedValues !== void 0 ? checkedValues : {}
		};
	};
	/**
	* Adds appropriate state values and handlers for selectable items
	* i.e checkboxes and radios
	*/ const useToolbarSelectableState = (state) => {
		const [checkedValues, setCheckedValues] = useControllableState({
			state: state.checkedValues,
			defaultState: state.defaultCheckedValues,
			initialState: {}
		});
		const { onCheckedValueChange: onCheckedValueChangeOriginal } = state;
		return [checkedValues, useEventCallback((e, { name, checkedItems }) => {
			if (onCheckedValueChangeOriginal) onCheckedValueChangeOriginal(e, {
				name,
				checkedItems
			});
			setCheckedValues((s) => {
				return s ? {
					...s,
					[name]: checkedItems
				} : { [name]: checkedItems };
			});
		})];
	};

//#endregion
//#region node_modules/@fluentui/react-toolbar/lib/components/Toolbar/ToolbarContext.js
	const ToolbarContext = createContext(void 0);
	const toolbarContextDefaultValue = {
		size: "medium",
		handleToggleButton: () => null,
		handleRadio: () => null,
		vertical: false,
		checkedValues: {}
	};
	const useToolbarContext_unstable = (selector) => useContextSelector(ToolbarContext, (ctx = toolbarContextDefaultValue) => selector(ctx));

//#endregion
//#region node_modules/@fluentui/react-toolbar/lib/components/Toolbar/renderToolbar.js
/**
	* Render the final JSX of Toolbar
	*/ const renderToolbar_unstable = (state, contextValues) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(ToolbarContext.Provider, {
			value: contextValues.toolbar,
			children: /* @__PURE__ */ jsx(state.root, { children: state.root.children })
		});
	};

//#endregion
//#region node_modules/@fluentui/react-toolbar/lib/components/Toolbar/useToolbarStyles.styles.js
	const toolbarClassNames = { root: "fui-Toolbar" };
	/**
	* Styles for the root slot
	*/
	const useStyles$70 = /* @__PURE__ */ __styles({
		root: {
			mc9l5x: "f22iagw",
			Bt984gj: "f122n59",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f1yqiaad"
		},
		vertical: {
			Beiy3e4: "f1vx9l62",
			a9b677: "f1acs6jw"
		},
		small: {
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "fvz760z"
		},
		medium: {
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f1yqiaad"
		},
		large: {
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f1ms6bdn"
		}
	}, { d: [
		".f22iagw{display:flex;}",
		".f122n59{align-items:center;}",
		[".f1yqiaad{padding:4px 8px;}", { p: -1 }],
		".f1vx9l62{flex-direction:column;}",
		".f1acs6jw{width:fit-content;}",
		[".fvz760z{padding:0px 4px;}", { p: -1 }],
		[".f1yqiaad{padding:4px 8px;}", { p: -1 }],
		[".f1ms6bdn{padding:4px 20px;}", { p: -1 }]
	] });
	/**
	* Apply styling to the Toolbar slots based on the state
	*/
	const useToolbarStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$70();
		const { vertical, size: size$2 } = state;
		state.root.className = mergeClasses(toolbarClassNames.root, styles.root, vertical && styles.vertical, size$2 === "small" && !vertical && styles.small, size$2 === "medium" && !vertical && styles.medium, size$2 === "large" && !vertical && styles.large, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-toolbar/lib/components/Toolbar/useToolbarContextValues.js
	function useToolbarContextValues_unstable(state) {
		const { size: size$2, handleToggleButton, vertical, checkedValues, handleRadio } = state;
		return { toolbar: {
			size: size$2,
			vertical,
			handleToggleButton,
			handleRadio,
			checkedValues
		} };
	}

//#endregion
//#region node_modules/@fluentui/react-toolbar/lib/components/Toolbar/Toolbar.js
/**
	* Toolbar component
	*/ const Toolbar = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useToolbar_unstable(props, ref);
		const contextValues = useToolbarContextValues_unstable(state);
		useToolbarStyles_unstable(state);
		useCustomStyleHook("useToolbarStyles_unstable")(state);
		return renderToolbar_unstable(state, contextValues);
	});
	Toolbar.displayName = "Toolbar";

//#endregion
//#region node_modules/@fluentui/react-toolbar/lib/components/ToolbarButton/useToolbarButtonStyles.styles.js
	const useBaseStyles$6 = /* @__PURE__ */ __styles({
		vertical: { Beiy3e4: "f1vx9l62" },
		verticalIcon: {
			Be2twd7: "f1rt2boy",
			jrapky: 0,
			Frg6f3: 0,
			t21cq0: 0,
			B6of3ja: 0,
			B74szlk: "f1s184ao"
		}
	}, { d: [
		".f1vx9l62{flex-direction:column;}",
		".f1rt2boy{font-size:24px;}",
		[".f1s184ao{margin:0;}", { p: -1 }]
	] });
	/**
	* Apply styling to the ToolbarButton slots based on the state
	*/
	const useToolbarButtonStyles_unstable = (state) => {
		"use no memo";
		const buttonStyles = useBaseStyles$6();
		state.root.className = mergeClasses(state.vertical && buttonStyles.vertical, state.root.className);
		if (state.icon) state.icon.className = mergeClasses(state.vertical && buttonStyles.verticalIcon, state.icon.className);
		useButtonStyles_unstable(state);
	};

//#endregion
//#region node_modules/@fluentui/react-toolbar/lib/components/ToolbarButton/useToolbarButton.js
/**
	* Given user props, defines default props for the Button, calls useButtonState and useChecked, and returns
	* processed state.
	* @param props - User provided props to the Button component.
	* @param ref - User provided ref to be passed to the Button component.
	*/ const useToolbarButton_unstable = (props, ref) => {
		const { vertical = false, ...buttonProps } = props;
		return {
			vertical,
			...useButton_unstable({
				appearance: "subtle",
				...buttonProps,
				size: "medium"
			}, ref)
		};
	};

//#endregion
//#region node_modules/@fluentui/react-toolbar/lib/components/ToolbarButton/ToolbarButton.js
/**
	* ToolbarButton component is a Button to be used inside Toolbar
	* which will respect toolbar props such as `size`
	*/ const ToolbarButton = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useToolbarButton_unstable(props, ref);
		useToolbarButtonStyles_unstable(state);
		useCustomStyleHook("useToolbarButtonStyles_unstable")(state);
		return renderButton_unstable(state);
	});
	ToolbarButton.displayName = "ToolbarButton";

//#endregion
//#region node_modules/@fluentui/react-toolbar/lib/components/ToolbarDivider/useToolbarDividerStyles.styles.js
	const useBaseStyles$5 = /* @__PURE__ */ __styles({
		root: {
			mc9l5x: "ftuwxu6",
			B2u0y6b: "f1lwjmbk",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f1oic3e7"
		},
		vertical: { B2u0y6b: "fe668z" }
	}, { d: [
		".ftuwxu6{display:inline-flex;}",
		".f1lwjmbk{max-width:1px;}",
		[".f1oic3e7{padding:0 12px;}", { p: -1 }],
		".fe668z{max-width:initial;}"
	] });
	/**
	* Apply styling to the ToolbarDivider slots based on the state
	*/
	const useToolbarDividerStyles_unstable = (state) => {
		"use no memo";
		useDividerStyles_unstable(state);
		const { vertical } = state;
		const toolbarDividerStyles = useBaseStyles$5();
		state.root.className = mergeClasses(toolbarDividerStyles.root, !vertical && toolbarDividerStyles.vertical, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-toolbar/lib/components/ToolbarDivider/useToolbarDivider.js
/**
	* Create the state required to render ToolbarDivider.
	*
	* The returned state can be modified with hooks such as useToolbarDividerStyles_unstable,
	* before being passed to renderToolbar_unstable.
	*
	* @param props - props from this instance of ToolbarDivider
	* @param ref - reference to root HTMLElement of ToolbarDivider
	*/ const useToolbarDivider_unstable = (props, ref) => {
		return useDivider_unstable({
			vertical: !useToolbarContext_unstable((ctx) => ctx.vertical),
			...props
		}, ref);
	};

//#endregion
//#region node_modules/@fluentui/react-toolbar/lib/components/ToolbarDivider/ToolbarDivider.js
/**
	* ToolbarDivider component
	*/ const ToolbarDivider = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useToolbarDivider_unstable(props, ref);
		useToolbarDividerStyles_unstable(state);
		useCustomStyleHook("useToolbarDividerStyles_unstable")(state);
		return renderDivider_unstable(state);
	});
	ToolbarDivider.displayName = "ToolbarDivider";

//#endregion
//#region node_modules/@fluentui/react-toolbar/lib/components/ToolbarToggleButton/useToolbarToggleButton.js
/**
	* Given user props, defines default props for the ToggleButton, calls useButtonState and useChecked, and returns
	* processed state.
	* @param props - User provided props to the ToggleButton component.
	* @param ref - User provided ref to be passed to the ToggleButton component.
	*/ const useToolbarToggleButton_unstable = (props, ref) => {
		const handleToggleButton = useToolbarContext_unstable((ctx) => ctx.handleToggleButton);
		const checked = useToolbarContext_unstable((ctx) => {
			var _ctx_checkedValues_props_name;
			return !!((_ctx_checkedValues_props_name = ctx.checkedValues[props.name]) === null || _ctx_checkedValues_props_name === void 0 ? void 0 : _ctx_checkedValues_props_name.includes(props.value));
		});
		const { onClick: onClickOriginal } = props;
		const state = {
			...useToggleButton_unstable({
				checked,
				...props
			}, ref),
			name: props.name,
			value: props.value
		};
		const handleOnClick = (e) => {
			if (state.disabled || state.disabledFocusable) {
				e.preventDefault();
				e.stopPropagation();
				return;
			}
			handleToggleButton === null || handleToggleButton === void 0 || handleToggleButton(e, state.name, state.value, state.checked);
			onClickOriginal === null || onClickOriginal === void 0 || onClickOriginal(e);
		};
		state.root.onClick = handleOnClick;
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-toolbar/lib/components/ToolbarToggleButton/useToolbarToggleButtonStyles.styles.js
	const useBaseStyles$4 = /* @__PURE__ */ __styles({
		selected: {
			De3pzq: "fq5gl1p",
			sj55zd: "f1eryozh"
		},
		iconSelected: { sj55zd: "f1qj7y59" }
	}, { d: [
		".fq5gl1p{background-color:var(--colorSubtleBackgroundSelected);}",
		".f1eryozh{color:var(--colorNeutralForeground2Selected);}",
		".f1qj7y59{color:var(--colorNeutralForeground2BrandSelected);}"
	] });
	/**
	* Apply styling to the ToolbarToggleButton slots based on the state
	*/
	const useToolbarToggleButtonStyles_unstable = (state) => {
		"use no memo";
		const toggleButtonStyles = useBaseStyles$4();
		state.root.className = mergeClasses(state.checked && toggleButtonStyles.selected, state.root.className);
		if (state.icon) state.icon.className = mergeClasses(state.checked && toggleButtonStyles.iconSelected, state.icon.className);
		useToggleButtonStyles_unstable(state);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-toolbar/lib/components/ToolbarToggleButton/ToolbarToggleButton.js
/**
	* ToolbarToggleButton component
	*/ const ToolbarToggleButton = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useToolbarToggleButton_unstable(props, ref);
		useToolbarToggleButtonStyles_unstable(state);
		useCustomStyleHook("useToolbarToggleButtonStyles_unstable")(state);
		return renderButton_unstable(state);
	});
	ToolbarToggleButton.displayName = "ToolbarToggleButton";

//#endregion
//#region node_modules/@fluentui/react-toolbar/lib/components/ToolbarRadioButton/useToolbarRadioButton.js
/**
	* Given user props, defines default props for the RadioButton, calls useButtonState and useChecked, and returns
	* processed state.
	* @param props - User provided props to the RadioButton component.
	* @param ref - User provided ref to be passed to the RadioButton component.
	*/ const useToolbarRadioButton_unstable = (props, ref) => {
		const handleRadio = useToolbarContext_unstable((ctx) => ctx.handleRadio);
		const checked = useToolbarContext_unstable((ctx) => {
			var _ctx_checkedValues_props_name;
			return !!((_ctx_checkedValues_props_name = ctx.checkedValues[props.name]) === null || _ctx_checkedValues_props_name === void 0 ? void 0 : _ctx_checkedValues_props_name.includes(props.value));
		});
		const size$2 = useToolbarContext_unstable((ctx) => ctx.size);
		const { onClick: onClickOriginal } = props;
		const state = {
			...useToggleButton_unstable({
				size: size$2,
				checked,
				role: "radio",
				"aria-checked": checked,
				...props
			}, ref),
			name: props.name,
			value: props.value
		};
		const handleOnClick = useEventCallback((e) => {
			handleRadio === null || handleRadio === void 0 || handleRadio(e, state.name, state.value, state.checked);
			onClickOriginal === null || onClickOriginal === void 0 || onClickOriginal(e);
		});
		state.root["aria-pressed"] = void 0;
		state.root.onClick = handleOnClick;
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-toolbar/lib/components/ToolbarRadioButton/useToolbarRadioButtonStyles.styles.js
	const useBaseStyles$3 = /* @__PURE__ */ __styles({
		selected: {
			De3pzq: "fq5gl1p",
			sj55zd: "f1eryozh"
		},
		iconSelected: { sj55zd: "f1qj7y59" }
	}, { d: [
		".fq5gl1p{background-color:var(--colorSubtleBackgroundSelected);}",
		".f1eryozh{color:var(--colorNeutralForeground2Selected);}",
		".f1qj7y59{color:var(--colorNeutralForeground2BrandSelected);}"
	] });
	/**
	* Apply styling to the ToolbarRadioButton slots based on the state
	*/
	const useToolbarRadioButtonStyles_unstable = (state) => {
		"use no memo";
		const toggleButtonStyles = useBaseStyles$3();
		state.root.className = mergeClasses(state.checked && toggleButtonStyles.selected, state.root.className);
		if (state.icon) state.icon.className = mergeClasses(state.checked && toggleButtonStyles.iconSelected, state.icon.className);
		useToggleButtonStyles_unstable(state);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-toolbar/lib/components/ToolbarRadioButton/ToolbarRadioButton.js
/**
	* ToolbarRadioButton component
	*/ const ToolbarRadioButton = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useToolbarRadioButton_unstable(props, ref);
		useToolbarRadioButtonStyles_unstable(state);
		useCustomStyleHook("useToolbarRadioButtonStyles_unstable")(state);
		return renderButton_unstable(state);
	});
	ToolbarRadioButton.displayName = "ToolbarRadioButton";

//#endregion
//#region node_modules/@fluentui/react-toolbar/lib/components/ToolbarGroup/useToolbarGroup.js
/**
	* Given user props, defines default props for the Group
	* @param props - User provided props to the Group component.
	* @param ref - User provided ref to be passed to the Group component.
	*/ const useToolbarGroup_unstable = (props, ref) => {
		const vertical = useToolbarContext_unstable((ctx) => ctx.vertical);
		return {
			components: { root: "div" },
			root: always(getIntrinsicElementProps("div", {
				ref,
				role: "presentation",
				...props
			}), { elementType: "div" }),
			vertical
		};
	};

//#endregion
//#region node_modules/@fluentui/react-toolbar/lib/components/ToolbarGroup/useToolbarGroupStyles.styles.js
	const toolbarGroupClassNames = { root: "fui-ToolbarGroup" };
	const useStyles$69 = /* @__PURE__ */ __styles({
		root: {
			mc9l5x: "f22iagw",
			Bt984gj: "f122n59"
		},
		vertical: {
			Beiy3e4: "f1vx9l62",
			a9b677: "f1acs6jw"
		}
	}, { d: [
		".f22iagw{display:flex;}",
		".f122n59{align-items:center;}",
		".f1vx9l62{flex-direction:column;}",
		".f1acs6jw{width:fit-content;}"
	] });
	/**
	* Apply styling to the Toolbar slots based on the state
	*/
	const useToolbarGroupStyles_unstable = (state) => {
		"use no memo";
		const { vertical } = state;
		const styles = useStyles$69();
		state.root.className = mergeClasses(toolbarGroupClassNames.root, styles.root, vertical && styles.vertical, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-toolbar/lib/components/ToolbarGroup/renderToolbarGroup.js
/**
	* Render the final JSX of ToolbarGroup
	*/ const renderToolbarGroup_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, { children: state.root.children });
	};

//#endregion
//#region node_modules/@fluentui/react-toolbar/lib/components/ToolbarGroup/ToolbarGroup.js
/**
	* ToolbarGroup component is a Button to be used inside Toolbar
	* which will respect toolbar props such as `size`
	*/ const ToolbarGroup = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useToolbarGroup_unstable(props, ref);
		useToolbarGroupStyles_unstable(state);
		useCustomStyleHook("useToolbarGroupStyles_unstable")(state);
		return renderToolbarGroup_unstable(state);
	});
	ToolbarGroup.displayName = "ToolbarGroup";

//#endregion
//#region node_modules/@fluentui/react-toolbar/lib/components/ToolbarRadioGroup/ToolbarRadioGroup.js
/**
	* ToolbarRadioGroup component is a Button to be used inside Toolbar
	* which will respect toolbar props such as `size`
	*/ const ToolbarRadioGroup = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useToolbarGroup_unstable({
			role: "radiogroup",
			...props
		}, ref);
		useToolbarGroupStyles_unstable(state);
		useCustomStyleHook("useToolbarGroupStyles_unstable")(state);
		return renderToolbarGroup_unstable(state);
	});
	ToolbarRadioGroup.displayName = "ToolbarRadioGroup";

//#endregion
//#region node_modules/@fluentui/react-table/lib/hooks/useTableSelection.js
	const noop$6 = () => void 0;
	const defaultTableSelectionState = {
		allRowsSelected: false,
		clearRows: noop$6,
		deselectRow: noop$6,
		isRowSelected: () => false,
		selectRow: noop$6,
		selectedRows: /* @__PURE__ */ new Set(),
		someRowsSelected: false,
		toggleAllRows: noop$6,
		toggleRow: noop$6,
		selectionMode: "multiselect"
	};
	function useTableSelection(options) {
		"use no memo";
		return (tableState) => useTableSelectionState(tableState, options);
	}
	function useTableSelectionState(tableState, options) {
		const { items, getRowId } = tableState;
		const { selectionMode, defaultSelectedItems, selectedItems, onSelectionChange } = options;
		const [selected, selectionMethods] = useSelection({
			selectionMode,
			defaultSelectedItems,
			selectedItems,
			onSelectionChange
		});
		const selectableRowIds = react.useMemo(() => {
			const rowIds = /* @__PURE__ */ new Set();
			for (let i = 0; i < items.length; i++) {
				var _getRowId;
				rowIds.add((_getRowId = getRowId === null || getRowId === void 0 ? void 0 : getRowId(items[i])) !== null && _getRowId !== void 0 ? _getRowId : i);
			}
			return rowIds;
		}, [items, getRowId]);
		const allRowsSelected = react.useMemo(() => {
			if (selectionMode === "single") {
				const selectedRow = Array.from(selected)[0];
				return selectableRowIds.has(selectedRow);
			}
			if (selected.size < selectableRowIds.size) return false;
			if (selectableRowIds.size === 0) return false;
			let res = true;
			selectableRowIds.forEach((selectableRowId) => {
				if (!selected.has(selectableRowId)) res = false;
			});
			return res;
		}, [
			selectableRowIds,
			selected,
			selectionMode
		]);
		const someRowsSelected = react.useMemo(() => {
			if (selected.size <= 0) return false;
			let res = false;
			selectableRowIds.forEach((selectableRowId) => {
				if (selected.has(selectableRowId)) res = true;
			});
			return res;
		}, [selectableRowIds, selected]);
		const toggleAllRows = useEventCallback((e) => {
			selectionMethods.toggleAllItems(e, items.map((item, i) => {
				var _getRowId;
				return (_getRowId = getRowId === null || getRowId === void 0 ? void 0 : getRowId(item)) !== null && _getRowId !== void 0 ? _getRowId : i;
			}));
		});
		const toggleRow = useEventCallback((e, rowId) => selectionMethods.toggleItem(e, rowId));
		const deselectRow = useEventCallback((e, rowId) => selectionMethods.deselectItem(e, rowId));
		const selectRow = useEventCallback((e, rowId) => selectionMethods.selectItem(e, rowId));
		const isRowSelected = (rowId) => selectionMethods.isSelected(rowId);
		const clearRows = useEventCallback((e) => selectionMethods.clearItems(e));
		return {
			...tableState,
			selection: {
				selectionMode,
				someRowsSelected,
				allRowsSelected,
				selectedRows: selected,
				toggleRow,
				toggleAllRows,
				clearRows,
				deselectRow,
				selectRow,
				isRowSelected
			}
		};
	}

//#endregion
//#region node_modules/@fluentui/react-table/lib/hooks/useTableSort.js
	const noop$5 = () => void 0;
	const defaultTableSortState = {
		getSortDirection: () => "ascending",
		setColumnSort: noop$5,
		sort: (rows) => [...rows],
		sortColumn: void 0,
		sortDirection: "ascending",
		toggleColumnSort: noop$5
	};
	function useTableSort(options) {
		"use no memo";
		return (tableState) => useTableSortState(tableState, options);
	}
	function useTableSortState(tableState, options) {
		const { columns } = tableState;
		const { sortState, defaultSortState, onSortChange: onSortChangeProp = noop$5 } = options;
		const [sorted, setSorted] = useControllableState({
			initialState: {
				sortDirection: "ascending",
				sortColumn: void 0
			},
			defaultState: defaultSortState,
			state: sortState
		});
		const { sortColumn, sortDirection } = sorted;
		const onSortChange = useEventCallback(onSortChangeProp);
		const toggleColumnSort = react.useCallback((e, columnId) => {
			setSorted((s) => {
				const newState = {
					...s,
					sortColumn: columnId
				};
				if (s.sortColumn === columnId) newState.sortDirection = s.sortDirection === "ascending" ? "descending" : "ascending";
				else newState.sortDirection = "ascending";
				onSortChange === null || onSortChange === void 0 || onSortChange(e, newState);
				return newState;
			});
		}, [onSortChange, setSorted]);
		const setColumnSort = (e, nextSortColumn, nextSortDirection) => {
			const newState = {
				sortColumn: nextSortColumn,
				sortDirection: nextSortDirection
			};
			onSortChange === null || onSortChange === void 0 || onSortChange(e, newState);
			setSorted(newState);
		};
		const sort = react.useCallback((rows) => {
			return rows.slice().sort((a, b) => {
				const sortColumnDef = columns.find((column$1) => column$1.columnId === sortColumn);
				if (!(sortColumnDef === null || sortColumnDef === void 0 ? void 0 : sortColumnDef.compare)) return 0;
				const mod = sortDirection === "ascending" ? 1 : -1;
				return sortColumnDef.compare(a.item, b.item) * mod;
			});
		}, [
			columns,
			sortColumn,
			sortDirection
		]);
		const getSortDirection = (columnId) => {
			return sortColumn === columnId ? sortDirection : void 0;
		};
		return {
			...tableState,
			sort: {
				sort,
				sortColumn,
				sortDirection,
				setColumnSort,
				toggleColumnSort,
				getSortDirection
			}
		};
	}

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/TableResizeHandle/useTableResizeHandle.js
/**
	* Create the state required to render TableResizeHandle.
	*
	* The returned state can be modified with hooks such as useTableResizeHandleStyles_unstable,
	* before being passed to renderTableResizeHandle_unstable.
	*
	* @param props - props from this instance of TableResizeHandle
	* @param ref - reference to root HTMLElement of TableResizeHandle
	*/ const useTableResizeHandle_unstable = (props, ref) => {
		const onClick = useEventCallback((event) => {
			var _props_onClick;
			(_props_onClick = props.onClick) === null || _props_onClick === void 0 || _props_onClick.call(props, event);
			event.stopPropagation();
		});
		return {
			components: { root: "div" },
			root: always(getIntrinsicElementProps("div", {
				ref,
				...props,
				onClick
			}), { elementType: "div" })
		};
	};

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/TableResizeHandle/renderTableResizeHandle.js
/**
	* Render the final JSX of TableResizeHandle
	*/ const renderTableResizeHandle_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, {});
	};

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/TableResizeHandle/useTableResizeHandleStyles.styles.js
	const tableResizeHandleClassNames = { root: "fui-TableResizeHandle" };
	/**
	* Styles for the root slot
	*/
	const useStyles$68 = /* @__PURE__ */ __styles({ root: {
		qhf8xq: "f1euv43f",
		j35jbq: ["f1e31b4d", "f1vgc2s3"],
		Bhzewxz: "f15twtuk",
		B5kzvoi: "f1yab3r1",
		a9b677: "fjw5fx7",
		jrapky: 0,
		Frg6f3: 0,
		t21cq0: 0,
		B6of3ja: 0,
		B74szlk: "fg06o1j",
		Bceei9c: "fc3en1c",
		abs64n: "fk73vx1",
		Bmy1vo4: "f13u1uyl",
		B3o57yi: "fezquic",
		Bj3rh1h: "f19g0ac",
		B3cna0y: "f1tkae59",
		Brovlpu: "ftqa4ok",
		B7zu5sd: "f15pjodv",
		Bsft5z2: "f1rcdj94",
		ap17g6: "f2gz7yw",
		a2br6o: "ff2ryt5",
		E3zdtr: "f1mdlcz9",
		Eqx8gd: ["f10awi5f", "f1nzedbg"],
		bn5sak: "frwkxtg",
		By385i5: "fo72kxq",
		Bjyk6c5: "fdlpgxj"
	} }, {
		d: [
			".f1euv43f{position:absolute;}",
			".f1e31b4d{right:0;}",
			".f1vgc2s3{left:0;}",
			".f15twtuk{top:0;}",
			".f1yab3r1{bottom:0;}",
			".fjw5fx7{width:16px;}",
			[".fg06o1j{margin:0 -8px;}", { p: -1 }],
			".fc3en1c{cursor:col-resize;}",
			".fk73vx1{opacity:0;}",
			".f13u1uyl{transition-property:opacity;}",
			".fezquic{transition-duration:.2s;}",
			".f19g0ac{z-index:1;}",
			".f1rcdj94::after{content:\" \";}",
			".f2gz7yw::after{display:block;}",
			".ff2ryt5::after{width:1px;}",
			".f1mdlcz9::after{position:absolute;}",
			".f10awi5f::after{left:50%;}",
			".f1nzedbg::after{right:50%;}",
			".frwkxtg::after{top:0;}",
			".fo72kxq::after{bottom:0;}",
			".fdlpgxj::after{background-color:var(--colorNeutralStroke1);}"
		],
		f: [".f1tkae59:focus{opacity:1;}", ".ftqa4ok:focus{outline-style:none;}"],
		h: [".f15pjodv:hover{opacity:1;}"]
	});
	/**
	* Apply styling to the TableResizeHandle slots based on the state
	*/
	const useTableResizeHandleStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$68();
		state.root.className = mergeClasses(tableResizeHandleClassNames.root, styles.root, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/TableResizeHandle/TableResizeHandle.js
/**
	* TableResizeHandle component - TODO: add more docs
	*/ const TableResizeHandle = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useTableResizeHandle_unstable(props, ref);
		useTableResizeHandleStyles_unstable(state);
		useCustomStyleHook("useTableResizeHandleStyles_unstable")(state);
		return renderTableResizeHandle_unstable(state);
	});
	TableResizeHandle.displayName = "TableResizeHandle";

//#endregion
//#region node_modules/@fluentui/react-table/lib/hooks/useMeasureElement.js
/**
	* Provides a way of reporting element width.
	* Returns
	* `width` - current element width (0 by default),
	* `measureElementRef` - a ref function to be passed as `ref` to the element you want to measure
	*/ function useMeasureElement() {
		const [width, setWidth] = react.useState(0);
		const container = react.useRef(void 0);
		const resizeObserverRef = react.useRef(null);
		const { targetDocument } = useFluent();
		const handleResize = react.useCallback(() => {
			var _container_current;
			setWidth(((_container_current = container.current) === null || _container_current === void 0 ? void 0 : _container_current.getBoundingClientRect().width) || 0);
		}, []);
		const measureElementRef = react.useCallback((el) => {
			if (!targetDocument) return;
			if (!el && resizeObserverRef.current && container.current) resizeObserverRef.current.unobserve(container.current);
			container.current = void 0;
			if (el === null || el === void 0 ? void 0 : el.parentElement) {
				var _resizeObserverRef_current;
				container.current = el.parentElement;
				handleResize();
				(_resizeObserverRef_current = resizeObserverRef.current) === null || _resizeObserverRef_current === void 0 || _resizeObserverRef_current.observe(container.current);
			}
		}, [targetDocument, handleResize]);
		react.useEffect(() => {
			resizeObserverRef.current = createResizeObserverFromDocument(targetDocument, handleResize);
			if (!container.current || !resizeObserverRef.current) return;
			resizeObserverRef.current.observe(container.current);
			return () => {
				var _resizeObserverRef_current;
				(_resizeObserverRef_current = resizeObserverRef.current) === null || _resizeObserverRef_current === void 0 || _resizeObserverRef_current.disconnect();
			};
		}, [handleResize, targetDocument]);
		return {
			width,
			measureElementRef
		};
	}
	/**
	* FIXME - TS 3.8/3.9 don't have ResizeObserver types by default, move this to a shared utility once we bump the minbar
	* A utility method that creates a ResizeObserver from a target document
	* @param targetDocument - document to use to create the ResizeObserver
	* @param callback  - https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver/ResizeObserver#callback
	* @returns a ResizeObserver instance or null if the global does not exist on the document
	*/ function createResizeObserverFromDocument(targetDocument, callback) {
		var _targetDocument_defaultView;
		if (!(targetDocument === null || targetDocument === void 0 ? void 0 : (_targetDocument_defaultView = targetDocument.defaultView) === null || _targetDocument_defaultView === void 0 ? void 0 : _targetDocument_defaultView.ResizeObserver)) return null;
		return new targetDocument.defaultView.ResizeObserver(callback);
	}

//#endregion
//#region node_modules/@fluentui/react-table/lib/hooks/useTableColumnResizeMouseHandler.js
	function useTableColumnResizeMouseHandler(columnResizeState) {
		const mouseX = react.useRef(0);
		const currentWidth = react.useRef(0);
		const colId = react.useRef(void 0);
		const [dragging, setDragging] = react.useState(false);
		const { targetDocument } = useFluent();
		const { getColumnWidth: getColumnWidth$1, setColumnWidth } = columnResizeState;
		const recalculatePosition = react.useCallback((e) => {
			const { clientX } = getEventClientCoords(e);
			const dx = clientX - mouseX.current;
			currentWidth.current += dx;
			colId.current && setColumnWidth(e, {
				columnId: colId.current,
				width: currentWidth.current
			});
			mouseX.current = clientX;
		}, [setColumnWidth]);
		const [requestRecalcFrame] = useAnimationFrame();
		const onDrag = react.useCallback((e) => {
			requestRecalcFrame(() => recalculatePosition(e));
		}, [requestRecalcFrame, recalculatePosition]);
		const onDragEnd = react.useCallback((event) => {
			if (isMouseEvent$1(event)) {
				targetDocument === null || targetDocument === void 0 || targetDocument.removeEventListener("mouseup", onDragEnd);
				targetDocument === null || targetDocument === void 0 || targetDocument.removeEventListener("mousemove", onDrag);
			}
			if (isTouchEvent(event)) {
				targetDocument === null || targetDocument === void 0 || targetDocument.removeEventListener("touchend", onDragEnd);
				targetDocument === null || targetDocument === void 0 || targetDocument.removeEventListener("touchmove", onDrag);
			}
			setDragging(false);
		}, [onDrag, targetDocument]);
		return {
			getOnMouseDown: react.useCallback((columnId) => (event) => {
				currentWidth.current = getColumnWidth$1(columnId);
				mouseX.current = getEventClientCoords(event).clientX;
				colId.current = columnId;
				if (isMouseEvent$1(event)) {
					if (event.target !== event.currentTarget || event.button !== 0) return;
					targetDocument === null || targetDocument === void 0 || targetDocument.addEventListener("mouseup", onDragEnd);
					targetDocument === null || targetDocument === void 0 || targetDocument.addEventListener("mousemove", onDrag);
					setDragging(true);
				}
				if (isTouchEvent(event)) {
					targetDocument === null || targetDocument === void 0 || targetDocument.addEventListener("touchend", onDragEnd);
					targetDocument === null || targetDocument === void 0 || targetDocument.addEventListener("touchmove", onDrag);
					setDragging(true);
				}
			}, [
				getColumnWidth$1,
				onDrag,
				onDragEnd,
				targetDocument
			]),
			dragging
		};
	}

//#endregion
//#region node_modules/@fluentui/react-table/lib/utils/columnResizeUtils.js
	const DEFAULT_WIDTH = 150;
	const DEFAULT_MIN_WIDTH = 100;
	/**
	* This function takes the column definitions and the curent ColumnWidthState and returns new state.
	*  - It uses existing state for existing columns.
	*  - It removes any state for columns no longer present.
	*  - It checks if any column has been replaced and returns updated state if so
	*  - It returns old state if no changes in the state have been made (so that react doesn't call effects)
	* @param columns
	* @param state
	* @returns
	*/ function columnDefinitionsToState(columns, state = [], columnSizingOptions = {}) {
		let updated = false;
		const stateMap = new Map(state.map((s) => [s.columnId, s]));
		const updatedState = columns.map((column$1) => {
			const existingColumnState = stateMap.get(column$1.columnId);
			if (existingColumnState) {
				var _columnSizingOptions_column_columnId;
				const { idealWidth: idealWidth$1 = existingColumnState.idealWidth, minWidth: minWidth$1 = existingColumnState.minWidth, padding: padding$2 = existingColumnState.padding } = (_columnSizingOptions_column_columnId = columnSizingOptions[column$1.columnId]) !== null && _columnSizingOptions_column_columnId !== void 0 ? _columnSizingOptions_column_columnId : {};
				if (idealWidth$1 !== existingColumnState.idealWidth || minWidth$1 !== existingColumnState.minWidth || padding$2 !== existingColumnState.padding) {
					updated = true;
					return {
						...existingColumnState,
						idealWidth: idealWidth$1,
						width: idealWidth$1,
						minWidth: minWidth$1,
						padding: padding$2
					};
				}
				return existingColumnState;
			}
			var _columnSizingOptions_column_columnId1;
			const { defaultWidth, idealWidth = DEFAULT_WIDTH, minWidth = DEFAULT_MIN_WIDTH, padding: padding$1 } = (_columnSizingOptions_column_columnId1 = columnSizingOptions[column$1.columnId]) !== null && _columnSizingOptions_column_columnId1 !== void 0 ? _columnSizingOptions_column_columnId1 : {};
			updated = true;
			return {
				columnId: column$1.columnId,
				width: Math.max(defaultWidth !== null && defaultWidth !== void 0 ? defaultWidth : idealWidth, minWidth),
				minWidth,
				idealWidth: Math.max(defaultWidth !== null && defaultWidth !== void 0 ? defaultWidth : idealWidth, minWidth),
				padding: padding$1 !== null && padding$1 !== void 0 ? padding$1 : 16
			};
		});
		if (updatedState.length !== state.length || updated) {
			const column$1 = updatedState.find((col) => col.width > col.idealWidth);
			if (column$1) column$1.width = column$1.idealWidth;
			updated = true;
		}
		return updated ? updatedState : state;
	}
	function getColumnById(state, columnId) {
		return state.find((c) => c.columnId === columnId);
	}
	function getColumnByIndex(state, index) {
		return state[index];
	}
	function getTotalWidth(state) {
		return state.reduce((sum, column$1) => sum + column$1.width + column$1.padding, 0);
	}
	function getColumnWidth(state, columnId) {
		const column$1 = getColumnById(state, columnId);
		var _column_width;
		return (_column_width = column$1 === null || column$1 === void 0 ? void 0 : column$1.width) !== null && _column_width !== void 0 ? _column_width : 0;
	}
	/**
	* This function takes the current state and returns an updated state, so that it can be set.
	* The reason for this is that we can update the state multiple times before commiting to render.
	* This is an optimization and also prevents flickering.
	* It also returns new copy of the state only if the value is different than the one currently in
	* the state, further preventing unnecessary updates.
	* @param localState
	* @param columnId
	* @param property
	* @param value
	* @returns
	*/ function setColumnProperty(localState, columnId, property, value) {
		const currentColumn = getColumnById(localState, columnId);
		if (!currentColumn || (currentColumn === null || currentColumn === void 0 ? void 0 : currentColumn[property]) === value) return localState;
		const updatedColumn = {
			...currentColumn,
			[property]: value
		};
		return localState.reduce((acc, current) => {
			if (current.columnId === updatedColumn.columnId) return [...acc, updatedColumn];
			return [...acc, current];
		}, []);
	}
	/**
	* This function takes the state and container width and makes sure the each column in the state
	* is its optimal width, and that the columns
	* a) fit to the container
	* b) always fill the whole container
	* @param state
	* @param containerWidth
	* @returns
	*/ function adjustColumnWidthsToFitContainer(state, containerWidth) {
		let newState = state;
		const totalWidth = getTotalWidth(newState);
		if (totalWidth < containerWidth) {
			let difference = containerWidth - totalWidth;
			let i = 0;
			while (i < newState.length && difference > 0) {
				const currentCol = getColumnByIndex(newState, i);
				if (!currentCol) break;
				const colAdjustment = Math.min(currentCol.idealWidth - currentCol.width, difference);
				newState = setColumnProperty(newState, currentCol.columnId, "width", currentCol.width + colAdjustment);
				difference -= colAdjustment;
				if (i === newState.length - 1 && difference !== 0) {
					const lastCol = getColumnByIndex(newState, i);
					if (lastCol) newState = setColumnProperty(newState, lastCol.columnId, "width", lastCol.width + difference);
				}
				i++;
			}
		} else if (totalWidth >= containerWidth) {
			let difference = totalWidth - containerWidth;
			let j = newState.length - 1;
			while (j >= 0 && difference > 0) {
				const currentCol = getColumnByIndex(newState, j);
				if (!currentCol) {
					j--;
					continue;
				}
				if (currentCol.width > currentCol.minWidth) {
					const colAdjustment = Math.min(currentCol.width - currentCol.minWidth, difference);
					difference -= colAdjustment;
					newState = setColumnProperty(newState, currentCol.columnId, "width", currentCol.width - colAdjustment);
				}
				j--;
			}
		}
		return newState;
	}

//#endregion
//#region node_modules/@fluentui/react-table/lib/hooks/useTableColumnResizeState.js
	const createReducer = (autoFitColumns) => (state, action) => {
		switch (action.type) {
			case "CONTAINER_WIDTH_UPDATED": return {
				...state,
				containerWidth: action.containerWidth,
				columnWidthState: autoFitColumns ? adjustColumnWidthsToFitContainer(state.columnWidthState, action.containerWidth) : state.columnWidthState
			};
			case "COLUMNS_UPDATED":
				const newS = columnDefinitionsToState(action.columns, state.columnWidthState, state.columnSizingOptions);
				return {
					...state,
					columns: action.columns,
					columnWidthState: autoFitColumns ? adjustColumnWidthsToFitContainer(newS, state.containerWidth) : newS
				};
			case "COLUMN_SIZING_OPTIONS_UPDATED":
				const newState = columnDefinitionsToState(state.columns, state.columnWidthState, action.columnSizingOptions);
				return {
					...state,
					columnSizingOptions: action.columnSizingOptions,
					columnWidthState: autoFitColumns ? adjustColumnWidthsToFitContainer(newState, state.containerWidth) : newState
				};
			case "SET_COLUMN_WIDTH":
				const { columnId, width } = action;
				const { containerWidth } = state;
				const column$1 = getColumnById(state.columnWidthState, columnId);
				let newColumnWidthState = [...state.columnWidthState];
				if (!column$1) return state;
				newColumnWidthState = setColumnProperty(newColumnWidthState, columnId, "width", width);
				newColumnWidthState = setColumnProperty(newColumnWidthState, columnId, "idealWidth", width);
				if (autoFitColumns) newColumnWidthState = adjustColumnWidthsToFitContainer(newColumnWidthState, containerWidth);
				return {
					...state,
					columnWidthState: newColumnWidthState
				};
		}
	};
	function useTableColumnResizeState(columns, containerWidth, params = {}) {
		const { onColumnResize, columnSizingOptions, autoFitColumns = true } = params;
		const reducer = react.useMemo(() => createReducer(autoFitColumns), [autoFitColumns]);
		const [state, dispatch] = react.useReducer(reducer, {
			columns,
			containerWidth: 0,
			columnWidthState: columnDefinitionsToState(columns, void 0, columnSizingOptions),
			columnSizingOptions
		});
		useIsomorphicLayoutEffect(() => {
			dispatch({
				type: "CONTAINER_WIDTH_UPDATED",
				containerWidth
			});
		}, [containerWidth]);
		useIsomorphicLayoutEffect(() => {
			dispatch({
				type: "COLUMNS_UPDATED",
				columns
			});
		}, [columns]);
		useIsomorphicLayoutEffect(() => {
			dispatch({
				type: "COLUMN_SIZING_OPTIONS_UPDATED",
				columnSizingOptions
			});
		}, [columnSizingOptions]);
		const setColumnWidth = useEventCallback((event, data) => {
			let { width } = data;
			const { columnId } = data;
			const col = getColumnById(state.columnWidthState, columnId);
			if (!col) return;
			width = Math.max(col.minWidth || 0, width);
			if (onColumnResize) onColumnResize(event, {
				columnId,
				width
			});
			dispatch({
				type: "SET_COLUMN_WIDTH",
				columnId,
				width
			});
		});
		return {
			getColumnById: react.useCallback((colId) => getColumnById(state.columnWidthState, colId), [state.columnWidthState]),
			getColumns: react.useCallback(() => state.columnWidthState, [state.columnWidthState]),
			getColumnWidth: react.useCallback((colId) => getColumnWidth(state.columnWidthState, colId), [state.columnWidthState]),
			setColumnWidth
		};
	}

//#endregion
//#region node_modules/@fluentui/react-table/lib/hooks/useKeyboardResizing.js
	const STEP = 20;
	const PRECISION_MODIFIER = Shift;
	const PRECISION_FACTOR = 1 / 4;
	function useKeyboardResizing(columnResizeState) {
		const [columnId, setColumnId] = react.useState();
		const onChangeRef = react.useRef(void 0);
		const { findPrevFocusable } = useFocusFinders();
		const columnResizeStateRef = react.useRef(columnResizeState);
		react.useEffect(() => {
			columnResizeStateRef.current = columnResizeState;
		}, [columnResizeState]);
		const [resizeHandleRefs] = react.useState(() => /* @__PURE__ */ new Map());
		const keyboardHandler = useEventCallback((event) => {
			if (!columnId) return;
			const width = columnResizeStateRef.current.getColumnWidth(columnId);
			const precisionModifier = event.getModifierState(PRECISION_MODIFIER);
			const stopEvent = () => {
				event.preventDefault();
				event.stopPropagation();
			};
			switch (event.key) {
				case ArrowLeft:
					stopEvent();
					columnResizeStateRef.current.setColumnWidth(event.nativeEvent, {
						columnId,
						width: width - (precisionModifier ? STEP * PRECISION_FACTOR : STEP)
					});
					return;
				case ArrowRight:
					stopEvent();
					columnResizeStateRef.current.setColumnWidth(event.nativeEvent, {
						columnId,
						width: width + (precisionModifier ? STEP * PRECISION_FACTOR : STEP)
					});
					return;
				case Space:
				case Enter:
				case Escape:
					var _resizeHandleRefs_get_current, _resizeHandleRefs_get;
					stopEvent();
					(_resizeHandleRefs_get = resizeHandleRefs.get(columnId)) === null || _resizeHandleRefs_get === void 0 || (_resizeHandleRefs_get_current = _resizeHandleRefs_get.current) == null || _resizeHandleRefs_get_current.blur();
					break;
			}
		});
		const enableInteractiveMode = react.useCallback((colId) => {
			var _onChangeRef_current, _resizeHandleRefs_get;
			setColumnId(colId);
			(_onChangeRef_current = onChangeRef.current) === null || _onChangeRef_current === void 0 || _onChangeRef_current.call(onChangeRef, colId, true);
			const handle = (_resizeHandleRefs_get = resizeHandleRefs.get(colId)) === null || _resizeHandleRefs_get === void 0 ? void 0 : _resizeHandleRefs_get.current;
			if (handle) {
				handle.setAttribute("tabindex", "-1");
				handle.tabIndex = -1;
				handle.focus();
			}
		}, [resizeHandleRefs]);
		const disableInteractiveMode = react.useCallback(() => {
			var _onChangeRef_current, _resizeHandleRefs_get;
			if (!columnId) return;
			(_onChangeRef_current = onChangeRef.current) === null || _onChangeRef_current === void 0 || _onChangeRef_current.call(onChangeRef, columnId, false);
			const el = (_resizeHandleRefs_get = resizeHandleRefs.get(columnId)) === null || _resizeHandleRefs_get === void 0 ? void 0 : _resizeHandleRefs_get.current;
			if (el) {
				var _findPrevFocusable;
				(_findPrevFocusable = findPrevFocusable(el)) === null || _findPrevFocusable === void 0 || _findPrevFocusable.focus();
				el.removeAttribute("tabindex");
			}
			setColumnId(void 0);
		}, [
			columnId,
			findPrevFocusable,
			resizeHandleRefs
		]);
		const toggleInteractiveMode = (colId, onChange) => {
			onChangeRef.current = onChange;
			if (!columnId) enableInteractiveMode(colId);
			else if (colId && columnId !== colId) {
				enableInteractiveMode(colId);
				setColumnId(colId);
			} else disableInteractiveMode();
		};
		const getKeyboardResizingRef = react.useCallback((colId) => {
			const ref = resizeHandleRefs.get(colId) || react.createRef();
			resizeHandleRefs.set(colId, ref);
			return ref;
		}, [resizeHandleRefs]);
		const tabsterAttrs = useTabsterAttributes({ focusable: { ignoreKeydown: {
			ArrowLeft: true,
			ArrowRight: true
		} } });
		return {
			toggleInteractiveMode,
			columnId,
			getKeyboardResizingProps: react.useCallback((colId, currentWidth) => ({
				onKeyDown: keyboardHandler,
				onBlur: disableInteractiveMode,
				ref: getKeyboardResizingRef(colId),
				role: "separator",
				"aria-label": "Resize column",
				"aria-valuetext": `${currentWidth} pixels`,
				"aria-hidden": colId === columnId ? false : true,
				tabIndex: colId === columnId ? 0 : void 0,
				...tabsterAttrs
			}), [
				columnId,
				disableInteractiveMode,
				getKeyboardResizingRef,
				keyboardHandler,
				tabsterAttrs
			])
		};
	}

//#endregion
//#region node_modules/@fluentui/react-table/lib/hooks/useTableColumnSizing.js
	const defaultColumnSizingState = {
		getColumnWidths: () => [],
		getOnMouseDown: () => () => null,
		setColumnWidth: () => null,
		getTableProps: () => ({}),
		getTableHeaderCellProps: () => ({
			style: {},
			columnId: ""
		}),
		getTableCellProps: () => ({
			style: {},
			columnId: ""
		}),
		enableKeyboardMode: () => () => null
	};
	function useTableColumnSizing_unstable(params) {
		"use no memo";
		return (tableState) => useTableColumnSizingState(tableState, {
			autoFitColumns: true,
			...params
		});
	}
	function getColumnStyles(column$1, dragging) {
		const width = column$1.width;
		return {
			width,
			minWidth: width,
			maxWidth: width,
			...dragging ? { pointerEvents: "none" } : {}
		};
	}
	function useTableColumnSizingState(tableState, params = {}) {
		const { columns } = tableState;
		const { width, measureElementRef } = useMeasureElement();
		const columnResizeState = useTableColumnResizeState(columns, width + ((params === null || params === void 0 ? void 0 : params.containerWidthOffset) || 0), params);
		const mouseHandler = useTableColumnResizeMouseHandler(columnResizeState);
		const { toggleInteractiveMode, getKeyboardResizingProps } = useKeyboardResizing(columnResizeState);
		const { autoFitColumns } = params;
		const enableKeyboardMode = react.useCallback((columnId, onChange) => (e) => {
			e.preventDefault();
			e.nativeEvent.stopPropagation();
			toggleInteractiveMode(columnId, onChange);
		}, [toggleInteractiveMode]);
		const { getColumnById: getColumnById$1, setColumnWidth, getColumns } = columnResizeState;
		const { getOnMouseDown, dragging } = mouseHandler;
		return {
			...tableState,
			tableRef: measureElementRef,
			columnSizing_unstable: {
				getOnMouseDown,
				setColumnWidth: (columnId, w) => setColumnWidth(void 0, {
					columnId,
					width: w
				}),
				getColumnWidths: getColumns,
				getTableProps: (props = {}) => {
					return {
						...props,
						style: {
							minWidth: "fit-content",
							...props.style || {}
						}
					};
				},
				getTableHeaderCellProps: react.useCallback((columnId) => {
					var _columns_;
					const col = getColumnById$1(columnId);
					const aside = ((_columns_ = columns[columns.length - 1]) === null || _columns_ === void 0 ? void 0 : _columns_.columnId) === columnId && autoFitColumns ? null : /* @__PURE__ */ react.createElement(TableResizeHandle, {
						onMouseDown: getOnMouseDown(columnId),
						onTouchStart: getOnMouseDown(columnId),
						...getKeyboardResizingProps(columnId, (col === null || col === void 0 ? void 0 : col.width) || 0)
					});
					return col ? {
						style: getColumnStyles(col, dragging),
						aside
					} : {};
				}, [
					getColumnById$1,
					columns,
					dragging,
					getKeyboardResizingProps,
					getOnMouseDown,
					autoFitColumns
				]),
				getTableCellProps: react.useCallback((columnId) => {
					const col = getColumnById$1(columnId);
					return col ? { style: getColumnStyles(col) } : {};
				}, [getColumnById$1]),
				enableKeyboardMode
			}
		};
	}

//#endregion
//#region node_modules/@fluentui/react-table/lib/hooks/useTableFeatures.js
	const defaultRowEnhancer = (row) => row;
	const defaultTableState = {
		selection: defaultTableSelectionState,
		sort: defaultTableSortState,
		getRows: () => [],
		getRowId: () => "",
		items: [],
		columns: [],
		columnSizing_unstable: defaultColumnSizingState,
		tableRef: react.createRef()
	};
	function useTableFeatures(options, plugins = []) {
		const { items, getRowId, columns } = options;
		const initialState = {
			getRowId,
			items,
			columns,
			getRows: react.useCallback((rowEnhancer = defaultRowEnhancer) => {
				return items.map((item, i) => {
					var _getRowId;
					return rowEnhancer({
						item,
						rowId: (_getRowId = getRowId === null || getRowId === void 0 ? void 0 : getRowId(item)) !== null && _getRowId !== void 0 ? _getRowId : i
					});
				});
			}, [items, getRowId]),
			selection: defaultTableSelectionState,
			sort: defaultTableSortState,
			columnSizing_unstable: defaultColumnSizingState,
			tableRef: react.createRef()
		};
		return plugins.reduce((state, plugin) => plugin(state), initialState);
	}

//#endregion
//#region node_modules/@fluentui/react-table/lib/hooks/createColumn.js
	const defaultCompare = () => 0;
	const defaultRenderCell = () => {
		console.warn("@fluentui/react-table: You are using the default column renderCell function that renders null");
		return null;
	};
	const defaultRenderHeaderCell = () => {
		console.warn("@fluentui/react-table: You are using the default column renderHeaderCell function that renders null");
		return null;
	};
	/**
	* Helper function to create column definition with defaults
	* @param options - column definition options
	* @returns - column definition with defaults
	*/ function createTableColumn(options) {
		const { columnId, renderCell = defaultRenderCell, renderHeaderCell = defaultRenderHeaderCell, compare = defaultCompare } = options;
		return {
			columnId,
			renderCell,
			renderHeaderCell,
			compare
		};
	}

//#endregion
//#region node_modules/@fluentui/react-table/lib/hooks/useTableCompositeNavigation.js
	function useTableCompositeNavigation() {
		const horizontalAttr = useArrowNavigationGroup({ axis: "horizontal" });
		const gridAttr = useArrowNavigationGroup({ axis: "grid" });
		const groupperAttr = useFocusableGroup({ tabBehavior: "limited-trap-focus" });
		const { findFirstFocusable } = useFocusFinders();
		const { targetDocument } = useFluent();
		const rowAttr = useMergedTabsterAttributes_unstable(horizontalAttr, groupperAttr);
		return {
			onTableKeyDown: react.useCallback((e) => {
				if (!targetDocument) return;
				let activeElement = targetDocument.activeElement;
				if (!activeElement || !e.currentTarget.contains(activeElement)) return;
				const activeElementRole = activeElement.getAttribute("role");
				if (e.key === ArrowRight && activeElementRole === "row" && isHTMLElement(activeElement)) {
					var _findFirstFocusable;
					(_findFirstFocusable = findFirstFocusable(activeElement)) === null || _findFirstFocusable === void 0 || _findFirstFocusable.focus();
				}
				if (activeElementRole === "row") return;
				const isInCell = (() => {
					let cur = isHTMLElement(activeElement) ? activeElement : null;
					while (cur) {
						const curRole = cur.getAttribute("role");
						if (curRole === "cell" || curRole === "gridcell") return true;
						cur = cur.parentElement;
					}
					return false;
				})();
				if (e.key === ArrowLeft && isInCell) {
					activeElement.dispatchEvent(new GroupperMoveFocusEvent({ action: GroupperMoveFocusActions.Escape }));
					return;
				}
				if ((e.key === ArrowDown || e.key === ArrowUp) && isInCell) {
					activeElement.dispatchEvent(new GroupperMoveFocusEvent({ action: GroupperMoveFocusActions.Escape }));
					activeElement = targetDocument.activeElement;
					if (activeElement) activeElement.dispatchEvent(new MoverMoveFocusEvent({ key: MoverKeys[e.key] }));
				}
			}, [targetDocument, findFirstFocusable]),
			tableTabsterAttribute: gridAttr,
			tableRowTabsterAttribute: rowAttr
		};
	}

//#endregion
//#region node_modules/@fluentui/react-table/lib/contexts/tableContext.js
	const tableContext = react.createContext(void 0);
	const tableContextDefaultValue = {
		size: "medium",
		noNativeElements: false,
		sortable: false
	};
	const TableContextProvider = tableContext.Provider;
	const useTableContext = () => {
		var _React_useContext;
		return (_React_useContext = react.useContext(tableContext)) !== null && _React_useContext !== void 0 ? _React_useContext : tableContextDefaultValue;
	};

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/TableCell/useTableCell.js
/**
	* Create the state required to render TableCell.
	*
	* The returned state can be modified with hooks such as useTableCellStyles_unstable,
	* before being passed to renderTableCell_unstable.
	*
	* @param props - props from this instance of TableCell
	* @param ref - reference to root HTMLElement of TableCell
	*/ const useTableCell_unstable = (props, ref) => {
		const { noNativeElements, size: size$2 } = useTableContext();
		var _props_as;
		const rootComponent = ((_props_as = props.as) !== null && _props_as !== void 0 ? _props_as : noNativeElements) ? "div" : "td";
		return {
			components: { root: rootComponent },
			root: always(getIntrinsicElementProps(rootComponent, {
				ref,
				role: rootComponent === "div" ? "cell" : void 0,
				...props
			}), { elementType: rootComponent }),
			noNativeElements,
			size: size$2
		};
	};

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/TableCell/renderTableCell.js
/**
	* Render the final JSX of TableCell
	*/ const renderTableCell_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, {});
	};

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/TableCell/useTableCellStyles.styles.js
	const tableCellClassName = "fui-TableCell";
	const tableCellClassNames = { root: tableCellClassName };
	const useTableLayoutStyles$6 = /* @__PURE__ */ __styles({
		root: {
			mc9l5x: "f15pt5es",
			ha4doy: "fmrv4ls"
		},
		medium: { Bqenvij: "f1ft4266" },
		small: { Bqenvij: "fbsu25e" },
		"extra-small": { Bqenvij: "frvgh55" }
	}, { d: [
		".f15pt5es{display:table-cell;}",
		".fmrv4ls{vertical-align:middle;}",
		".f1ft4266{height:44px;}",
		".fbsu25e{height:34px;}",
		".frvgh55{height:24px;}"
	] });
	const useFlexLayoutStyles$6 = /* @__PURE__ */ __styles({
		root: {
			mc9l5x: "f22iagw",
			Bf4jedk: "f10tiqix",
			Bt984gj: "f122n59",
			xawz: 0,
			Bh6795r: 0,
			Bnnss6s: 0,
			fkmc3a: "f1izfyrr"
		},
		medium: { sshi5w: "f5pgtk9" },
		small: { sshi5w: "fcep9tg" },
		"extra-small": { sshi5w: "f1pha7fy" }
	}, { d: [
		".f22iagw{display:flex;}",
		".f10tiqix{min-width:0px;}",
		".f122n59{align-items:center;}",
		[".f1izfyrr{flex:1 1 0px;}", { p: -1 }],
		".f5pgtk9{min-height:44px;}",
		".fcep9tg{min-height:34px;}",
		".f1pha7fy{min-height:24px;}"
	] });
	/**
	* Styles for the root slot
	*/
	const useStyles$67 = /* @__PURE__ */ __styles({ root: {
		qhf8xq: "f10pi13n",
		Byoj8tv: 0,
		uwmqm3: 0,
		z189sj: 0,
		z8tnut: 0,
		B0ocmuz: "f3gpkru",
		Bfpq7zp: 0,
		g9k6zt: 0,
		Bn4voq9: 0,
		giviqs: "f1dxfoyt",
		Bw81rd7: 0,
		kdpuga: 0,
		dm238s: 0,
		B6xbmo0: 0,
		B3whbx2: "f2krc9w"
	} }, { d: [
		".f10pi13n{position:relative;}",
		[".f3gpkru{padding:0px var(--spacingHorizontalS);}", { p: -1 }],
		[".f1dxfoyt[data-fui-focus-visible]{outline:2px solid var(--colorStrokeFocus2);}", { p: -1 }],
		[".f2krc9w[data-fui-focus-visible]{border-radius:var(--borderRadiusMedium);}", { p: -1 }]
	] });
	/**
	* Apply styling to the TableCell slots based on the state
	*/
	const useTableCellStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$67();
		const layoutStyles = {
			table: useTableLayoutStyles$6(),
			flex: useFlexLayoutStyles$6()
		};
		state.root.className = mergeClasses(tableCellClassNames.root, styles.root, state.noNativeElements ? layoutStyles.flex.root : layoutStyles.table.root, state.noNativeElements ? layoutStyles.flex[state.size] : layoutStyles.table[state.size], state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/TableCell/TableCell.js
/**
	* TableCell component
	*/ const TableCell = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useTableCell_unstable(props, ref);
		useTableCellStyles_unstable(state);
		useCustomStyleHook("useTableCellStyles_unstable")(state);
		return renderTableCell_unstable(state);
	});
	TableCell.displayName = "TableCell";

//#endregion
//#region node_modules/@fluentui/react-table/lib/contexts/tableHeaderContext.js
	const tableHeaderContext = react.createContext(void 0);
	const tableHeaderContextDefaultValue = "";
	const TableHeaderContextProvider = tableHeaderContext.Provider;
	const useIsInTableHeader = () => react.useContext(tableHeaderContext) === tableHeaderContextDefaultValue;

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/TableRow/useTableRow.js
/**
	* Create the state required to render TableRow.
	*
	* The returned state can be modified with hooks such as useTableRowStyles_unstable,
	* before being passed to renderTableRow_unstable.
	*
	* @param props - props from this instance of TableRow
	* @param ref - reference to root HTMLElement of TableRow
	*/ const useTableRow_unstable = (props, ref) => {
		const { noNativeElements, size: size$2 } = useTableContext();
		var _props_as;
		const rootComponent = ((_props_as = props.as) !== null && _props_as !== void 0 ? _props_as : noNativeElements) ? "div" : "tr";
		const focusVisibleRef = useFocusVisible();
		const focusWithinRef = useFocusWithin();
		const isHeaderRow = useIsInTableHeader();
		var _props_appearance;
		return {
			components: { root: rootComponent },
			root: always(getIntrinsicElementProps(rootComponent, {
				ref: useMergedRefs(ref, focusVisibleRef, focusWithinRef),
				role: rootComponent === "div" ? "row" : void 0,
				...props
			}), { elementType: rootComponent }),
			size: size$2,
			noNativeElements,
			appearance: (_props_appearance = props.appearance) !== null && _props_appearance !== void 0 ? _props_appearance : "none",
			isHeaderRow
		};
	};

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/TableRow/renderTableRow.js
/**
	* Render the final JSX of TableRow
	*/ const renderTableRow_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, {});
	};

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/TableCellActions/useTableCellActionsStyles.styles.js
	const tableCellActionsClassNames = { root: "fui-TableCellActions" };
	/**
	* Styles for the root slot
	*/
	const useStyles$66 = /* @__PURE__ */ __styles({
		root: {
			De3pzq: "f1u2r49w",
			qhf8xq: "f1euv43f",
			j35jbq: ["f10k790i", "f1xynx9j"],
			Bhzewxz: "f1i1t8d1",
			Bz10aip: "f188r07x",
			abs64n: "fk73vx1",
			Frg6f3: ["fcgxt0o", "f1ujusj6"]
		},
		visible: { abs64n: "f5p0z4x" }
	}, { d: [
		".f1u2r49w{background-color:inherit;}",
		".f1euv43f{position:absolute;}",
		".f10k790i{right:0px;}",
		".f1xynx9j{left:0px;}",
		".f1i1t8d1{top:50%;}",
		".f188r07x{transform:translateY(-50%);}",
		".fk73vx1{opacity:0;}",
		".fcgxt0o{margin-left:auto;}",
		".f1ujusj6{margin-right:auto;}",
		".f5p0z4x{opacity:1;}"
	] });
	/**
	* Apply styling to the TableCellActions slots based on the state
	*/
	const useTableCellActionsStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$66();
		state.root.className = mergeClasses(tableCellActionsClassNames.root, styles.root, state.visible && styles.visible, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/TableSelectionCell/useTableSelectionCellStyles.styles.js
	const CELL_WIDTH = 44;
	const tableSelectionCellClassNames = {
		root: "fui-TableSelectionCell",
		checkboxIndicator: "fui-TableSelectionCell__checkboxIndicator",
		radioIndicator: "fui-TableSelectionCell__radioIndicator"
	};
	const useTableLayoutStyles$5 = /* @__PURE__ */ __styles({ root: {
		mc9l5x: "f15pt5es",
		a9b677: "fksc0bp"
	} }, { d: [".f15pt5es{display:table-cell;}", ".fksc0bp{width:44px;}"] });
	const useFlexLayoutStyles$5 = /* @__PURE__ */ __styles({ root: {
		mc9l5x: "f22iagw",
		xawz: 0,
		Bh6795r: 0,
		Bnnss6s: 0,
		fkmc3a: "f1izfyrr",
		Bf4jedk: "fvrlu0f",
		B2u0y6b: "f1c71y05",
		Brf1p80: "f4d9j23"
	} }, { d: [
		".f22iagw{display:flex;}",
		[".f1izfyrr{flex:1 1 0px;}", { p: -1 }],
		".fvrlu0f{min-width:44px;}",
		".f1c71y05{max-width:44px;}",
		".f4d9j23{justify-content:center;}"
	] });
	/**
	* Styles for the root slot
	*/
	const useStyles$65 = /* @__PURE__ */ __styles({
		root: {
			fsow6f: "f17mccla",
			Huce71: "fz5stix",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f1mk8lai",
			Bfpq7zp: 0,
			g9k6zt: 0,
			Bn4voq9: 0,
			giviqs: "f1dxfoyt",
			Bw81rd7: 0,
			kdpuga: 0,
			dm238s: 0,
			B6xbmo0: 0,
			B3whbx2: "f2krc9w"
		},
		radioIndicator: {
			mc9l5x: "f22iagw",
			Bh6795r: "fqerorx",
			Bt984gj: "f122n59",
			Brf1p80: "f4d9j23"
		},
		subtle: {
			abs64n: "fk73vx1",
			B8a84jv: "f1y7ij6c"
		},
		hidden: { abs64n: "fk73vx1" }
	}, { d: [
		".f17mccla{text-align:center;}",
		".fz5stix{white-space:nowrap;}",
		[".f1mk8lai{padding:0;}", { p: -1 }],
		[".f1dxfoyt[data-fui-focus-visible]{outline:2px solid var(--colorStrokeFocus2);}", { p: -1 }],
		[".f2krc9w[data-fui-focus-visible]{border-radius:var(--borderRadiusMedium);}", { p: -1 }],
		".f22iagw{display:flex;}",
		".fqerorx{flex-grow:1;}",
		".f122n59{align-items:center;}",
		".f4d9j23{justify-content:center;}",
		".fk73vx1{opacity:0;}",
		".f1y7ij6c[data-fui-focus-within]:focus-within{opacity:1;}"
	] });
	/**
	* Apply styling to the TableSelectionCell slots based on the state
	*/
	const useTableSelectionCellStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$65();
		const layoutStyles = {
			table: useTableLayoutStyles$5(),
			flex: useFlexLayoutStyles$5()
		};
		state.root.className = mergeClasses(tableSelectionCellClassNames.root, styles.root, state.noNativeElements ? layoutStyles.flex.root : layoutStyles.table.root, state.subtle && state.checked === false && styles.subtle, state.hidden && styles.hidden, state.root.className);
		if (state.checkboxIndicator) state.checkboxIndicator.className = mergeClasses(tableSelectionCellClassNames.checkboxIndicator, state.checkboxIndicator.className);
		if (state.radioIndicator) state.radioIndicator.className = mergeClasses(tableSelectionCellClassNames.radioIndicator, styles.radioIndicator, state.radioIndicator.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/TableRow/useTableRowStyles.styles.js
	const tableRowClassName = "fui-TableRow";
	const tableRowClassNames = { root: tableRowClassName };
	const useTableLayoutStyles$4 = /* @__PURE__ */ __styles({ root: { mc9l5x: "f1u0rzck" } }, { d: [".f1u0rzck{display:table-row;}"] });
	const useFlexLayoutStyles$4 = /* @__PURE__ */ __styles({ root: {
		mc9l5x: "f22iagw",
		Bt984gj: "f122n59"
	} }, { d: [".f22iagw{display:flex;}", ".f122n59{align-items:center;}"] });
	/**
	* Styles for the root slot
	*/
	const useStyles$64 = /* @__PURE__ */ __styles({
		root: {
			sj55zd: "f19n0e5",
			B7ck84d: "f1ewtqcl",
			Bconypa: "f1jazu75",
			B6guboy: "f1xeqee6",
			Bfpq7zp: 0,
			g9k6zt: 0,
			Bn4voq9: 0,
			giviqs: "f1dxfoyt",
			Bw81rd7: 0,
			kdpuga: 0,
			dm238s: 0,
			B6xbmo0: 0,
			B3whbx2: "f2krc9w"
		},
		rootInteractive: {
			B6guboy: "f1xeqee6",
			ecr2s2: "f1wfn5kd",
			lj723h: "f1g4hkjv",
			B43xm9u: "f15ngxrw",
			i921ia: "fjbbrdp",
			Jwef8y: "f1t94bn6",
			Bi91k9c: "feu1g3u",
			Bpt6rm4: "f1uorfem",
			ff6mpl: "fw60kww",
			Bahaeuw: "f1v3eptx",
			F230oe: "f8gmj8i",
			Bdw8ktp: ["f1ap8nzx", "fjag8bx"],
			Bj1xduy: "f1igan7k",
			Bhh2cfd: ["fjag8bx", "f1ap8nzx"]
		},
		medium: {
			B9xav0g: 0,
			oivjwe: 0,
			Bn0qgzm: 0,
			Bgfg5da: "f1facbz3"
		},
		small: {
			B9xav0g: 0,
			oivjwe: 0,
			Bn0qgzm: 0,
			Bgfg5da: "f1facbz3"
		},
		"extra-small": { Be2twd7: "fy9rknc" },
		brand: {
			De3pzq: "f16xkysk",
			g2u3we: "f1bh3yvw",
			h3c5rm: ["fmi79ni", "f11fozsx"],
			B9xav0g: "fnzw4c6",
			zhjwy3: ["f11fozsx", "fmi79ni"],
			ecr2s2: "f7tkmfy",
			lj723h: "f1r2dosr",
			wmvzou: 0,
			sc4o1m: 0,
			wymq9i: 0,
			u9orzk: 0,
			puiv5t: 0,
			Bosien3: 0,
			b2z72d: 0,
			Beulxaw: 0,
			B57pkaw: 0,
			Jcjdmf: 0,
			B8qgbzl: 0,
			Bbmb0sr: 0,
			B14q8qp: 0,
			Bcq6wej: 0,
			Byz1pjr: 0,
			kr9cjb: 0,
			Ff9ifp: "f1msmgpi",
			Bmclvqj: 0,
			psczho: 0,
			B0tx59b: 0,
			sk7i8k: 0,
			zlwzm7: "fbo0xvd",
			Bkp2nk: "fjuvmhu",
			gy0h4g: "f1kvufhq"
		},
		neutral: {
			wmvzou: 0,
			sc4o1m: 0,
			wymq9i: 0,
			u9orzk: 0,
			puiv5t: 0,
			Bosien3: 0,
			b2z72d: 0,
			Beulxaw: 0,
			B57pkaw: 0,
			Jcjdmf: 0,
			B8qgbzl: 0,
			Bbmb0sr: 0,
			B14q8qp: 0,
			Bcq6wej: 0,
			Byz1pjr: 0,
			kr9cjb: 0,
			Ff9ifp: "f1msmgpi",
			Bmclvqj: 0,
			psczho: 0,
			B0tx59b: 0,
			sk7i8k: 0,
			zlwzm7: "fbo0xvd",
			Bkp2nk: "fjuvmhu",
			gy0h4g: "f1kvufhq",
			De3pzq: "fq5gl1p",
			sj55zd: "f1cgsbmv",
			Jwef8y: "f1uqaxdt",
			ecr2s2: "fa9o754",
			g2u3we: "frmsihh",
			h3c5rm: ["frttxa5", "f11o2r7f"],
			B9xav0g: "fem5et0",
			zhjwy3: ["f11o2r7f", "frttxa5"]
		},
		none: {}
	}, {
		d: [
			".f19n0e5{color:var(--colorNeutralForeground1);}",
			".f1ewtqcl{box-sizing:border-box;}",
			".f1jazu75[data-fui-focus-within]:focus-within .fui-TableSelectionCell{opacity:1;}",
			".f1xeqee6[data-fui-focus-within]:focus-within .fui-TableCellActions{opacity:1;}",
			[".f1dxfoyt[data-fui-focus-visible]{outline:2px solid var(--colorStrokeFocus2);}", { p: -1 }],
			[".f2krc9w[data-fui-focus-visible]{border-radius:var(--borderRadiusMedium);}", { p: -1 }],
			[".f1facbz3{border-bottom:var(--strokeWidthThin) solid var(--colorNeutralStroke2);}", { p: -1 }],
			[".f1facbz3{border-bottom:var(--strokeWidthThin) solid var(--colorNeutralStroke2);}", { p: -1 }],
			".fy9rknc{font-size:var(--fontSizeBase200);}",
			".f16xkysk{background-color:var(--colorBrandBackground2);}",
			".f1bh3yvw{border-top-color:var(--colorTransparentStrokeInteractive);}",
			".fmi79ni{border-right-color:var(--colorTransparentStrokeInteractive);}",
			".f11fozsx{border-left-color:var(--colorTransparentStrokeInteractive);}",
			".fnzw4c6{border-bottom-color:var(--colorTransparentStrokeInteractive);}",
			".fq5gl1p{background-color:var(--colorSubtleBackgroundSelected);}",
			".f1cgsbmv{color:var(--colorNeutralForeground1Hover);}",
			".frmsihh{border-top-color:var(--colorNeutralStrokeOnBrand);}",
			".frttxa5{border-right-color:var(--colorNeutralStrokeOnBrand);}",
			".f11o2r7f{border-left-color:var(--colorNeutralStrokeOnBrand);}",
			".fem5et0{border-bottom-color:var(--colorNeutralStrokeOnBrand);}"
		],
		a: [
			".f1wfn5kd:active{background-color:var(--colorSubtleBackgroundPressed);}",
			".f1g4hkjv:active{color:var(--colorNeutralForeground1Pressed);}",
			".f15ngxrw:active .fui-TableCellActions{opacity:1;}",
			".fjbbrdp:active .fui-TableSelectionCell{opacity:1;}",
			".f7tkmfy:active{background-color:var(--colorBrandBackground2);}",
			".f1r2dosr:active{color:var(--colorNeutralForeground1);}",
			".fa9o754:active{background-color:var(--colorSubtleBackgroundSelected);}"
		],
		h: [
			".f1t94bn6:hover{background-color:var(--colorSubtleBackgroundHover);}",
			".feu1g3u:hover{color:var(--colorNeutralForeground1Hover);}",
			".f1uorfem:hover .fui-TableCellActions{opacity:1;}",
			".fw60kww:hover .fui-TableSelectionCell{opacity:1;}",
			".f1uqaxdt:hover{background-color:var(--colorSubtleBackgroundSelected);}"
		],
		m: [
			["@media (forced-colors: active){.f1v3eptx:hover{color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f8gmj8i:hover{border-top-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1ap8nzx:hover{border-right-color:Highlight;}.fjag8bx:hover{border-left-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1igan7k:hover{border-bottom-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1msmgpi{border:2px solid transparent;}}", {
				p: -2,
				m: "(forced-colors: active)"
			}],
			["@media (forced-colors: active){.fbo0xvd{border-radius:var(--borderRadiusMedium);}}", {
				p: -1,
				m: "(forced-colors: active)"
			}],
			["@media (forced-colors: active){.fjuvmhu{box-sizing:border-box;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1kvufhq:focus-visible{outline-offset:-4px;}}", { m: "(forced-colors: active)" }]
		]
	});
	/**
	* Apply styling to the TableRow slots based on the state
	*/
	const useTableRowStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$64();
		const layoutStyles = {
			table: useTableLayoutStyles$4(),
			flex: useFlexLayoutStyles$4()
		};
		state.root.className = mergeClasses(tableRowClassNames.root, styles.root, !state.isHeaderRow && styles.rootInteractive, styles[state.size], state.noNativeElements ? layoutStyles.flex.root : layoutStyles.table.root, styles[state.appearance], state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/TableRow/TableRow.js
/**
	* TableRow component
	*/ const TableRow = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useTableRow_unstable(props, ref);
		useTableRowStyles_unstable(state);
		useCustomStyleHook("useTableRowStyles_unstable")(state);
		return renderTableRow_unstable(state);
	});
	TableRow.displayName = "TableRow";

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/TableBody/useTableBody.js
/**
	* Create the state required to render TableBody.
	*
	* The returned state can be modified with hooks such as useTableBodyStyles_unstable,
	* before being passed to renderTableBody_unstable.
	*
	* @param props - props from this instance of TableBody
	* @param ref - reference to root HTMLElement of TableBody
	*/ const useTableBody_unstable = (props, ref) => {
		const { noNativeElements } = useTableContext();
		var _props_as;
		const rootComponent = ((_props_as = props.as) !== null && _props_as !== void 0 ? _props_as : noNativeElements) ? "div" : "tbody";
		return {
			components: { root: rootComponent },
			root: always(getIntrinsicElementProps(rootComponent, {
				ref,
				role: rootComponent === "div" ? "rowgroup" : void 0,
				...props
			}), { elementType: rootComponent }),
			noNativeElements
		};
	};

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/TableBody/renderTableBody.js
/**
	* Render the final JSX of TableBody
	*/ const renderTableBody_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, {});
	};

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/TableBody/useTableBodyStyles.styles.js
	const useTableLayoutStyles$3 = /* @__PURE__ */ __styles({ root: { mc9l5x: "f1tp1avn" } }, { d: [".f1tp1avn{display:table-row-group;}"] });
	const useFlexLayoutStyles$3 = /* @__PURE__ */ __styles({ root: { mc9l5x: "ftgm304" } }, { d: [".ftgm304{display:block;}"] });
	const tableBodyClassName = "fui-TableBody";
	const tableBodyClassNames = { root: "fui-TableBody" };
	/**
	* Apply styling to the TableBody slots based on the state
	*/
	const useTableBodyStyles_unstable = (state) => {
		"use no memo";
		const layoutStyles = {
			table: useTableLayoutStyles$3(),
			flex: useFlexLayoutStyles$3()
		};
		state.root.className = mergeClasses(tableBodyClassName, state.noNativeElements ? layoutStyles.flex.root : layoutStyles.table.root, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/TableBody/TableBody.js
/**
	* TableBody component
	*/ const TableBody = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useTableBody_unstable(props, ref);
		useTableBodyStyles_unstable(state);
		useCustomStyleHook("useTableBodyStyles_unstable")(state);
		return renderTableBody_unstable(state);
	});
	TableBody.displayName = "TableBody";

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/Table/useTable.js
/**
	* Create the state required to render Table.
	*
	* The returned state can be modified with hooks such as useTableStyles_unstable,
	* before being passed to renderTable_unstable.
	*
	* @param props - props from this instance of Table
	* @param ref - reference to root HTMLElement of Table
	*/ const useTable_unstable = (props, ref) => {
		var _props_as;
		const rootComponent = ((_props_as = props.as) !== null && _props_as !== void 0 ? _props_as : props.noNativeElements) ? "div" : "table";
		var _props_size, _props_noNativeElements, _props_sortable;
		return {
			components: { root: rootComponent },
			root: always(getIntrinsicElementProps(rootComponent, {
				ref,
				role: rootComponent === "div" ? "table" : void 0,
				...props
			}), { elementType: rootComponent }),
			size: (_props_size = props.size) !== null && _props_size !== void 0 ? _props_size : "medium",
			noNativeElements: (_props_noNativeElements = props.noNativeElements) !== null && _props_noNativeElements !== void 0 ? _props_noNativeElements : false,
			sortable: (_props_sortable = props.sortable) !== null && _props_sortable !== void 0 ? _props_sortable : false
		};
	};

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/Table/renderTable.js
/**
	* Render the final JSX of Table
	*/ const renderTable_unstable = (state, contextValues) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(TableContextProvider, {
			value: contextValues.table,
			children: /* @__PURE__ */ jsx(state.root, {})
		});
	};

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/Table/useTableStyles.styles.js
	const tableClassName = "fui-Table";
	const tableClassNames = { root: "fui-Table" };
	const useTableLayoutStyles$2 = /* @__PURE__ */ __styles({ root: {
		mc9l5x: "f1w4nmp0",
		ha4doy: "fmrv4ls",
		a9b677: "fly5x3f",
		B73mfa3: "f14m3nip"
	} }, { d: [
		".f1w4nmp0{display:table;}",
		".fmrv4ls{vertical-align:middle;}",
		".fly5x3f{width:100%;}",
		".f14m3nip{table-layout:fixed;}"
	] });
	const useFlexLayoutStyles$2 = /* @__PURE__ */ __styles({ root: { mc9l5x: "ftgm304" } }, { d: [".ftgm304{display:block;}"] });
	/**
	* Styles for the root slot
	*/
	const useStyles$63 = /* @__PURE__ */ __styles({ root: {
		po53p8: "fgkb47j",
		De3pzq: "fhovq9v"
	} }, { d: [".fgkb47j{border-collapse:collapse;}", ".fhovq9v{background-color:var(--colorSubtleBackground);}"] });
	/**
	* Apply styling to the Table slots based on the state
	*/
	const useTableStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$63();
		const layoutStyles = {
			table: useTableLayoutStyles$2(),
			flex: useFlexLayoutStyles$2()
		};
		state.root.className = mergeClasses(tableClassName, styles.root, state.noNativeElements ? layoutStyles.flex.root : layoutStyles.table.root, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/Table/useTableContextValues.js
	function useTableContextValues_unstable(state) {
		const { size: size$2, noNativeElements, sortable } = state;
		return { table: react.useMemo(() => ({
			noNativeElements,
			size: size$2,
			sortable
		}), [
			noNativeElements,
			size$2,
			sortable
		]) };
	}

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/Table/Table.js
/**
	* Table component
	*/ const Table = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useTable_unstable(props, ref);
		useTableStyles_unstable(state);
		useCustomStyleHook("useTableStyles_unstable")(state);
		return renderTable_unstable(state, useTableContextValues_unstable(state));
	});
	Table.displayName = "Table";

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/TableHeader/useTableHeader.js
/**
	* Create the state required to render TableHeader.
	*
	* The returned state can be modified with hooks such as useTableHeaderStyles_unstable,
	* before being passed to renderTableHeader_unstable.
	*
	* @param props - props from this instance of TableHeader
	* @param ref - reference to root HTMLElement of TableHeader
	*/ const useTableHeader_unstable = (props, ref) => {
		const { noNativeElements } = useTableContext();
		var _props_as;
		const rootComponent = ((_props_as = props.as) !== null && _props_as !== void 0 ? _props_as : noNativeElements) ? "div" : "thead";
		return {
			components: { root: rootComponent },
			root: always(getIntrinsicElementProps(rootComponent, {
				ref,
				role: rootComponent === "div" ? "rowgroup" : void 0,
				...props
			}), { elementType: rootComponent }),
			noNativeElements
		};
	};

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/TableHeader/renderTableHeader.js
/**
	* Render the final JSX of TableHeader
	*/ const renderTableHeader_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(TableHeaderContextProvider, {
			value: "",
			children: /* @__PURE__ */ jsx(state.root, {})
		});
	};

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/TableHeader/useTableHeaderStyles.styles.js
	const tableHeaderClassName = "fui-TableHeader";
	const tableHeaderClassNames = { root: "fui-TableHeader" };
	const useFlexLayoutStyles$1 = /* @__PURE__ */ __styles({ root: { mc9l5x: "ftgm304" } }, { d: [".ftgm304{display:block;}"] });
	const useTableLayoutStyles$1 = /* @__PURE__ */ __styles({ root: { mc9l5x: "f1tp1avn" } }, { d: [".f1tp1avn{display:table-row-group;}"] });
	/**
	* Apply styling to the TableHeader slots based on the state
	*/
	const useTableHeaderStyles_unstable = (state) => {
		"use no memo";
		const layoutStyles = {
			table: useTableLayoutStyles$1(),
			flex: useFlexLayoutStyles$1()
		};
		state.root.className = mergeClasses(tableHeaderClassName, state.noNativeElements ? layoutStyles.flex.root : layoutStyles.table.root, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/TableHeader/TableHeader.js
/**
	* TableHeader component
	*/ const TableHeader = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useTableHeader_unstable(props, ref);
		useTableHeaderStyles_unstable(state);
		useCustomStyleHook("useTableHeaderStyles_unstable")(state);
		return renderTableHeader_unstable(state);
	});
	TableHeader.displayName = "TableHeader";

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/TableHeaderCell/useTableHeaderCell.js
	const sortIcons = {
		ascending: /* @__PURE__ */ react.createElement(ArrowUpRegular, { fontSize: 12 }),
		descending: /* @__PURE__ */ react.createElement(ArrowDownRegular, { fontSize: 12 })
	};
	/**
	* Create the state required to render TableHeaderCell.
	*
	* The returned state can be modified with hooks such as useTableHeaderCellStyles_unstable,
	* before being passed to renderTableHeaderCell_unstable.
	*
	* @param props - props from this instance of TableHeaderCell
	* @param ref - reference to root HTMLElement of TableHeaderCell
	*/ const useTableHeaderCell_unstable = (props, ref) => {
		const { noNativeElements, sortable: contextSortable } = useTableContext();
		const { sortable = contextSortable } = props;
		var _props_as;
		const rootComponent = ((_props_as = props.as) !== null && _props_as !== void 0 ? _props_as : noNativeElements) ? "div" : "th";
		const buttonSlot = always(props.button, {
			elementType: "div",
			defaultProps: { as: "div" }
		});
		const ariaButtonProps = useARIAButtonProps(buttonSlot.as, buttonSlot);
		var _props_sortDirection;
		return {
			components: {
				root: rootComponent,
				button: "div",
				sortIcon: "span",
				aside: "span"
			},
			root: always(getIntrinsicElementProps(rootComponent, {
				ref: useMergedRefs(ref, useFocusWithin()),
				role: rootComponent === "div" ? "columnheader" : void 0,
				"aria-sort": sortable ? (_props_sortDirection = props.sortDirection) !== null && _props_sortDirection !== void 0 ? _props_sortDirection : "none" : void 0,
				...props
			}), { elementType: rootComponent }),
			aside: optional(props.aside, { elementType: "span" }),
			sortIcon: optional(props.sortIcon, {
				renderByDefault: !!props.sortDirection,
				defaultProps: { children: props.sortDirection ? sortIcons[props.sortDirection] : void 0 },
				elementType: "span"
			}),
			button: sortable ? ariaButtonProps : buttonSlot,
			sortable,
			noNativeElements
		};
	};

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/TableHeaderCell/renderTableHeaderCell.js
/**
	* Render the final JSX of TableHeaderCell
	*/ const renderTableHeaderCell_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(state.root, { children: [/* @__PURE__ */ jsxs(state.button, { children: [state.root.children, state.sortIcon && /* @__PURE__ */ jsx(state.sortIcon, {})] }), state.aside && /* @__PURE__ */ jsx(state.aside, {})] });
	};

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/TableHeaderCell/useTableHeaderCellStyles.styles.js
	const tableHeaderCellClassName = "fui-TableHeaderCell";
	const tableHeaderCellClassNames = {
		root: "fui-TableHeaderCell",
		button: "fui-TableHeaderCell__button",
		sortIcon: "fui-TableHeaderCell__sortIcon",
		aside: "fui-TableHeaderCell__aside"
	};
	const useTableLayoutStyles = /* @__PURE__ */ __styles({ root: {
		mc9l5x: "f15pt5es",
		ha4doy: "fmrv4ls"
	} }, { d: [".f15pt5es{display:table-cell;}", ".fmrv4ls{vertical-align:middle;}"] });
	const useFlexLayoutStyles = /* @__PURE__ */ __styles({ root: {
		mc9l5x: "f22iagw",
		xawz: 0,
		Bh6795r: 0,
		Bnnss6s: 0,
		fkmc3a: "f1izfyrr",
		Bf4jedk: "f10tiqix"
	} }, { d: [
		".f22iagw{display:flex;}",
		[".f1izfyrr{flex:1 1 0px;}", { p: -1 }],
		".f10tiqix{min-width:0px;}"
	] });
	/**
	* Styles for the root slot
	*/
	const useStyles$62 = /* @__PURE__ */ __styles({
		root: {
			Bhrd7zp: "figsok6",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f3gpkru",
			robkg1: 0,
			Bmvh20x: 0,
			B3nxjsc: 0,
			Bmkhcsx: "f14ym4q2",
			B8osjzx: 0,
			pehzd3: 0,
			Blsv9te: 0,
			u7xebq: 0,
			Bsvwmf7: "f1euou18",
			qhf8xq: "f10pi13n"
		},
		rootInteractive: {
			Bi91k9c: "feu1g3u",
			Jwef8y: "f1t94bn6",
			lj723h: "f1g4hkjv",
			ecr2s2: "f1wfn5kd"
		},
		resetButton: {
			B3rzk8w: "fq6nmtn",
			B7ck84d: "f1e4lqlz",
			De3pzq: "f1u2r49w",
			sj55zd: "f1ym3bx4",
			Bahqtrf: "f1mo0ibp",
			Be2twd7: "fjoy568",
			Bg96gwp: "fytdu2e",
			B68tc82: 0,
			Bmxbyg5: 0,
			Bpg54ce: "f1gl81tg",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f1mk8lai",
			Bgfg5da: 0,
			B9xav0g: 0,
			oivjwe: 0,
			Bn0qgzm: 0,
			B4g9neb: 0,
			zhjwy3: 0,
			wvpqe5: 0,
			ibv6hh: 0,
			u1mtju: 0,
			h3c5rm: 0,
			vrafjx: 0,
			Bekrc4i: 0,
			i8vvqc: 0,
			g2u3we: 0,
			icvyot: 0,
			B4j52fo: 0,
			irswps: "f3bhgqh",
			fsow6f: "fgusgyc"
		},
		button: {
			qhf8xq: "f10pi13n",
			a9b677: "fly5x3f",
			mc9l5x: "f22iagw",
			Bh6795r: 0,
			Bqenvij: "f1l02sjl",
			Bt984gj: "f122n59",
			i8kkvl: 0,
			Belr9w4: 0,
			rmohyg: "fkln5zr",
			sshi5w: "f1nxs5xn",
			xawz: 0,
			Bnnss6s: 0,
			fkmc3a: "f1izfyrr",
			oeaueh: "f1s6fcnf"
		},
		sortable: { Bceei9c: "f1k6fduh" },
		sortIcon: {
			mc9l5x: "f22iagw",
			Bt984gj: "f122n59",
			z8tnut: "fclwglc"
		},
		resizeHandle: {}
	}, {
		d: [
			".figsok6{font-weight:var(--fontWeightRegular);}",
			[".f3gpkru{padding:0px var(--spacingHorizontalS);}", { p: -1 }],
			[".f14ym4q2[data-fui-focus-within]:focus-within{outline:2px solid var(--colorStrokeFocus2);}", { p: -1 }],
			[".f1euou18[data-fui-focus-within]:focus-within{border-radius:var(--borderRadiusMedium);}", { p: -1 }],
			".f10pi13n{position:relative;}",
			".fq6nmtn{resize:horizontal;}",
			".f1e4lqlz{box-sizing:content-box;}",
			".f1u2r49w{background-color:inherit;}",
			".f1ym3bx4{color:inherit;}",
			".f1mo0ibp{font-family:inherit;}",
			".fjoy568{font-size:inherit;}",
			".fytdu2e{line-height:normal;}",
			[".f1gl81tg{overflow:visible;}", { p: -1 }],
			[".f1mk8lai{padding:0;}", { p: -1 }],
			[".f3bhgqh{border:none;}", { p: -2 }],
			".fgusgyc{text-align:unset;}",
			".fly5x3f{width:100%;}",
			".f22iagw{display:flex;}",
			".fqerorx{flex-grow:1;}",
			".f1l02sjl{height:100%;}",
			".f122n59{align-items:center;}",
			[".fkln5zr{gap:var(--spacingHorizontalXS);}", { p: -1 }],
			".f1nxs5xn{min-height:32px;}",
			[".f1izfyrr{flex:1 1 0px;}", { p: -1 }],
			".f1s6fcnf{outline-style:none;}",
			".f1k6fduh{cursor:pointer;}",
			".fclwglc{padding-top:var(--spacingVerticalXXS);}"
		],
		h: [".feu1g3u:hover{color:var(--colorNeutralForeground1Hover);}", ".f1t94bn6:hover{background-color:var(--colorSubtleBackgroundHover);}"],
		a: [".f1g4hkjv:active{color:var(--colorNeutralForeground1Pressed);}", ".f1wfn5kd:active{background-color:var(--colorSubtleBackgroundPressed);}"]
	});
	/**
	* Apply styling to the TableHeaderCell slots based on the state
	*/
	const useTableHeaderCellStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$62();
		const layoutStyles = {
			table: useTableLayoutStyles(),
			flex: useFlexLayoutStyles()
		};
		state.root.className = mergeClasses(tableHeaderCellClassNames.root, styles.root, state.sortable && styles.rootInteractive, state.noNativeElements ? layoutStyles.flex.root : layoutStyles.table.root, state.root.className);
		state.button.className = mergeClasses(tableHeaderCellClassNames.button, styles.resetButton, styles.button, state.sortable && styles.sortable, state.button.className);
		if (state.sortIcon) state.sortIcon.className = mergeClasses(tableHeaderCellClassNames.sortIcon, styles.sortIcon, state.sortIcon.className);
		if (state.aside) state.aside.className = mergeClasses(tableHeaderCellClassNames.aside, styles.resizeHandle, state.aside.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/TableHeaderCell/TableHeaderCell.js
/**
	* TableHeaderCell component
	*/ const TableHeaderCell = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useTableHeaderCell_unstable(props, ref);
		useTableHeaderCellStyles_unstable(state);
		useCustomStyleHook("useTableHeaderCellStyles_unstable")(state);
		return renderTableHeaderCell_unstable(state);
	});
	TableHeaderCell.displayName = "TableHeaderCell";

//#endregion
//#region node_modules/@fluentui/react-table/lib/contexts/columnIdContext.js
	const columnIdContext = react.createContext(void 0);
	const columnIdContextDefaultValue = "";
	const useColumnIdContext = () => {
		var _React_useContext;
		return (_React_useContext = react.useContext(columnIdContext)) !== null && _React_useContext !== void 0 ? _React_useContext : columnIdContextDefaultValue;
	};
	const ColumnIdContextProvider = columnIdContext.Provider;

//#endregion
//#region node_modules/@fluentui/react-table/lib/contexts/rowIdContext.js
	const rowIdContext = react.createContext(void 0);
	const tableRowIdContextDefaultValue = "";
	const useTableRowIdContext = () => {
		var _React_useContext;
		return (_React_useContext = react.useContext(rowIdContext)) !== null && _React_useContext !== void 0 ? _React_useContext : tableRowIdContextDefaultValue;
	};
	const TableRowIdContextProvider = rowIdContext.Provider;

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/TableSelectionCell/useTableSelectionCell.js
/**
	* Create the state required to render TableSelectionCell.
	*
	* The returned state can be modified with hooks such as useTableSelectionCellStyles_unstable,
	* before being passed to renderTableSelectionCell_unstable.
	*
	* @param props - props from this instance of TableSelectionCell
	* @param ref - reference to root HTMLElement of TableSelectionCell
	*/ const useTableSelectionCell_unstable = (props, ref) => {
		const tableCellState = useTableCell_unstable(props, useMergedRefs(ref, useFocusWithin()));
		const { noNativeElements } = useTableContext();
		const { type = "checkbox", checked = false, subtle = false, hidden = false, invisible = false } = props;
		return {
			...tableCellState,
			components: {
				...tableCellState.components,
				checkboxIndicator: Checkbox,
				radioIndicator: Radio
			},
			checkboxIndicator: optional(props.checkboxIndicator, {
				renderByDefault: type === "checkbox",
				defaultProps: { checked: props.checked },
				elementType: Checkbox
			}),
			radioIndicator: optional(props.radioIndicator, {
				renderByDefault: type === "radio",
				defaultProps: {
					checked: !!checked,
					input: { name: useId("table-selection-radio") }
				},
				elementType: Radio
			}),
			type,
			checked,
			noNativeElements,
			subtle,
			hidden: invisible || hidden
		};
	};

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/TableSelectionCell/renderTableSelectionCell.js
/**
	* Render the final JSX of TableSelectionCell
	*/ const renderTableSelectionCell_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(state.root, { children: [state.type === "checkbox" && state.checkboxIndicator && /* @__PURE__ */ jsx(state.checkboxIndicator, {}), state.type === "radio" && state.radioIndicator && /* @__PURE__ */ jsx(state.radioIndicator, {})] });
	};

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/TableSelectionCell/TableSelectionCell.js
/**
	* TableSelectionCell component
	*/ const TableSelectionCell = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useTableSelectionCell_unstable(props, ref);
		useTableSelectionCellStyles_unstable(state);
		useCustomStyleHook("useTableSelectionCellStyles_unstable")(state);
		return renderTableSelectionCell_unstable(state);
	});
	TableSelectionCell.displayName = "TableSelectionCell";

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/TableCellActions/useTableCellActions.js
/**
	* Create the state required to render TableCellActions.
	*
	* The returned state can be modified with hooks such as useTableCellActionsStyles_unstable,
	* before being passed to renderTableCellActions_unstable.
	*
	* @param props - props from this instance of TableCellActions
	* @param ref - reference to root HTMLElement of TableCellActions
	*/ const useTableCellActions_unstable = (props, ref) => {
		var _props_visible;
		return {
			components: { root: "div" },
			root: always(getIntrinsicElementProps("div", {
				ref,
				...props
			}), { elementType: "div" }),
			visible: (_props_visible = props.visible) !== null && _props_visible !== void 0 ? _props_visible : false
		};
	};

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/TableCellActions/renderTableCellActions.js
/**
	* Render the final JSX of TableCellActions
	*/ const renderTableCellActions_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, {});
	};

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/TableCellActions/TableCellActions.js
/**
	* TableCellActions component
	*/ const TableCellActions = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useTableCellActions_unstable(props, ref);
		useTableCellActionsStyles_unstable(state);
		useCustomStyleHook("useTableCellActionsStyles_unstable")(state);
		return renderTableCellActions_unstable(state);
	});
	TableCellActions.displayName = "TableCellActions";

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/TableCellLayout/useTableCellLayout.js
	const tableAvatarSizeMap = {
		medium: 32,
		small: 24,
		"extra-small": 20
	};
	/**
	* Create the state required to render TableCellLayout.
	*
	* The returned state can be modified with hooks such as useTableCellLayoutStyles_unstable,
	* before being passed to renderTableCellLayout_unstable.
	*
	* @param props - props from this instance of TableCellLayout
	* @param ref - reference to root HTMLElement of TableCellLayout
	*/ const useTableCellLayout_unstable = (props, ref) => {
		const { size: size$2 } = useTableContext();
		return {
			components: {
				root: "div",
				main: "span",
				description: "span",
				content: "div",
				media: "span"
			},
			root: always(getIntrinsicElementProps("div", {
				ref,
				...props
			}, ["content"]), { elementType: "div" }),
			appearance: props.appearance,
			truncate: props.truncate,
			main: optional(props.main, {
				renderByDefault: true,
				elementType: "span"
			}),
			media: optional(props.media, { elementType: "span" }),
			description: optional(props.description, { elementType: "span" }),
			content: optional(props.content, {
				renderByDefault: !!props.description || !!props.children,
				elementType: "div"
			}),
			avatarSize: tableAvatarSizeMap[size$2],
			size: size$2
		};
	};

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/TableCellLayout/renderTableCellLayout.js
/**
	* Render the final JSX of TableCellLayout
	*/ const renderTableCellLayout_unstable = (state, contextValues) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(state.root, { children: [state.media && /* @__PURE__ */ jsx(AvatarContextProvider, {
			value: contextValues.avatar,
			children: /* @__PURE__ */ jsx(state.media, {})
		}), state.content && /* @__PURE__ */ jsxs(state.content, { children: [state.main && /* @__PURE__ */ jsx(state.main, { children: state.root.children }), state.description && /* @__PURE__ */ jsx(state.description, {})] })] });
	};

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/TableCellLayout/useTableCellLayoutStyles.styles.js
	const tableCellLayoutClassNames = {
		root: "fui-TableCellLayout",
		media: "fui-TableCellLayout__media",
		main: "fui-TableCellLayout__main",
		description: "fui-TableCellLayout__description",
		content: "fui-TableCellLayout__content"
	};
	/**
	* Styles for the root slot
	*/
	const useStyles$61 = /* @__PURE__ */ __styles({
		root: {
			mc9l5x: "f22iagw",
			Bt984gj: "f122n59",
			i8kkvl: 0,
			Belr9w4: 0,
			rmohyg: "faqewft",
			xawz: 0,
			Bh6795r: 0,
			Bnnss6s: 0,
			fkmc3a: "f1izfyrr"
		},
		rootTruncate: { B68tc82: "f1p9o1ba" },
		content: {
			mc9l5x: "f22iagw",
			Beiy3e4: "f1vx9l62"
		},
		contentTruncate: { B68tc82: "f1p9o1ba" },
		media: {
			mc9l5x: "f22iagw",
			Bt984gj: "f122n59"
		},
		mediaExtraSmall: { Be2twd7: "f4ybsrx" },
		mediaSmallAndMedium: { Be2twd7: "fe5j1ua" },
		mediaPrimary: { Be2twd7: "f1rt2boy" },
		mainPrimary: { Bhrd7zp: "fl43uef" },
		mainTruncate: {
			B68tc82: "f1p9o1ba",
			Huce71: "fz5stix",
			ygn44y: "f1cmbuwj"
		},
		description: {
			sj55zd: "fkfq4zb",
			Bahqtrf: "fk6fouc",
			Be2twd7: "fy9rknc",
			Bhrd7zp: "figsok6",
			Bg96gwp: "fwrc4pm"
		}
	}, { d: [
		".f22iagw{display:flex;}",
		".f122n59{align-items:center;}",
		[".faqewft{gap:var(--spacingHorizontalS);}", { p: -1 }],
		[".f1izfyrr{flex:1 1 0px;}", { p: -1 }],
		".f1p9o1ba{overflow-x:hidden;}",
		".f1vx9l62{flex-direction:column;}",
		".f4ybsrx{font-size:16px;}",
		".fe5j1ua{font-size:20px;}",
		".f1rt2boy{font-size:24px;}",
		".fl43uef{font-weight:var(--fontWeightSemibold);}",
		".fz5stix{white-space:nowrap;}",
		".f1cmbuwj{text-overflow:ellipsis;}",
		".fkfq4zb{color:var(--colorNeutralForeground2);}",
		".fk6fouc{font-family:var(--fontFamilyBase);}",
		".fy9rknc{font-size:var(--fontSizeBase200);}",
		".figsok6{font-weight:var(--fontWeightRegular);}",
		".fwrc4pm{line-height:var(--lineHeightBase200);}"
	] });
	/**
	* Apply styling to the TableCellLayout slots based on the state
	*/
	const useTableCellLayoutStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$61();
		const { truncate } = state;
		state.root.className = mergeClasses(tableCellLayoutClassNames.root, styles.root, truncate && styles.rootTruncate, state.root.className);
		const primary = state.appearance === "primary";
		if (state.media) {
			const mediaSizedStyles = {
				small: styles.mediaSmallAndMedium,
				medium: styles.mediaSmallAndMedium,
				"extra-small": styles.mediaExtraSmall
			};
			state.media.className = mergeClasses(tableCellLayoutClassNames.media, styles.media, mediaSizedStyles[state.size], primary && styles.mediaPrimary, state.media.className);
		}
		if (state.main) state.main.className = mergeClasses(tableCellLayoutClassNames.main, truncate && styles.mainTruncate, primary && styles.mainPrimary, state.main.className);
		if (state.description) state.description.className = mergeClasses(tableCellLayoutClassNames.description, styles.description, state.description.className);
		if (state.content) state.content.className = mergeClasses(tableCellLayoutClassNames.content, styles.content, truncate && styles.contentTruncate, state.content.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/TableCellLayout/useTableCellLayoutContextValues.js
	function useTableCellLayoutContextValues_unstable(state) {
		const { avatarSize } = state;
		return { avatar: react.useMemo(() => ({ size: avatarSize }), [avatarSize]) };
	}

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/TableCellLayout/TableCellLayout.js
/**
	* TableCellLayout component
	*/ const TableCellLayout = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useTableCellLayout_unstable(props, ref);
		useTableCellLayoutStyles_unstable(state);
		useCustomStyleHook("useTableCellLayoutStyles_unstable")(state);
		return renderTableCellLayout_unstable(state, useTableCellLayoutContextValues_unstable(state));
	});
	TableCellLayout.displayName = "TableCellLayout";

//#endregion
//#region node_modules/@fluentui/react-table/lib/contexts/dataGridContext.js
	const dataGridContext = createContext(void 0);
	const dataGridContextDefaultValue = {
		...defaultTableState,
		subtleSelection: false,
		selectableRows: false,
		selectionAppearance: "brand",
		focusMode: "none",
		compositeRowTabsterAttribute: {}
	};
	const DataGridContextProvider = dataGridContext.Provider;
	const useDataGridContext_unstable = (selector) => useContextSelector(dataGridContext, (ctx = dataGridContextDefaultValue) => selector(ctx));

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/DataGridCell/useDataGridCell.js
/**
	* Create the state required to render DataGridCell.
	*
	* The returned state can be modified with hooks such as useDataGridCellStyles_unstable,
	* before being passed to renderDataGridCell_unstable.
	*
	* @param props - props from this instance of DataGridCell
	* @param ref - reference to root HTMLElement of DataGridCell
	*/ const useDataGridCell_unstable = (props, ref) => {
		const { focusMode = "cell" } = props;
		const columnId = useColumnIdContext();
		const tabbable = useDataGridContext_unstable((ctx) => (ctx.focusMode === "cell" || ctx.focusMode === "composite") && focusMode !== "none");
		const resizableColumns = useDataGridContext_unstable((ctx) => ctx.resizableColumns);
		const getTableCellProps = useDataGridContext_unstable((ctx) => {
			return ctx.columnSizing_unstable.getTableCellProps;
		});
		const focusableGroupAttr = useFocusableGroup({ tabBehavior: "limited-trap-focus" });
		return useTableCell_unstable({
			as: "div",
			role: "gridcell",
			...focusMode === "group" && focusableGroupAttr,
			tabIndex: tabbable ? 0 : void 0,
			...resizableColumns ? getTableCellProps(columnId) : {},
			...props
		}, ref);
	};

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/DataGridCell/renderDataGridCell.js
/**
	* Render the final JSX of DataGridCell
	*/ const renderDataGridCell_unstable = (state) => {
		return renderTableCell_unstable(state);
	};

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/DataGridCell/useDataGridCellStyles.styles.js
	const dataGridCellClassNames = { root: "fui-DataGridCell" };
	/**
	* Apply styling to the DataGridCell slots based on the state
	*/
	const useDataGridCellStyles_unstable = (state) => {
		"use no memo";
		useTableCellStyles_unstable(state);
		state.root.className = mergeClasses(dataGridCellClassNames.root, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/DataGridCell/DataGridCell.js
/**
	* DataGridCell component
	*/ const DataGridCell = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useDataGridCell_unstable(props, ref);
		useDataGridCellStyles_unstable(state);
		useCustomStyleHook("useDataGridCellStyles_unstable")(state);
		return renderDataGridCell_unstable(state);
	});
	DataGridCell.displayName = "DataGridCell";

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/DataGridSelectionCell/useDataGridSelectionCell.js
/**
	* Create the state required to render DataGridSelectionCell.
	*
	* The returned state can be modified with hooks such as useDataGridSelectionCellStyles_unstable,
	* before being passed to renderDataGridSelectionCell_unstable.
	*
	* @param props - props from this instance of DataGridSelectionCell
	* @param ref - reference to root HTMLElement of DataGridSelectionCell
	*/ const useDataGridSelectionCell_unstable = (props, ref) => {
		const isHeader = useIsInTableHeader();
		const rowId = useTableRowIdContext();
		const subtle = useDataGridContext_unstable((ctx) => ctx.subtleSelection);
		const checked = useDataGridContext_unstable((ctx) => {
			if (isHeader && ctx.selection.selectionMode === "multiselect") return ctx.selection.allRowsSelected ? true : ctx.selection.someRowsSelected ? "mixed" : false;
			return ctx.selection.isRowSelected(rowId);
		});
		const toggleAllRows = useDataGridContext_unstable((ctx) => ctx.selection.toggleAllRows);
		const type = useDataGridContext_unstable((ctx) => ctx.selection.selectionMode === "multiselect" ? "checkbox" : "radio");
		const onClick = useEventCallback((e) => {
			var _props_onClick;
			if (isHeader) toggleAllRows(e);
			(_props_onClick = props.onClick) === null || _props_onClick === void 0 || _props_onClick.call(props, e);
		});
		return useTableSelectionCell_unstable({
			as: "div",
			role: "gridcell",
			checked,
			type,
			invisible: isHeader && type === "radio",
			"aria-selected": checked === "mixed" ? void 0 : checked,
			subtle,
			radioIndicator: isHeader ? null : void 0,
			...props,
			onClick
		}, ref);
	};

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/DataGridSelectionCell/renderDataGridSelectionCell.js
/**
	* Render the final JSX of DataGridSelectionCell
	*/ const renderDataGridSelectionCell_unstable = (state) => {
		return renderTableSelectionCell_unstable(state);
	};

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/DataGridSelectionCell/useDataGridSelectionCellStyles.styles.js
	const dataGridSelectionCellClassNames = {
		root: "fui-DataGridSelectionCell",
		checkboxIndicator: "fui-DataGridSelectionCell__checkboxIndicator",
		radioIndicator: "fui-DataGridSelectionCell__radioIndicator"
	};
	/**
	* Apply styling to the DataGridSelectionCell slots based on the state
	*/
	const useDataGridSelectionCellStyles_unstable = (state) => {
		"use no memo";
		useTableSelectionCellStyles_unstable(state);
		state.root.className = mergeClasses(dataGridSelectionCellClassNames.root, state.root.className);
		if (state.checkboxIndicator) state.checkboxIndicator.className = mergeClasses(dataGridSelectionCellClassNames.checkboxIndicator, state.checkboxIndicator.className);
		if (state.radioIndicator) state.radioIndicator.className = mergeClasses(dataGridSelectionCellClassNames.radioIndicator, state.radioIndicator.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/DataGridSelectionCell/DataGridSelectionCell.js
/**
	* DataGridSelectionCell component
	*/ const DataGridSelectionCell = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useDataGridSelectionCell_unstable(props, ref);
		useDataGridSelectionCellStyles_unstable(state);
		useCustomStyleHook("useDataGridSelectionCellStyles_unstable")(state);
		return renderDataGridSelectionCell_unstable(state);
	});
	DataGridSelectionCell.displayName = "DataGridSelectionCell";

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/DataGridRow/useDataGridRow.js
/**
	* Create the state required to render DataGridRow.
	*
	* The returned state can be modified with hooks such as useDataGridRowStyles_unstable,
	* before being passed to renderDataGridRow_unstable.
	*
	* @param props - props from this instance of DataGridRow
	* @param ref - reference to root HTMLElement of DataGridRow
	*/ const useDataGridRow_unstable = (props, ref) => {
		const rowId = useTableRowIdContext();
		const isHeader = useIsInTableHeader();
		const columnDefs = useDataGridContext_unstable((ctx) => ctx.columns);
		const selectable = useDataGridContext_unstable((ctx) => ctx.selectableRows);
		const selected = useDataGridContext_unstable((ctx) => ctx.selection.isRowSelected(rowId));
		const focusMode = useDataGridContext_unstable((ctx) => ctx.focusMode);
		const compositeRowTabsterAttribute = useDataGridContext_unstable((ctx) => ctx.compositeRowTabsterAttribute);
		const tabbable = focusMode === "row_unstable" || focusMode === "composite";
		const appearance = useDataGridContext_unstable((ctx) => {
			if (!isHeader && selectable && ctx.selection.isRowSelected(rowId)) return ctx.selectionAppearance;
			return "none";
		});
		const toggleRow = useDataGridContext_unstable((ctx) => ctx.selection.toggleRow);
		const onClick = useEventCallback((e) => {
			var _props_onClick;
			if (selectable && !isHeader) toggleRow(e, rowId);
			(_props_onClick = props.onClick) === null || _props_onClick === void 0 || _props_onClick.call(props, e);
		});
		const onKeyDown = useEventCallback((e) => {
			var _props_onKeyDown;
			if (selectable && !isHeader && e.key === Space && !isInteractiveHTMLElement(e.target)) {
				e.preventDefault();
				toggleRow(e, rowId);
			}
			(_props_onKeyDown = props.onKeyDown) === null || _props_onKeyDown === void 0 || _props_onKeyDown.call(props, e);
		});
		const baseState = useTableRow_unstable({
			appearance,
			"aria-selected": selectable ? selected : void 0,
			tabIndex: tabbable && !isHeader ? 0 : void 0,
			...focusMode === "composite" && !isHeader && compositeRowTabsterAttribute,
			...props,
			onClick,
			onKeyDown,
			children: null,
			as: "div"
		}, ref);
		return {
			...baseState,
			components: {
				...baseState.components,
				selectionCell: DataGridSelectionCell
			},
			selectionCell: optional(props.selectionCell, {
				renderByDefault: selectable,
				elementType: DataGridSelectionCell
			}),
			renderCell: props.children,
			columnDefs,
			dataGridContextValue: useStableDataGridContextValue()
		};
	};
	function useStableDataGridContextValue() {
		const ref = react.useRef(dataGridContextDefaultValue);
		useDataGridContext_unstable((ctx) => {
			ref.current = ctx;
			return null;
		});
		return ref.current;
	}

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/DataGridRow/renderDataGridRow.js
/**
	* Render the final JSX of DataGridRow
	*/ const renderDataGridRow_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(state.root, { children: [state.selectionCell && /* @__PURE__ */ jsx(state.selectionCell, {}), state.columnDefs.map((columnDef) => /* @__PURE__ */ jsx(ColumnIdContextProvider, {
			value: columnDef.columnId,
			children: state.renderCell(columnDef, state.dataGridContextValue)
		}, columnDef.columnId))] });
	};

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/DataGridRow/useDataGridRowStyles.styles.js
	const dataGridRowClassNames = {
		root: "fui-DataGridRow",
		selectionCell: "fui-DataGridRow__selectionCell"
	};
	const useStyles$60 = /* @__PURE__ */ __styles({ subtleSelection: {
		Bconypa: "f1jazu75",
		ff6mpl: "fw60kww"
	} }, {
		d: [".f1jazu75[data-fui-focus-within]:focus-within .fui-TableSelectionCell{opacity:1;}"],
		h: [".fw60kww:hover .fui-TableSelectionCell{opacity:1;}"]
	});
	/**
	* Apply styling to the DataGridRow slots based on the state
	*/
	const useDataGridRowStyles_unstable = (state) => {
		"use no memo";
		const isSubtle = useDataGridContext_unstable((ctx) => ctx.subtleSelection);
		const styles = useStyles$60();
		useTableRowStyles_unstable(state);
		state.root.className = mergeClasses(dataGridRowClassNames.root, state.root.className, isSubtle && styles.subtleSelection);
		if (state.selectionCell) state.selectionCell.className = mergeClasses(dataGridRowClassNames.selectionCell, state.selectionCell.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/DataGridRow/DataGridRow.js
/**
	* DataGridRow component
	*/ const DataGridRow = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useDataGridRow_unstable(props, ref);
		useDataGridRowStyles_unstable(state);
		useCustomStyleHook("useDataGridRowStyles_unstable")(state);
		return renderDataGridRow_unstable(state);
	});
	DataGridRow.displayName = "DataGridRow";

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/DataGridBody/useDataGridBody.js
/**
	* Create the state required to render DataGridBody.
	*
	* The returned state can be modified with hooks such as useDataGridBodyStyles_unstable,
	* before being passed to renderDataGridBody_unstable.
	*
	* @param props - props from this instance of DataGridBody
	* @param ref - reference to root HTMLElement of DataGridBody
	*/ const useDataGridBody_unstable = (props, ref) => {
		const { sortable } = useTableContext();
		const getRows = useDataGridContext_unstable((ctx) => ctx.getRows);
		const sort = useDataGridContext_unstable((ctx) => ctx.sort.sort);
		const rows = sortable ? sort(getRows()) : getRows();
		return {
			...useTableBody_unstable({
				...props,
				children: null,
				as: "div"
			}, ref),
			rows,
			renderRow: props.children
		};
	};

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/DataGridBody/renderDataGridBody.js
/**
	* Render the final JSX of DataGridBody
	*/ const renderDataGridBody_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, { children: state.rows.map((row) => /* @__PURE__ */ jsx(TableRowIdContextProvider, {
			value: row.rowId,
			children: state.renderRow(row)
		}, row.rowId)) });
	};

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/DataGridBody/useDataGridBodyStyles.styles.js
	const dataGridBodyClassNames = { root: "fui-DataGridBody" };
	/**
	* Apply styling to the DataGridBody slots based on the state
	*/
	const useDataGridBodyStyles_unstable = (state) => {
		"use no memo";
		useTableBodyStyles_unstable(state);
		state.root.className = mergeClasses(dataGridBodyClassNames.root, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/DataGridBody/DataGridBody.js
/**
	* DataGridBody component
	*/ const DataGridBody = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useDataGridBody_unstable(props, ref);
		useDataGridBodyStyles_unstable(state);
		useCustomStyleHook("useDataGridBodyStyles_unstable")(state);
		return renderDataGridBody_unstable(state);
	});
	DataGridBody.displayName = "DataGridBody";

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/DataGrid/useDataGrid.js
/**
	* Create the state required to render DataGrid.
	*
	* The returned state can be modified with hooks such as useDataGridStyles_unstable,
	* before being passed to renderDataGrid_unstable.
	*
	* @param props - props from this instance of DataGrid
	* @param ref - reference to root HTMLElement of DataGrid
	*/ const useDataGrid_unstable = (props, ref) => {
		const { items, columns, focusMode = "cell", selectionMode, onSortChange, onSelectionChange, defaultSortState, sortState, selectedItems, defaultSelectedItems, subtleSelection = false, selectionAppearance = "brand", getRowId, resizableColumns, columnSizingOptions, onColumnResize, containerWidthOffset, resizableColumnsOptions = {} } = props;
		const widthOffset = containerWidthOffset !== null && containerWidthOffset !== void 0 ? containerWidthOffset : selectionMode ? -CELL_WIDTH : 0;
		const gridTabsterAttribute = useArrowNavigationGroup({ axis: "grid" });
		const { onTableKeyDown: onCompositeKeyDown, tableTabsterAttribute: compositeTabsterAttribute, tableRowTabsterAttribute: compositeRowTabsterAttribute } = useTableCompositeNavigation();
		var _resizableColumnsOptions_autoFitColumns;
		const tableState = useTableFeatures({
			items,
			columns,
			getRowId
		}, [
			useTableSort({
				defaultSortState,
				sortState,
				onSortChange
			}),
			useTableSelection({
				defaultSelectedItems,
				selectedItems,
				onSelectionChange,
				selectionMode: selectionMode !== null && selectionMode !== void 0 ? selectionMode : "multiselect"
			}),
			useTableColumnSizing_unstable({
				onColumnResize,
				columnSizingOptions,
				containerWidthOffset: widthOffset,
				autoFitColumns: (_resizableColumnsOptions_autoFitColumns = resizableColumnsOptions.autoFitColumns) !== null && _resizableColumnsOptions_autoFitColumns !== void 0 ? _resizableColumnsOptions_autoFitColumns : true
			})
		]);
		const innerRef = react.useRef(null);
		const { findFirstFocusable, findLastFocusable } = useFocusFinders();
		const onKeyDown = useEventCallback((e) => {
			var _props_onKeyDown;
			(_props_onKeyDown = props.onKeyDown) === null || _props_onKeyDown === void 0 || _props_onKeyDown.call(props, e);
			focusMode === "composite" && onCompositeKeyDown(e);
			if (!innerRef.current || !e.ctrlKey || e.defaultPrevented) return;
			if (e.key === Home) {
				const firstRow = innerRef.current.querySelector("[role=\"row\"]");
				if (firstRow) {
					var _findFirstFocusable;
					(_findFirstFocusable = findFirstFocusable(firstRow)) === null || _findFirstFocusable === void 0 || _findFirstFocusable.focus();
				}
			}
			if (e.key === End) {
				const rows = innerRef.current.querySelectorAll("[role=\"row\"]");
				if (rows.length) {
					var _findLastFocusable;
					(_findLastFocusable = findLastFocusable(rows.item(rows.length - 1))) === null || _findLastFocusable === void 0 || _findLastFocusable.focus();
				}
			}
		});
		return {
			...useTable_unstable({
				role: "grid",
				as: "div",
				noNativeElements: true,
				...focusMode === "cell" && gridTabsterAttribute,
				...focusMode === "composite" && compositeTabsterAttribute,
				...props,
				onKeyDown,
				...resizableColumns ? tableState.columnSizing_unstable.getTableProps(props) : {}
			}, useMergedRefs(ref, tableState.tableRef, innerRef)),
			focusMode,
			tableState,
			selectableRows: !!selectionMode,
			subtleSelection,
			selectionAppearance,
			resizableColumns,
			compositeRowTabsterAttribute
		};
	};

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/DataGrid/renderDataGrid.js
/**
	* Render the final JSX of DataGrid
	*/ const renderDataGrid_unstable = (state, contextValues) => {
		return /* @__PURE__ */ react.createElement(DataGridContextProvider, { value: contextValues.dataGrid }, renderTable_unstable(state, contextValues));
	};

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/DataGrid/useDataGridStyles.styles.js
	const dataGridClassNames = { root: "fui-DataGrid" };
	/**
	* Apply styling to the DataGrid slots based on the state
	*/
	const useDataGridStyles_unstable = (state) => {
		"use no memo";
		useTableStyles_unstable(state);
		state.root.className = mergeClasses(dataGridClassNames.root, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/DataGrid/useDataGridContextValues.js
	function useDataGridContextValues_unstable(state) {
		const tableContextValues = useTableContextValues_unstable(state);
		const { tableState, focusMode, selectableRows, subtleSelection, selectionAppearance, resizableColumns, compositeRowTabsterAttribute } = state;
		return {
			...tableContextValues,
			dataGrid: {
				...tableState,
				focusMode,
				selectableRows,
				subtleSelection,
				selectionAppearance,
				resizableColumns,
				compositeRowTabsterAttribute
			}
		};
	}

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/DataGrid/DataGrid.js
/**
	* DataGrid component
	*/ const DataGrid = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useDataGrid_unstable(props, ref);
		useDataGridStyles_unstable(state);
		useCustomStyleHook("useDataGridStyles_unstable")(state);
		return renderDataGrid_unstable(state, useDataGridContextValues_unstable(state));
	});
	DataGrid.displayName = "DataGrid";

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/DataGridHeader/useDataGridHeader.js
/**
	* Create the state required to render DataGridHeader.
	*
	* The returned state can be modified with hooks such as useDataGridHeaderStyles_unstable,
	* before being passed to renderDataGridHeader_unstable.
	*
	* @param props - props from this instance of DataGridHeader
	* @param ref - reference to root HTMLElement of DataGridHeader
	*/ const useDataGridHeader_unstable = (props, ref) => {
		return useTableHeader_unstable({
			...props,
			as: "div"
		}, ref);
	};

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/DataGridHeader/renderDataGridHeader.js
/**
	* Render the final JSX of DataGridHeader
	*/ const renderDataGridHeader_unstable = (state) => {
		return renderTableHeader_unstable(state);
	};

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/DataGridHeader/useDataGridHeaderStyles.styles.js
	const dataGridHeaderClassNames = { root: "fui-DataGridHeader" };
	/**
	* Apply styling to the DataGridHeader slots based on the state
	*/
	const useDataGridHeaderStyles_unstable = (state) => {
		"use no memo";
		useTableHeaderStyles_unstable(state);
		state.root.className = mergeClasses(dataGridHeaderClassNames.root, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/DataGridHeader/DataGridHeader.js
/**
	* DataGridHeader component
	*/ const DataGridHeader = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useDataGridHeader_unstable(props, ref);
		useDataGridHeaderStyles_unstable(state);
		useCustomStyleHook("useDataGridHeaderStyles_unstable")(state);
		return renderDataGridHeader_unstable(state);
	});
	DataGridHeader.displayName = "DataGridHeader";

//#endregion
//#region node_modules/@fluentui/react-table/lib/utils/isColumnSortable.js
	function isColumnSortable(column$1) {
		return column$1.compare.length > 0;
	}

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/DataGridHeaderCell/useDataGridHeaderCell.js
/**
	* Create the state required to render DataGridHeaderCell.
	*
	* The returned state can be modified with hooks such as useDataGridHeaderCellStyles_unstable,
	* before being passed to renderDataGridHeaderCell_unstable.
	*
	* @param props - props from this instance of DataGridHeaderCell
	* @param ref - reference to root HTMLElement of DataGridHeaderCell
	*/ const useDataGridHeaderCell_unstable = (props, ref) => {
		const columnId = useColumnIdContext();
		const { sortable: gridSortable } = useTableContext();
		const toggleColumnSort = useDataGridContext_unstable((ctx) => ctx.sort.toggleColumnSort);
		const sortable = useDataGridContext_unstable((ctx) => {
			const columnSortable = !!ctx.columns.find((c) => c.columnId === columnId && isColumnSortable(c));
			if (!gridSortable) return false;
			return columnSortable;
		});
		const sortDirection = useDataGridContext_unstable((ctx) => sortable ? ctx.sort.getSortDirection(columnId) : void 0);
		const resizableColumns = useDataGridContext_unstable((ctx) => ctx.resizableColumns);
		const getTableHeaderCellProps = useDataGridContext_unstable((ctx) => {
			return ctx.columnSizing_unstable.getTableHeaderCellProps;
		});
		const { focusMode = sortable ? "none" : "cell" } = props;
		const focusableGroupAttr = useFocusableGroup({ tabBehavior: "limited-trap-focus" });
		const onClick = useEventCallback((e) => {
			var _props_onClick;
			if (sortable) toggleColumnSort(e, columnId);
			(_props_onClick = props.onClick) === null || _props_onClick === void 0 || _props_onClick.call(props, e);
		});
		return useTableHeaderCell_unstable({
			sortable,
			sortDirection,
			as: "div",
			tabIndex: focusMode !== "none" ? 0 : void 0,
			...focusMode === "group" && focusableGroupAttr,
			...resizableColumns ? getTableHeaderCellProps(columnId) : {},
			...props,
			onClick
		}, ref);
	};

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/DataGridHeaderCell/renderDataGridHeaderCell.js
/**
	* Render the final JSX of DataGridHeaderCell
	*/ const renderDataGridHeaderCell_unstable = (state) => {
		return renderTableHeaderCell_unstable(state);
	};

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/DataGridHeaderCell/useDataGridHeaderCellStyles.styles.js
	const dataGridHeaderCellClassNames = {
		root: "fui-DataGridHeaderCell",
		button: "fui-DataGridHeaderCell__button",
		sortIcon: "fui-DataGridHeaderCell__sortIcon",
		aside: "fui-DataGridHeaderCell__aside"
	};
	/**
	* Apply styling to the DataGridHeaderCell slots based on the state
	*/
	const useDataGridHeaderCellStyles_unstable = (state) => {
		"use no memo";
		useTableHeaderCellStyles_unstable(state);
		state.root.className = mergeClasses(dataGridHeaderCellClassNames.root, state.root.className);
		if (state.button) state.button.className = mergeClasses(dataGridHeaderCellClassNames.button, state.button.className);
		if (state.sortIcon) state.sortIcon.className = mergeClasses(dataGridHeaderCellClassNames.sortIcon, state.sortIcon.className);
		if (state.aside) state.aside.className = mergeClasses(dataGridHeaderCellClassNames.aside, state.aside.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-table/lib/components/DataGridHeaderCell/DataGridHeaderCell.js
/**
	* DataGridHeaderCell component
	*/ const DataGridHeaderCell = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useDataGridHeaderCell_unstable(props, ref);
		useDataGridHeaderCellStyles_unstable(state);
		useCustomStyleHook("useDataGridHeaderCellStyles_unstable")(state);
		return renderDataGridHeaderCell_unstable(state);
	});
	DataGridHeaderCell.displayName = "DataGridHeaderCell";

//#endregion
//#region node_modules/@fluentui/react-card/lib/components/Card/useCardSelectable.js
/**
	* @internal
	*
	* Create the state related to selectable cards.
	*
	* This internal hook controls all the logic for selectable cards and is
	* intended to be used alongside with useCard_unstable.
	*
	* @param props - props from this instance of Card
	* @param a11yProps - accessibility props shared between elements of the card
	* @param cardRef - reference to the root element of Card
	*/ const useCardSelectable = (props, { referenceLabel, referenceId }, cardRef) => {
		const { checkbox = {}, onSelectionChange, floatingAction, onClick, onKeyDown, disabled } = props;
		const { findAllFocusable } = useFocusFinders();
		const checkboxRef = react.useRef(null);
		const [selected, setSelected] = useControllableState({
			state: props.selected,
			defaultState: props.defaultSelected,
			initialState: false
		});
		const selectable = [
			props.selected,
			props.defaultSelected,
			onSelectionChange
		].some((prop) => typeof prop !== "undefined");
		const [selectFocused, setSelectFocused] = react.useState(false);
		const shouldRestrictTriggerAction = react.useCallback((event) => {
			if (!cardRef.current) return false;
			const focusableElements = findAllFocusable(cardRef.current);
			const target = event.target;
			const isElementInFocusableGroup = focusableElements.some((element) => element.contains(target));
			const isCheckboxSlot = (checkboxRef === null || checkboxRef === void 0 ? void 0 : checkboxRef.current) === target;
			return isElementInFocusableGroup && !isCheckboxSlot;
		}, [cardRef, findAllFocusable]);
		const onChangeHandler = react.useCallback((event) => {
			if (disabled || shouldRestrictTriggerAction(event)) return;
			const newCheckedValue = !selected;
			setSelected(newCheckedValue);
			if (onSelectionChange) onSelectionChange(event, { selected: newCheckedValue });
		}, [
			disabled,
			onSelectionChange,
			selected,
			setSelected,
			shouldRestrictTriggerAction
		]);
		const onKeyDownHandler = react.useCallback((event) => {
			if ([Enter].includes(event.key)) {
				event.preventDefault();
				onChangeHandler(event);
			}
		}, [onChangeHandler]);
		const checkboxSlot = react.useMemo(() => {
			if (!selectable || floatingAction) return;
			const selectableCheckboxProps = {};
			if (referenceId) selectableCheckboxProps["aria-labelledby"] = referenceId;
			else if (referenceLabel) selectableCheckboxProps["aria-label"] = referenceLabel;
			return optional(checkbox, {
				defaultProps: {
					ref: checkboxRef,
					type: "checkbox",
					checked: selected,
					disabled,
					onChange: (event) => onChangeHandler(event),
					onFocus: () => setSelectFocused(true),
					onBlur: () => setSelectFocused(false),
					...selectableCheckboxProps
				},
				elementType: "input"
			});
		}, [
			checkbox,
			disabled,
			floatingAction,
			selected,
			selectable,
			onChangeHandler,
			referenceId,
			referenceLabel
		]);
		const floatingActionSlot = react.useMemo(() => {
			if (!floatingAction) return;
			return optional(floatingAction, {
				defaultProps: { ref: checkboxRef },
				elementType: "div"
			});
		}, [floatingAction]);
		return {
			selected,
			selectable,
			selectFocused,
			selectableCardProps: react.useMemo(() => {
				if (!selectable) return null;
				return {
					onClick: mergeCallbacks(onClick, onChangeHandler),
					onKeyDown: mergeCallbacks(onKeyDown, onKeyDownHandler)
				};
			}, [
				selectable,
				onChangeHandler,
				onClick,
				onKeyDown,
				onKeyDownHandler
			]),
			checkboxSlot,
			floatingActionSlot
		};
	};

//#endregion
//#region node_modules/@fluentui/react-card/lib/components/Card/CardContext.js
	const cardContext = react.createContext(void 0);
	/**
	* @internal
	*/ const cardContextDefaultValue = { selectableA11yProps: {
		referenceId: void 0,
		setReferenceId() {},
		referenceLabel: void 0,
		setReferenceLabel() {}
	} };
	/**
	* @internal
	*/ const CardProvider = cardContext.Provider;
	/**
	* @internal
	*/ const useCardContext_unstable = () => {
		var _React_useContext;
		return (_React_useContext = react.useContext(cardContext)) !== null && _React_useContext !== void 0 ? _React_useContext : cardContextDefaultValue;
	};

//#endregion
//#region node_modules/@fluentui/react-card/lib/components/Card/useCard.js
	const focusMap = {
		off: void 0,
		"no-tab": "limited-trap-focus",
		"tab-exit": "limited",
		"tab-only": "unlimited"
	};
	/**
	* Create the state for interactive cards.
	*
	* This internal hook defines if the card is interactive
	* and control focus properties based on that.
	*
	* @param props - props from this instance of Card
	*/ const useCardInteractive = ({ focusMode: initialFocusMode, disabled = false, ...props }) => {
		const interactive = [
			"onClick",
			"onDoubleClick",
			"onMouseUp",
			"onMouseDown",
			"onPointerUp",
			"onPointerDown",
			"onTouchStart",
			"onTouchEnd",
			"onDragStart",
			"onDragEnd"
		].some((prop) => props[prop]);
		const focusMode = initialFocusMode !== null && initialFocusMode !== void 0 ? initialFocusMode : interactive ? "no-tab" : "off";
		const groupperAttrs = useFocusableGroup({ tabBehavior: focusMap[focusMode] });
		if (disabled) return {
			interactive: false,
			focusAttributes: null
		};
		if (focusMode === "off") return {
			interactive,
			focusAttributes: null
		};
		return {
			interactive,
			focusAttributes: {
				...groupperAttrs,
				tabIndex: 0
			}
		};
	};
	/**
	* Create the state required to render Card.
	*
	* The returned state can be modified with hooks such as useCardStyles_unstable,
	* before being passed to renderCard_unstable.
	*
	* @param props - props from this instance of Card
	* @param ref - reference to the root element of Card
	*/ const useCard_unstable = (props, ref) => {
		const { appearance = "filled", orientation = "vertical", size: size$2 = "medium", disabled = false, ...restProps } = props;
		const [referenceId, setReferenceId] = react.useState(cardContextDefaultValue.selectableA11yProps.referenceId);
		const [referenceLabel, setReferenceLabel] = react.useState(cardContextDefaultValue.selectableA11yProps.referenceId);
		const cardBaseRef = useFocusWithin();
		const { selectable, selected, selectableCardProps, selectFocused, checkboxSlot, floatingActionSlot } = useCardSelectable(props, {
			referenceId,
			referenceLabel
		}, cardBaseRef);
		const cardRef = useMergedRefs(cardBaseRef, ref);
		const { interactive, focusAttributes } = useCardInteractive(props);
		let cardRootProps = {
			...!selectable ? focusAttributes : null,
			...restProps,
			...selectableCardProps
		};
		if (disabled) cardRootProps = {
			...restProps,
			"aria-disabled": true,
			onClick: void 0
		};
		return {
			appearance,
			orientation,
			size: size$2,
			interactive,
			selectable,
			selectFocused,
			selected,
			disabled,
			selectableA11yProps: {
				setReferenceId,
				referenceId,
				referenceLabel,
				setReferenceLabel
			},
			components: {
				root: "div",
				floatingAction: "div",
				checkbox: "input"
			},
			root: always(getIntrinsicElementProps("div", {
				ref: cardRef,
				role: "group",
				...cardRootProps
			}), { elementType: "div" }),
			floatingAction: floatingActionSlot,
			checkbox: checkboxSlot
		};
	};

//#endregion
//#region node_modules/@fluentui/react-card/lib/components/Card/renderCard.js
/**
	* Render the final JSX of Card.
	*/ const renderCard_unstable = (state, cardContextValue) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, { children: /* @__PURE__ */ jsxs(CardProvider, {
			value: cardContextValue,
			children: [
				state.checkbox ? /* @__PURE__ */ jsx(state.checkbox, {}) : null,
				state.floatingAction ? /* @__PURE__ */ jsx(state.floatingAction, {}) : null,
				state.root.children
			]
		}) });
	};

//#endregion
//#region node_modules/@fluentui/react-card/lib/components/CardPreview/useCardPreviewStyles.styles.js
/**
	* Static CSS class names used internally for the component slots.
	*/
	const cardPreviewClassNames = {
		root: "fui-CardPreview",
		logo: "fui-CardPreview__logo"
	};
	const useStyles$59 = /* @__PURE__ */ __styles({
		root: {
			qhf8xq: "f10pi13n",
			Byfpedg: "fgourly",
			Btj6oj6: "f1vui7lx",
			B1m4t4s: "fda5zwx"
		},
		logo: {
			qhf8xq: "f1euv43f",
			B5kzvoi: "f1gcvs1y",
			oyh7mz: ["f1t6tvco", "ffrfxm3"],
			a9b677: "f1szoe96",
			Bqenvij: "f1d2rq10"
		}
	}, { d: [
		".f10pi13n{position:relative;}",
		".fgourly>:not(.fui-CardPreview__logo){display:block;}",
		".f1vui7lx>:not(.fui-CardPreview__logo){height:100%;}",
		".fda5zwx>:not(.fui-CardPreview__logo){width:100%;}",
		".f1euv43f{position:absolute;}",
		".f1gcvs1y{bottom:12px;}",
		".f1t6tvco{left:12px;}",
		".ffrfxm3{right:12px;}",
		".f1szoe96{width:32px;}",
		".f1d2rq10{height:32px;}"
	] });
	/**
	* Apply styling to the CardPreview slots based on the state.
	*/
	const useCardPreviewStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$59();
		state.root.className = mergeClasses(cardPreviewClassNames.root, styles.root, state.root.className);
		if (state.logo) state.logo.className = mergeClasses(cardPreviewClassNames.logo, styles.logo, state.logo.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-card/lib/components/CardHeader/useCardHeaderStyles.styles.js
/**
	* Static CSS class names used internally for the component slots.
	*/
	const cardHeaderClassNames = {
		root: "fui-CardHeader",
		image: "fui-CardHeader__image",
		header: "fui-CardHeader__header",
		description: "fui-CardHeader__description",
		action: "fui-CardHeader__action"
	};
	/**
	* CSS variable names used internally for uniform styling in CardHeader.
	*/
	const cardHeaderCSSVars = { cardHeaderGapVar: "--fui-CardHeader--gap" };
	const useStyles$58 = /* @__PURE__ */ __styles({
		root: {
			Bkc6ea2: "fkufhic",
			Bt984gj: "f122n59"
		},
		image: {
			mc9l5x: "ftuwxu6",
			t21cq0: ["fql5097", "f6yss9k"]
		},
		header: { mc9l5x: "f22iagw" },
		description: { mc9l5x: "f22iagw" },
		action: {
			Frg6f3: ["f6yss9k", "fql5097"],
			rjrqlh: "fs9eatd",
			Boue1pl: ["fxoo9ru", "f1g0ekvh"],
			Bhz1vi0: "f1m6zfxz",
			etxrgc: ["f1g0ekvh", "fxoo9ru"],
			Bdua9ef: "f1sret3r",
			cbfxhg: "fs4gbcv"
		}
	}, {
		d: [
			".fkufhic{--fui-CardHeader--gap:12px;}",
			".f122n59{align-items:center;}",
			".ftuwxu6{display:inline-flex;}",
			".fql5097{margin-right:var(--fui-CardHeader--gap);}",
			".f6yss9k{margin-left:var(--fui-CardHeader--gap);}",
			".f22iagw{display:flex;}"
		],
		m: [
			["@media (forced-colors: active){.fs9eatd .fui-Button,.fs9eatd .fui-Link{border-top-color:currentColor;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1g0ekvh .fui-Button,.f1g0ekvh .fui-Link{border-left-color:currentColor;}.fxoo9ru .fui-Button,.fxoo9ru .fui-Link{border-right-color:currentColor;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1m6zfxz .fui-Button,.f1m6zfxz .fui-Link{border-bottom-color:currentColor;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1sret3r .fui-Button,.f1sret3r .fui-Link{color:currentColor;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fs4gbcv .fui-Button,.fs4gbcv .fui-Link{outline-color:currentColor;}}", { m: "(forced-colors: active)" }]
		]
	});
	const useStylesGrid = /* @__PURE__ */ __styles({
		root: {
			mc9l5x: "f13qh94s",
			t4k1zu: "f8a668j"
		},
		image: {
			Br312pm: "fwpfdsa",
			Ijaq50: "fldnz9j"
		},
		header: {
			Br312pm: "fd46tj4",
			Ijaq50: "f16hsg94"
		},
		description: {
			Br312pm: "fd46tj4",
			Ijaq50: "faunodf"
		},
		action: {
			Br312pm: "fis13di",
			Ijaq50: "fldnz9j"
		}
	}, { d: [
		".f13qh94s{display:grid;}",
		".f8a668j{grid-auto-columns:min-content 1fr min-content;}",
		".fwpfdsa{grid-column-start:1;}",
		".fldnz9j{grid-row-start:span 2;}",
		".fd46tj4{grid-column-start:2;}",
		".f16hsg94{grid-row-start:1;}",
		".faunodf{grid-row-start:2;}",
		".fis13di{grid-column-start:3;}"
	] });
	const useStylesFlex = /* @__PURE__ */ __styles({
		root: { mc9l5x: "f22iagw" },
		header: { Bh6795r: "fqerorx" },
		image: {},
		description: {},
		action: {}
	}, { d: [".f22iagw{display:flex;}", ".fqerorx{flex-grow:1;}"] });
	/**
	* Apply styling to the CardHeader slots based on the state.
	*/
	const useCardHeaderStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$58();
		const stylesGrid = useStylesGrid();
		const stylesFlex = useStylesFlex();
		const boxModelStyles = state.description ? stylesGrid : stylesFlex;
		const getSlotStyles = (slotName) => {
			var _state_slotName;
			return mergeClasses(cardHeaderClassNames[slotName], styles[slotName], boxModelStyles[slotName], (_state_slotName = state[slotName]) === null || _state_slotName === void 0 ? void 0 : _state_slotName.className);
		};
		state.root.className = getSlotStyles("root");
		if (state.image) state.image.className = getSlotStyles("image");
		if (state.header) state.header.className = getSlotStyles("header");
		if (state.description) state.description.className = getSlotStyles("description");
		if (state.action) state.action.className = getSlotStyles("action");
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-card/lib/components/CardFooter/useCardFooterStyles.styles.js
/**
	* Static CSS class names used internally for the component slots.
	*/
	const cardFooterClassNames = {
		root: "fui-CardFooter",
		action: "fui-CardFooter__action"
	};
	const useStyles$57 = /* @__PURE__ */ __styles({
		root: {
			mc9l5x: "f22iagw",
			Beiy3e4: "f1063pyq",
			i8kkvl: 0,
			Belr9w4: 0,
			rmohyg: "fsbu5mz"
		},
		action: {
			Frg6f3: ["fcgxt0o", "f1ujusj6"],
			rjrqlh: "fs9eatd",
			Boue1pl: ["fxoo9ru", "f1g0ekvh"],
			Bhz1vi0: "f1m6zfxz",
			etxrgc: ["f1g0ekvh", "fxoo9ru"],
			Bdua9ef: "f1sret3r",
			cbfxhg: "fs4gbcv"
		}
	}, {
		d: [
			".f22iagw{display:flex;}",
			".f1063pyq{flex-direction:row;}",
			[".fsbu5mz{gap:12px;}", { p: -1 }],
			".fcgxt0o{margin-left:auto;}",
			".f1ujusj6{margin-right:auto;}"
		],
		m: [
			["@media (forced-colors: active){.fs9eatd .fui-Button,.fs9eatd .fui-Link{border-top-color:currentColor;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1g0ekvh .fui-Button,.f1g0ekvh .fui-Link{border-left-color:currentColor;}.fxoo9ru .fui-Button,.fxoo9ru .fui-Link{border-right-color:currentColor;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1m6zfxz .fui-Button,.f1m6zfxz .fui-Link{border-bottom-color:currentColor;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1sret3r .fui-Button,.f1sret3r .fui-Link{color:currentColor;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fs4gbcv .fui-Button,.fs4gbcv .fui-Link{outline-color:currentColor;}}", { m: "(forced-colors: active)" }]
		]
	});
	/**
	* Apply styling to the CardFooter slots based on the state.
	*/
	const useCardFooterStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$57();
		state.root.className = mergeClasses(cardFooterClassNames.root, styles.root, state.root.className);
		if (state.action) state.action.className = mergeClasses(cardFooterClassNames.action, styles.action, state.action.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-card/lib/components/Card/useCardStyles.styles.js
/**
	* Static CSS class names used internally for the component slots.
	*/
	const cardClassNames = {
		root: "fui-Card",
		floatingAction: "fui-Card__floatingAction",
		checkbox: "fui-Card__checkbox"
	};
	/**
	* CSS variable names used internally for uniform styling in Card.
	*/
	const cardCSSVars = {
		cardSizeVar: "--fui-Card--size",
		cardBorderRadiusVar: "--fui-Card--border-radius"
	};
	`${cardCSSVars.cardBorderRadiusVar}`, tokens.strokeWidthThick;
	const useCardResetStyles = /* @__PURE__ */ __resetStyles("rfxo2k2", "rgle7w9", [
		".rfxo2k2{overflow:hidden;border-radius:var(--fui-Card--border-radius);padding:var(--fui-Card--size);gap:var(--fui-Card--size);display:flex;position:relative;box-sizing:border-box;color:var(--colorNeutralForeground1);}",
		".rfxo2k2::after{position:absolute;top:0;left:0;right:0;bottom:0;content:\"\";pointer-events:none;border-top-style:solid;border-right-style:solid;border-bottom-style:solid;border-left-style:solid;border-top-width:var(--strokeWidthThin);border-right-width:var(--strokeWidthThin);border-bottom-width:var(--strokeWidthThin);border-left-width:var(--strokeWidthThin);border-radius:var(--fui-Card--border-radius);}",
		".rfxo2k2>.fui-CardHeader,.rfxo2k2>.fui-CardFooter{flex-shrink:0;}",
		".rgle7w9{overflow:hidden;border-radius:var(--fui-Card--border-radius);padding:var(--fui-Card--size);gap:var(--fui-Card--size);display:flex;position:relative;box-sizing:border-box;color:var(--colorNeutralForeground1);}",
		".rgle7w9::after{position:absolute;top:0;right:0;left:0;bottom:0;content:\"\";pointer-events:none;border-top-style:solid;border-left-style:solid;border-bottom-style:solid;border-right-style:solid;border-top-width:var(--strokeWidthThin);border-left-width:var(--strokeWidthThin);border-bottom-width:var(--strokeWidthThin);border-right-width:var(--strokeWidthThin);border-radius:var(--fui-Card--border-radius);}",
		".rgle7w9>.fui-CardHeader,.rgle7w9>.fui-CardFooter{flex-shrink:0;}"
	]);
	tokens.colorNeutralForegroundDisabled, tokens.colorNeutralBackgroundDisabled, tokens.shadow2, { .../* @__PURE__ */ shorthands.borderColor(tokens.colorNeutralStrokeDisabled) }, `${tokens.zIndexContent}`, { .../* @__PURE__ */ shorthands.borderColor(tokens.colorNeutralStrokeDisabled) };
	const useCardStyles = /* @__PURE__ */ __styles({
		focused: {
			Brovlpu: "ftqa4ok",
			B486eqv: "f2hkw1w",
			B8q5s1w: "f8hki3x",
			Bci5o5g: ["f1d2448m", "ffh67wi"],
			n8qw10: "f1bjia2o",
			Bdrgwmp: ["ffh67wi", "f1d2448m"],
			Bqhya38: "f1j6vpng",
			Bwxa6fj: ["f1pniga2", "f1ffjurs"],
			Bdhvstf: "f987i1v",
			B7zbvrb: ["f1ffjurs", "f1pniga2"],
			Bm4h7ae: "f15bsgw9",
			B7ys5i9: "f14e48fq",
			Busjfv9: "f18yb2kv",
			Bhk32uz: "fd6o370",
			f6g5ot: 0,
			Boxcth7: 0,
			Bhdgwq3: 0,
			hgwjuy: 0,
			Bshpdp8: 0,
			Bsom6fd: 0,
			Blkhhs4: 0,
			Bonggc9: 0,
			Ddfuxk: 0,
			i03rao: 0,
			kclons: 0,
			clg4pj: 0,
			Bpqj9nj: 0,
			B6dhp37: 0,
			Bf4ptjt: 0,
			Bqtpl0w: 0,
			i4rwgc: "fpqizxz",
			Dah5zi: 0,
			B1tsrr9: 0,
			qqdqy8: 0,
			Bkh64rk: 0,
			e3fwne: "fnd8nzh",
			J0r882: "f15fr7a0",
			Bule8hv: ["fwsq40z", "fy0y4wt"],
			Bjwuhne: "f34ld9f",
			Ghsupd: ["fy0y4wt", "fwsq40z"]
		},
		selectableFocused: {
			Brovlpu: "ftqa4ok",
			B486eqv: "f2hkw1w",
			Bssx7fj: "f1b1k54r",
			uh7if5: ["f4ne723", "fqqcjud"],
			clntm0: "fh7aioi",
			Dlk2r6: ["fqqcjud", "f4ne723"],
			h6p2u: "f1ufm4qn",
			I6qiy5: ["f1qnwcb4", "fgrk5zm"],
			yzno9d: "fi52z01",
			By0wis0: ["fgrk5zm", "f1qnwcb4"],
			B2j2mmj: "ffht0p2",
			wigs8: "f1p0ul1q",
			pbfy6t: "f1c901ms",
			B0v4ure: "f1alokd7",
			Byrf0fs: 0,
			Bsiemmq: 0,
			Bwckmig: 0,
			skfxo0: 0,
			Iidy0u: 0,
			B98u21t: 0,
			Bvwlmkc: 0,
			jo1ztg: 0,
			Ba1iezr: 0,
			Blmvk6g: 0,
			B24cy0v: 0,
			Bil7v7r: 0,
			Br3gin4: 0,
			nr063g: 0,
			ghq09: 0,
			Bbgo44z: 0,
			Bseh09z: "f1i978nd",
			az1dzo: 0,
			Ba3ybja: 0,
			B6352mv: 0,
			vppk2z: 0,
			Biaj6j7: "f1nh8hsq",
			B2pnrqr: "f1amxum7",
			B29w5g4: ["f1cec8w7", "f554mv0"],
			Bhhzhcn: "f1sj6kbr",
			Bec0n69: ["f554mv0", "f1cec8w7"]
		},
		orientationHorizontal: {
			Beiy3e4: "f1063pyq",
			Bt984gj: "f122n59",
			Binpb3b: "ftrw7vg",
			qrt8p2: "f18opajm",
			k6ws3r: ["f13002it", "fqo182t"],
			Btcwela: ["f18yna97", "f1kd6wh7"],
			Fer9m8: "f4i4759"
		},
		orientationVertical: {
			Beiy3e4: "f1vx9l62",
			B5nvv7i: ["f14k419y", "f1fgo9fz"],
			Baxg94k: ["f1fgo9fz", "f14k419y"],
			tn21ii: "fvqmfsm",
			B0ud6bj: "f3am6yf",
			Bgdo4j: "f1r5wgso"
		},
		sizeSmall: {
			B7balbw: "f1pi9uxy",
			B1h88n7: "f1h1zgly"
		},
		sizeMedium: {
			B7balbw: "frsmuga",
			B1h88n7: "fuldkky"
		},
		sizeLarge: {
			B7balbw: "f1qua4xo",
			B1h88n7: "fimkt6v"
		},
		interactive: { rhjd8f: "f1epqm3e" },
		filled: {
			De3pzq: "fxugw4r",
			E5pizo: "f1whvlc6",
			B0n5ga8: "f16gxe2i",
			s924m2: ["fpgykix", "fzybk4o"],
			B1q35kw: "f1osi826",
			Gp14am: ["fzybk4o", "fpgykix"]
		},
		filledInteractive: {
			Bceei9c: "f1k6fduh",
			De3pzq: "fxugw4r",
			E5pizo: "f1whvlc6",
			B0n5ga8: "f16gxe2i",
			s924m2: ["fpgykix", "fzybk4o"],
			B1q35kw: "f1osi826",
			Gp14am: ["fzybk4o", "fpgykix"],
			Bi91k9c: "feu1g3u",
			Jwef8y: "f1knas48",
			Bvxd0ez: "f1m145df",
			ecr2s2: "fb40n2d"
		},
		filledInteractiveSelected: {
			De3pzq: "f1nfm20t",
			B0n5ga8: "f16eln5f",
			s924m2: ["fa2okxs", "fg4zq3l"],
			B1q35kw: "ff6932p",
			Gp14am: ["fg4zq3l", "fa2okxs"],
			Bi91k9c: "fx9teim",
			Jwef8y: "f1kz6goq"
		},
		filledAlternative: {
			De3pzq: "f1dmdbja",
			E5pizo: "f1whvlc6",
			B0n5ga8: "f16gxe2i",
			s924m2: ["fpgykix", "fzybk4o"],
			B1q35kw: "f1osi826",
			Gp14am: ["fzybk4o", "fpgykix"]
		},
		filledAlternativeInteractive: {
			Bceei9c: "f1k6fduh",
			De3pzq: "f1dmdbja",
			E5pizo: "f1whvlc6",
			B0n5ga8: "f16gxe2i",
			s924m2: ["fpgykix", "fzybk4o"],
			B1q35kw: "f1osi826",
			Gp14am: ["fzybk4o", "fpgykix"],
			Bi91k9c: "fnwyq0v",
			Jwef8y: "f1uvynv3",
			Bvxd0ez: "f1m145df",
			ecr2s2: "f1yhgkbh"
		},
		filledAlternativeInteractiveSelected: {
			De3pzq: "fjxa0vh",
			B0n5ga8: "f16eln5f",
			s924m2: ["fa2okxs", "fg4zq3l"],
			B1q35kw: "ff6932p",
			Gp14am: ["fg4zq3l", "fa2okxs"],
			Bi91k9c: "f1luvkty",
			Jwef8y: "fehi0vp"
		},
		outline: {
			De3pzq: "f1c21dwh",
			E5pizo: "f1couhl3",
			B0n5ga8: "ft83z1f",
			s924m2: ["f1g4150c", "f192dr6e"],
			B1q35kw: "f1qnawh6",
			Gp14am: ["f192dr6e", "f1g4150c"]
		},
		outlineInteractive: {
			Bceei9c: "f1k6fduh",
			De3pzq: "f1c21dwh",
			E5pizo: "f1couhl3",
			B0n5ga8: "ft83z1f",
			s924m2: ["f1g4150c", "f192dr6e"],
			B1q35kw: "f1qnawh6",
			Gp14am: ["f192dr6e", "f1g4150c"],
			Bi91k9c: "feu1g3u",
			Jwef8y: "fjxutwb",
			Be0v6ae: "f1llr77y",
			B5kxglz: ["fzk0khw", "fjj8tog"],
			B3pwyw6: "fb1u8ub",
			Bymgtzf: ["fjj8tog", "fzk0khw"],
			ecr2s2: "fophhak",
			dmfk: "f1uohb70",
			B4ofi8: ["f1jm7v1n", "f1bus3rq"],
			jgq6uv: "f1fbu7rr",
			Baxewws: ["f1bus3rq", "f1jm7v1n"]
		},
		outlineInteractiveSelected: {
			De3pzq: "f1q9pm1r",
			B0n5ga8: "f16eln5f",
			s924m2: ["fa2okxs", "fg4zq3l"],
			B1q35kw: "ff6932p",
			Gp14am: ["fg4zq3l", "fa2okxs"],
			Bi91k9c: "fx9teim",
			Jwef8y: "fg59vm4"
		},
		outlineDisabled: {
			De3pzq: "f1c21dwh",
			E5pizo: "f1couhl3",
			g2u3we: "f1jj8ep1",
			h3c5rm: ["f15xbau", "fy0fskl"],
			B9xav0g: "f4ikngz",
			zhjwy3: ["fy0fskl", "f15xbau"],
			ezxybo: "f1ls5moo",
			wc7uws: "f1qiza15",
			B0n5ga8: "f13dj02",
			s924m2: ["f9wngki", "f17v59j0"],
			B1q35kw: "f1vxzwsp",
			Gp14am: ["f17v59j0", "f9wngki"]
		},
		subtle: {
			De3pzq: "fhovq9v",
			E5pizo: "f1couhl3",
			B0n5ga8: "f16gxe2i",
			s924m2: ["fpgykix", "fzybk4o"],
			B1q35kw: "f1osi826",
			Gp14am: ["fzybk4o", "fpgykix"]
		},
		subtleInteractive: {
			Bceei9c: "f1k6fduh",
			De3pzq: "fhovq9v",
			E5pizo: "f1couhl3",
			B0n5ga8: "f16gxe2i",
			s924m2: ["fpgykix", "fzybk4o"],
			B1q35kw: "f1osi826",
			Gp14am: ["fzybk4o", "fpgykix"],
			Bi91k9c: "feu1g3u",
			Jwef8y: "f1t94bn6",
			ecr2s2: "f1wfn5kd"
		},
		subtleInteractiveSelected: {
			De3pzq: "fq5gl1p",
			B0n5ga8: "f16eln5f",
			s924m2: ["fa2okxs", "fg4zq3l"],
			B1q35kw: "ff6932p",
			Gp14am: ["fg4zq3l", "fa2okxs"],
			Bi91k9c: "fx9teim",
			Jwef8y: "f1uqaxdt"
		},
		highContrastSelected: {
			B8gzw0y: "f1h3a8gf",
			By8wz76: "f1nz3ub2",
			B7iucu3: "fqc85l4",
			Boo9lyk: "f1ucc5z8",
			sga51p: "fyj59f4",
			qj1yg9: ["f19v95gn", "f1n69f6i"],
			B8acmzm: "f16q7dot",
			Gezqo6: ["f1n69f6i", "f19v95gn"]
		},
		highContrastInteractive: {
			waf3gn: "f1quqgnd",
			B96h8j5: "f193utb4",
			Bpd3jnq: "f1io67iv",
			uhbujs: "f3n01jk",
			sga51p: "fyj59f4",
			qj1yg9: ["f19v95gn", "f1n69f6i"],
			B8acmzm: "f16q7dot",
			Gezqo6: ["f1n69f6i", "f19v95gn"]
		},
		select: {
			qhf8xq: "f1euv43f",
			Bhzewxz: "fqclxi7",
			j35jbq: ["fiv86kb", "f36uhnt"],
			Bj3rh1h: "fom9my7"
		},
		hiddenCheckbox: {
			B68tc82: 0,
			Bmxbyg5: 0,
			Bpg54ce: "f1a3p1vp",
			a9b677: "frkrog8",
			Bqenvij: "f1mpe4l3",
			qhf8xq: "f1euv43f",
			Bh84pgu: "fmf1zke",
			Bgl5zvf: "f1wch0ki",
			Huce71: "fz5stix"
		},
		disabled: {
			Bceei9c: "fdrzuqr",
			famaaq: "f1xqy1su",
			sj55zd: "f1s2aq7o",
			De3pzq: "f1bg9a2p",
			E5pizo: "fyed02w",
			g2u3we: "f1jj8ep1",
			h3c5rm: ["f15xbau", "fy0fskl"],
			B9xav0g: "f4ikngz",
			zhjwy3: ["fy0fskl", "f15xbau"],
			Ftih45: "f1wl9k8s",
			Brfgrao: "f1j7ml58",
			lawp4y: 0,
			Fbdkly: 0,
			mdwyqc: 0,
			Bciustq: 0,
			gc50h5: "f13vvzas",
			Ehzi8l: "f198lalb",
			B0n5ga8: "f13dj02",
			s924m2: ["f9wngki", "f17v59j0"],
			B1q35kw: "f1vxzwsp",
			Gp14am: ["f17v59j0", "f9wngki"],
			Bikrtoi: "f11og98d",
			G8qf51: "f1rg3h4v",
			Brxh4y7: "fbm2y3b",
			ezxybo: "f4yodeu",
			wc7uws: "fcwfbwp",
			gp3uxg: "f1repx37",
			Fohawp: ["f1ybi8ct", "f1h4eg6q"],
			Bxulg6k: "f18mejnb",
			vcjq4m: ["f1h4eg6q", "f1ybi8ct"],
			Bsqkqe9: "f1nift3m",
			fskg1g: "f1wu3i8x",
			iwiei9: 0,
			Effecx: 0,
			Bkt1b9m: 0,
			jfmxvr: 0,
			orauir: "f6v4vfa",
			B2yd9ot: "folrdqs",
			Fn9tzk: "f168z5yf",
			Bv0wker: ["fpor7gj", "fzextn6"],
			Bp2dl5b: "f1yaw79v",
			pzn0iz: ["fzextn6", "fpor7gj"]
		}
	}, {
		f: [".ftqa4ok:focus{outline-style:none;}"],
		i: [".f2hkw1w:focus-visible{outline-style:none;}"],
		d: [
			".f8hki3x[data-fui-focus-visible]{border-top-color:transparent;}",
			".f1d2448m[data-fui-focus-visible]{border-right-color:transparent;}",
			".ffh67wi[data-fui-focus-visible]{border-left-color:transparent;}",
			".f1bjia2o[data-fui-focus-visible]{border-bottom-color:transparent;}",
			".f15bsgw9[data-fui-focus-visible]::after{content:\"\";}",
			".f14e48fq[data-fui-focus-visible]::after{position:absolute;}",
			".f18yb2kv[data-fui-focus-visible]::after{pointer-events:none;}",
			".fd6o370[data-fui-focus-visible]::after{z-index:1;}",
			[".fpqizxz[data-fui-focus-visible]::after{border:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}", { p: -2 }],
			[".fnd8nzh[data-fui-focus-visible]::after{border-radius:var(--fui-Card--border-radius);}", { p: -1 }],
			".f15fr7a0[data-fui-focus-visible]::after{top:calc(0px - var(--strokeWidthThick) - -2px);}",
			".fwsq40z[data-fui-focus-visible]::after{right:calc(0px - var(--strokeWidthThick) - -2px);}",
			".fy0y4wt[data-fui-focus-visible]::after{left:calc(0px - var(--strokeWidthThick) - -2px);}",
			".f34ld9f[data-fui-focus-visible]::after{bottom:calc(0px - var(--strokeWidthThick) - -2px);}",
			".f1b1k54r[data-fui-focus-within]:focus-within{border-top-color:transparent;}",
			".f4ne723[data-fui-focus-within]:focus-within{border-right-color:transparent;}",
			".fqqcjud[data-fui-focus-within]:focus-within{border-left-color:transparent;}",
			".fh7aioi[data-fui-focus-within]:focus-within{border-bottom-color:transparent;}",
			".ffht0p2[data-fui-focus-within]:focus-within::after{content:\"\";}",
			".f1p0ul1q[data-fui-focus-within]:focus-within::after{position:absolute;}",
			".f1c901ms[data-fui-focus-within]:focus-within::after{pointer-events:none;}",
			".f1alokd7[data-fui-focus-within]:focus-within::after{z-index:1;}",
			[".f1i978nd[data-fui-focus-within]:focus-within::after{border:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}", { p: -2 }],
			[".f1nh8hsq[data-fui-focus-within]:focus-within::after{border-radius:var(--fui-Card--border-radius);}", { p: -1 }],
			".f1amxum7[data-fui-focus-within]:focus-within::after{top:calc(0px - var(--strokeWidthThick) - -2px);}",
			".f1cec8w7[data-fui-focus-within]:focus-within::after{right:calc(0px - var(--strokeWidthThick) - -2px);}",
			".f554mv0[data-fui-focus-within]:focus-within::after{left:calc(0px - var(--strokeWidthThick) - -2px);}",
			".f1sj6kbr[data-fui-focus-within]:focus-within::after{bottom:calc(0px - var(--strokeWidthThick) - -2px);}",
			".f1063pyq{flex-direction:row;}",
			".f122n59{align-items:center;}",
			".ftrw7vg>.fui-CardPreview{margin-top:calc(var(--fui-Card--size) * -1);}",
			".f18opajm>.fui-CardPreview{margin-bottom:calc(var(--fui-Card--size) * -1);}",
			".f13002it>:not([aria-hidden=\"true\"]).fui-CardPreview:first-of-type{margin-left:calc(var(--fui-Card--size) * -1);}",
			".fqo182t>:not([aria-hidden=\"true\"]).fui-CardPreview:first-of-type{margin-right:calc(var(--fui-Card--size) * -1);}",
			".f18yna97>:not([aria-hidden=\"true\"]).fui-CardPreview:last-of-type{margin-right:calc(var(--fui-Card--size) * -1);}",
			".f1kd6wh7>:not([aria-hidden=\"true\"]).fui-CardPreview:last-of-type{margin-left:calc(var(--fui-Card--size) * -1);}",
			".f4i4759>.fui-CardHeader:last-of-type,.f4i4759>.fui-CardFooter:last-of-type{flex-grow:1;}",
			".f1vx9l62{flex-direction:column;}",
			".f14k419y>.fui-CardPreview{margin-left:calc(var(--fui-Card--size) * -1);}",
			".f1fgo9fz>.fui-CardPreview{margin-right:calc(var(--fui-Card--size) * -1);}",
			".fvqmfsm>:not([aria-hidden=\"true\"]).fui-CardPreview:first-of-type{margin-top:calc(var(--fui-Card--size) * -1);}",
			".f3am6yf>.fui-Card__floatingAction+.fui-CardPreview{margin-top:calc(var(--fui-Card--size) * -1);}",
			".f1r5wgso>:not([aria-hidden=\"true\"]).fui-CardPreview:last-of-type{margin-bottom:calc(var(--fui-Card--size) * -1);}",
			".f1pi9uxy{--fui-Card--size:8px;}",
			".f1h1zgly{--fui-Card--border-radius:var(--borderRadiusSmall);}",
			".frsmuga{--fui-Card--size:12px;}",
			".fuldkky{--fui-Card--border-radius:var(--borderRadiusMedium);}",
			".f1qua4xo{--fui-Card--size:16px;}",
			".fimkt6v{--fui-Card--border-radius:var(--borderRadiusLarge);}",
			".f1epqm3e .fui-Text{color:currentColor;}",
			".fxugw4r{background-color:var(--colorNeutralBackground1);}",
			".f1whvlc6{box-shadow:var(--shadow4);}",
			".f16gxe2i::after{border-top-color:var(--colorTransparentStroke);}",
			".fpgykix::after{border-right-color:var(--colorTransparentStroke);}",
			".fzybk4o::after{border-left-color:var(--colorTransparentStroke);}",
			".f1osi826::after{border-bottom-color:var(--colorTransparentStroke);}",
			".f1k6fduh{cursor:pointer;}",
			".f1nfm20t{background-color:var(--colorNeutralBackground1Selected);}",
			".f16eln5f::after{border-top-color:var(--colorNeutralStroke1Selected);}",
			".fa2okxs::after{border-right-color:var(--colorNeutralStroke1Selected);}",
			".fg4zq3l::after{border-left-color:var(--colorNeutralStroke1Selected);}",
			".ff6932p::after{border-bottom-color:var(--colorNeutralStroke1Selected);}",
			".f1dmdbja{background-color:var(--colorNeutralBackground2);}",
			".fjxa0vh{background-color:var(--colorNeutralBackground2Selected);}",
			".f1c21dwh{background-color:var(--colorTransparentBackground);}",
			".f1couhl3{box-shadow:none;}",
			".ft83z1f::after{border-top-color:var(--colorNeutralStroke1);}",
			".f1g4150c::after{border-right-color:var(--colorNeutralStroke1);}",
			".f192dr6e::after{border-left-color:var(--colorNeutralStroke1);}",
			".f1qnawh6::after{border-bottom-color:var(--colorNeutralStroke1);}",
			".f1q9pm1r{background-color:var(--colorTransparentBackgroundSelected);}",
			".f1jj8ep1{border-top-color:var(--colorNeutralStrokeDisabled);}",
			".f15xbau{border-right-color:var(--colorNeutralStrokeDisabled);}",
			".fy0fskl{border-left-color:var(--colorNeutralStrokeDisabled);}",
			".f4ikngz{border-bottom-color:var(--colorNeutralStrokeDisabled);}",
			".f13dj02::after{border-top-color:var(--colorNeutralStrokeDisabled);}",
			".f9wngki::after{border-right-color:var(--colorNeutralStrokeDisabled);}",
			".f17v59j0::after{border-left-color:var(--colorNeutralStrokeDisabled);}",
			".f1vxzwsp::after{border-bottom-color:var(--colorNeutralStrokeDisabled);}",
			".fhovq9v{background-color:var(--colorSubtleBackground);}",
			".fq5gl1p{background-color:var(--colorSubtleBackgroundSelected);}",
			".f1euv43f{position:absolute;}",
			".fqclxi7{top:4px;}",
			".fiv86kb{right:4px;}",
			".f36uhnt{left:4px;}",
			".fom9my7{z-index:var(--zIndexContent, 1);}",
			[".f1a3p1vp{overflow:hidden;}", { p: -1 }],
			".frkrog8{width:1px;}",
			".f1mpe4l3{height:1px;}",
			".fmf1zke{clip:rect(0 0 0 0);}",
			".f1wch0ki{clip-path:inset(50%);}",
			".fz5stix{white-space:nowrap;}",
			".fdrzuqr{cursor:not-allowed;}",
			".f1xqy1su{-webkit-user-select:none;-moz-user-select:none;user-select:none;}",
			".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}",
			".f1bg9a2p{background-color:var(--colorNeutralBackgroundDisabled);}",
			".fyed02w{box-shadow:var(--shadow2);}",
			".f1wl9k8s::before{content:\"\";}",
			".f1j7ml58::before{position:absolute;}",
			[".f13vvzas::before{inset:0;}", { p: -1 }],
			".f198lalb::before{z-index:calc(var(--zIndexContent, 1) + 1);}"
		],
		m: [
			["@media (forced-colors: active){.f1j6vpng[data-fui-focus-visible]::after{border-top-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1ffjurs[data-fui-focus-visible]::after{border-left-color:Highlight;}.f1pniga2[data-fui-focus-visible]::after{border-right-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f987i1v[data-fui-focus-visible]::after{border-bottom-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1ufm4qn[data-fui-focus-within]:focus-within::after{border-top-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1qnwcb4[data-fui-focus-within]:focus-within::after{border-right-color:Highlight;}.fgrk5zm[data-fui-focus-within]:focus-within::after{border-left-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fi52z01[data-fui-focus-within]:focus-within::after{border-bottom-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1h3a8gf{forced-color-adjust:none;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1nz3ub2{background-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fqc85l4{color:HighlightText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1ucc5z8 .fui-CardPreview,.f1ucc5z8 .fui-CardFooter{forced-color-adjust:auto;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fyj59f4::after{border-top-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f19v95gn::after{border-right-color:Highlight;}.f1n69f6i::after{border-left-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f16q7dot::after{border-bottom-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1quqgnd:hover,.f1quqgnd :active{forced-color-adjust:none;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f193utb4:hover,.f193utb4 :active{background-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1io67iv:hover,.f1io67iv :active{color:HighlightText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f3n01jk:hover .fui-CardPreview,.f3n01jk :active .fui-CardPreview,.f3n01jk:hover .fui-CardFooter,.f3n01jk :active .fui-CardFooter{forced-color-adjust:auto;}}", { m: "(forced-colors: active)" }]
		],
		h: [
			".feu1g3u:hover{color:var(--colorNeutralForeground1Hover);}",
			".f1knas48:hover{background-color:var(--colorNeutralBackground1Hover);}",
			".f1m145df:hover{box-shadow:var(--shadow8);}",
			".fx9teim:hover{color:var(--colorNeutralForeground1Selected);}",
			".f1kz6goq:hover{background-color:var(--colorNeutralBackground1Selected);}",
			".fnwyq0v:hover{color:var(--colorNeutralForeground2Hover);}",
			".f1uvynv3:hover{background-color:var(--colorNeutralBackground2Hover);}",
			".f1luvkty:hover{color:var(--colorNeutralForeground2Selected);}",
			".fehi0vp:hover{background-color:var(--colorNeutralBackground2Selected);}",
			".fjxutwb:hover{background-color:var(--colorTransparentBackgroundHover);}",
			".f1llr77y:hover::after{border-top-color:var(--colorNeutralStroke1Hover);}",
			".fzk0khw:hover::after{border-right-color:var(--colorNeutralStroke1Hover);}",
			".fjj8tog:hover::after{border-left-color:var(--colorNeutralStroke1Hover);}",
			".fb1u8ub:hover::after{border-bottom-color:var(--colorNeutralStroke1Hover);}",
			".fg59vm4:hover{background-color:var(--colorTransparentBackgroundSelected);}",
			".f1ls5moo:hover,.f1ls5moo:active{background-color:var(--colorTransparentBackground);}",
			".f1qiza15:hover,.f1qiza15:active{box-shadow:none;}",
			".f1t94bn6:hover{background-color:var(--colorSubtleBackgroundHover);}",
			".f1uqaxdt:hover{background-color:var(--colorSubtleBackgroundSelected);}",
			".f11og98d:hover,.f11og98d:active{cursor:not-allowed;}",
			".f1rg3h4v:hover,.f1rg3h4v:active{-webkit-user-select:none;-moz-user-select:none;user-select:none;}",
			".fbm2y3b:hover,.fbm2y3b:active{color:var(--colorNeutralForegroundDisabled);}",
			".f4yodeu:hover,.f4yodeu:active{background-color:var(--colorNeutralBackgroundDisabled);}",
			".fcwfbwp:hover,.fcwfbwp:active{box-shadow:var(--shadow2);}",
			".f1repx37:hover,.f1repx37:active{border-top-color:var(--colorNeutralStrokeDisabled);}",
			".f1ybi8ct:hover,.f1ybi8ct:active{border-right-color:var(--colorNeutralStrokeDisabled);}",
			".f1h4eg6q:hover,.f1h4eg6q:active{border-left-color:var(--colorNeutralStrokeDisabled);}",
			".f18mejnb:hover,.f18mejnb:active{border-bottom-color:var(--colorNeutralStrokeDisabled);}",
			".f1nift3m:hover::before,.f1nift3m:active::before{content:\"\";}",
			".f1wu3i8x:hover::before,.f1wu3i8x:active::before{position:absolute;}",
			[".f6v4vfa:hover::before,.f6v4vfa:active::before{inset:0;}", { p: -1 }],
			".folrdqs:hover::before,.folrdqs:active::before{z-index:calc(var(--zIndexContent, 1) + 1);}",
			".f168z5yf:hover::after,.f168z5yf:active::after{border-top-color:var(--colorNeutralStrokeDisabled);}",
			".fpor7gj:hover::after,.fpor7gj:active::after{border-right-color:var(--colorNeutralStrokeDisabled);}",
			".fzextn6:hover::after,.fzextn6:active::after{border-left-color:var(--colorNeutralStrokeDisabled);}",
			".f1yaw79v:hover::after,.f1yaw79v:active::after{border-bottom-color:var(--colorNeutralStrokeDisabled);}"
		],
		a: [
			".fb40n2d:active{background-color:var(--colorNeutralBackground1Pressed);}",
			".f1yhgkbh:active{background-color:var(--colorNeutralBackground2Pressed);}",
			".fophhak:active{background-color:var(--colorTransparentBackgroundPressed);}",
			".f1uohb70:active::after{border-top-color:var(--colorNeutralStroke1Pressed);}",
			".f1jm7v1n:active::after{border-right-color:var(--colorNeutralStroke1Pressed);}",
			".f1bus3rq:active::after{border-left-color:var(--colorNeutralStroke1Pressed);}",
			".f1fbu7rr:active::after{border-bottom-color:var(--colorNeutralStroke1Pressed);}",
			".f1wfn5kd:active{background-color:var(--colorSubtleBackgroundPressed);}"
		]
	});
	/**
	* Apply styling to the Card slots based on the state.
	*/
	const useCardStyles_unstable = (state) => {
		"use no memo";
		const resetStyles = useCardResetStyles();
		const styles = useCardStyles();
		const orientationMap = {
			horizontal: styles.orientationHorizontal,
			vertical: styles.orientationVertical
		};
		const sizeMap = {
			small: styles.sizeSmall,
			medium: styles.sizeMedium,
			large: styles.sizeLarge
		};
		const appearanceMap = {
			filled: styles.filled,
			"filled-alternative": styles.filledAlternative,
			outline: styles.outline,
			subtle: styles.subtle
		};
		const selectedMap = {
			filled: styles.filledInteractiveSelected,
			"filled-alternative": styles.filledAlternativeInteractiveSelected,
			outline: styles.outlineInteractiveSelected,
			subtle: styles.subtleInteractiveSelected
		};
		const interactiveMap = {
			filled: styles.filledInteractive,
			"filled-alternative": styles.filledAlternativeInteractive,
			outline: styles.outlineInteractive,
			subtle: styles.subtleInteractive
		};
		const isSelectableOrInteractive = !state.disabled && (state.interactive || state.selectable);
		const focusedClassName = react.useMemo(() => {
			if (state.disabled) return "";
			if (state.selectable) {
				if (state.selectFocused) return styles.selectableFocused;
				return "";
			}
			return styles.focused;
		}, [
			state.disabled,
			state.selectFocused,
			state.selectable,
			styles.focused,
			styles.selectableFocused
		]);
		state.root.className = mergeClasses(cardClassNames.root, resetStyles, orientationMap[state.orientation], sizeMap[state.size], appearanceMap[state.appearance], isSelectableOrInteractive && styles.interactive, isSelectableOrInteractive && interactiveMap[state.appearance], state.selected && selectedMap[state.appearance], focusedClassName, isSelectableOrInteractive && styles.highContrastInteractive, state.selected && styles.highContrastSelected, state.disabled && styles.disabled, state.disabled && state.appearance === "outline" && styles.outlineDisabled, state.root.className);
		if (state.floatingAction) state.floatingAction.className = mergeClasses(cardClassNames.floatingAction, styles.select, state.floatingAction.className);
		if (state.checkbox) state.checkbox.className = mergeClasses(cardClassNames.checkbox, styles.hiddenCheckbox, state.checkbox.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-card/lib/components/Card/useCardContextValue.js
	function useCardContextValue({ selectableA11yProps }) {
		return { selectableA11yProps };
	}

//#endregion
//#region node_modules/@fluentui/react-card/lib/components/Card/Card.js
/**
	* A card provides scaffolding for hosting actions and content for a single topic.
	*/ const Card = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useCard_unstable(props, ref);
		const cardContextValue = useCardContextValue(state);
		useCardStyles_unstable(state);
		useCustomStyleHook("useCardStyles_unstable")(state);
		return renderCard_unstable(state, cardContextValue);
	});
	Card.displayName = "Card";

//#endregion
//#region node_modules/@fluentui/react-card/lib/components/CardFooter/useCardFooter.js
/**
	* Create the state required to render CardFooter.
	*
	* The returned state can be modified with hooks such as useCardFooterStyles_unstable,
	* before being passed to renderCardFooter_unstable.
	*
	* @param props - props from this instance of CardFooter
	* @param ref - reference to root HTMLElement of CardFooter
	*/ const useCardFooter_unstable = (props, ref) => {
		const { action } = props;
		return {
			components: {
				root: "div",
				action: "div"
			},
			root: always(getIntrinsicElementProps("div", {
				ref,
				...props
			}), { elementType: "div" }),
			action: optional(action, { elementType: "div" })
		};
	};

//#endregion
//#region node_modules/@fluentui/react-card/lib/components/CardFooter/renderCardFooter.js
/**
	* Render the final JSX of CardFooter.
	*/ const renderCardFooter_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(state.root, { children: [state.root.children, state.action && /* @__PURE__ */ jsx(state.action, {})] });
	};

//#endregion
//#region node_modules/@fluentui/react-card/lib/components/CardFooter/CardFooter.js
/**
	* Component to render Button actions in a Card component.
	*/ const CardFooter = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useCardFooter_unstable(props, ref);
		useCardFooterStyles_unstable(state);
		useCustomStyleHook("useCardFooterStyles_unstable")(state);
		return renderCardFooter_unstable(state);
	});
	CardFooter.displayName = "CardFooter";

//#endregion
//#region node_modules/@fluentui/react-card/lib/components/CardHeader/useCardHeader.js
/**
	* Finds the first child of CardHeader with an id prop.
	*
	* @param header - the header prop of CardHeader
	*/ function getChildWithId(header) {
		function isReactElementWithIdProp(element) {
			return react.isValidElement(element) && Boolean(element.props.id);
		}
		return react.Children.toArray(header).find(isReactElementWithIdProp);
	}
	/**
	* Returns the id to use for the CardHeader root element.
	*
	* @param headerId - the id prop of the CardHeader component
	* @param childWithId - the first child of the CardHeader component with an id prop
	* @param generatedId - a generated id
	*
	* @returns the id to use for the CardHeader root element
	*/ function getReferenceId(headerId, childWithId, generatedId) {
		if (headerId) return headerId;
		if (childWithId === null || childWithId === void 0 ? void 0 : childWithId.props.id) return childWithId.props.id;
		return generatedId;
	}
	/**
	* Create the state required to render CardHeader.
	*
	* The returned state can be modified with hooks such as useCardHeaderStyles_unstable,
	* before being passed to renderCardHeader_unstable.
	*
	* @param props - props from this instance of CardHeader
	* @param ref - reference to root HTMLElement of CardHeader
	*/ const useCardHeader_unstable = (props, ref) => {
		const { image, header, description, action } = props;
		const { selectableA11yProps: { referenceId, setReferenceId } } = useCardContext_unstable();
		const headerRef = react.useRef(null);
		const hasChildId = react.useRef(false);
		const generatedId = useId(cardHeaderClassNames.header, referenceId);
		const headerSlot = optional(header, {
			renderByDefault: true,
			defaultProps: {
				ref: headerRef,
				id: !hasChildId.current ? referenceId : void 0
			},
			elementType: "div"
		});
		react.useEffect(() => {
			var _headerRef_current;
			const headerId = !hasChildId.current ? (_headerRef_current = headerRef.current) === null || _headerRef_current === void 0 ? void 0 : _headerRef_current.id : void 0;
			const childWithId = getChildWithId(headerSlot === null || headerSlot === void 0 ? void 0 : headerSlot.children);
			hasChildId.current = Boolean(childWithId);
			setReferenceId(getReferenceId(headerId, childWithId, generatedId));
		}, [
			generatedId,
			header,
			headerSlot,
			setReferenceId
		]);
		return {
			components: {
				root: "div",
				image: "div",
				header: "div",
				description: "div",
				action: "div"
			},
			root: always(getIntrinsicElementProps("div", {
				ref,
				...props
			}), { elementType: "div" }),
			image: optional(image, { elementType: "div" }),
			header: headerSlot,
			description: optional(description, { elementType: "div" }),
			action: optional(action, { elementType: "div" })
		};
	};

//#endregion
//#region node_modules/@fluentui/react-card/lib/components/CardHeader/renderCardHeader.js
/**
	* Render the final JSX of CardHeader.
	*/ const renderCardHeader_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(state.root, { children: [
			state.image && /* @__PURE__ */ jsx(state.image, {}),
			state.header && /* @__PURE__ */ jsx(state.header, {}),
			state.description && /* @__PURE__ */ jsx(state.description, {}),
			state.action && /* @__PURE__ */ jsx(state.action, {})
		] });
	};

//#endregion
//#region node_modules/@fluentui/react-card/lib/components/CardHeader/CardHeader.js
/**
	* Component to render an image, text and an action in a Card component.
	*/ const CardHeader = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useCardHeader_unstable(props, ref);
		useCardHeaderStyles_unstable(state);
		useCustomStyleHook("useCardHeaderStyles_unstable")(state);
		return renderCardHeader_unstable(state);
	});
	CardHeader.displayName = "CardHeader";

//#endregion
//#region node_modules/@fluentui/react-card/lib/components/CardPreview/useCardPreview.js
/**
	* Create the state required to render CardPreview.
	*
	* The returned state can be modified with hooks such as useCardPreviewStyles_unstable,
	* before being passed to renderCardPreview_unstable.
	*
	* @param props - props from this instance of CardPreview
	* @param ref - reference to root HTMLElement of CardPreview
	*/ const useCardPreview_unstable = (props, ref) => {
		const { logo } = props;
		const { selectableA11yProps: { referenceLabel, referenceId, setReferenceLabel, setReferenceId } } = useCardContext_unstable();
		const previewRef = useMergedRefs(ref, react.useRef(null));
		react.useEffect(() => {
			if (referenceLabel && referenceId) return;
			if (previewRef.current && previewRef.current.parentNode) {
				const img = previewRef.current.parentNode.querySelector(`.${cardPreviewClassNames.root} > img`);
				if (img) {
					const ariaLabel = img.getAttribute("aria-label");
					const ariaDescribedby = img.getAttribute("aria-describedby");
					if (ariaDescribedby) setReferenceId(ariaDescribedby);
					else if (img.alt) setReferenceLabel(img.alt);
					else if (ariaLabel) setReferenceLabel(ariaLabel);
				}
			}
		}, [
			setReferenceLabel,
			referenceLabel,
			previewRef,
			referenceId,
			setReferenceId
		]);
		return {
			components: {
				root: "div",
				logo: "div"
			},
			root: always(getIntrinsicElementProps("div", {
				ref: previewRef,
				...props
			}), { elementType: "div" }),
			logo: optional(logo, { elementType: "div" })
		};
	};

//#endregion
//#region node_modules/@fluentui/react-card/lib/components/CardPreview/renderCardPreview.js
/**
	* Render the final JSX of CardPreview.
	*/ const renderCardPreview_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(state.root, { children: [state.root.children, state.logo && /* @__PURE__ */ jsx(state.logo, {})] });
	};

//#endregion
//#region node_modules/@fluentui/react-card/lib/components/CardPreview/CardPreview.js
/**
	* Component to render image previews of documents or articles in a Card component.
	*/ const CardPreview = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useCardPreview_unstable(props, ref);
		useCardPreviewStyles_unstable(state);
		useCustomStyleHook("useCardPreviewStyles_unstable")(state);
		return renderCardPreview_unstable(state);
	});
	CardPreview.displayName = "CardPreview";

//#endregion
//#region node_modules/@fluentui/react-toast/lib/state/constants.js
	const EVENTS = {
		show: "fui-toast-show",
		dismiss: "fui-toast-dismiss",
		dismissAll: "fui-toast-dismiss-all",
		update: "fui-toast-update",
		pause: "fui-toast-pause",
		play: "fui-toast-play"
	};
	const TOAST_POSITIONS = {
		bottom: "bottom",
		bottomEnd: "bottom-end",
		bottomStart: "bottom-start",
		top: "top",
		topEnd: "top-end",
		topStart: "top-start"
	};

//#endregion
//#region node_modules/@fluentui/react-toast/lib/state/vanilla/dispatchToast.js
	let counter$1 = 0;
	function dispatchToast(content, options = {}, targetDocument) {
		var _options_toastId;
		const detail = {
			...options,
			content,
			toastId: (_options_toastId = options.toastId) !== null && _options_toastId !== void 0 ? _options_toastId : (counter$1++).toString()
		};
		const event = new CustomEvent(EVENTS.show, {
			bubbles: false,
			cancelable: false,
			detail
		});
		targetDocument.dispatchEvent(event);
	}

//#endregion
//#region node_modules/@fluentui/react-toast/lib/state/vanilla/dismissToast.js
	function dismissToast(toastId, toasterId = void 0, targetDocument) {
		const event = new CustomEvent(EVENTS.dismiss, {
			bubbles: false,
			cancelable: false,
			detail: {
				toastId,
				toasterId
			}
		});
		targetDocument.dispatchEvent(event);
	}

//#endregion
//#region node_modules/@fluentui/react-toast/lib/state/vanilla/dismissAllToasts.js
	function dismissAllToasts(toasterId = void 0, targetDocument) {
		const event = new CustomEvent(EVENTS.dismissAll, {
			bubbles: false,
			cancelable: false,
			detail: { toasterId }
		});
		targetDocument.dispatchEvent(event);
	}

//#endregion
//#region node_modules/@fluentui/react-toast/lib/state/vanilla/updateToast.js
	function updateToast(options, targetDocument) {
		const event = new CustomEvent(EVENTS.update, {
			bubbles: false,
			cancelable: false,
			detail: options
		});
		targetDocument.dispatchEvent(event);
	}

//#endregion
//#region node_modules/@fluentui/react-toast/lib/state/vanilla/pauseToast.js
	function pauseToast(toastId, toasterId = void 0, targetDocument) {
		const event = new CustomEvent(EVENTS.pause, {
			bubbles: false,
			cancelable: false,
			detail: {
				toastId,
				toasterId
			}
		});
		targetDocument.dispatchEvent(event);
	}

//#endregion
//#region node_modules/@fluentui/react-toast/lib/state/vanilla/playToast.js
	function playToast(toastId, toasterId = void 0, targetDocument) {
		const event = new CustomEvent(EVENTS.play, {
			bubbles: false,
			cancelable: false,
			detail: {
				toastId,
				toasterId
			}
		});
		targetDocument.dispatchEvent(event);
	}

//#endregion
//#region node_modules/@fluentui/react-toast/lib/state/vanilla/createToaster.js
	function assignDefined(a, b) {
		for (const [key, prop] of Object.entries(b)) if (prop != void 0) a[key] = prop;
	}
	const defaulToastOptions = {
		onStatusChange: void 0,
		priority: 0,
		pauseOnHover: false,
		pauseOnWindowBlur: false,
		position: "bottom-end",
		timeout: 3e3
	};
	let counter = 0;
	/**
	* Toast are managed outside of the react lifecycle because they can be
	* dispatched imperatively. Therefore the state of toast visibility can't
	* really be managed properly by a declarative lifecycle.
	*/ function createToaster(options) {
		const { limit = Number.POSITIVE_INFINITY } = options;
		const visibleToasts = /* @__PURE__ */ new Set();
		const toasts = /* @__PURE__ */ new Map();
		const queue = createPriorityQueue$1((ta, tb) => {
			const a = toasts.get(ta);
			const b = toasts.get(tb);
			if (!a || !b) return 0;
			if (a.priority === b.priority) return a.order - b.order;
			return a.priority - b.priority;
		});
		const isToastVisible = (toastId) => {
			return visibleToasts.has(toastId);
		};
		/**
		* Updates an existing toast with any available option
		*/ const updateToast$1 = (toastOptions) => {
			const { toastId } = toastOptions;
			const toastToUpdate = toasts.get(toastId);
			if (!toastToUpdate) return;
			Object.assign(toastToUpdate, toastOptions);
			toastToUpdate.updateId++;
		};
		/**
		* Dismisses a toast with a specific id
		*/ const dismissToast$1 = (toastId) => {
			visibleToasts.delete(toastId);
		};
		/**
		* Dismisses all toasts and clears the queue
		*/ const dismissAllToasts$1 = () => {
			visibleToasts.clear();
			queue.clear();
		};
		/**
		* @param toastOptions user configured options
		* @param onUpdate Some toast methods can result in UI changes (i.e. close) use this to dispatch callbacks
		*/ const buildToast = (toastOptions, onUpdate) => {
			var _toast_onStatusChange;
			const { toastId, content, toasterId } = toastOptions;
			if (toasts.has(toastId)) return;
			const close = () => {
				var _toast_onStatusChange$1;
				const toast$1 = toasts.get(toastId);
				if (!toast$1) return;
				visibleToasts.delete(toastId);
				onUpdate();
				(_toast_onStatusChange$1 = toast$1.onStatusChange) === null || _toast_onStatusChange$1 === void 0 || _toast_onStatusChange$1.call(toast$1, null, {
					status: "dismissed",
					...toast$1
				});
			};
			const remove = () => {
				if (!toasts.get(toastId)) return;
				toasts.delete(toastId);
				if (visibleToasts.size < limit && queue.peek()) {
					const nextToast = toasts.get(queue.dequeue());
					if (!nextToast) return;
					visibleToasts.add(nextToast.toastId);
				}
				onUpdate();
			};
			const toast = {
				...defaulToastOptions,
				close,
				remove,
				toastId,
				content,
				updateId: 0,
				toasterId,
				order: counter++,
				data: {},
				imperativeRef: react.createRef()
			};
			assignDefined(toast, options);
			assignDefined(toast, toastOptions);
			toasts.set(toastId, toast);
			(_toast_onStatusChange = toast.onStatusChange) === null || _toast_onStatusChange === void 0 || _toast_onStatusChange.call(toast, null, {
				status: "queued",
				...toast
			});
			if (visibleToasts.size >= limit) queue.enqueue(toastId);
			else visibleToasts.add(toastId);
		};
		return {
			buildToast,
			dismissAllToasts: dismissAllToasts$1,
			dismissToast: dismissToast$1,
			isToastVisible,
			updateToast: updateToast$1,
			visibleToasts,
			toasts
		};
	}

//#endregion
//#region node_modules/@fluentui/react-toast/lib/state/vanilla/getPositionStyles.js
	const getPositionStyles = (position$1, dir, offset$3) => {
		const positionStyles = {};
		var _offset_position;
		const offsetStyles = offset$3 ? isShorthandOffset(offset$3) ? offset$3 : (_offset_position = offset$3[position$1]) !== null && _offset_position !== void 0 ? _offset_position : {} : {};
		const centered = position$1 === "top" || position$1 === "bottom";
		const { horizontal = centered ? 0 : 20, vertical = 16 } = offsetStyles;
		const start = dir === "ltr" ? "left" : "right";
		const end = dir === "ltr" ? "right" : "left";
		switch (position$1) {
			case "top":
				Object.assign(positionStyles, {
					top: vertical,
					left: `calc(50% + ${horizontal}px)`,
					transform: "translateX(-50%)"
				});
				break;
			case "bottom":
				Object.assign(positionStyles, {
					bottom: vertical,
					left: `calc(50% + ${horizontal}px)`,
					transform: "translateX(-50%)"
				});
				break;
			case "top-start":
				Object.assign(positionStyles, {
					top: vertical,
					[start]: horizontal
				});
				break;
			case "top-end":
				Object.assign(positionStyles, {
					top: vertical,
					[end]: horizontal
				});
				break;
			case "bottom-start":
				Object.assign(positionStyles, {
					bottom: vertical,
					[start]: horizontal
				});
				break;
			case "bottom-end":
				Object.assign(positionStyles, {
					bottom: vertical,
					[end]: horizontal
				});
				break;
		}
		return positionStyles;
	};
	function isShorthandOffset(offset$3) {
		return "horizontal" in offset$3 || "vertical" in offset$3;
	}

//#endregion
//#region node_modules/@fluentui/react-toast/lib/state/useToaster.js
	function useToaster(options = {}) {
		const forceUpdate = useForceUpdate();
		const { toasterId: userToasterId, shortcuts } = options;
		const [toaster] = react.useState(() => createToaster(options));
		const { targetDocument } = useFluent();
		const lastActiveElementRef = react.useRef(null);
		const isCorrectToaster = useEventCallback((toasterId) => {
			return toasterId === userToasterId;
		});
		const isFocusShortcut = useEventCallback((e) => {
			if (shortcuts === null || shortcuts === void 0 ? void 0 : shortcuts.focus) return shortcuts.focus(e);
		});
		const pauseAllToasts = react.useCallback(() => {
			toaster.visibleToasts.forEach((toastId) => {
				var _toast_imperativeRef_current;
				const toast = toaster.toasts.get(toastId);
				toast === null || toast === void 0 || (_toast_imperativeRef_current = toast.imperativeRef.current) == null || _toast_imperativeRef_current.pause();
			});
		}, [toaster]);
		const playAllToasts = react.useCallback(() => {
			toaster.visibleToasts.forEach((toastId) => {
				var _toast_imperativeRef_current;
				const toast = toaster.toasts.get(toastId);
				toast === null || toast === void 0 || (_toast_imperativeRef_current = toast.imperativeRef.current) == null || _toast_imperativeRef_current.play();
			});
		}, [toaster]);
		const getMostRecentVisibleToast = react.useCallback(() => {
			return Array.from(toaster.visibleToasts).reduce((cur, next$1) => {
				const toast = toaster.toasts.get(next$1);
				if (!toast) return cur;
				if (!cur) return toast;
				if (cur.order < (toast === null || toast === void 0 ? void 0 : toast.order)) return toast;
				return cur;
			}, void 0);
		}, [toaster]);
		const tryRestoreFocus = react.useCallback(() => {
			const mostRecentToast = getMostRecentVisibleToast();
			if (mostRecentToast === null || mostRecentToast === void 0 ? void 0 : mostRecentToast.imperativeRef.current) mostRecentToast.imperativeRef.current.focus();
			else {
				var _lastActiveElementRef_current;
				(_lastActiveElementRef_current = lastActiveElementRef.current) === null || _lastActiveElementRef_current === void 0 || _lastActiveElementRef_current.focus();
				lastActiveElementRef.current = null;
			}
		}, [getMostRecentVisibleToast]);
		const closeAllToasts = react.useCallback(() => {
			toaster.visibleToasts.forEach((toastId) => {
				const toast = toaster.toasts.get(toastId);
				toast === null || toast === void 0 || toast.close();
			});
			tryRestoreFocus();
		}, [toaster, tryRestoreFocus]);
		react.useEffect(() => {
			if (!targetDocument) return;
			const addToastListener = (eventType, callback) => {
				const listener = (e) => {
					if (!isCorrectToaster(e.detail.toasterId)) return;
					callback(e);
					forceUpdate();
				};
				targetDocument.addEventListener(eventType, listener);
				return () => targetDocument.removeEventListener(eventType, listener);
			};
			const buildToast = (e) => {
				toaster.buildToast(e.detail, forceUpdate);
			};
			const dismissToast$1 = (e) => {
				toaster.dismissToast(e.detail.toastId);
			};
			const updateToast$1 = (e) => {
				toaster.updateToast(e.detail);
			};
			const dismissAllToasts$1 = (e) => {
				toaster.dismissAllToasts();
			};
			const pauseToast$1 = (e) => {
				const toast = toaster.toasts.get(e.detail.toastId);
				if (toast) {
					var _toast_imperativeRef_current;
					(_toast_imperativeRef_current = toast.imperativeRef.current) === null || _toast_imperativeRef_current === void 0 || _toast_imperativeRef_current.pause();
				}
			};
			const playToast$1 = (e) => {
				const toast = toaster.toasts.get(e.detail.toastId);
				if (toast) {
					var _toast_imperativeRef_current;
					(_toast_imperativeRef_current = toast.imperativeRef.current) === null || _toast_imperativeRef_current === void 0 || _toast_imperativeRef_current.play();
				}
			};
			const cleanupBuildListener = addToastListener(EVENTS.show, buildToast);
			const cleanupUpdateListener = addToastListener(EVENTS.update, updateToast$1);
			const cleanupDismissListener = addToastListener(EVENTS.dismiss, dismissToast$1);
			const cleanupDismissAllListener = addToastListener(EVENTS.dismissAll, dismissAllToasts$1);
			const cleanupPauseListener = addToastListener(EVENTS.pause, pauseToast$1);
			const cleanupPlayListener = addToastListener(EVENTS.play, playToast$1);
			const focusShortcutListener = (e) => {
				if (isFocusShortcut(e)) {
					pauseAllToasts();
					const mostRecentToast = getMostRecentVisibleToast();
					if (mostRecentToast) {
						var _mostRecentToast_imperativeRef_current;
						lastActiveElementRef.current = isHTMLElement(targetDocument.activeElement) ? targetDocument.activeElement : null;
						(_mostRecentToast_imperativeRef_current = mostRecentToast.imperativeRef.current) === null || _mostRecentToast_imperativeRef_current === void 0 || _mostRecentToast_imperativeRef_current.focus();
					}
				}
			};
			targetDocument.addEventListener("keydown", focusShortcutListener);
			return () => {
				cleanupBuildListener();
				cleanupDismissAllListener();
				cleanupUpdateListener();
				cleanupDismissListener();
				cleanupPauseListener();
				cleanupPlayListener();
				targetDocument.removeEventListener("keydown", focusShortcutListener);
			};
		}, [
			toaster,
			forceUpdate,
			targetDocument,
			isCorrectToaster,
			pauseAllToasts,
			getMostRecentVisibleToast,
			isFocusShortcut
		]);
		const toastsToRender = (() => {
			if (!toaster) return /* @__PURE__ */ new Map();
			const toRender = /* @__PURE__ */ new Map();
			Array.from(toaster.toasts.values()).forEach((toast) => {
				const { position: position$1 } = toast;
				toRender.has(position$1) || toRender.set(position$1, []);
				if (position$1.startsWith("bottom")) toRender.get(position$1).push(toast);
				else toRender.get(position$1).unshift(toast);
			});
			return toRender;
		})();
		return {
			isToastVisible: toaster.isToastVisible,
			toastsToRender,
			pauseAllToasts,
			playAllToasts,
			tryRestoreFocus,
			closeAllToasts
		};
	}

//#endregion
//#region node_modules/@fluentui/react-toast/lib/state/useToastController.js
	const noop$4 = () => void 0;
	/**
	* @param toasterId - If an id is provided all imperative methods control that specific toaster
	* @returns Imperative methods to control toasts
	*/ function useToastController(toasterId) {
		const { targetDocument } = useFluent();
		return react.useMemo(() => {
			if (!targetDocument) return {
				dispatchToast: noop$4,
				dismissToast: noop$4,
				dismissAllToasts: noop$4,
				updateToast: noop$4,
				pauseToast: noop$4,
				playToast: noop$4
			};
			return {
				dispatchToast: (content, options) => {
					dispatchToast(content, {
						...options,
						toasterId,
						data: { root: options === null || options === void 0 ? void 0 : options.root }
					}, targetDocument);
				},
				dismissToast: (toastId) => {
					dismissToast(toastId, toasterId, targetDocument);
				},
				dismissAllToasts: () => {
					dismissAllToasts(toasterId, targetDocument);
				},
				updateToast: (options) => {
					updateToast({
						...options,
						data: { root: options.root },
						toasterId
					}, targetDocument);
				},
				pauseToast: (toastId) => {
					pauseToast(toastId, toasterId, targetDocument);
				},
				playToast: (toastId) => {
					playToast(toastId, toasterId, targetDocument);
				}
			};
		}, [targetDocument, toasterId]);
	}

//#endregion
//#region node_modules/@fluentui/react-toast/lib/contexts/toastContainerContext.js
	const toastContainerContextDefaultValue = {
		close: () => null,
		intent: void 0,
		bodyId: "",
		titleId: ""
	};
	const ToastContainerContext = /* @__PURE__ */ react.createContext(void 0);
	const ToastContainerContextProvider = ToastContainerContext.Provider;
	const useToastContainerContext = () => {
		var _React_useContext;
		return (_React_useContext = react.useContext(ToastContainerContext)) !== null && _React_useContext !== void 0 ? _React_useContext : toastContainerContextDefaultValue;
	};

//#endregion
//#region node_modules/@fluentui/react-toast/lib/components/ToastTrigger/useToastTrigger.js
/**
	* A non-visual component that wraps its child
	* and configures them to be the trigger that will close a `Toast`.
	* This component should only accept one child.
	*
	* This component sole purpose is to avoid opting out of the internal controlled open state of a `Toast`
	* Besides being a trigger that closes a toast through context this component doesn't do much,
	* making it basically unnecessary in cases where the trigger is outside of a toast.
	*/ const useToastTrigger_unstable = (props) => {
		const { children, disableButtonEnhancement = false } = props;
		const { close } = useToastContainerContext();
		const child = getTriggerChild(children);
		const handleClick = useEventCallback((e) => {
			var _child_props_onClick, _child_props;
			child === null || child === void 0 || (_child_props_onClick = (_child_props = child.props).onClick) == null || _child_props_onClick.call(_child_props, e);
			if (!e.isDefaultPrevented()) close();
		});
		const triggerChildProps = {
			...child === null || child === void 0 ? void 0 : child.props,
			ref: getReactElementRef(child),
			onClick: handleClick
		};
		const ariaButtonTriggerChildProps = useARIAButtonProps((child === null || child === void 0 ? void 0 : child.type) === "button" || (child === null || child === void 0 ? void 0 : child.type) === "a" ? child.type : "div", {
			...triggerChildProps,
			type: "button"
		});
		return { children: applyTriggerPropsToChildren(children, disableButtonEnhancement ? triggerChildProps : ariaButtonTriggerChildProps) };
	};

//#endregion
//#region node_modules/@fluentui/react-toast/lib/components/ToastTrigger/renderToastTrigger.js
/**
	* Render the final JSX of MenuTrigger
	*
	* Only renders children
	*/ const renderToastTrigger_unstable = (state) => state.children;

//#endregion
//#region node_modules/@fluentui/react-toast/lib/components/ToastTrigger/ToastTrigger.js
/**
	* ToastTrigger component
	*/ const ToastTrigger = (props) => {
		return renderToastTrigger_unstable(useToastTrigger_unstable(props));
	};
	ToastTrigger.displayName = "ToastTrigger";

//#endregion
//#region node_modules/@fluentui/react-toast/lib/components/Timer/useTimerStyles.styles.js
	const useBaseAnimationStyles = /* @__PURE__ */ __resetStyles("r16zaflb", "r75casi", [
		".r16zaflb{animation-name:rsacmq1;}",
		"@keyframes rsacmq1{from{opacity:0;}to{opacity:0;}}",
		".r75casi{animation-name:rsacmq1;}"
	]);

//#endregion
//#region node_modules/@fluentui/react-toast/lib/components/Timer/Timer.js
	const Timer = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const baseAnimationStyles = useBaseAnimationStyles();
		const { running, timeout, onTimeout } = props;
		const style = {
			animationDuration: `${timeout}ms`,
			animationPlayState: running ? "running" : "paused"
		};
		if (timeout < 0) return null;
		return /* @__PURE__ */ react.createElement("span", {
			onAnimationEnd: onTimeout,
			"data-timer-status": style.animationPlayState,
			ref,
			style,
			className: baseAnimationStyles
		});
	});
	Timer.displayName = "Timer";

//#endregion
//#region node_modules/@fluentui/react-toast/lib/components/ToastContainer/useToastContainer.js
	const intentPolitenessMap = {
		success: "assertive",
		warning: "assertive",
		error: "assertive",
		info: "polite"
	};
	/**
	* Create the state required to render ToastContainer.
	*
	* The returned state can be modified with hooks such as useToastContainerStyles_unstable,
	* before being passed to renderToastContainer_unstable.
	*
	* @param props - props from this instance of ToastContainer
	* @param ref - reference to root HTMLElement of ToastContainer
	*/ const useToastContainer_unstable = (props, ref) => {
		const { visible, children, close: closeProp, remove, updateId, announce, data, timeout: timerTimeout, politeness: desiredPoliteness, intent = "info", pauseOnHover, pauseOnWindowBlur, imperativeRef, tryRestoreFocus, content: _content, ...rest } = props;
		const titleId = useId("toast-title");
		const bodyId = useId("toast-body");
		const toastRef = react.useRef(null);
		const { targetDocument } = useFluent();
		const [running, setRunning] = react.useState(false);
		const imperativePauseRef = react.useRef(false);
		const focusedToastBeforeClose = react.useRef(false);
		const focusableGroupAttribute = useFocusableGroup({
			tabBehavior: "limited-trap-focus",
			ignoreDefaultKeydown: {
				Tab: true,
				Escape: true,
				Enter: true
			}
		});
		const close = useEventCallback(() => {
			var _toastRef_current;
			const activeElement = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.activeElement;
			if (activeElement && ((_toastRef_current = toastRef.current) === null || _toastRef_current === void 0 ? void 0 : _toastRef_current.contains(activeElement))) focusedToastBeforeClose.current = true;
			closeProp();
		});
		const onStatusChange = useEventCallback((status) => {
			var _props_onStatusChange;
			return (_props_onStatusChange = props.onStatusChange) === null || _props_onStatusChange === void 0 ? void 0 : _props_onStatusChange.call(props, null, {
				status,
				...props
			});
		});
		const pause = useEventCallback(() => setRunning(false));
		const play = useEventCallback(() => {
			var _toastRef_current;
			if (imperativePauseRef.current) return;
			var _targetDocument_activeElement;
			const containsActive = !!((_toastRef_current = toastRef.current) === null || _toastRef_current === void 0 ? void 0 : _toastRef_current.contains((_targetDocument_activeElement = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.activeElement) !== null && _targetDocument_activeElement !== void 0 ? _targetDocument_activeElement : null));
			if (timerTimeout < 0) {
				setRunning(true);
				return;
			}
			if (!containsActive) setRunning(true);
		});
		react.useImperativeHandle(imperativeRef, () => ({
			focus: () => {
				if (!toastRef.current) return;
				toastRef.current.focus();
			},
			play: () => {
				imperativePauseRef.current = false;
				play();
			},
			pause: () => {
				imperativePauseRef.current = true;
				pause();
			}
		}));
		react.useEffect(() => {
			return () => onStatusChange("unmounted");
		}, [onStatusChange]);
		react.useEffect(() => {
			if (!targetDocument) return;
			if (pauseOnWindowBlur) {
				var _targetDocument_defaultView, _targetDocument_defaultView1;
				(_targetDocument_defaultView = targetDocument.defaultView) === null || _targetDocument_defaultView === void 0 || _targetDocument_defaultView.addEventListener("focus", play);
				(_targetDocument_defaultView1 = targetDocument.defaultView) === null || _targetDocument_defaultView1 === void 0 || _targetDocument_defaultView1.addEventListener("blur", pause);
				return () => {
					var _targetDocument_defaultView$1, _targetDocument_defaultView1$1;
					(_targetDocument_defaultView$1 = targetDocument.defaultView) === null || _targetDocument_defaultView$1 === void 0 || _targetDocument_defaultView$1.removeEventListener("focus", play);
					(_targetDocument_defaultView1$1 = targetDocument.defaultView) === null || _targetDocument_defaultView1$1 === void 0 || _targetDocument_defaultView1$1.removeEventListener("blur", pause);
				};
			}
		}, [
			targetDocument,
			pause,
			play,
			pauseOnWindowBlur
		]);
		const userRootSlot = data.root;
		const onMotionFinish = react.useCallback((_, { direction }) => {
			if (direction === "exit") remove();
			if (direction === "enter") {
				play();
				onStatusChange("visible");
			}
		}, [
			onStatusChange,
			play,
			remove
		]);
		const onMouseEnter = useEventCallback((e) => {
			var _userRootSlot_onMouseEnter;
			pause();
			userRootSlot === null || userRootSlot === void 0 || (_userRootSlot_onMouseEnter = userRootSlot.onMouseEnter) == null || _userRootSlot_onMouseEnter.call(userRootSlot, e);
		});
		const onMouseLeave = useEventCallback((e) => {
			var _userRootSlot_onMouseEnter;
			play();
			userRootSlot === null || userRootSlot === void 0 || (_userRootSlot_onMouseEnter = userRootSlot.onMouseEnter) == null || _userRootSlot_onMouseEnter.call(userRootSlot, e);
		});
		const { findFirstFocusable, findLastFocusable } = useFocusFinders();
		const onKeyDown = useEventCallback((e) => {
			var _userRootSlot_onKeyDown;
			if (e.key === Delete) {
				e.preventDefault();
				close();
			}
			if (e.key === Tab$1 && e.currentTarget === e.target) {
				e.preventDefault();
				if (e.shiftKey) {
					var _findLastFocusable;
					(_findLastFocusable = findLastFocusable(e.currentTarget)) === null || _findLastFocusable === void 0 || _findLastFocusable.focus();
				} else {
					var _findFirstFocusable;
					(_findFirstFocusable = findFirstFocusable(e.currentTarget)) === null || _findFirstFocusable === void 0 || _findFirstFocusable.focus();
				}
			}
			userRootSlot === null || userRootSlot === void 0 || (_userRootSlot_onKeyDown = userRootSlot.onKeyDown) == null || _userRootSlot_onKeyDown.call(userRootSlot, e);
		});
		react.useEffect(() => {
			var _toastRef_current;
			if (!visible) return;
			const politeness = desiredPoliteness !== null && desiredPoliteness !== void 0 ? desiredPoliteness : intentPolitenessMap[intent];
			var _toastRef_current_textContent;
			announce((_toastRef_current_textContent = (_toastRef_current = toastRef.current) === null || _toastRef_current === void 0 ? void 0 : _toastRef_current.textContent) !== null && _toastRef_current_textContent !== void 0 ? _toastRef_current_textContent : "", { politeness });
		}, [
			announce,
			desiredPoliteness,
			toastRef,
			visible,
			updateId,
			intent
		]);
		react.useEffect(() => {
			return () => {
				if (focusedToastBeforeClose.current) {
					focusedToastBeforeClose.current = false;
					tryRestoreFocus();
				}
			};
		}, [tryRestoreFocus]);
		return {
			components: {
				timer: Timer,
				root: "div"
			},
			timer: always({
				onTimeout: close,
				running,
				timeout: timerTimeout !== null && timerTimeout !== void 0 ? timerTimeout : -1
			}, { elementType: Timer }),
			root: always(getIntrinsicElementProps("div", {
				ref: useMergedRefs(ref, toastRef),
				children,
				tabIndex: 0,
				role: "listitem",
				"aria-labelledby": titleId,
				"aria-describedby": bodyId,
				...rest,
				...userRootSlot,
				...focusableGroupAttribute,
				onMouseEnter,
				onMouseLeave,
				onKeyDown
			}), { elementType: "div" }),
			timerTimeout,
			transitionTimeout: 0,
			running,
			visible,
			remove,
			close,
			onTransitionEntering: () => {},
			updateId,
			nodeRef: toastRef,
			intent,
			titleId,
			bodyId,
			onMotionFinish
		};
	};

//#endregion
//#region node_modules/@fluentui/react-toast/lib/components/ToastContainer/renderToastContainer.js
/**
	* Render the final JSX of ToastContainer
	*/ const renderToastContainer_unstable = (state, contextValues) => {
		const { onMotionFinish, visible, updateId } = state;
		assertSlots(state);
		return /* @__PURE__ */ jsx(ToastContainerContextProvider, {
			value: contextValues.toast,
			children: /* @__PURE__ */ jsx(CollapseDelayed, {
				appear: true,
				onMotionFinish,
				visible,
				unmountOnExit: true,
				children: /* @__PURE__ */ jsxs(state.root, { children: [state.root.children, /* @__PURE__ */ jsx(state.timer, {}, updateId)] })
			})
		});
	};

//#endregion
//#region node_modules/@fluentui/react-toast/lib/components/ToastContainer/useToastContainerStyles.styles.js
	const toastContainerClassNames = {
		root: "fui-ToastContainer",
		timer: "fui-ToastContainer__timer"
	};
	const useRootBaseClassName$7 = /* @__PURE__ */ __resetStyles("r98b696", null, [".r98b696{box-sizing:border-box;margin-top:16px;pointer-events:all;border-radius:var(--borderRadiusMedium);}", ".r98b696[data-fui-focus-visible]{outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}"]);
	/**
	* Apply styling to the ToastContainer slots based on the state
	*/
	const useToastContainerStyles_unstable = (state) => {
		"use no memo";
		const rootBaseClassName = useRootBaseClassName$7();
		state.root.className = mergeClasses(toastContainerClassNames.root, rootBaseClassName, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-toast/lib/components/ToastContainer/useToastContainerContextValues.js
	function useToastContainerContextValues_unstable(state) {
		const { close, intent, titleId, bodyId } = state;
		return { toast: react.useMemo(() => ({
			close,
			intent,
			titleId,
			bodyId
		}), [
			close,
			intent,
			titleId,
			bodyId
		]) };
	}

//#endregion
//#region node_modules/@fluentui/react-toast/lib/components/ToastContainer/ToastContainer.js
/**
	* ToastContainer component
	*/ const ToastContainer = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useToastContainer_unstable(props, ref);
		useToastContainerStyles_unstable(state);
		useCustomStyleHook("useToastContainerStyles_unstable")(state);
		return renderToastContainer_unstable(state, useToastContainerContextValues_unstable(state));
	});
	ToastContainer.displayName = "ToastContainer";

//#endregion
//#region node_modules/@fluentui/react-toast/lib/components/Toaster/useToasterFocusManagement.js
	const noop$3 = () => void 0;
	/**
	* @internal
	*/ function useToasterFocusManagement_unstable(pauseAllToasts, playAllToasts) {
		const { targetDocument } = useFluent();
		const cleanupListenersRef = react.useRef(noop$3);
		return react.useCallback((el) => {
			if (!el || !targetDocument) {
				cleanupListenersRef.current();
				cleanupListenersRef.current = noop$3;
				return;
			}
			const toastContainerWalker = targetDocument.createTreeWalker(el, NodeFilter.SHOW_ELEMENT, { acceptNode(node$1) {
				if (isHTMLElement(node$1) && node$1.classList.contains(toastContainerClassNames.root)) return NodeFilter.FILTER_ACCEPT;
				return NodeFilter.FILTER_SKIP;
			} });
			/**
			* FIXME: https://github.com/microsoft/tabster/issues/299
			* Toasts  should be arrow navigable and focus should be trapped in a stack of tasts
			* This is a temporary measure, Tabster does not have an API yet to enable mover arrow keys from within grouppers
			* Once tabster fully supports this use case, remove this hook
			*/ const keydownListener = (e) => {
				const { target, key } = e;
				if (!isHTMLElement(target)) return;
				if (key === ArrowDown) {
					toastContainerWalker.currentNode = target;
					let nextToastContainer = toastContainerWalker.nextNode();
					if (!nextToastContainer) {
						toastContainerWalker.currentNode = el;
						nextToastContainer = toastContainerWalker.nextNode();
					}
					if (isHTMLElement(nextToastContainer)) nextToastContainer.focus();
				}
				if (key === ArrowUp) {
					toastContainerWalker.currentNode = target;
					let prevToastContainer = toastContainerWalker.previousNode();
					if (prevToastContainer && prevToastContainer.contains(target)) prevToastContainer = toastContainerWalker.previousNode();
					if (!prevToastContainer) {
						toastContainerWalker.currentNode = el;
						prevToastContainer = toastContainerWalker.lastChild();
					}
					if (isHTMLElement(prevToastContainer)) prevToastContainer.focus();
				}
			};
			const focusInListener = (e) => {
				if (isHTMLElement(e.currentTarget) && !e.currentTarget.contains(isHTMLElement(e.relatedTarget) ? e.relatedTarget : null)) pauseAllToasts();
			};
			const focusOutListener = (e) => {
				if (isHTMLElement(e.currentTarget) && !e.currentTarget.contains(isHTMLElement(e.relatedTarget) ? e.relatedTarget : null)) playAllToasts();
			};
			el.addEventListener("keydown", keydownListener);
			el.addEventListener("focusin", focusInListener);
			el.addEventListener("focusout", focusOutListener);
			cleanupListenersRef.current = () => {
				el.removeEventListener("keydown", keydownListener);
				el.removeEventListener("focusin", focusInListener);
				el.removeEventListener("focusout", focusOutListener);
			};
		}, [
			targetDocument,
			pauseAllToasts,
			playAllToasts
		]);
	}

//#endregion
//#region node_modules/@fluentui/react-toast/lib/components/Toaster/useToastAnnounce.js
/**
	* Wraps an aria live announcement function.
	* Aria live announcements can be detrimental once the user is already navigating
	* multiple toasts. Once the user is focused inside the toaster, the announecments should be disabled.
	* @param announce
	* @returns A function to announce a toast and a ref to attach to the toaster element
	*/ function useToastAnnounce(announce) {
		const activeRef = react.useRef(true);
		const cleanupRef = react.useRef(() => void 0);
		return {
			announceToast: react.useCallback((message, options) => {
				if (activeRef.current) announce(message, options);
			}, [announce]),
			toasterRef: react.useCallback((el) => {
				if (!el) {
					cleanupRef.current();
					return;
				}
				const onFocusIn = (e) => {
					if (isHTMLElement(e.currentTarget) && e.currentTarget.contains(isHTMLElement(e.relatedTarget) ? e.relatedTarget : null)) return;
					activeRef.current = false;
				};
				const onFocusOut = (e) => {
					if (isHTMLElement(e.currentTarget) && e.currentTarget.contains(isHTMLElement(e.relatedTarget) ? e.relatedTarget : null)) return;
					activeRef.current = true;
				};
				el.addEventListener("focusin", onFocusIn);
				el.addEventListener("focusout", onFocusOut);
				cleanupRef.current = () => {
					el.removeEventListener("focusin", onFocusIn);
					el.removeEventListener("focusout", onFocusOut);
				};
			}, [])
		};
	}

//#endregion
//#region node_modules/@fluentui/react-toast/lib/components/Toaster/useToaster.js
/**
	* Create the state required to render Toaster.
	*
	* @param props - props from this instance of Toaster
	*/ const useToaster_unstable = (props) => {
		"use no memo";
		const { offset: offset$3, announce: announceProp, mountNode, inline = false, ...rest } = props;
		const announceRef = react.useRef(() => null);
		const { toastsToRender, isToastVisible, pauseAllToasts, playAllToasts, tryRestoreFocus, closeAllToasts } = useToaster(rest);
		const announce = react.useCallback((message, options) => announceRef.current(message, options), []);
		const { dir } = useFluent();
		const { onKeyDown: onKeyDownProp, ...rootProps } = always(getIntrinsicElementProps("div", rest), { elementType: "div" });
		const focusableGroupAttr = useFocusableGroup({
			tabBehavior: "limited-trap-focus",
			ignoreDefaultKeydown: { Escape: true }
		});
		const onKeyDown = useEventCallback((e) => {
			if (e.key === Escape) {
				e.preventDefault();
				closeAllToasts();
			}
			onKeyDownProp === null || onKeyDownProp === void 0 || onKeyDownProp(e);
		});
		const usePositionSlot = (toastPosition) => {
			var _toastsToRender_get;
			const focusManagementRef = useToasterFocusManagement_unstable(pauseAllToasts, playAllToasts);
			const { announceToast, toasterRef } = useToastAnnounce(announceProp !== null && announceProp !== void 0 ? announceProp : announce);
			return optional(toastsToRender.has(toastPosition) ? rootProps : null, {
				defaultProps: {
					ref: useMergedRefs(focusManagementRef, toasterRef),
					children: (_toastsToRender_get = toastsToRender.get(toastPosition)) === null || _toastsToRender_get === void 0 ? void 0 : _toastsToRender_get.map((toast) => /* @__PURE__ */ react.createElement(ToastContainer, {
						...toast,
						tryRestoreFocus,
						intent: toast.intent,
						announce: announceToast,
						key: toast.toastId,
						visible: isToastVisible(toast.toastId)
					}, toast.content)),
					onKeyDown,
					...focusableGroupAttr,
					"data-toaster-position": toastPosition,
					role: "list"
				},
				elementType: "div"
			});
		};
		return {
			dir,
			mountNode,
			components: {
				root: "div",
				bottomStart: "div",
				bottomEnd: "div",
				topStart: "div",
				topEnd: "div",
				top: "div",
				bottom: "div"
			},
			root: always(rootProps, { elementType: "div" }),
			bottomStart: usePositionSlot(TOAST_POSITIONS.bottomStart),
			bottomEnd: usePositionSlot(TOAST_POSITIONS.bottomEnd),
			topStart: usePositionSlot(TOAST_POSITIONS.topStart),
			topEnd: usePositionSlot(TOAST_POSITIONS.topEnd),
			top: usePositionSlot(TOAST_POSITIONS.top),
			bottom: usePositionSlot(TOAST_POSITIONS.bottom),
			announceRef,
			offset: offset$3,
			announce: announceProp !== null && announceProp !== void 0 ? announceProp : announce,
			renderAriaLive: !announceProp,
			inline
		};
	};

//#endregion
//#region node_modules/@fluentui/react-toast/lib/components/AriaLive/useAriaLive.js
/** The duration the message needs to be in present in DOM for screen readers to register a change and announce */ const MESSAGE_DURATION = 500;
	/**
	* Create the state required to render AriaLive.
	*
	* The returned state can be modified with hooks such as useAriaLiveStyles_unstable,
	* before being passed to renderAriaLive_unstable.
	*
	* @param props - props from this instance of AriaLive
	*/ const useAriaLive_unstable = (props) => {
		const [currentMessage, setCurrentMessage] = react.useState(void 0);
		const order = react.useRef(0);
		const [messageQueue] = react.useState(() => createPriorityQueue$1((a, b) => {
			if (a.politeness === b.politeness) return a.createdAt - b.createdAt;
			return a.politeness === "assertive" ? -1 : 1;
		}));
		const announce = useEventCallback((message, options) => {
			const { politeness } = options;
			if (message === (currentMessage === null || currentMessage === void 0 ? void 0 : currentMessage.message)) return;
			const liveMessage = {
				message,
				politeness,
				createdAt: order.current++
			};
			if (!currentMessage) setCurrentMessage(liveMessage);
			else messageQueue.enqueue(liveMessage);
		});
		const [setMessageTimeout, clearMessageTimeout] = useTimeout();
		react.useEffect(() => {
			setMessageTimeout(() => {
				if (messageQueue.peek()) setCurrentMessage(messageQueue.dequeue());
				else setCurrentMessage(void 0);
			}, MESSAGE_DURATION);
			return () => clearMessageTimeout();
		}, [
			currentMessage,
			messageQueue,
			setMessageTimeout,
			clearMessageTimeout
		]);
		react.useImperativeHandle(props.announceRef, () => announce);
		const politeMessage = (currentMessage === null || currentMessage === void 0 ? void 0 : currentMessage.politeness) === "polite" ? currentMessage.message : void 0;
		const assertiveMessage = (currentMessage === null || currentMessage === void 0 ? void 0 : currentMessage.politeness) === "assertive" ? currentMessage.message : void 0;
		return {
			components: {
				assertive: "div",
				polite: "div"
			},
			assertive: always(props.assertive, {
				defaultProps: {
					"aria-live": "assertive",
					children: assertiveMessage
				},
				elementType: "div"
			}),
			polite: always(props.polite, {
				defaultProps: {
					"aria-live": "polite",
					children: politeMessage
				},
				elementType: "div"
			})
		};
	};

//#endregion
//#region node_modules/@fluentui/react-toast/lib/components/AriaLive/renderAriaLive.js
/**
	* Render the final JSX of AriaLive
	*/ const renderAriaLive_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(react.Fragment, { children: [/* @__PURE__ */ jsx(state.assertive, {}), /* @__PURE__ */ jsx(state.polite, {})] });
	};

//#endregion
//#region node_modules/@fluentui/react-toast/lib/components/AriaLive/useAriaLiveStyles.styles.js
	const ariaLiveClassNames = {
		assertive: "fui-AriaLive__assertive",
		polite: "fui-AriaLive__polite"
	};
	/**
	* Styles for the root slot
	*/
	const useResetStyles$2 = /* @__PURE__ */ __resetStyles("rrd10u0", null, [".rrd10u0{clip:rect(0px, 0px, 0px, 0px);height:1px;margin:-1px;overflow:hidden;padding:0px;width:1px;position:absolute;}"]);
	/**
	* Apply styling to the AriaLive slots based on the state
	*/
	const useAriaLiveStyles_unstable = (state) => {
		"use no memo";
		const visuallyHidden = useResetStyles$2();
		state.assertive.className = mergeClasses(visuallyHidden, ariaLiveClassNames.assertive, state.assertive.className);
		state.polite.className = mergeClasses(visuallyHidden, ariaLiveClassNames.polite, state.polite.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-toast/lib/components/AriaLive/AriaLive.js
/**
	* A component that manages aria live announcements imperatively
	*/ const AriaLive = (props) => {
		const state = useAriaLive_unstable(props);
		useAriaLiveStyles_unstable(state);
		return renderAriaLive_unstable(state);
	};
	AriaLive.displayName = "AriaLive";

//#endregion
//#region node_modules/@fluentui/react-toast/lib/components/Toaster/renderToaster.js
/**
	* Render the final JSX of Toaster
	*/ const renderToaster_unstable = (state) => {
		const { announceRef, renderAriaLive, inline, mountNode } = state;
		assertSlots(state);
		const hasToasts = !!state.bottomStart || !!state.bottomEnd || !!state.topStart || !!state.topEnd || !!state.top || !!state.bottom;
		const ariaLive = renderAriaLive ? /* @__PURE__ */ jsx(AriaLive, { announceRef }) : null;
		const positionSlots = /* @__PURE__ */ jsxs(react.Fragment, { children: [
			state.bottom ? /* @__PURE__ */ jsx(state.bottom, {}) : null,
			state.bottomStart ? /* @__PURE__ */ jsx(state.bottomStart, {}) : null,
			state.bottomEnd ? /* @__PURE__ */ jsx(state.bottomEnd, {}) : null,
			state.topStart ? /* @__PURE__ */ jsx(state.topStart, {}) : null,
			state.topEnd ? /* @__PURE__ */ jsx(state.topEnd, {}) : null,
			state.top ? /* @__PURE__ */ jsx(state.top, {}) : null
		] });
		if (inline) return /* @__PURE__ */ jsxs(react.Fragment, { children: [ariaLive, hasToasts ? positionSlots : null] });
		return /* @__PURE__ */ jsxs(react.Fragment, { children: [ariaLive, hasToasts ? /* @__PURE__ */ jsx(Portal, {
			mountNode,
			children: positionSlots
		}) : null] });
	};

//#endregion
//#region node_modules/@fluentui/react-toast/lib/components/Toaster/useToasterStyles.styles.js
	const toasterClassNames = { root: "fui-Toaster" };
	/**
	* Styles for the root slot
	*/
	const useRootBaseClassName$6 = /* @__PURE__ */ __resetStyles("r3hfdjz", null, [".r3hfdjz{position:fixed;width:292px;pointer-events:none;}"]);
	const useToasterStyles = /* @__PURE__ */ __styles({ inline: { qhf8xq: "f1euv43f" } }, { d: [".f1euv43f{position:absolute;}"] });
	/**
	* Apply styling to the Toaster slots based on the state
	*/
	const useToasterStyles_unstable = (state) => {
		"use no memo";
		const rootBaseClassName = useRootBaseClassName$6();
		const styles = useToasterStyles();
		const className = mergeClasses(toasterClassNames.root, rootBaseClassName, state.inline && styles.inline, state.root.className);
		if (state.bottomStart) {
			var _state_bottomStart;
			state.bottomStart.className = className;
			var _style;
			(_style = (_state_bottomStart = state.bottomStart).style) !== null && _style !== void 0 || (_state_bottomStart.style = {});
			Object.assign(state.bottomStart.style, getPositionStyles(TOAST_POSITIONS.bottomStart, state.dir, state.offset));
		}
		if (state.bottomEnd) {
			var _state_bottomEnd;
			state.bottomEnd.className = className;
			var _style1;
			(_style1 = (_state_bottomEnd = state.bottomEnd).style) !== null && _style1 !== void 0 || (_state_bottomEnd.style = {});
			Object.assign(state.bottomEnd.style, getPositionStyles(TOAST_POSITIONS.bottomEnd, state.dir, state.offset));
		}
		if (state.topStart) {
			var _state_topStart;
			state.topStart.className = className;
			var _style2;
			(_style2 = (_state_topStart = state.topStart).style) !== null && _style2 !== void 0 || (_state_topStart.style = {});
			Object.assign(state.topStart.style, getPositionStyles(TOAST_POSITIONS.topStart, state.dir, state.offset));
		}
		if (state.topEnd) {
			var _state_topEnd;
			state.topEnd.className = className;
			var _style3;
			(_style3 = (_state_topEnd = state.topEnd).style) !== null && _style3 !== void 0 || (_state_topEnd.style = {});
			Object.assign(state.topEnd.style, getPositionStyles(TOAST_POSITIONS.topEnd, state.dir, state.offset));
		}
		if (state.top) {
			var _state_top;
			state.top.className = className;
			var _style4;
			(_style4 = (_state_top = state.top).style) !== null && _style4 !== void 0 || (_state_top.style = {});
			Object.assign(state.top.style, getPositionStyles(TOAST_POSITIONS.top, state.dir, state.offset));
		}
		if (state.bottom) {
			var _state_bottom;
			state.bottom.className = className;
			var _style5;
			(_style5 = (_state_bottom = state.bottom).style) !== null && _style5 !== void 0 || (_state_bottom.style = {});
			Object.assign(state.bottom.style, getPositionStyles(TOAST_POSITIONS.bottom, state.dir, state.offset));
		}
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-toast/lib/components/Toaster/Toaster.js
/**
	* Toaster component - renders a collection of toasts dispatched imperatively
	*/ const Toaster = (props) => {
		const state = useToaster_unstable(props);
		useToasterStyles_unstable(state);
		useCustomStyleHook("useToasterStyles_unstable")(state);
		return renderToaster_unstable(state);
	};
	Toaster.displayName = "Toaster";

//#endregion
//#region node_modules/@fluentui/react-toast/lib/components/Toast/useToast.js
/**
	* Create the state required to render Toast.
	*
	* The returned state can be modified with hooks such as useToastStyles_unstable,
	* before being passed to renderToast_unstable.
	*
	* @param props - props from this instance of Toast
	* @param ref - reference to root HTMLElement of Toast
	*/ const useToast_unstable = (props, ref) => {
		const { intent } = useToastContainerContext();
		return {
			components: { root: "div" },
			root: always(getIntrinsicElementProps("div", {
				ref,
				...props
			}), { elementType: "div" }),
			backgroundAppearance: props.appearance,
			intent
		};
	};

//#endregion
//#region node_modules/@fluentui/react-toast/lib/components/Toast/renderToast.js
/**
	* Render the final JSX of Toast
	*/ const renderToast_unstable = (state, contextValues) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(BackgroundAppearanceProvider, {
			value: contextValues.backgroundAppearance,
			children: /* @__PURE__ */ jsx(state.root, {})
		});
	};

//#endregion
//#region node_modules/@fluentui/react-toast/lib/components/Toast/useToastStyles.styles.js
	const toastClassNames = { root: "fui-Toast" };
	const useRootBaseClassName$5 = /* @__PURE__ */ __resetStyles("rhf7k35", null, [".rhf7k35{display:grid;grid-template-columns:auto 1fr auto;padding:12px;border-radius:var(--borderRadiusMedium);border:1px solid var(--colorTransparentStroke);box-shadow:var(--shadow8);font-size:var(--fontSizeBase300);line-height:20px;font-weight:var(--fontWeightSemibold);color:var(--colorNeutralForeground1);background-color:var(--colorNeutralBackground1);}"]);
	const useStyles$56 = /* @__PURE__ */ __styles({ inverted: {
		sj55zd: "f1w7i9ko",
		De3pzq: "f5pduvr"
	} }, { d: [".f1w7i9ko{color:var(--colorNeutralForegroundInverted2);}", ".f5pduvr{background-color:var(--colorNeutralBackgroundInverted);}"] });
	/**
	* Apply styling to the Toast slots based on the state
	*/
	const useToastStyles_unstable = (state) => {
		"use no memo";
		const rootBaseClassName = useRootBaseClassName$5();
		const styles = useStyles$56();
		state.root.className = mergeClasses(toastClassNames.root, rootBaseClassName, state.backgroundAppearance === "inverted" && styles.inverted, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-toast/lib/components/Toast/useToastContextValues.js
	function useToastContextValues_unstable(state) {
		const { backgroundAppearance } = state;
		return { backgroundAppearance };
	}

//#endregion
//#region node_modules/@fluentui/react-toast/lib/components/Toast/Toast.js
/**
	* Toast component
	*/ const Toast = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useToast_unstable(props, ref);
		useToastStyles_unstable(state);
		useCustomStyleHook("useToastStyles_unstable")(state);
		return renderToast_unstable(state, useToastContextValues_unstable(state));
	});
	Toast.displayName = "Toast";

//#endregion
//#region node_modules/@fluentui/react-toast/lib/components/ToastTitle/useToastTitle.js
/**
	* Create the state required to render ToastTitle.
	*
	* The returned state can be modified with hooks such as useToastTitleStyles_unstable,
	* before being passed to renderToastTitle_unstable.
	*
	* @param props - props from this instance of ToastTitle
	* @param ref - reference to root HTMLElement of ToastTitle
	*/ const useToastTitle_unstable = (props, ref) => {
		const { intent, titleId } = useToastContainerContext();
		const backgroundAppearance = useBackgroundAppearance();
		/** Determine the role and media to render based on the intent */ let defaultIcon;
		switch (intent) {
			case "success":
				defaultIcon = /* @__PURE__ */ react.createElement(CheckmarkCircleFilled, null);
				break;
			case "error":
				defaultIcon = /* @__PURE__ */ react.createElement(DismissCircleFilled, null);
				break;
			case "warning":
				defaultIcon = /* @__PURE__ */ react.createElement(WarningFilled, null);
				break;
			case "info":
				defaultIcon = /* @__PURE__ */ react.createElement(InfoFilled, null);
				break;
		}
		return {
			action: optional(props.action, { elementType: "div" }),
			components: {
				root: "div",
				media: "div",
				action: "div"
			},
			media: optional(props.media, {
				renderByDefault: !!intent,
				defaultProps: { children: defaultIcon },
				elementType: "div"
			}),
			root: always(getIntrinsicElementProps("div", {
				ref,
				children: props.children,
				id: titleId,
				...props
			}), { elementType: "div" }),
			intent,
			backgroundAppearance
		};
	};

//#endregion
//#region node_modules/@fluentui/react-toast/lib/components/ToastTitle/renderToastTitle.js
/**
	* Render the final JSX of ToastTitle
	*/ const renderToastTitle_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(react.Fragment, { children: [
			state.media ? /* @__PURE__ */ jsx(state.media, {}) : null,
			/* @__PURE__ */ jsx(state.root, {}),
			state.action ? /* @__PURE__ */ jsx(state.action, {}) : null
		] });
	};

//#endregion
//#region node_modules/@fluentui/react-toast/lib/components/ToastTitle/useToastTitleStyles.styles.js
	const toastTitleClassNames = {
		root: "fui-ToastTitle",
		media: "fui-ToastTitle__media",
		action: "fui-ToastTitle__action"
	};
	const useRootBaseClassName$4 = /* @__PURE__ */ __resetStyles("rdjap1e", null, [".rdjap1e{display:flex;grid-column-end:3;color:var(--colorNeutralForeground1);word-break:break-word;}"]);
	const useMediaBaseClassName = /* @__PURE__ */ __resetStyles("r8x5mrd", "r1soj19y", [".r8x5mrd{display:flex;padding-top:2px;grid-column-end:2;padding-right:8px;font-size:16px;color:var(--colorNeutralForeground1);}", ".r1soj19y{display:flex;padding-top:2px;grid-column-end:2;padding-left:8px;font-size:16px;color:var(--colorNeutralForeground1);}"]);
	const useActionBaseClassName = /* @__PURE__ */ __resetStyles("r2j19ip", "rjfozdo", [".r2j19ip{display:flex;align-items:start;padding-left:12px;grid-column-end:-1;color:var(--colorBrandForeground1);}", ".rjfozdo{display:flex;align-items:start;padding-right:12px;grid-column-end:-1;color:var(--colorBrandForeground1);}"]);
	const useInvertedStyles$1 = /* @__PURE__ */ __styles({
		root: { sj55zd: "f1w7i9ko" },
		action: { sj55zd: "f1qz2gb0" },
		media: { sj55zd: "fqpbvvt" }
	}, { d: [
		".f1w7i9ko{color:var(--colorNeutralForegroundInverted2);}",
		".f1qz2gb0{color:var(--colorBrandForegroundInverted);}",
		".fqpbvvt{color:var(--colorNeutralForegroundInverted);}"
	] });
	const useIntentIconStyles = /* @__PURE__ */ __styles({
		success: { sj55zd: "f36rra6" },
		error: { sj55zd: "f1ca9wz" },
		warning: { sj55zd: "f13isgzr" },
		info: { sj55zd: "fkfq4zb" }
	}, { d: [
		".f36rra6{color:var(--colorStatusSuccessForeground1);}",
		".f1ca9wz{color:var(--colorStatusDangerForeground1);}",
		".f13isgzr{color:var(--colorStatusWarningForeground1);}",
		".fkfq4zb{color:var(--colorNeutralForeground2);}"
	] });
	const useIntentIconStylesInverted = /* @__PURE__ */ __styles({
		success: { sj55zd: "ff3wk4x" },
		error: { sj55zd: "fbq2gqr" },
		warning: { sj55zd: "fx6hq1t" },
		info: { sj55zd: "f1w7i9ko" }
	}, { d: [
		".ff3wk4x{color:var(--colorStatusSuccessForegroundInverted);}",
		".fbq2gqr{color:var(--colorStatusDangerForegroundInverted);}",
		".fx6hq1t{color:var(--colorStatusWarningForegroundInverted);}",
		".f1w7i9ko{color:var(--colorNeutralForegroundInverted2);}"
	] });
	/**
	* Apply styling to the ToastTitle slots based on the state
	*/
	const useToastTitleStyles_unstable = (state) => {
		"use no memo";
		const rootBaseClassName = useRootBaseClassName$4();
		const actionBaseClassName = useActionBaseClassName();
		const mediaBaseClassName = useMediaBaseClassName();
		const intentIconStyles = useIntentIconStyles();
		const intentIconStylesInverted = useIntentIconStylesInverted();
		const { intent } = state;
		const invertedStyles = useInvertedStyles$1();
		state.root.className = mergeClasses(toastTitleClassNames.root, rootBaseClassName, state.backgroundAppearance === "inverted" && invertedStyles.root, state.root.className);
		if (state.media) state.media.className = mergeClasses(toastTitleClassNames.media, mediaBaseClassName, state.backgroundAppearance === "inverted" && invertedStyles.media, intent && intentIconStyles[intent], intent && state.backgroundAppearance === "inverted" && intentIconStylesInverted[intent], state.media.className);
		if (state.action) state.action.className = mergeClasses(toastTitleClassNames.action, actionBaseClassName, state.backgroundAppearance === "inverted" && invertedStyles.action, state.action.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-toast/lib/components/ToastTitle/ToastTitle.js
/**
	* ToastTitle component
	*/ const ToastTitle = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useToastTitle_unstable(props, ref);
		useToastTitleStyles_unstable(state);
		useCustomStyleHook("useToastTitleStyles_unstable")(state);
		return renderToastTitle_unstable(state);
	});
	ToastTitle.displayName = "ToastTitle";

//#endregion
//#region node_modules/@fluentui/react-toast/lib/components/ToastBody/useToastBody.js
/**
	* Create the state required to render ToastBody.
	*
	* The returned state can be modified with hooks such as useToastBodyStyles_unstable,
	* before being passed to renderToastBody_unstable.
	*
	* @param props - props from this instance of ToastBody
	* @param ref - reference to root HTMLElement of ToastBody
	*/ const useToastBody_unstable = (props, ref) => {
		const backgroundAppearance = useBackgroundAppearance();
		const { bodyId } = useToastContainerContext();
		return {
			components: {
				root: "div",
				subtitle: "div"
			},
			subtitle: optional(props.subtitle, { elementType: "div" }),
			root: always(getIntrinsicElementProps("div", {
				ref,
				id: bodyId,
				...props
			}), { elementType: "div" }),
			backgroundAppearance
		};
	};

//#endregion
//#region node_modules/@fluentui/react-toast/lib/components/ToastBody/renderToastBody.js
/**
	* Render the final JSX of ToastBody
	*/ const renderToastBody_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(react.Fragment, { children: [/* @__PURE__ */ jsx(state.root, {}), state.subtitle ? /* @__PURE__ */ jsx(state.subtitle, {}) : null] });
	};

//#endregion
//#region node_modules/@fluentui/react-toast/lib/components/ToastBody/useToastBodyStyles.styles.js
	const toastBodyClassNames = {
		root: "fui-ToastBody",
		subtitle: "fui-ToastBody__subtitle"
	};
	const useRootBaseClassName$3 = /* @__PURE__ */ __resetStyles("r1u44l4o", null, [".r1u44l4o{grid-column-start:2;grid-column-end:3;padding-top:6px;font-size:var(--fontSizeBase300);line-height:var(--lineHeightBase300);font-weight:var(--fontWeightRegular);color:var(--colorNeutralForeground1);word-break:break-word;}"]);
	const useSubtitleBaseClassName = /* @__PURE__ */ __resetStyles("rzjw1xk", null, [".rzjw1xk{padding-top:4px;grid-column-start:2;grid-column-end:3;font-size:var(--fontSizeBase200);line-height:var(--fontSizeBase200);font-weight:var(--fontWeightRegular);color:var(--colorNeutralForeground2);}"]);
	const useInvertedStyles = /* @__PURE__ */ __styles({
		root: { sj55zd: "f1w7i9ko" },
		subtitle: { sj55zd: "f1w7i9ko" }
	}, { d: [".f1w7i9ko{color:var(--colorNeutralForegroundInverted2);}"] });
	/**
	* Apply styling to the ToastBody slots based on the state
	*/
	const useToastBodyStyles_unstable = (state) => {
		"use no memo";
		const rootBaseClassName = useRootBaseClassName$3();
		const subtitleBaseClassName = useSubtitleBaseClassName();
		const invertedStyles = useInvertedStyles();
		state.root.className = mergeClasses(toastBodyClassNames.root, rootBaseClassName, state.backgroundAppearance === "inverted" && invertedStyles.root, state.root.className);
		if (state.subtitle) state.subtitle.className = mergeClasses(toastBodyClassNames.subtitle, subtitleBaseClassName, state.backgroundAppearance === "inverted" && invertedStyles.subtitle, state.subtitle.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-toast/lib/components/ToastBody/ToastBody.js
/**
	* ToastBody component
	*/ const ToastBody = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useToastBody_unstable(props, ref);
		useToastBodyStyles_unstable(state);
		useCustomStyleHook("useToastBodyStyles_unstable")(state);
		return renderToastBody_unstable(state);
	});
	ToastBody.displayName = "ToastBody";

//#endregion
//#region node_modules/@fluentui/react-toast/lib/components/ToastFooter/useToastFooter.js
/**
	* Create the state required to render ToastFooter.
	*
	* The returned state can be modified with hooks such as useToastFooterStyles_unstable,
	* before being passed to renderToastFooter_unstable.
	*
	* @param props - props from this instance of ToastFooter
	* @param ref - reference to root HTMLElement of ToastFooter
	*/ const useToastFooter_unstable = (props, ref) => {
		return {
			components: { root: "div" },
			root: always(getIntrinsicElementProps("div", {
				ref,
				...props
			}), { elementType: "div" })
		};
	};

//#endregion
//#region node_modules/@fluentui/react-toast/lib/components/ToastFooter/renderToastFooter.js
/**
	* Render the final JSX of ToastFooter
	*/ const renderToastFooter_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, {});
	};

//#endregion
//#region node_modules/@fluentui/react-toast/lib/components/ToastFooter/useToastFooterStyles.styles.js
	const toastFooterClassNames = { root: "fui-ToastFooter" };
	/**
	* Styles for the root slot
	*/
	const useRootBaseClassName$2 = /* @__PURE__ */ __resetStyles("r56x6h2", null, [".r56x6h2{padding-top:16px;grid-column-start:2;grid-column-end:3;display:flex;align-items:center;gap:14px;}"]);
	/**
	* Apply styling to the ToastFooter slots based on the state
	*/
	const useToastFooterStyles_unstable = (state) => {
		"use no memo";
		const rootBaseClassName = useRootBaseClassName$2();
		state.root.className = mergeClasses(toastFooterClassNames.root, rootBaseClassName, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-toast/lib/components/ToastFooter/ToastFooter.js
/**
	* ToastFooter component
	*/ const ToastFooter = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useToastFooter_unstable(props, ref);
		useToastFooterStyles_unstable(state);
		useCustomStyleHook("useToastFooterStyles_unstable")(state);
		return renderToastFooter_unstable(state);
	});
	ToastFooter.displayName = "ToastFooter";

//#endregion
//#region node_modules/@fluentui/react-tree/lib/utils/ImmutableSet.js
	const internalSetSymbol = Symbol("#internalSet");
	let _internalSetSymbol = internalSetSymbol;
	/**
	* @public
	*
	* Small immutable wrapper around the native Set implementation.
	* Every operation that would modify the set returns a new copy instance.
	*/ var ImmutableSet = class ImmutableSet {
		static dangerouslyGetInternalSet(set) {
			return set[internalSetSymbol];
		}
		static copy(immutableSet) {
			return new ImmutableSet(new Set(immutableSet[internalSetSymbol]));
		}
		/**
		* Creates a new {@link ImmutableSet} from an iterable.
		* If the iterable is undefined, {@link ImmutableSet.empty} will be returned.
		* If the iterable is already an {@link ImmutableSet}, it will be returned as is no copy will be made.
		*/ static from(iterable) {
			if (iterable === void 0) return this.empty;
			if (iterable instanceof this) return iterable;
			return new this(new Set(iterable));
		}
		static [Symbol.hasInstance](instance) {
			return Boolean(typeof instance === "object" && instance && internalSetSymbol in instance);
		}
		add(value) {
			if (this.has(value)) return this;
			const copy$1 = ImmutableSet.copy(this);
			copy$1[internalSetSymbol].add(value);
			return copy$1;
		}
		delete(value) {
			if (!this.has(value)) return this;
			const copy$1 = ImmutableSet.copy(this);
			copy$1[internalSetSymbol].delete(value);
			return copy$1;
		}
		has(value) {
			return this[internalSetSymbol].has(value);
		}
		[Symbol.iterator]() {
			return this[internalSetSymbol].values();
		}
		/**
		* Do not use this constructor directly, use {@link ImmutableSet.from} instead.
		* {@link ImmutableSet.from} handles instance verification (which might be problematic on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof#instanceof_and_multiple_realms | multiple realms}),
		* avoid unnecessary copies, supports iterables and ensures that the internal set is never exposed.
		*
		*  _By using this constructor directly, you might end up with a mutable set, as it is not guaranteed that the internal set is not exposed._ 
		*/ constructor(internalSet) {
			_define_property(this, "size", void 0);
			_define_property(this, _internalSetSymbol, void 0);
			this[internalSetSymbol] = internalSet;
			this.size = this[internalSetSymbol].size;
		}
	};
	_define_property(ImmutableSet, "empty", new ImmutableSet(/* @__PURE__ */ new Set()));

//#endregion
//#region node_modules/@fluentui/react-tree/lib/hooks/useControllableOpenItems.js
/**
	* @internal
	*/ function useControllableOpenItems(props) {
		return useControllableState({
			state: react.useMemo(() => props.openItems && ImmutableSet.from(props.openItems), [props.openItems]),
			defaultState: props.defaultOpenItems && (() => ImmutableSet.from(props.defaultOpenItems)),
			initialState: ImmutableSet.empty
		});
	}
	/**
	* @internal
	*/ function createNextOpenItems(data, previousOpenItems) {
		return data.open ? previousOpenItems.add(data.value) : previousOpenItems.delete(data.value);
	}

//#endregion
//#region node_modules/@fluentui/react-tree/lib/utils/ImmutableMap.js
	const internalMapSymbol = Symbol("#internalMap");
	let _internalMapSymbol = internalMapSymbol;
	var ImmutableMap = class ImmutableMap {
		static dangerouslyGetInternalMap(immutableMap) {
			return immutableMap[internalMapSymbol];
		}
		static copy(immutableMap) {
			return this.from(immutableMap[internalMapSymbol]);
		}
		static from(iterable, mapFn) {
			if (iterable === void 0) return this.empty;
			if (!mapFn) {
				if (iterable instanceof this) return iterable;
				const iterableAsTuple = iterable;
				return new this(new Map(iterableAsTuple));
			}
			const map = /* @__PURE__ */ new Map();
			for (const value of iterable) map.set(...mapFn(value));
			return new this(map);
		}
		static [Symbol.hasInstance](instance) {
			return Boolean(typeof instance === "object" && instance && internalMapSymbol in instance);
		}
		delete(key) {
			if (!this.has(key)) return this;
			const copy$1 = ImmutableMap.copy(this);
			copy$1[internalMapSymbol].delete(key);
			return copy$1;
		}
		get(key) {
			return this[internalMapSymbol].get(key);
		}
		has(key) {
			return this[internalMapSymbol].has(key);
		}
		set(key, value) {
			if (this.get(key) === value) return this;
			const copy$1 = ImmutableMap.copy(this);
			copy$1[internalMapSymbol].set(key, value);
			return copy$1;
		}
		[Symbol.iterator]() {
			return this[internalMapSymbol].entries();
		}
		/**
		* Do not use this constructor directly, use {@link ImmutableMap.from} instead.
		* {@link ImmutableMap.from} handles instance verification (which might be problematic on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof#instanceof_and_multiple_realms | multiple realms}),
		* avoid unnecessary copies, supports iterables and ensures that the internal map is never exposed.
		*
		*  _By using this constructor directly, you might end up with a mutable map, as it is not guaranteed that the internal map is not exposed._ 
		*/ constructor(internalMap) {
			_define_property(this, "size", void 0);
			_define_property(this, _internalMapSymbol, void 0);
			this[internalMapSymbol] = internalMap;
			this.size = this[internalMapSymbol].size;
		}
	};
	_define_property(ImmutableMap, "empty", new ImmutableMap(/* @__PURE__ */ new Map()));

//#endregion
//#region node_modules/@fluentui/react-tree/lib/utils/createCheckedItems.js
	const tuplifyCheckedItem = (value) => Array.isArray(value) ? value : [value, true];
	const createCheckedItems = (iterable) => ImmutableMap.from(iterable, tuplifyCheckedItem);

//#endregion
//#region node_modules/@fluentui/react-tree/lib/components/Tree/useNestedControllableCheckedItems.js
	function useNestedCheckedItems(props) {
		return react.useMemo(() => createCheckedItems(props.checkedItems), [props.checkedItems]);
	}
	function createNextNestedCheckedItems(data, previousCheckedItems) {
		if (data.selectionMode === "single") return ImmutableMap.from([[data.value, data.checked]]);
		if (data.selectionMode === "multiselect") return previousCheckedItems.set(data.value, data.checked);
		return previousCheckedItems;
	}

//#endregion
//#region node_modules/@fluentui/react-tree/lib/contexts/subtreeContext.js
/**
	* @internal
	*/ const defaultSubTreeContextValue = {
		level: 0,
		contextType: "subtree"
	};
	/**
	* @internal
	*/ const SubtreeContext = react.createContext(void 0);
	const useSubtreeContext_unstable = () => {
		var _React_useContext;
		return (_React_useContext = react.useContext(SubtreeContext)) !== null && _React_useContext !== void 0 ? _React_useContext : defaultSubTreeContextValue;
	};

//#endregion
//#region node_modules/@fluentui/react-tree/lib/utils/tokens.js
	const treeItemLevelToken = "--fluent-TreeItem--level";
	const treeAvatarSize = {
		medium: 32,
		small: 24
	};
	const treeDataTypes = {
		ArrowLeft,
		ArrowRight,
		Enter,
		Click: "Click",
		ExpandIconClick: "ExpandIconClick",
		End,
		Home,
		ArrowUp,
		ArrowDown,
		TypeAhead: "TypeAhead",
		Change: "Change"
	};

//#endregion
//#region node_modules/@fluentui/react-tree/lib/hooks/useRootTree.js
/**
	* Create the state required to render the root level tree.
	*
	* @param props - props from this instance of tree
	* @param ref - reference to root HTMLElement of tree
	*/ function useRootTree(props, ref) {
		warnIfNoProperPropsRootTree(props);
		const { appearance = "subtle", size: size$2 = "medium", selectionMode = "none" } = props;
		const openItems = react.useMemo(() => ImmutableSet.from(props.openItems), [props.openItems]);
		const checkedItems = react.useMemo(() => createCheckedItems(props.checkedItems), [props.checkedItems]);
		const requestOpenChange = (request) => {
			var _props_onOpenChange;
			(_props_onOpenChange = props.onOpenChange) === null || _props_onOpenChange === void 0 || _props_onOpenChange.call(props, request.event, {
				...request,
				openItems: ImmutableSet.dangerouslyGetInternalSet(createNextOpenItems(request, openItems))
			});
		};
		const requestCheckedChange = (request) => {
			var _props_onCheckedChange;
			if (selectionMode === "none") return;
			(_props_onCheckedChange = props.onCheckedChange) === null || _props_onCheckedChange === void 0 || _props_onCheckedChange.call(props, request.event, {
				...request,
				selectionMode,
				checkedItems: ImmutableMap.dangerouslyGetInternalMap(checkedItems)
			});
		};
		const requestNavigation = (request) => {
			var _props_onNavigation;
			let isScrollPrevented = false;
			(_props_onNavigation = props.onNavigation) === null || _props_onNavigation === void 0 || _props_onNavigation.call(props, request.event, {
				...request,
				preventScroll: () => {
					isScrollPrevented = true;
				},
				isScrollPrevented: () => isScrollPrevented
			});
			switch (request.type) {
				case treeDataTypes.ArrowDown:
				case treeDataTypes.ArrowUp:
				case treeDataTypes.Home:
				case treeDataTypes.End: request.event.preventDefault();
			}
		};
		const requestTreeResponse = useEventCallback((request) => {
			switch (request.requestType) {
				case "navigate": return requestNavigation(request);
				case "open": return requestOpenChange(request);
				case "selection": return requestCheckedChange(request);
			}
		});
		var _props_navigationMode;
		return {
			components: {
				root: "div",
				collapseMotion: Collapse
			},
			contextType: "root",
			selectionMode,
			navigationMode: (_props_navigationMode = props.navigationMode) !== null && _props_navigationMode !== void 0 ? _props_navigationMode : "tree",
			open: true,
			appearance,
			size: size$2,
			level: 1,
			openItems,
			checkedItems,
			requestTreeResponse,
			forceUpdateRovingTabIndex: () => {},
			root: always(getIntrinsicElementProps("div", {
				ref,
				role: "tree",
				"aria-multiselectable": selectionMode === "multiselect" ? true : void 0,
				...props
			}), { elementType: "div" }),
			collapseMotion: void 0
		};
	}
	function warnIfNoProperPropsRootTree(props) {
		if (!props["aria-label"] && !props["aria-labelledby"]) console.warn(`@fluentui/react-tree [useRootTree]:
Tree must have either a \`aria-label\` or \`aria-labelledby\` property defined`);
	}

//#endregion
//#region node_modules/@fluentui/react-tree/lib/contexts/treeContext.js
/**
	* @internal
	*/ const defaultTreeContextValue = {
		level: 0,
		contextType: "root",
		treeType: "nested",
		selectionMode: "none",
		openItems: ImmutableSet.empty,
		checkedItems: ImmutableMap.empty,
		requestTreeResponse: noop$2,
		forceUpdateRovingTabIndex: noop$2,
		appearance: "subtle",
		size: "medium",
		navigationMode: "tree"
	};
	function noop$2() {}
	/**
	* @internal
	*/ const TreeContext = createContext(void 0);
	const useTreeContext_unstable = (selector) => useContextSelector(TreeContext, (ctx = defaultTreeContextValue) => selector(ctx));

//#endregion
//#region node_modules/@fluentui/react-tree/lib/utils/createHeadlessTree.js
/**
	* creates a list of virtual tree items
	* and provides a map to access each item by id
	*/ function createHeadlessTree(initialProps = []) {
		const root = createHeadlessTreeRootItem();
		const itemsPerValue = new Map([[root.value, root]]);
		const headlessTree = {
			root,
			get size() {
				return itemsPerValue.size;
			},
			getParent: (key) => {
				var _itemsPerValue_get;
				var _itemsPerValue_get_parentValue, _itemsPerValue_get1;
				return (_itemsPerValue_get1 = itemsPerValue.get((_itemsPerValue_get_parentValue = (_itemsPerValue_get = itemsPerValue.get(key)) === null || _itemsPerValue_get === void 0 ? void 0 : _itemsPerValue_get.parentValue) !== null && _itemsPerValue_get_parentValue !== void 0 ? _itemsPerValue_get_parentValue : root.value)) !== null && _itemsPerValue_get1 !== void 0 ? _itemsPerValue_get1 : root;
			},
			get: (key) => itemsPerValue.get(key),
			has: (key) => itemsPerValue.has(key),
			add(props) {
				const { parentValue = headlessTreeRootId, ...propsWithoutParentValue } = props;
				const parentItem = itemsPerValue.get(parentValue);
				if (!parentItem) {
					console.error(`@fluentui/react-tree [createHeadlessTree]:
TreeItem "${props.value}" is wrongly positioned, did you properly ordered provided item props? make sure provided items are organized, parents should come before children`);
					return;
				}
				parentItem.itemType = "branch";
				var _propsWithoutParentValue_itemType;
				const item = {
					value: props.value,
					getTreeItemProps: () => ({
						...propsWithoutParentValue,
						parentValue,
						"aria-level": item.level,
						"aria-posinset": item.position,
						"aria-setsize": parentItem.childrenValues.length,
						itemType: item.itemType
					}),
					itemType: (_propsWithoutParentValue_itemType = propsWithoutParentValue.itemType) !== null && _propsWithoutParentValue_itemType !== void 0 ? _propsWithoutParentValue_itemType : "leaf",
					level: parentItem.level + 1,
					parentValue,
					childrenValues: [],
					index: -1,
					position: parentItem.childrenValues.push(props.value)
				};
				itemsPerValue.set(item.value, item);
			},
			subtree: (key) => HeadlessTreeSubtreeGenerator(key, headlessTree),
			children: (key) => HeadlessTreeChildrenGenerator(key, headlessTree),
			ancestors: (key) => HeadlessTreeAncestorsGenerator(key, headlessTree),
			visibleItems: (openItems) => HeadlessTreeVisibleItemsGenerator(openItems, headlessTree)
		};
		initialProps.forEach(headlessTree.add);
		return headlessTree;
	}
	const headlessTreeRootId = "__fuiHeadlessTreeRoot";
	function createHeadlessTreeRootItem() {
		return {
			parentValue: void 0,
			value: headlessTreeRootId,
			itemType: "branch",
			getTreeItemProps: () => {
				console.error(`@fluentui/react-tree [createHeadlessTree]:
Internal error, trying to access treeitem props from invalid root element`);
				return {
					id: headlessTreeRootId,
					parentValue: void 0,
					value: headlessTreeRootId,
					"aria-setsize": -1,
					"aria-level": -1,
					"aria-posinset": -1,
					itemType: "branch"
				};
			},
			childrenValues: [],
			get index() {
				console.error(`@fluentui/react-tree [createHeadlessTree]:
Internal error, trying to access treeitem props from invalid root element`);
				return -1;
			},
			get position() {
				console.error(`@fluentui/react-tree [createHeadlessTree]:
Internal error, trying to access treeitem props from invalid root element`);
				return -1;
			},
			level: 0
		};
	}
	/**
	* Generator that returns all subtree of a given virtual tree item
	* @param key - the key of the item to get the subtree from
	*/ function* HeadlessTreeSubtreeGenerator(key, virtualTreeItems) {
		const item = virtualTreeItems.get(key);
		if (!item || item.childrenValues.length === 0) return;
		for (const childValue of item.childrenValues) {
			yield virtualTreeItems.get(childValue);
			yield* HeadlessTreeSubtreeGenerator(childValue, virtualTreeItems);
		}
	}
	/**
	* Generator that returns all children of a given virtual tree item
	* @param key - the key of the item to get the children from
	*/ function* HeadlessTreeChildrenGenerator(key, virtualTreeItems) {
		const item = virtualTreeItems.get(key);
		if (!item || item.childrenValues.length === 0) return;
		for (const childValue of item.childrenValues) yield virtualTreeItems.get(childValue);
	}
	/**
	* Generator that returns all ancestors of a given virtual tree item
	* @param key - the key of the item to get the children from
	*/ function* HeadlessTreeAncestorsGenerator(key, virtualTreeItems) {
		let parent$1 = virtualTreeItems.getParent(key);
		while (parent$1 !== virtualTreeItems.root) {
			yield parent$1;
			parent$1 = virtualTreeItems.getParent(parent$1.value);
		}
	}
	/**
	* Generator that returns all visible items of a given virtual tree
	* @param openItems - the open items of the tree
	*/ function* HeadlessTreeVisibleItemsGenerator(openItems, virtualTreeItems) {
		let index = 0;
		for (const item of recursiveVisibleItems(virtualTreeItems.root.value, openItems, virtualTreeItems)) {
			item.index = index++;
			yield item;
		}
	}
	function* recursiveVisibleItems(parentValue, openItems, virtualTreeItems) {
		const parent$1 = virtualTreeItems.get(parentValue);
		if (!parent$1 || parent$1.childrenValues.length === 0) return;
		for (const childValue of parent$1.childrenValues) {
			const child = virtualTreeItems.get(childValue);
			if (!child) continue;
			if (isItemVisible(child, openItems, virtualTreeItems)) {
				yield child;
				if (openItems.has(childValue)) yield* recursiveVisibleItems(childValue, openItems, virtualTreeItems);
			}
		}
	}
	function isItemVisible(item, openItems, virtualTreeItems) {
		if (item.level === 1) return true;
		while (item.parentValue && item.parentValue !== virtualTreeItems.root.value) {
			if (!openItems.has(item.parentValue)) return false;
			const parent$1 = virtualTreeItems.get(item.parentValue);
			if (!parent$1) return false;
			item = parent$1;
		}
		return true;
	}

//#endregion
//#region node_modules/@fluentui/react-tree/lib/contexts/treeItemContext.js
	const defaultContextValue$1 = {
		value: headlessTreeRootId,
		selectionRef: react.createRef(),
		layoutRef: react.createRef(),
		treeItemRef: react.createRef(),
		subtreeRef: react.createRef(),
		actionsRef: react.createRef(),
		expandIconRef: react.createRef(),
		isActionsVisible: false,
		isAsideVisible: false,
		itemType: "leaf",
		open: false,
		checked: false
	};
	const TreeItemContext = createContext(void 0);
	const { Provider: TreeItemProvider } = TreeItemContext;
	const useTreeItemContext_unstable = (selector) => useContextSelector(TreeItemContext, (ctx = defaultContextValue$1) => selector(ctx));

//#endregion
//#region node_modules/@fluentui/react-tree/lib/hooks/useSubtree.js
/**
	* Create the state required to render a sub-level tree.
	*
	* @param props - props from this instance of tree
	* @param ref - reference to root HTMLElement of tree
	*/ function useSubtree(props, ref) {
		const subtreeRef = useTreeItemContext_unstable((ctx) => ctx.subtreeRef);
		const { level: parentLevel } = useSubtreeContext_unstable();
		const open = useTreeItemContext_unstable((ctx) => ctx.open);
		return {
			contextType: "subtree",
			open,
			components: {
				root: "div",
				collapseMotion: Collapse
			},
			level: parentLevel + 1,
			root: always(getIntrinsicElementProps("div", {
				ref: useMergedRefs(ref, subtreeRef),
				role: "group",
				...props
			}), { elementType: "div" }),
			collapseMotion: presenceMotionSlot(props.collapseMotion, {
				elementType: Collapse,
				defaultProps: {
					visible: open,
					unmountOnExit: true
				}
			})
		};
	}

//#endregion
//#region node_modules/@fluentui/react-tree/lib/utils/nextTypeAheadElement.js
	function nextTypeAheadElement(treeWalker, key) {
		const keyToLowerCase = key.toLowerCase();
		const typeAheadFilter = (element) => {
			var _element_textContent;
			return ((_element_textContent = element.textContent) === null || _element_textContent === void 0 ? void 0 : _element_textContent.trim().charAt(0).toLowerCase()) === keyToLowerCase ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
		};
		let nextElement = treeWalker.nextElement(typeAheadFilter);
		if (!nextElement) {
			treeWalker.currentElement = treeWalker.root;
			nextElement = treeWalker.nextElement(typeAheadFilter);
		}
		return nextElement;
	}

//#endregion
//#region node_modules/@fluentui/react-tree/lib/hooks/useRovingTabIndexes.js
	const findTreeItemRoot = (element) => {
		let parent$1 = element.parentElement;
		while (parent$1 && parent$1.getAttribute("role") !== "tree") parent$1 = parent$1.parentElement;
		return parent$1;
	};
	/**
	* @internal
	* https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/#kbd_roving_tabindex
	*/ function useRovingTabIndex() {
		const currentElementRef = react.useRef(null);
		const walkerRef = react.useRef(null);
		const { targetDocument } = useFluent();
		useFocusedElementChange((element) => {
			if ((element === null || element === void 0 ? void 0 : element.getAttribute("role")) === "treeitem" && walkerRef.current && walkerRef.current.root.contains(element)) {
				const treeitemRoot = findTreeItemRoot(element);
				if (walkerRef.current.root !== treeitemRoot) return;
				rove(element);
			}
		});
		const initialize = react.useCallback((walker) => {
			walkerRef.current = walker;
			walker.currentElement = walker.root;
			let tabbableChild = walker.firstChild((element) => element.tabIndex === 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP);
			walker.currentElement = walker.root;
			tabbableChild !== null && tabbableChild !== void 0 || (tabbableChild = walker.firstChild());
			if (!tabbableChild) return;
			tabbableChild.tabIndex = 0;
			currentElementRef.current = tabbableChild;
			let nextElement = null;
			while ((nextElement = walker.nextElement()) && nextElement !== tabbableChild) nextElement.tabIndex = -1;
		}, []);
		const rove = react.useCallback((nextElement, focusOptions) => {
			if (!currentElementRef.current) return;
			currentElementRef.current.tabIndex = -1;
			nextElement.tabIndex = 0;
			nextElement.focus(focusOptions);
			currentElementRef.current = nextElement;
		}, []);
		return {
			rove,
			initialize,
			forceUpdate: react.useCallback(() => {
				if ((currentElementRef.current === null || !(targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.body.contains(currentElementRef.current))) && walkerRef.current) initialize(walkerRef.current);
			}, [targetDocument, initialize])
		};
	}

//#endregion
//#region node_modules/@fluentui/react-tree/lib/utils/createHTMLElementWalker.js
	function createHTMLElementWalker(root, targetDocument, filter = () => NodeFilter.FILTER_ACCEPT) {
		let temporaryFilter;
		const treeWalker = targetDocument.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, { acceptNode(node$1) {
			if (!isHTMLElement(node$1)) return NodeFilter.FILTER_REJECT;
			const filterResult = filter(node$1);
			var _temporaryFilter;
			return filterResult === NodeFilter.FILTER_ACCEPT ? (_temporaryFilter = temporaryFilter === null || temporaryFilter === void 0 ? void 0 : temporaryFilter(node$1)) !== null && _temporaryFilter !== void 0 ? _temporaryFilter : filterResult : filterResult;
		} });
		return {
			get root() {
				return treeWalker.root;
			},
			get currentElement() {
				return treeWalker.currentNode;
			},
			set currentElement(element) {
				treeWalker.currentNode = element;
			},
			firstChild: (localFilter) => {
				temporaryFilter = localFilter;
				const result = treeWalker.firstChild();
				temporaryFilter = void 0;
				return result;
			},
			lastChild: (localFilter) => {
				temporaryFilter = localFilter;
				const result = treeWalker.lastChild();
				temporaryFilter = void 0;
				return result;
			},
			nextElement: (localFilter) => {
				temporaryFilter = localFilter;
				const result = treeWalker.nextNode();
				temporaryFilter = void 0;
				return result;
			},
			nextSibling: (localFilter) => {
				temporaryFilter = localFilter;
				const result = treeWalker.nextSibling();
				temporaryFilter = void 0;
				return result;
			},
			parentElement: (localFilter) => {
				temporaryFilter = localFilter;
				const result = treeWalker.parentNode();
				temporaryFilter = void 0;
				return result;
			},
			previousElement: (localFilter) => {
				temporaryFilter = localFilter;
				const result = treeWalker.previousNode();
				temporaryFilter = void 0;
				return result;
			},
			previousSibling: (localFilter) => {
				temporaryFilter = localFilter;
				const result = treeWalker.previousSibling();
				temporaryFilter = void 0;
				return result;
			}
		};
	}

//#endregion
//#region node_modules/@fluentui/react-tree/lib/utils/treeItemFilter.js
	const treeItemFilter = (element) => {
		return element.getAttribute("role") === "treeitem" ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
	};

//#endregion
//#region node_modules/@fluentui/react-tree/lib/hooks/useHTMLElementWalkerRef.js
	function useHTMLElementWalkerRef() {
		const { targetDocument } = useFluent();
		const walkerRef = react.useRef(void 0);
		return {
			walkerRef,
			rootRef: react.useCallback((root) => {
				walkerRef.current = targetDocument && root ? createHTMLElementWalker(root, targetDocument, treeItemFilter) : void 0;
			}, [targetDocument])
		};
	}

//#endregion
//#region node_modules/@fluentui/react-tree/lib/components/TreeItemChevron.js
	const TreeItemChevron = /* @__PURE__ */ react.memo(() => {
		const open = useTreeItemContext_unstable((ctx) => ctx.open);
		const { dir } = useFluent();
		const expandIconRotation = open ? 90 : dir !== "rtl" ? 0 : 180;
		return /* @__PURE__ */ react.createElement(ChevronRight12Regular, { style: {
			...expandIconInlineStyles[expandIconRotation],
			transition: `transform ${durations$1.durationNormal}ms ${curves.curveEasyEaseMax}`
		} });
	});
	TreeItemChevron.displayName = "TreeItemChevron";
	const expandIconInlineStyles = {
		90: { transform: `rotate(90deg)` },
		0: { transform: `rotate(0deg)` },
		180: { transform: `rotate(180deg)` }
	};

//#endregion
//#region node_modules/@fluentui/react-tree/lib/components/TreeItemLayout/useTreeItemLayout.js
/**
	* Create the state required to render TreeItemLayout.
	*
	* The returned state can be modified with hooks such as useTreeItemLayoutStyles_unstable,
	* before being passed to renderTreeItemLayout_unstable.
	*
	* @param props - props from this instance of TreeItemLayout
	* @param ref - reference to root HTMLElement of TreeItemLayout
	*/ const useTreeItemLayout_unstable = (props, ref) => {
		"use no memo";
		const { main, iconAfter, iconBefore } = props;
		const layoutRef = useTreeItemContext_unstable((ctx) => ctx.layoutRef);
		const selectionMode = useTreeContext_unstable((ctx) => ctx.selectionMode);
		const navigationMode = useTreeContext_unstable((ctx) => {
			var _ctx_navigationMode;
			return (_ctx_navigationMode = ctx.navigationMode) !== null && _ctx_navigationMode !== void 0 ? _ctx_navigationMode : "tree";
		});
		const [isActionsVisibleFromProps, onActionVisibilityChange] = isResolvedShorthand(props.actions) ? [props.actions.visible, props.actions.onVisibilityChange] : [void 0, void 0];
		const [isActionsVisible, setIsActionsVisible] = useControllableState({
			state: isActionsVisibleFromProps,
			initialState: false
		});
		const selectionRef = useTreeItemContext_unstable((ctx) => ctx.selectionRef);
		const expandIconRef = useTreeItemContext_unstable((ctx) => ctx.expandIconRef);
		const actionsRef = useTreeItemContext_unstable((ctx) => ctx.actionsRef);
		const actionsRefInternal = react.useRef(null);
		const treeItemRef = useTreeItemContext_unstable((ctx) => ctx.treeItemRef);
		const subtreeRef = useTreeItemContext_unstable((ctx) => ctx.subtreeRef);
		const checked = useTreeItemContext_unstable((ctx) => ctx.checked);
		const isBranch = useTreeItemContext_unstable((ctx) => ctx.itemType === "branch");
		assertIsRefObject(treeItemRef);
		assertIsRefObject(subtreeRef);
		const setActionsVisibleIfNotFromSubtree = react.useCallback((event) => {
			if (!Boolean(subtreeRef.current && elementContains(subtreeRef.current, event.target))) {
				onActionVisibilityChange === null || onActionVisibilityChange === void 0 || onActionVisibilityChange(event, {
					visible: true,
					event,
					type: event.type
				});
				if (event.defaultPrevented) return;
				setIsActionsVisible(true);
			}
		}, [
			subtreeRef,
			setIsActionsVisible,
			onActionVisibilityChange
		]);
		const { targetDocument } = useFluent();
		const isNavigatingWithKeyboard = useIsNavigatingWithKeyboard();
		const setActionsInvisibleIfNotFromSubtree = react.useCallback((event) => {
			const isRelatedTargetFromActions = () => Boolean(actionsRefInternal.current && elementContains(actionsRefInternal.current, event.relatedTarget));
			const isRelatedTargetFromTreeItem = () => Boolean(treeItemRef.current && elementContains(treeItemRef.current, event.relatedTarget));
			const isTargetFromActions = () => {
				var _actionsRefInternal_current;
				return Boolean((_actionsRefInternal_current = actionsRefInternal.current) === null || _actionsRefInternal_current === void 0 ? void 0 : _actionsRefInternal_current.contains(event.target));
			};
			if (isRelatedTargetFromActions()) {
				onActionVisibilityChange === null || onActionVisibilityChange === void 0 || onActionVisibilityChange(event, {
					visible: true,
					event,
					type: event.type
				});
				if (event.defaultPrevented) return;
				setIsActionsVisible(true);
				return;
			}
			if (isTargetFromActions() && isRelatedTargetFromTreeItem()) return;
			if (event.type === "mouseout" && isNavigatingWithKeyboard() && ((targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.activeElement) === treeItemRef.current || elementContains(actionsRefInternal.current, targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.activeElement))) return;
			onActionVisibilityChange === null || onActionVisibilityChange === void 0 || onActionVisibilityChange(event, {
				visible: false,
				event,
				type: event.type
			});
			if (event.defaultPrevented) return;
			setIsActionsVisible(false);
		}, [
			setIsActionsVisible,
			onActionVisibilityChange,
			treeItemRef,
			isNavigatingWithKeyboard,
			targetDocument
		]);
		const expandIcon = optional(props.expandIcon, {
			renderByDefault: isBranch,
			defaultProps: {
				children: /* @__PURE__ */ react.createElement(TreeItemChevron, null),
				"aria-hidden": true
			},
			elementType: "div"
		});
		const expandIconRefs = useMergedRefs(expandIcon === null || expandIcon === void 0 ? void 0 : expandIcon.ref, expandIconRef);
		if (expandIcon) expandIcon.ref = expandIconRefs;
		const arrowNavigationProps = useArrowNavigationGroup({
			circular: navigationMode === "tree",
			axis: "horizontal"
		});
		const actions = isActionsVisible ? optional(props.actions, {
			defaultProps: {
				...arrowNavigationProps,
				role: "toolbar"
			},
			elementType: "div"
		}) : void 0;
		actions === null || actions === void 0 || delete actions.visible;
		actions === null || actions === void 0 || delete actions.onVisibilityChange;
		const actionsRefs = useMergedRefs(actions === null || actions === void 0 ? void 0 : actions.ref, actionsRef, actionsRefInternal);
		const handleActionsBlur = useEventCallback((event) => {
			if (isResolvedShorthand(props.actions)) {
				var _props_actions_onBlur, _props_actions;
				(_props_actions_onBlur = (_props_actions = props.actions).onBlur) === null || _props_actions_onBlur === void 0 || _props_actions_onBlur.call(_props_actions, event);
			}
			const isRelatedTargetFromActions = Boolean(elementContains(event.currentTarget, event.relatedTarget));
			onActionVisibilityChange === null || onActionVisibilityChange === void 0 || onActionVisibilityChange(event, {
				visible: isRelatedTargetFromActions,
				event,
				type: event.type
			});
			setIsActionsVisible(isRelatedTargetFromActions);
		});
		if (actions) {
			actions.ref = actionsRefs;
			actions.onBlur = handleActionsBlur;
		}
		const hasActions = Boolean(props.actions);
		react.useEffect(() => {
			if (treeItemRef.current && hasActions) {
				const treeItemElement = treeItemRef.current;
				const handleMouseOver = setActionsVisibleIfNotFromSubtree;
				const handleMouseOut = setActionsInvisibleIfNotFromSubtree;
				const handleFocus = setActionsVisibleIfNotFromSubtree;
				const handleBlur = setActionsInvisibleIfNotFromSubtree;
				treeItemElement.addEventListener("mouseover", handleMouseOver);
				treeItemElement.addEventListener("mouseout", handleMouseOut);
				treeItemElement.addEventListener("focus", handleFocus);
				treeItemElement.addEventListener("blur", handleBlur);
				return () => {
					treeItemElement.removeEventListener("mouseover", handleMouseOver);
					treeItemElement.removeEventListener("mouseout", handleMouseOut);
					treeItemElement.removeEventListener("focus", handleFocus);
					treeItemElement.removeEventListener("blur", handleBlur);
				};
			}
		}, [
			hasActions,
			treeItemRef,
			setActionsVisibleIfNotFromSubtree,
			setActionsInvisibleIfNotFromSubtree
		]);
		return {
			components: {
				root: "div",
				expandIcon: "div",
				iconBefore: "div",
				main: "div",
				iconAfter: "div",
				actions: "div",
				aside: "div",
				selector: selectionMode === "multiselect" ? Checkbox : Radio
			},
			buttonContextValue: { size: "small" },
			root: always(getIntrinsicElementProps("div", {
				...props,
				ref: useMergedRefs(ref, layoutRef)
			}), { elementType: "div" }),
			iconBefore: optional(iconBefore, { elementType: "div" }),
			main: always(main, { elementType: "div" }),
			iconAfter: optional(iconAfter, { elementType: "div" }),
			aside: !isActionsVisible ? optional(props.aside, { elementType: "div" }) : void 0,
			actions,
			expandIcon,
			selector: optional(props.selector, {
				renderByDefault: selectionMode !== "none",
				defaultProps: {
					checked,
					tabIndex: -1,
					"aria-hidden": true,
					ref: selectionRef
				},
				elementType: selectionMode === "multiselect" ? Checkbox : Radio
			})
		};
	};
	function assertIsRefObject(ref) {
		if (typeof ref !== "object" || ref === null || !("current" in ref)) throw new Error(`
        @fluentui/react-tree [${useTreeItemLayout_unstable.name}]:
        Internal Error: contextual ref is not a RefObject! Please report this bug immediately, as contextual refs should be RefObjects.
      `);
	}

//#endregion
//#region node_modules/@fluentui/react-tree/lib/components/TreeItemLayout/renderTreeItemLayout.js
/**
	* Render the final JSX of TreeItemLayout
	*/ const renderTreeItemLayout_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(state.root, { children: [
			state.expandIcon && /* @__PURE__ */ jsx(state.expandIcon, {}),
			state.selector && /* @__PURE__ */ jsx(state.selector, {}),
			state.iconBefore && /* @__PURE__ */ jsx(state.iconBefore, {}),
			/* @__PURE__ */ jsx(state.main, { children: state.root.children }),
			state.iconAfter && /* @__PURE__ */ jsx(state.iconAfter, {}),
			/* @__PURE__ */ jsxs(ButtonContextProvider, {
				value: state.buttonContextValue,
				children: [state.actions && /* @__PURE__ */ jsx(state.actions, {}), state.aside && /* @__PURE__ */ jsx(state.aside, {})]
			})
		] });
	};

//#endregion
//#region node_modules/@fluentui/react-tree/lib/components/TreeItemLayout/useTreeItemLayoutStyles.styles.js
	const treeItemLayoutClassNames = {
		root: "fui-TreeItemLayout",
		iconBefore: "fui-TreeItemLayout__iconBefore",
		main: "fui-TreeItemLayout__main",
		iconAfter: "fui-TreeItemLayout__iconAfter",
		expandIcon: "fui-TreeItemLayout__expandIcon",
		aside: "fui-TreeItemLayout__aside",
		actions: "fui-TreeItemLayout__actions",
		selector: "fui-TreeItemLayout__selector"
	};
	const useRootBaseStyles$7 = /* @__PURE__ */ __resetStyles("ryb8khq", null, [
		".ryb8khq{display:flex;align-items:center;min-height:32px;box-sizing:border-box;grid-area:layout;}",
		".ryb8khq:hover{color:var(--colorNeutralForeground2Hover);background-color:var(--colorSubtleBackgroundHover);}",
		".ryb8khq:hover .fui-TreeItemLayout__expandIcon{color:var(--colorNeutralForeground3Hover);}",
		".ryb8khq:active{color:var(--colorNeutralForeground2Pressed);background-color:var(--colorSubtleBackgroundPressed);}",
		".ryb8khq:active .fui-TreeItemLayout__expandIcon{color:var(--colorNeutralForeground3Pressed);}"
	]);
	/**
	* Styles for the root slot
	*/
	const useRootStyles$11 = /* @__PURE__ */ __styles({
		leaf: { uwmqm3: ["f1k1erfc", "faevyjx"] },
		branch: { uwmqm3: ["fo100m9", "f6yw3pu"] },
		medium: {
			Bahqtrf: "fk6fouc",
			Be2twd7: "fkhj508",
			Bhrd7zp: "figsok6",
			Bg96gwp: "f1i3iumi"
		},
		small: {
			sshi5w: "f1pha7fy",
			Bahqtrf: "fk6fouc",
			Be2twd7: "fy9rknc",
			Bhrd7zp: "figsok6",
			Bg96gwp: "fwrc4pm"
		},
		subtle: {},
		"subtle-alpha": {
			Jwef8y: "f146ro5n",
			ecr2s2: "fkam630"
		},
		transparent: {
			De3pzq: "f1c21dwh",
			Jwef8y: "fjxutwb",
			ecr2s2: "fophhak"
		}
	}, {
		d: [
			".f1k1erfc{padding-left:calc(var(--fluent-TreeItem--level, 1) * var(--spacingHorizontalXXL));}",
			".faevyjx{padding-right:calc(var(--fluent-TreeItem--level, 1) * var(--spacingHorizontalXXL));}",
			".fo100m9{padding-left:calc((var(--fluent-TreeItem--level, 1) - 1) * var(--spacingHorizontalXXL));}",
			".f6yw3pu{padding-right:calc((var(--fluent-TreeItem--level, 1) - 1) * var(--spacingHorizontalXXL));}",
			".fk6fouc{font-family:var(--fontFamilyBase);}",
			".fkhj508{font-size:var(--fontSizeBase300);}",
			".figsok6{font-weight:var(--fontWeightRegular);}",
			".f1i3iumi{line-height:var(--lineHeightBase300);}",
			".f1pha7fy{min-height:24px;}",
			".fy9rknc{font-size:var(--fontSizeBase200);}",
			".fwrc4pm{line-height:var(--lineHeightBase200);}",
			".f1c21dwh{background-color:var(--colorTransparentBackground);}"
		],
		h: [".f146ro5n:hover{background-color:var(--colorSubtleBackgroundLightAlphaHover);}", ".fjxutwb:hover{background-color:var(--colorTransparentBackgroundHover);}"],
		a: [".fkam630:active{background-color:var(--colorSubtleBackgroundLightAlphaPressed);}", ".fophhak:active{background-color:var(--colorTransparentBackgroundPressed);}"]
	});
	/**
	* Styles for the action icon slot
	*/
	const useActionsBaseStyles$1 = /* @__PURE__ */ __resetStyles("rzvs2in", "r17h8a29", [".rzvs2in{display:flex;margin-left:auto;position:relative;z-index:1;grid-area:aside;padding:0 var(--spacingHorizontalS);}", ".r17h8a29{display:flex;margin-right:auto;position:relative;z-index:1;grid-area:aside;padding:0 var(--spacingHorizontalS);}"]);
	/**
	* Styles for the action icon slot
	*/
	const useAsideBaseStyles$1 = /* @__PURE__ */ __resetStyles("r1825u21", "rezy0yk", [".r1825u21{display:flex;margin-left:auto;align-items:center;z-index:0;grid-area:aside;padding:0 var(--spacingHorizontalM);gap:var(--spacingHorizontalXS);}", ".rezy0yk{display:flex;margin-right:auto;align-items:center;z-index:0;grid-area:aside;padding:0 var(--spacingHorizontalM);gap:var(--spacingHorizontalXS);}"]);
	/**
	* Styles for the expand icon slot
	*/
	const useExpandIconBaseStyles$1 = /* @__PURE__ */ __resetStyles("rh4pu5o", null, [".rh4pu5o{display:flex;align-items:center;justify-content:center;min-width:24px;box-sizing:border-box;color:var(--colorNeutralForeground3);flex:0 0 auto;padding:var(--spacingVerticalXS) 0;}"]);
	/**
	* Styles for the content slot
	*/
	const useMainBaseStyles$1 = /* @__PURE__ */ __resetStyles("rklbe47", null, [".rklbe47{padding:0 var(--spacingHorizontalXXS);}"]);
	/**
	* Styles for the before/after icon slot
	*/
	const useIconBaseStyles$1 = /* @__PURE__ */ __resetStyles("rphzgg1", null, [".rphzgg1{display:flex;align-items:center;color:var(--colorNeutralForeground2);line-height:var(--lineHeightBase500);font-size:var(--fontSizeBase500);}"]);
	const useIconBeforeStyles = /* @__PURE__ */ __styles({
		medium: { z189sj: ["f7x41pl", "fruq291"] },
		small: { z189sj: ["ffczdla", "fgiv446"] }
	}, { d: [
		".f7x41pl{padding-right:var(--spacingHorizontalXS);}",
		".fruq291{padding-left:var(--spacingHorizontalXS);}",
		".ffczdla{padding-right:var(--spacingHorizontalXXS);}",
		".fgiv446{padding-left:var(--spacingHorizontalXXS);}"
	] });
	const useIconAfterStyles = /* @__PURE__ */ __styles({
		medium: { uwmqm3: ["fruq291", "f7x41pl"] },
		small: { uwmqm3: ["fgiv446", "ffczdla"] }
	}, { d: [
		".fruq291{padding-left:var(--spacingHorizontalXS);}",
		".f7x41pl{padding-right:var(--spacingHorizontalXS);}",
		".fgiv446{padding-left:var(--spacingHorizontalXXS);}",
		".ffczdla{padding-right:var(--spacingHorizontalXXS);}"
	] });
	/**
	* Apply styling to the TreeItemLayout slots based on the state
	*/
	const useTreeItemLayoutStyles_unstable = (state) => {
		"use no memo";
		const { main, iconAfter, iconBefore, expandIcon, root, aside, actions, selector } = state;
		const rootStyles = useRootStyles$11();
		const rootBaseStyles = useRootBaseStyles$7();
		const actionsBaseStyles = useActionsBaseStyles$1();
		const asideBaseStyles = useAsideBaseStyles$1();
		const mainBaseStyles = useMainBaseStyles$1();
		const expandIconBaseStyles = useExpandIconBaseStyles$1();
		const iconBaseStyles = useIconBaseStyles$1();
		const iconBeforeStyles = useIconBeforeStyles();
		const iconAfterStyles = useIconAfterStyles();
		const size$2 = useTreeContext_unstable((ctx) => ctx.size);
		const appearance = useTreeContext_unstable((ctx) => ctx.appearance);
		const itemType = useTreeItemContext_unstable((ctx) => ctx.itemType);
		root.className = mergeClasses(treeItemLayoutClassNames.root, rootBaseStyles, rootStyles[appearance], rootStyles[size$2], rootStyles[itemType], root.className);
		main.className = mergeClasses(treeItemLayoutClassNames.main, mainBaseStyles, main.className);
		if (expandIcon) expandIcon.className = mergeClasses(treeItemLayoutClassNames.expandIcon, expandIconBaseStyles, expandIcon.className);
		if (iconBefore) iconBefore.className = mergeClasses(treeItemLayoutClassNames.iconBefore, iconBaseStyles, iconBeforeStyles[size$2], iconBefore.className);
		if (iconAfter) iconAfter.className = mergeClasses(treeItemLayoutClassNames.iconAfter, iconBaseStyles, iconAfterStyles[size$2], iconAfter.className);
		if (actions) actions.className = mergeClasses(treeItemLayoutClassNames.actions, actionsBaseStyles, actions.className);
		if (aside) aside.className = mergeClasses(treeItemLayoutClassNames.aside, asideBaseStyles, aside.className);
		if (selector) selector.className = mergeClasses(treeItemLayoutClassNames.selector, selector.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-tree/lib/components/TreeItemLayout/TreeItemLayout.js
/**
	* The `TreeItemLayout` component is used as a child of `TreeItem` to define the content and layout of a tree item.
	* It provides a consistent visual structure for tree items in a `Tree` component.
	* This component should only be used as a direct child of `TreeItem`.
	*/ const TreeItemLayout = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useTreeItemLayout_unstable(props, ref);
		useTreeItemLayoutStyles_unstable(state);
		useCustomStyleHook("useTreeItemLayoutStyles_unstable")(state);
		return renderTreeItemLayout_unstable(state);
	});
	TreeItemLayout.displayName = "TreeItemLayout";

//#endregion
//#region node_modules/@fluentui/react-tree/lib/hooks/useTreeNavigation.js
/***
	* Hook used to manage navigation in the tree.
	*
	* @param navigationMode - the navigation mode of the tree, 'tree' (default) or 'treegrid'
	*/ function useTreeNavigation(navigationMode = "tree") {
		"use no memo";
		const { rove, initialize: initializeRovingTabIndex, forceUpdate: forceUpdateRovingTabIndex } = useRovingTabIndex();
		const { findFirstFocusable } = useFocusFinders();
		const { walkerRef, rootRef: walkerRootRef } = useHTMLElementWalkerRef();
		const rootRefCallback = react.useCallback((root) => {
			if (root && walkerRef.current) initializeRovingTabIndex(walkerRef.current);
		}, [walkerRef, initializeRovingTabIndex]);
		const getNextElement = (data) => {
			if (!walkerRef.current) return null;
			switch (data.type) {
				case treeDataTypes.Click: return data.target;
				case treeDataTypes.TypeAhead:
					walkerRef.current.currentElement = data.target;
					return nextTypeAheadElement(walkerRef.current, data.event.key);
				case treeDataTypes.ArrowLeft: {
					const actions = queryActions$1(data.target);
					if (navigationMode === "treegrid" && (actions === null || actions === void 0 ? void 0 : actions.contains(data.target.ownerDocument.activeElement))) return data.target;
					walkerRef.current.currentElement = data.target;
					return walkerRef.current.parentElement();
				}
				case treeDataTypes.ArrowRight:
					if (navigationMode === "treegrid") {
						const actions = queryActions$1(data.target);
						if (actions) {
							var _findFirstFocusable;
							(_findFirstFocusable = findFirstFocusable(actions)) === null || _findFirstFocusable === void 0 || _findFirstFocusable.focus();
						}
						return null;
					}
					walkerRef.current.currentElement = data.target;
					return walkerRef.current.firstChild();
				case treeDataTypes.End:
					walkerRef.current.currentElement = walkerRef.current.root;
					return lastChildRecursive(walkerRef.current);
				case treeDataTypes.Home:
					walkerRef.current.currentElement = walkerRef.current.root;
					return walkerRef.current.firstChild();
				case treeDataTypes.ArrowDown:
					walkerRef.current.currentElement = data.target;
					return walkerRef.current.nextElement();
				case treeDataTypes.ArrowUp:
					walkerRef.current.currentElement = data.target;
					return walkerRef.current.previousElement();
			}
		};
		function navigate(data, focusOptions) {
			const nextElement = getNextElement(data);
			if (nextElement) rove(nextElement, focusOptions);
			return nextElement;
		}
		return {
			navigate,
			treeRef: useMergedRefs(walkerRootRef, rootRefCallback),
			forceUpdateRovingTabIndex
		};
	}
	function lastChildRecursive(walker) {
		let lastElement = null;
		let nextElement = null;
		while (nextElement = walker.lastChild()) lastElement = nextElement;
		return lastElement;
	}
	const queryActions$1 = (target) => target.querySelector(`:scope > .${treeItemLayoutClassNames.root} > .${treeItemLayoutClassNames.actions}`);

//#endregion
//#region node_modules/@fluentui/react-tree/lib/components/Tree/useTree.js
	const useTree_unstable = (props, ref) => {
		"use no memo";
		return react.useContext(SubtreeContext) === void 0 ? useNestedRootTree(props, ref) : useNestedSubtree(props, ref);
	};
	function useNestedRootTree(props, ref) {
		"use no memo";
		const [openItems, setOpenItems] = useControllableOpenItems(props);
		const checkedItems = useNestedCheckedItems(props);
		const navigation = useTreeNavigation(props.navigationMode);
		return Object.assign(useRootTree({
			...props,
			openItems,
			checkedItems,
			onOpenChange: useEventCallback((event, data) => {
				var _props_onOpenChange;
				const nextOpenItems = createNextOpenItems(data, openItems);
				(_props_onOpenChange = props.onOpenChange) === null || _props_onOpenChange === void 0 || _props_onOpenChange.call(props, event, {
					...data,
					openItems: ImmutableSet.dangerouslyGetInternalSet(nextOpenItems)
				});
				setOpenItems(nextOpenItems);
			}),
			onNavigation: useEventCallback((event, data) => {
				var _props_onNavigation;
				(_props_onNavigation = props.onNavigation) === null || _props_onNavigation === void 0 || _props_onNavigation.call(props, event, data);
				if (!event.isDefaultPrevented()) navigation.navigate(data, { preventScroll: data.isScrollPrevented() });
			}),
			onCheckedChange: useEventCallback((event, data) => {
				var _props_onCheckedChange;
				const nextCheckedItems = createNextNestedCheckedItems(data, checkedItems);
				(_props_onCheckedChange = props.onCheckedChange) === null || _props_onCheckedChange === void 0 || _props_onCheckedChange.call(props, event, {
					...data,
					checkedItems: ImmutableMap.dangerouslyGetInternalMap(nextCheckedItems)
				});
			})
		}, useMergedRefs(ref, navigation.treeRef)), {
			treeType: "nested",
			forceUpdateRovingTabIndex: navigation.forceUpdateRovingTabIndex
		});
	}
	function useNestedSubtree(props, ref) {
		"use no memo";
		if (useTreeContext_unstable((ctx) => ctx.treeType) === "flat") throw new Error(`@fluentui/react-tree [useTree]:
Subtrees are not allowed in a FlatTree!
You cannot use a <Tree> component inside of a <FlatTree> component!`);
		return useSubtree(props, ref);
	}

//#endregion
//#region node_modules/@fluentui/react-tree/lib/components/Tree/useTreeContextValues.js
	function useTreeContextValues_unstable(state) {
		"use no memo";
		if (state.contextType === "root") {
			const { openItems, level, contextType, treeType, checkedItems, selectionMode, navigationMode, appearance, size: size$2, requestTreeResponse, forceUpdateRovingTabIndex } = state;
			return { tree: {
				treeType,
				size: size$2,
				openItems,
				appearance,
				checkedItems,
				selectionMode,
				navigationMode,
				contextType,
				level,
				requestTreeResponse,
				forceUpdateRovingTabIndex
			} };
		}
		return { tree: react.useMemo(() => ({
			level: state.level,
			contextType: "subtree"
		}), [state.level]) };
	}

//#endregion
//#region node_modules/@fluentui/react-tree/lib/components/Tree/useTreeStyles.styles.js
	const treeClassNames = { root: "fui-Tree" };
	const useBaseStyles$2 = /* @__PURE__ */ __resetStyles("rnv2ez3", null, [".rnv2ez3{display:flex;flex-direction:column;row-gap:var(--spacingVerticalXXS);}"]);
	const useStyles$55 = /* @__PURE__ */ __styles({ subtree: { z8tnut: "fclwglc" } }, { d: [".fclwglc{padding-top:var(--spacingVerticalXXS);}"] });
	const useTreeStyles_unstable = (state) => {
		"use no memo";
		const baseStyles = useBaseStyles$2();
		const styles = useStyles$55();
		const isSubTree = state.level > 1;
		state.root.className = mergeClasses(treeClassNames.root, baseStyles, isSubTree && styles.subtree, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-tree/lib/components/TreeProvider.js
/**
	* @internal
	*/ const rootSubtreeContextValue = {
		level: 1,
		contextType: "subtree"
	};
	const TreeProvider = (props) => {
		if (props.value.contextType === "subtree") return /* @__PURE__ */ react.createElement(SubtreeContext.Provider, { value: props.value }, props.children);
		return /* @__PURE__ */ react.createElement(TreeContext.Provider, { value: props.value }, /* @__PURE__ */ react.createElement(SubtreeContext.Provider, { value: rootSubtreeContextValue }, props.children));
	};
	TreeProvider.displayName = "TreeProvider";
	const TreeRootReset = (props) => /* @__PURE__ */ react.createElement(SubtreeContext.Provider, { value: void 0 }, props.children);

//#endregion
//#region node_modules/@fluentui/react-tree/lib/components/Tree/renderTree.js
	const renderTree_unstable = (state, contextValues) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(TreeProvider, {
			value: contextValues.tree,
			children: state.collapseMotion ? /* @__PURE__ */ jsx(state.collapseMotion, { children: /* @__PURE__ */ jsx(state.root, {}) }) : /* @__PURE__ */ jsx(state.root, {})
		});
	};

//#endregion
//#region node_modules/@fluentui/react-tree/lib/components/Tree/Tree.js
/**
	* The `Tree` component renders nested items in a hierarchical structure.
	* Use it with `TreeItem` component and layouts components `TreeItemLayout` or `TreeItemPersonaLayout`.
	*/ const Tree = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useTree_unstable(props, ref);
		const contextValues = useTreeContextValues_unstable(state);
		useTreeStyles_unstable(state);
		useCustomStyleHook("useTreeStyles_unstable")(state);
		return renderTree_unstable(state, contextValues);
	});
	Tree.displayName = "Tree";

//#endregion
//#region node_modules/@fluentui/react-tree/lib/utils/getTreeItemValueFromElement.js
	const dataTreeItemValueAttrName = "data-fui-tree-item-value";

//#endregion
//#region node_modules/@fluentui/react-tree/lib/hooks/useFlatTreeNavigation.js
	function useFlatTreeNavigation(navigationMode = "tree") {
		"use no memo";
		const { walkerRef, rootRef: walkerRootRef } = useHTMLElementWalkerRef();
		const { rove, forceUpdate: forceUpdateRovingTabIndex, initialize: initializeRovingTabIndex } = useRovingTabIndex();
		const { findFirstFocusable } = useFocusFinders();
		const rootRefCallback = react.useCallback((root) => {
			if (walkerRef.current && root) initializeRovingTabIndex(walkerRef.current);
		}, [initializeRovingTabIndex, walkerRef]);
		function getNextElement(data) {
			if (!walkerRef.current) return null;
			switch (data.type) {
				case treeDataTypes.Click: return data.target;
				case treeDataTypes.TypeAhead:
					walkerRef.current.currentElement = data.target;
					return nextTypeAheadElement(walkerRef.current, data.event.key);
				case treeDataTypes.ArrowLeft: {
					const actions = queryActions(data.target);
					if (navigationMode === "treegrid" && (actions === null || actions === void 0 ? void 0 : actions.contains(data.target.ownerDocument.activeElement))) return data.target;
					const nextElement = parentElement(data.parentValue, walkerRef.current);
					if (!nextElement && true) console.warn(`@fluentui/react-tree [useFlatTreeNavigation]:
\'ArrowLeft\' navigation was not possible.
No parent element found for the current element:`, data.target);
					return nextElement;
				}
				case treeDataTypes.ArrowRight: {
					if (navigationMode === "treegrid") {
						const actions = queryActions(data.target);
						if (actions) {
							var _findFirstFocusable;
							(_findFirstFocusable = findFirstFocusable(actions)) === null || _findFirstFocusable === void 0 || _findFirstFocusable.focus();
						}
						return null;
					}
					walkerRef.current.currentElement = data.target;
					const nextElement = firstChild(data.target, walkerRef.current);
					if (!nextElement && true) {
						const ariaLevel = Number(data.target.getAttribute("aria-level"));
						console.warn(`@fluentui/react-tree [useFlatTreeNavigation]:
\'ArrowRight\' navigation was not possible.
No element with "aria-posinset=1" and "aria-level=${ariaLevel + 1}"
was found after the current element!`, data.target);
					}
					return nextElement;
				}
				case treeDataTypes.End:
					walkerRef.current.currentElement = walkerRef.current.root;
					return walkerRef.current.lastChild();
				case treeDataTypes.Home:
					walkerRef.current.currentElement = walkerRef.current.root;
					return walkerRef.current.firstChild();
				case treeDataTypes.ArrowDown:
					walkerRef.current.currentElement = data.target;
					return walkerRef.current.nextElement();
				case treeDataTypes.ArrowUp:
					walkerRef.current.currentElement = data.target;
					return walkerRef.current.previousElement();
			}
		}
		return {
			navigate: useEventCallback((data) => {
				const nextElement = getNextElement(data);
				if (nextElement) rove(nextElement);
			}),
			rootRef: useMergedRefs(walkerRootRef, rootRefCallback),
			forceUpdateRovingTabIndex
		};
	}
	function firstChild(target, treeWalker) {
		const nextElement = treeWalker.nextElement();
		if (!nextElement) return null;
		const nextElementAriaPosInSet = nextElement.getAttribute("aria-posinset");
		const nextElementAriaLevel = nextElement.getAttribute("aria-level");
		const targetAriaLevel = target.getAttribute("aria-level");
		if (nextElementAriaPosInSet === "1" && Number(nextElementAriaLevel) === Number(targetAriaLevel) + 1) return nextElement;
		return null;
	}
	function parentElement(parentValue, treeWalker) {
		if (parentValue === void 0) return null;
		return treeWalker.root.querySelector(`[${dataTreeItemValueAttrName}="${parentValue}"]`);
	}
	const queryActions = (target) => target.querySelector(`:scope > .${treeItemLayoutClassNames.root} > .${treeItemLayoutClassNames.actions}`);

//#endregion
//#region node_modules/@fluentui/react-tree/lib/components/FlatTree/useFlatTree.js
	const useFlatTree_unstable = (props, ref) => {
		"use no memo";
		return react.useContext(SubtreeContext) === void 0 ? useRootFlatTree(props, ref) : useSubFlatTree(props, ref);
	};
	function useRootFlatTree(props, ref) {
		const navigation = useFlatTreeNavigation(props.navigationMode);
		return Object.assign(useRootTree({
			...props,
			onNavigation: useEventCallback((event, data) => {
				var _props_onNavigation;
				(_props_onNavigation = props.onNavigation) === null || _props_onNavigation === void 0 || _props_onNavigation.call(props, event, data);
				if (!event.isDefaultPrevented()) navigation.navigate(data);
			})
		}, useMergedRefs(ref, navigation.rootRef)), {
			treeType: "flat",
			forceUpdateRovingTabIndex: navigation.forceUpdateRovingTabIndex
		});
	}
	function useSubFlatTree(props, ref) {
		throw new Error(`@fluentui/react-tree [useFlatTree]:
Subtrees are not allowed in a FlatTree!
You cannot use a <FlatTree> component inside of another <FlatTree> nor a <Tree> component!`);
	}

//#endregion
//#region node_modules/@fluentui/react-tree/lib/components/FlatTree/useFlatTreeStyles.styles.js
	const flatTreeClassNames = { root: "fui-FlatTree" };
	const useBaseStyles$1 = /* @__PURE__ */ __resetStyles("rnv2ez3", null, [".rnv2ez3{display:flex;flex-direction:column;row-gap:var(--spacingVerticalXXS);}"]);
	const useFlatTreeStyles_unstable = (state) => {
		"use no memo";
		const baseStyles = useBaseStyles$1();
		state.root.className = mergeClasses(flatTreeClassNames.root, baseStyles, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-tree/lib/components/FlatTree/useFlatTreeContextValues.js
	const useFlatTreeContextValues_unstable = (state) => {
		const { openItems, level, contextType, treeType, checkedItems, selectionMode, navigationMode, appearance, size: size$2, requestTreeResponse, forceUpdateRovingTabIndex } = state;
		return { tree: {
			treeType,
			size: size$2,
			openItems,
			appearance,
			checkedItems,
			selectionMode,
			navigationMode,
			contextType,
			level,
			requestTreeResponse,
			forceUpdateRovingTabIndex
		} };
	};

//#endregion
//#region node_modules/@fluentui/react-tree/lib/components/FlatTree/renderFlatTree.js
	const renderFlatTree_unstable = renderTree_unstable;

//#endregion
//#region node_modules/@fluentui/react-tree/lib/components/FlatTree/FlatTree.js
/**
	* The `FlatTree` component is a variation of the `Tree` component that deals with a flattened data structure.
	*
	* It should be used on cases where more complex interactions with a Tree is required.
	* On simple scenarios it is advised to simply use a nested structure instead.
	*/ const FlatTree = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useFlatTree_unstable(props, ref);
		const contextValues = useFlatTreeContextValues_unstable(state);
		useFlatTreeStyles_unstable(state);
		useCustomStyleHook("useFlatTreeStyles_unstable")(state);
		return renderFlatTree_unstable(state, contextValues);
	});
	FlatTree.displayName = "FlatTree";

//#endregion
//#region node_modules/@fluentui/react-tree/lib/components/FlatTree/useFlatControllableCheckedItems.js
	function useFlatControllableCheckedItems(props, headlessTree) {
		return useControllableState({
			initialState: ImmutableMap.empty,
			state: react.useMemo(() => props.selectionMode ? props.checkedItems && createCheckedItems(props.checkedItems) : void 0, [props.checkedItems, props.selectionMode]),
			defaultState: props.defaultCheckedItems ? () => initializeCheckedItems(props, headlessTree) : void 0
		});
	}
	function createNextFlatCheckedItems(data, previousCheckedItems, headlessTree) {
		if (data.selectionMode === "single") return ImmutableMap.from([[data.value, data.checked]]);
		const treeItem = headlessTree.get(data.value);
		if (!treeItem) {
			console.error(`@fluentui/react-tree [useHeadlessFlatTree]:
Tree item ${data.value} not found.`);
			return previousCheckedItems;
		}
		const nextCheckedItemsMap = new Map(ImmutableMap.dangerouslyGetInternalMap(previousCheckedItems));
		nextCheckedItemsMap.set(data.value, data.checked);
		for (const children of headlessTree.subtree(data.value)) nextCheckedItemsMap.set(children.value, data.checked);
		let isAncestorsMixed = false;
		for (const ancestor of headlessTree.ancestors(treeItem.value)) {
			if (isAncestorsMixed) {
				nextCheckedItemsMap.set(ancestor.value, "mixed");
				continue;
			}
			let childrenWithSameState = 0;
			for (const child of headlessTree.children(ancestor.value)) if ((nextCheckedItemsMap.get(child.value) || false) === data.checked) childrenWithSameState++;
			if (childrenWithSameState === ancestor.childrenValues.length) nextCheckedItemsMap.set(ancestor.value, data.checked);
			else {
				nextCheckedItemsMap.set(ancestor.value, "mixed");
				isAncestorsMixed = true;
			}
		}
		return ImmutableMap.from(nextCheckedItemsMap);
	}
	function initializeCheckedItems(props, headlessTree) {
		if (!props.selectionMode) return ImmutableMap.empty;
		let state = createCheckedItems(props.defaultCheckedItems);
		if (props.selectionMode === "multiselect") for (const [value, checked] of state) state = createNextFlatCheckedItems({
			value,
			checked,
			selectionMode: props.selectionMode
		}, state, headlessTree);
		return state;
	}

//#endregion
//#region node_modules/@fluentui/react-tree/lib/components/FlatTree/useHeadlessFlatTree.js
/**
	* this hook provides FlatTree API to manage all required mechanisms to convert a list of items into renderable TreeItems
	* in multiple scenarios including virtualization.
	*
	* !!A flat tree is an unofficial spec for tree!!
	*
	* It should be used on cases where more complex interactions with a Tree is required.
	* On simple scenarios it is advised to simply use a nested structure instead.
	*
	* @param props - a list of tree items
	* @param options - in case control over the internal openItems is required
	*/ function useHeadlessFlatTree_unstable(props, options = {}) {
		"use no memo";
		const headlessTree = react.useMemo(() => createHeadlessTree(props), [props]);
		const [openItems, setOpenItems] = useControllableOpenItems(options);
		const [checkedItems, setCheckedItems] = useFlatControllableCheckedItems(options, headlessTree);
		const navigation = useFlatTreeNavigation();
		const treeRef = react.useRef(null);
		const handleOpenChange = useEventCallback((event, data) => {
			var _options_onOpenChange;
			const nextOpenItems = createNextOpenItems(data, openItems);
			(_options_onOpenChange = options.onOpenChange) === null || _options_onOpenChange === void 0 || _options_onOpenChange.call(options, event, {
				...data,
				openItems: ImmutableSet.dangerouslyGetInternalSet(nextOpenItems)
			});
			setOpenItems(nextOpenItems);
		});
		const handleCheckedChange = useEventCallback((event, data) => {
			var _options_onCheckedChange;
			const nextCheckedItems = createNextFlatCheckedItems(data, checkedItems, headlessTree);
			(_options_onCheckedChange = options.onCheckedChange) === null || _options_onCheckedChange === void 0 || _options_onCheckedChange.call(options, event, {
				...data,
				checkedItems: ImmutableMap.dangerouslyGetInternalMap(nextCheckedItems)
			});
			setCheckedItems(nextCheckedItems);
		});
		const getNextNavigableItem = useEventCallback((visibleItems, data) => {
			const item = headlessTree.get(data.value);
			if (item) switch (data.type) {
				case treeDataTypes.TypeAhead: return item;
				case treeDataTypes.ArrowLeft: return headlessTree.get(item.parentValue);
				case treeDataTypes.ArrowRight: return visibleItems[item.index + 1];
				case treeDataTypes.End: return visibleItems[visibleItems.length - 1];
				case treeDataTypes.Home: return visibleItems[0];
				case treeDataTypes.ArrowDown: return visibleItems[item.index + 1];
				case treeDataTypes.ArrowUp: return visibleItems[item.index - 1];
			}
		});
		const getElementFromItem = react.useCallback((item) => {
			var _treeRef_current;
			return (_treeRef_current = treeRef.current) === null || _treeRef_current === void 0 ? void 0 : _treeRef_current.querySelector(`[${dataTreeItemValueAttrName}="${item.value}"]`);
		}, []);
		const ref = useMergedRefs(treeRef, navigation.rootRef);
		const getTreeProps = react.useCallback(() => {
			var _options_onNavigation;
			return {
				ref,
				openItems,
				selectionMode: options.selectionMode,
				checkedItems,
				onOpenChange: handleOpenChange,
				onCheckedChange: handleCheckedChange,
				onNavigation: (_options_onNavigation = options.onNavigation) !== null && _options_onNavigation !== void 0 ? _options_onNavigation : noop$1
			};
		}, [
			openItems,
			checkedItems,
			options.selectionMode,
			options.onNavigation
		]);
		const items = react.useCallback(() => headlessTree.visibleItems(openItems), [openItems, headlessTree]);
		const getItem = react.useCallback((value) => headlessTree.get(value), [headlessTree]);
		return react.useMemo(() => ({
			navigate: navigation.navigate,
			getTreeProps,
			getNextNavigableItem,
			getElementFromItem,
			items,
			getItem
		}), [
			navigation.navigate,
			getTreeProps,
			getNextNavigableItem,
			getElementFromItem,
			items,
			getItem
		]);
	}
	/** @internal */ function noop$1() {}

//#endregion
//#region node_modules/@fluentui/react-tree/lib/components/TreeItem/useTreeItem.js
/**
	* Create the state required to render TreeItem.
	*
	* The returned state can be modified with hooks such as useTreeItemStyles_unstable,
	* before being passed to renderTreeItem_unstable.
	*
	* @param props - props from this instance of TreeItem
	* @param ref - reference to root HTMLElement of TreeItem
	*/ function useTreeItem_unstable(props, ref) {
		"use no memo";
		if (useTreeContext_unstable((ctx) => ctx.treeType) === "flat") warnIfNoProperPropsFlatTreeItem(props);
		const requestTreeResponse = useTreeContext_unstable((ctx) => ctx.requestTreeResponse);
		const navigationMode = useTreeContext_unstable((ctx) => {
			var _ctx_navigationMode;
			return (_ctx_navigationMode = ctx.navigationMode) !== null && _ctx_navigationMode !== void 0 ? _ctx_navigationMode : "tree";
		});
		const forceUpdateRovingTabIndex = useTreeContext_unstable((ctx) => ctx.forceUpdateRovingTabIndex);
		const { level: contextLevel } = useSubtreeContext_unstable();
		const parentValue = useTreeItemContext_unstable((ctx) => {
			var _props_parentValue;
			return (_props_parentValue = props.parentValue) !== null && _props_parentValue !== void 0 ? _props_parentValue : ctx.value;
		});
		const internalValue = useId("fuiTreeItemValue-");
		var _props_value;
		const value = (_props_value = props.value) !== null && _props_value !== void 0 ? _props_value : internalValue;
		const { onClick, onKeyDown, onChange, as = "div", itemType = "leaf", "aria-level": level = contextLevel, "aria-selected": ariaSelected, "aria-expanded": ariaExpanded, ...rest } = props;
		const actionsRef = react.useRef(null);
		const expandIconRef = react.useRef(null);
		const layoutRef = react.useRef(null);
		const subtreeRef = react.useRef(null);
		const selectionRef = react.useRef(null);
		const treeItemRef = react.useRef(null);
		{
			const hasTreeContext = useHasParentContext(TreeContext);
			react.useEffect(() => {
				var _treeItemRef_current;
				if (hasTreeContext) return;
				if ((_treeItemRef_current = treeItemRef.current) === null || _treeItemRef_current === void 0 ? void 0 : _treeItemRef_current.querySelector(`.${treeClassNames.root}`)) console.error(`@fluentui/react-tree [useTreeItem]:
<TreeItem> should be declared inside a <Tree> component.`);
			}, [hasTreeContext]);
		}
		react.useEffect(() => {
			forceUpdateRovingTabIndex === null || forceUpdateRovingTabIndex === void 0 || forceUpdateRovingTabIndex();
			const treeItem = treeItemRef.current;
			return () => {
				if (treeItem && treeItem.tabIndex === 0) forceUpdateRovingTabIndex === null || forceUpdateRovingTabIndex === void 0 || forceUpdateRovingTabIndex();
			};
		}, [forceUpdateRovingTabIndex]);
		const open = useTreeContext_unstable((ctx) => {
			var _props_open;
			return (_props_open = props.open) !== null && _props_open !== void 0 ? _props_open : ctx.openItems.has(value);
		});
		const getNextOpen = () => itemType === "branch" ? !open : open;
		const selectionMode = useTreeContext_unstable((ctx) => ctx.selectionMode);
		const checked = useTreeContext_unstable((ctx) => {
			var _ctx_checkedItems_get;
			return (_ctx_checkedItems_get = ctx.checkedItems.get(value)) !== null && _ctx_checkedItems_get !== void 0 ? _ctx_checkedItems_get : false;
		});
		const handleClick = useEventCallback((event) => {
			var _expandIconRef_current;
			const isEventFromActions = () => actionsRef.current && elementContains(actionsRef.current, event.target);
			const isEventFromSubtree = () => subtreeRef.current && elementContains(subtreeRef.current, event.target);
			const isEventFromSelection = () => {
				var _selectionRef_current;
				return (_selectionRef_current = selectionRef.current) === null || _selectionRef_current === void 0 ? void 0 : _selectionRef_current.contains(event.target);
			};
			const isEventFromExpandIcon = (_expandIconRef_current = expandIconRef.current) === null || _expandIconRef_current === void 0 ? void 0 : _expandIconRef_current.contains(event.target);
			if (isEventFromActions() || isEventFromSubtree() || isEventFromSelection()) return;
			else if (!isEventFromExpandIcon) onClick === null || onClick === void 0 || onClick(event);
			if (event.isDefaultPrevented()) return;
			react_dom.unstable_batchedUpdates(() => {
				const data = {
					event,
					value,
					open: getNextOpen(),
					target: event.currentTarget,
					type: isEventFromExpandIcon ? treeDataTypes.ExpandIconClick : treeDataTypes.Click
				};
				if (itemType !== "leaf") {
					var _props_onOpenChange;
					(_props_onOpenChange = props.onOpenChange) === null || _props_onOpenChange === void 0 || _props_onOpenChange.call(props, event, data);
					requestTreeResponse({
						...data,
						itemType,
						requestType: "open"
					});
				}
				requestTreeResponse({
					...data,
					itemType,
					parentValue,
					requestType: "navigate",
					type: treeDataTypes.Click
				});
			});
		});
		const handleKeyDown = useEventCallback((event) => {
			onKeyDown === null || onKeyDown === void 0 || onKeyDown(event);
			if (event.isDefaultPrevented() || !treeItemRef.current) return;
			const isEventFromTreeItem = event.currentTarget === event.target;
			const isEventFromActions = actionsRef.current && actionsRef.current.contains(event.target);
			switch (event.key) {
				case Space:
					if (!isEventFromTreeItem) return;
					if (selectionMode !== "none") {
						var _selectionRef_current;
						(_selectionRef_current = selectionRef.current) === null || _selectionRef_current === void 0 || _selectionRef_current.click();
						event.preventDefault();
					}
					return;
				case treeDataTypes.Enter:
					if (!isEventFromTreeItem) return;
					return event.currentTarget.click();
				case treeDataTypes.End:
				case treeDataTypes.Home:
				case treeDataTypes.ArrowUp:
					if (!isEventFromTreeItem && !isEventFromActions) return;
					return requestTreeResponse({
						requestType: "navigate",
						event,
						value,
						itemType,
						parentValue,
						type: event.key,
						target: event.currentTarget
					});
				case treeDataTypes.ArrowDown:
					if (!isEventFromTreeItem && !isEventFromActions) return;
					if (isEventFromActions && (!isHTMLElement(event.target) || event.target.hasAttribute("aria-haspopup"))) return;
					return requestTreeResponse({
						requestType: "navigate",
						event,
						value,
						itemType,
						parentValue,
						type: event.key,
						target: event.currentTarget
					});
				case treeDataTypes.ArrowLeft: {
					if (event.altKey) return;
					const data = {
						value,
						event,
						open: getNextOpen(),
						type: event.key,
						itemType,
						parentValue,
						target: event.currentTarget
					};
					if (isEventFromActions && navigationMode === "treegrid") {
						requestTreeResponse({
							...data,
							requestType: "navigate"
						});
						return;
					}
					if (!isEventFromTreeItem) return;
					if (level === 1 && !open) return;
					if (open) {
						var _props_onOpenChange;
						(_props_onOpenChange = props.onOpenChange) === null || _props_onOpenChange === void 0 || _props_onOpenChange.call(props, event, data);
					}
					requestTreeResponse({
						...data,
						requestType: open ? "open" : "navigate"
					});
					return;
				}
				case treeDataTypes.ArrowRight: {
					if (!isEventFromTreeItem) return;
					if (event.altKey) return;
					const data = {
						value,
						event,
						open: getNextOpen(),
						type: event.key,
						target: event.currentTarget
					};
					if (itemType === "branch" && !open) {
						var _props_onOpenChange1;
						(_props_onOpenChange1 = props.onOpenChange) === null || _props_onOpenChange1 === void 0 || _props_onOpenChange1.call(props, event, data);
						requestTreeResponse({
							...data,
							itemType,
							requestType: "open"
						});
					} else requestTreeResponse({
						...data,
						itemType,
						parentValue,
						requestType: "navigate"
					});
					return;
				}
			}
			if (!isEventFromTreeItem) return;
			if (event.key.length === 1 && event.key.match(/\w/) && !event.altKey && !event.ctrlKey && !event.metaKey) requestTreeResponse({
				requestType: "navigate",
				event,
				target: event.currentTarget,
				value,
				itemType,
				type: treeDataTypes.TypeAhead,
				parentValue
			});
		});
		const handleChange = useEventCallback((event) => {
			onChange === null || onChange === void 0 || onChange(event);
			if (event.isDefaultPrevented()) return;
			if (subtreeRef.current && elementContains(subtreeRef.current, event.target)) return;
			requestTreeResponse({
				requestType: "selection",
				event,
				value,
				itemType,
				type: "Change",
				target: event.currentTarget,
				checked: checked === "mixed" ? true : !checked
			});
		});
		return {
			value,
			open,
			checked,
			subtreeRef,
			layoutRef,
			selectionRef,
			expandIconRef,
			treeItemRef,
			actionsRef,
			itemType,
			level,
			components: { root: "div" },
			isAsideVisible: false,
			isActionsVisible: false,
			root: always(getIntrinsicElementProps(as, {
				tabIndex: -1,
				[dataTreeItemValueAttrName]: value,
				role: "treeitem",
				...rest,
				ref: useMergedRefs(ref, treeItemRef),
				"aria-level": level,
				"aria-checked": selectionMode === "multiselect" ? checked : void 0,
				"aria-selected": ariaSelected !== void 0 ? ariaSelected : selectionMode === "single" ? !!checked : void 0,
				"aria-expanded": ariaExpanded !== void 0 ? ariaExpanded : itemType === "branch" ? open : void 0,
				onClick: handleClick,
				onKeyDown: handleKeyDown,
				onChange: handleChange
			}), { elementType: "div" })
		};
	}
	function warnIfNoProperPropsFlatTreeItem(props) {
		if (props["aria-posinset"] === void 0 || props["aria-setsize"] === void 0 || props["aria-level"] === void 0 || props.parentValue === void 0 && props["aria-level"] !== 1) console.error(`@fluentui/react-tree [${useTreeItem_unstable.name}]:
A flat treeitem must have "aria-posinset", "aria-setsize", "aria-level"
and "parentValue" (if "aria-level" > 1) to ensure a11y and navigation.

- "aria-posinset": the position of this treeitem in the current level of the tree.
- "aria-setsize": the number of siblings in this level of the tree.
- "aria-level": the current level of the treeitem.
- "parentValue": the "value" property of the parent item of this item.`);
	}

//#endregion
//#region node_modules/@fluentui/react-tree/lib/components/TreeItem/renderTreeItem.js
/**
	* Render the final JSX of TreeItem
	*/ const renderTreeItem_unstable = (state, contextValues) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, { children: /* @__PURE__ */ jsx(TreeItemProvider, {
			value: contextValues.treeItem,
			children: state.root.children
		}) });
	};

//#endregion
//#region node_modules/@fluentui/react-tree/lib/components/TreeItemPersonaLayout/useTreeItemPersonaLayoutStyles.styles.js
	const treeItemPersonaLayoutClassNames = {
		root: "fui-TreeItemPersonaLayout",
		media: "fui-TreeItemPersonaLayout__media",
		description: "fui-TreeItemPersonaLayout__description",
		main: "fui-TreeItemPersonaLayout__main",
		expandIcon: "fui-TreeItemPersonaLayout__expandIcon",
		aside: "fui-TreeItemPersonaLayout__aside",
		actions: "fui-TreeItemPersonaLayout__actions",
		selector: "fui-TreeItemPersonaLayout__selector"
	};
	const useRootBaseStyles$6 = /* @__PURE__ */ __resetStyles("r1r98egg", null, [
		".r1r98egg{display:grid;grid-template-rows:1fr auto;grid-template-columns:auto auto 1fr auto;grid-template-areas:\"expandIcon media main        aside\" \"expandIcon media description aside\";align-items:center;font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase300);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase300);}",
		".r1r98egg:active{color:var(--colorNeutralForeground2Pressed);background-color:var(--colorSubtleBackgroundPressed);}",
		".r1r98egg:active .fui-TreeItemPersonaLayout__expandIcon{color:var(--colorNeutralForeground3Pressed);}",
		".r1r98egg:hover{color:var(--colorNeutralForeground2Hover);background-color:var(--colorSubtleBackgroundHover);}",
		".r1r98egg:hover .fui-TreeItemPersonaLayout__expandIcon{color:var(--colorNeutralForeground3Hover);}"
	]);
	/**
	* Styles for the root slot
	*/
	const useRootStyles$10 = /* @__PURE__ */ __styles({
		leaf: { uwmqm3: ["f1k1erfc", "faevyjx"] },
		branch: { uwmqm3: ["fo100m9", "f6yw3pu"] },
		medium: {
			Bahqtrf: "fk6fouc",
			Be2twd7: "fkhj508",
			Bhrd7zp: "figsok6",
			Bg96gwp: "f1i3iumi"
		},
		small: {
			sshi5w: "f1pha7fy",
			Bahqtrf: "fk6fouc",
			Be2twd7: "fy9rknc",
			Bhrd7zp: "figsok6",
			Bg96gwp: "fwrc4pm"
		},
		subtle: {},
		"subtle-alpha": {
			Jwef8y: "f146ro5n",
			ecr2s2: "fkam630"
		},
		transparent: {
			De3pzq: "f1c21dwh",
			Jwef8y: "fjxutwb",
			ecr2s2: "fophhak"
		}
	}, {
		d: [
			".f1k1erfc{padding-left:calc(var(--fluent-TreeItem--level, 1) * var(--spacingHorizontalXXL));}",
			".faevyjx{padding-right:calc(var(--fluent-TreeItem--level, 1) * var(--spacingHorizontalXXL));}",
			".fo100m9{padding-left:calc((var(--fluent-TreeItem--level, 1) - 1) * var(--spacingHorizontalXXL));}",
			".f6yw3pu{padding-right:calc((var(--fluent-TreeItem--level, 1) - 1) * var(--spacingHorizontalXXL));}",
			".fk6fouc{font-family:var(--fontFamilyBase);}",
			".fkhj508{font-size:var(--fontSizeBase300);}",
			".figsok6{font-weight:var(--fontWeightRegular);}",
			".f1i3iumi{line-height:var(--lineHeightBase300);}",
			".f1pha7fy{min-height:24px;}",
			".fy9rknc{font-size:var(--fontSizeBase200);}",
			".fwrc4pm{line-height:var(--lineHeightBase200);}",
			".f1c21dwh{background-color:var(--colorTransparentBackground);}"
		],
		h: [".f146ro5n:hover{background-color:var(--colorSubtleBackgroundLightAlphaHover);}", ".fjxutwb:hover{background-color:var(--colorTransparentBackgroundHover);}"],
		a: [".fkam630:active{background-color:var(--colorSubtleBackgroundLightAlphaPressed);}", ".fophhak:active{background-color:var(--colorTransparentBackgroundPressed);}"]
	});
	/**
	* Styles for the expand icon slot
	*/
	const useMediaBaseStyles = /* @__PURE__ */ __resetStyles("rkcde6g", "r1e986zr", [".rkcde6g{display:flex;align-items:center;width:32px;height:32px;grid-area:media;padding:0 var(--spacingHorizontalXS) 0 var(--spacingHorizontalXXS);}", ".r1e986zr{display:flex;align-items:center;width:32px;height:32px;grid-area:media;padding:0 var(--spacingHorizontalXXS) 0 var(--spacingHorizontalXS);}"]);
	const useMainBaseStyles = /* @__PURE__ */ __resetStyles("r1qjtz99", "rob5fcp", [".r1qjtz99{grid-area:main;padding:var(--spacingVerticalMNudge) var(--spacingHorizontalXS) var(--spacingVerticalMNudge) var(--spacingHorizontalS);}", ".rob5fcp{grid-area:main;padding:var(--spacingVerticalMNudge) var(--spacingHorizontalS) var(--spacingVerticalMNudge) var(--spacingHorizontalXS);}"]);
	const useMainStyles = /* @__PURE__ */ __styles({ withDescription: {
		Byoj8tv: 0,
		uwmqm3: 0,
		z189sj: 0,
		z8tnut: 0,
		B0ocmuz: ["f1625emv", "f5y9hxg"]
	} }, { d: [[".f1625emv{padding:var(--spacingVerticalMNudge) var(--spacingHorizontalXS) 0 var(--spacingHorizontalS);}", { p: -1 }], [".f5y9hxg{padding:var(--spacingVerticalMNudge) var(--spacingHorizontalS) 0 var(--spacingHorizontalXS);}", { p: -1 }]] });
	const useDescriptionBaseStyles = /* @__PURE__ */ __resetStyles("r1bnsn1b", "r13x7gq", [".r1bnsn1b{grid-area:description;font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase200);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase200);padding:0 var(--spacingHorizontalXS) var(--spacingVerticalMNudge) var(--spacingHorizontalS);}", ".r13x7gq{grid-area:description;font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase200);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase200);padding:0 var(--spacingHorizontalS) var(--spacingVerticalMNudge) var(--spacingHorizontalXS);}"]);
	/**
	* Styles for the action icon slot
	*/
	const useActionsBaseStyles = /* @__PURE__ */ __resetStyles("rzvs2in", "r17h8a29", [".rzvs2in{display:flex;margin-left:auto;position:relative;z-index:1;grid-area:aside;padding:0 var(--spacingHorizontalS);}", ".r17h8a29{display:flex;margin-right:auto;position:relative;z-index:1;grid-area:aside;padding:0 var(--spacingHorizontalS);}"]);
	/**
	* Styles for the action icon slot
	*/
	const useAsideBaseStyles = /* @__PURE__ */ __resetStyles("r1825u21", "rezy0yk", [".r1825u21{display:flex;margin-left:auto;align-items:center;z-index:0;grid-area:aside;padding:0 var(--spacingHorizontalM);gap:var(--spacingHorizontalXS);}", ".rezy0yk{display:flex;margin-right:auto;align-items:center;z-index:0;grid-area:aside;padding:0 var(--spacingHorizontalM);gap:var(--spacingHorizontalXS);}"]);
	/**
	* Styles for the expand icon slot
	*/
	const useExpandIconBaseStyles = /* @__PURE__ */ __resetStyles("rn61xvs", null, [".rn61xvs{display:flex;align-items:center;justify-content:center;min-width:24px;box-sizing:border-box;color:var(--colorNeutralForeground3);grid-area:expandIcon;flex:0 0 auto;padding:var(--spacingVerticalXS) 0;}"]);
	/**
	* Apply styling to the TreeItemPersonaLayout slots based on the state
	*/
	const useTreeItemPersonaLayoutStyles_unstable = (state) => {
		"use no memo";
		const rootBaseStyles = useRootBaseStyles$6();
		const rootStyles = useRootStyles$10();
		const mediaBaseStyles = useMediaBaseStyles();
		const descriptionBaseStyles = useDescriptionBaseStyles();
		const actionsBaseStyles = useActionsBaseStyles();
		const asideBaseStyles = useAsideBaseStyles();
		const expandIconBaseStyles = useExpandIconBaseStyles();
		const mainBaseStyles = useMainBaseStyles();
		const mainStyles = useMainStyles();
		const size$2 = useTreeContext_unstable((ctx) => ctx.size);
		const appearance = useTreeContext_unstable((ctx) => ctx.appearance);
		const itemType = useTreeItemContext_unstable((ctx) => ctx.itemType);
		state.root.className = mergeClasses(treeItemPersonaLayoutClassNames.root, rootBaseStyles, rootStyles[itemType], rootStyles[appearance], rootStyles[size$2], state.root.className);
		state.media.className = mergeClasses(treeItemPersonaLayoutClassNames.media, mediaBaseStyles, state.media.className);
		if (state.main) state.main.className = mergeClasses(treeItemPersonaLayoutClassNames.main, mainBaseStyles, state.description && mainStyles.withDescription, state.main.className);
		if (state.description) state.description.className = mergeClasses(treeItemPersonaLayoutClassNames.description, descriptionBaseStyles, state.description.className);
		if (state.actions) state.actions.className = mergeClasses(treeItemPersonaLayoutClassNames.actions, actionsBaseStyles, state.actions.className);
		if (state.aside) state.aside.className = mergeClasses(treeItemPersonaLayoutClassNames.aside, asideBaseStyles, state.aside.className);
		if (state.expandIcon) state.expandIcon.className = mergeClasses(treeItemPersonaLayoutClassNames.expandIcon, expandIconBaseStyles, state.expandIcon.className);
		if (state.selector) state.selector.className = mergeClasses(treeItemPersonaLayoutClassNames.selector, state.selector.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-tree/lib/components/TreeItem/useTreeItemStyles.styles.js
	const treeItemClassNames = { root: "fui-TreeItem" };
	const useBaseStyles = /* @__PURE__ */ __resetStyles("r15xhw3a", "r2f6k57", [
		".r15xhw3a{position:relative;cursor:pointer;display:flex;flex-direction:column;box-sizing:border-box;background-color:var(--colorSubtleBackground);color:var(--colorNeutralForeground2);padding-right:var(--spacingHorizontalNone);}",
		".r15xhw3a:focus{outline-style:none;}",
		".r15xhw3a:focus-visible{outline-style:none;}",
		".r15xhw3a[data-fui-focus-visible]>.fui-TreeItemLayout,.r15xhw3a[data-fui-focus-visible]>.fui-TreeItemPersonaLayout{border-radius:var(--borderRadiusMedium);outline-color:var(--colorStrokeFocus2);outline-radius:var(--borderRadiusMedium);outline-width:2px;outline-style:solid;}",
		".r2f6k57{position:relative;cursor:pointer;display:flex;flex-direction:column;box-sizing:border-box;background-color:var(--colorSubtleBackground);color:var(--colorNeutralForeground2);padding-left:var(--spacingHorizontalNone);}",
		".r2f6k57:focus{outline-style:none;}",
		".r2f6k57:focus-visible{outline-style:none;}",
		".r2f6k57[data-fui-focus-visible]>.fui-TreeItemLayout,.r2f6k57[data-fui-focus-visible]>.fui-TreeItemPersonaLayout{border-radius:var(--borderRadiusMedium);outline-color:var(--colorStrokeFocus2);outline-radius:var(--borderRadiusMedium);outline-width:2px;outline-style:solid;}"
	]);
	const useStyles$54 = /* @__PURE__ */ __styles({
		level1: { iytv0q: "f10bgyvd" },
		level2: { iytv0q: "f1h0rod3" },
		level3: { iytv0q: "fgoqafk" },
		level4: { iytv0q: "f75dvuh" },
		level5: { iytv0q: "fqk7yw6" },
		level6: { iytv0q: "f1r3z17b" },
		level7: { iytv0q: "f1hrpd1h" },
		level8: { iytv0q: "f1iy65d0" },
		level9: { iytv0q: "ftg42e5" },
		level10: { iytv0q: "fyat3t" }
	}, { d: [
		".f10bgyvd{--fluent-TreeItem--level:1;}",
		".f1h0rod3{--fluent-TreeItem--level:2;}",
		".fgoqafk{--fluent-TreeItem--level:3;}",
		".f75dvuh{--fluent-TreeItem--level:4;}",
		".fqk7yw6{--fluent-TreeItem--level:5;}",
		".f1r3z17b{--fluent-TreeItem--level:6;}",
		".f1hrpd1h{--fluent-TreeItem--level:7;}",
		".f1iy65d0{--fluent-TreeItem--level:8;}",
		".ftg42e5{--fluent-TreeItem--level:9;}",
		".fyat3t{--fluent-TreeItem--level:10;}"
	] });
	/**
	* Apply styling to the TreeItem slots based on the state
	*/
	const useTreeItemStyles_unstable = (state) => {
		"use no memo";
		const baseStyles = useBaseStyles();
		const styles = useStyles$54();
		const { level } = state;
		state.root.className = mergeClasses(treeItemClassNames.root, baseStyles, isStaticallyDefinedLevel(level) && styles[`level${level}`], state.root.className);
		return state;
	};
	function isStaticallyDefinedLevel(level) {
		return level >= 1 && level <= 10;
	}

//#endregion
//#region node_modules/@fluentui/react-tree/lib/components/TreeItem/useTreeItemContextValues.js
	function useTreeItemContextValues_unstable(state) {
		const { value, itemType, layoutRef, subtreeRef, open, expandIconRef, actionsRef, treeItemRef, isActionsVisible, isAsideVisible, selectionRef, checked } = state;
		return { treeItem: {
			value,
			checked,
			itemType,
			layoutRef,
			subtreeRef,
			open,
			selectionRef,
			isActionsVisible,
			isAsideVisible,
			actionsRef,
			treeItemRef,
			expandIconRef
		} };
	}

//#endregion
//#region node_modules/@fluentui/react-tree/lib/components/TreeItem/TreeItem.js
/**
	* The `TreeItem` component represents a single item in a tree.
	* It expects a certain order of children to work properly: the first child should be the node itself,
	* and the second child should be a nested subtree in the form of another Tree component or a standalone TreeItem.
	* This order follows the same order as document traversal for the TreeWalker API in JavaScript:
	* https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker.
	* The content and layout of a TreeItem can be defined using the TreeItemLayout or TreeItemPersonaLayout component,
	* which should be used as a direct child of TreeItem.
	*
	* When a TreeItem has nested child subtree, an expand/collapse control is displayed,
	* allowing the user to show or hide the children.
	*/ const TreeItem = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useTreeItem_unstable(props, ref);
		useTreeItemStyles_unstable(state);
		useCustomStyleHook("useTreeItemStyles_unstable")(state);
		return renderTreeItem_unstable(state, useTreeItemContextValues_unstable(state));
	});
	TreeItem.displayName = "TreeItem";

//#endregion
//#region node_modules/@fluentui/react-tree/lib/components/FlatTreeItem/FlatTreeItem.js
/**
	* The `FlatTreeItem` component represents a single item in a flat tree.
	*/ const FlatTreeItem = TreeItem;

//#endregion
//#region node_modules/@fluentui/react-tree/lib/components/TreeItemPersonaLayout/useTreeItemPersonaLayout.js
/**
	* Create the state required to render TreeItemPersonaLayout.
	*
	* The returned state can be modified with hooks such as useTreeItemPersonaLayoutStyles_unstable,
	* before being passed to renderTreeItemPersonaLayout_unstable.
	*
	* @param props - props from this instance of TreeItemPersonaLayout
	* @param ref - reference to root HTMLElement of TreeItemPersonaLayout
	*/ const useTreeItemPersonaLayout_unstable = (props, ref) => {
		const { media, children, main, description } = props;
		const treeItemLayoutState = useTreeItemLayout_unstable({
			...props,
			iconBefore: null,
			iconAfter: null
		}, ref);
		const size$2 = useTreeContext_unstable((ctx) => ctx.size);
		const selectionMode = useTreeContext_unstable((ctx) => ctx.selectionMode);
		return {
			...treeItemLayoutState,
			components: {
				expandIcon: "div",
				main: "div",
				description: "div",
				root: "div",
				media: "div",
				aside: "div",
				actions: "div",
				selector: selectionMode === "multiselect" ? Checkbox : Radio
			},
			avatarSize: treeAvatarSize[size$2],
			main: always(main, {
				defaultProps: { children },
				elementType: "div"
			}),
			media: always(media, { elementType: "div" }),
			description: optional(description, { elementType: "div" })
		};
	};

//#endregion
//#region node_modules/@fluentui/react-tree/lib/components/TreeItemPersonaLayout/renderTreeItemPersonaLayout.js
/**
	* Render the final JSX of TreeItemPersonaLayout
	*/ const renderTreeItemPersonaLayout_unstable = (state, contextValues) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(state.root, { children: [
			state.expandIcon && /* @__PURE__ */ jsx(state.expandIcon, {}),
			state.selector && /* @__PURE__ */ jsx(state.selector, {}),
			/* @__PURE__ */ jsx(AvatarContextProvider, {
				value: contextValues.avatar,
				children: /* @__PURE__ */ jsx(state.media, {})
			}),
			/* @__PURE__ */ jsx(state.main, {}),
			state.description && /* @__PURE__ */ jsx(state.description, {}),
			/* @__PURE__ */ jsxs(ButtonContextProvider, {
				value: state.buttonContextValue,
				children: [state.actions && /* @__PURE__ */ jsx(state.actions, {}), state.aside && /* @__PURE__ */ jsx(state.aside, {})]
			})
		] });
	};

//#endregion
//#region node_modules/@fluentui/react-tree/lib/components/TreeItemPersonaLayout/useTreeItemPersonaLayoutContextValues.js
	function useTreeItemPersonaLayoutContextValues_unstable(state) {
		const { avatarSize } = state;
		return { avatar: react.useMemo(() => ({ size: avatarSize }), [avatarSize]) };
	}

//#endregion
//#region node_modules/@fluentui/react-tree/lib/components/TreeItemPersonaLayout/TreeItemPersonaLayout.js
/**
	* The `TreeItemPersonaLayout` component is used as a child of `TreeItem` to display a `TreeItem` with a media (typically an avatar) and a description.
	* It provides a more visually appealing representation of a `TreeItem` and is typically used to display a list of people or topics.
	* This component should only be used as a direct child of `TreeItem`.
	*/ const TreeItemPersonaLayout = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useTreeItemPersonaLayout_unstable(props, ref);
		useTreeItemPersonaLayoutStyles_unstable(state);
		useCustomStyleHook("useTreeItemPersonaLayoutStyles_unstable")(state);
		return renderTreeItemPersonaLayout_unstable(state, useTreeItemPersonaLayoutContextValues_unstable(state));
	});
	TreeItemPersonaLayout.displayName = "TreeItemPersonaLayout";

//#endregion
//#region node_modules/@fluentui/react-tree/lib/utils/flattenTree.js
	function flattenTreeRecursive(items, parent$1, level = 1) {
		return items.reduce((acc, { subtree, ...item }, index) => {
			const flatTreeItem = {
				"aria-level": level,
				"aria-posinset": index + 1,
				"aria-setsize": items.length,
				parentValue: parent$1 === null || parent$1 === void 0 ? void 0 : parent$1.value,
				...item
			};
			acc.push(flatTreeItem);
			if (subtree !== void 0) acc.push(...flattenTreeRecursive(subtree, flatTreeItem, level + 1));
			return acc;
		}, []);
	}
	/**
	* Converts a nested structure to a flat one which can be consumed by `useFlatTreeItems`
	* @example
	* ```tsx
	* const defaultItems = flattenTree_unstable([
	*  {
	*    children: <TreeItemLayout>level 1, item 1</TreeItemLayout>,
	*    subtree: [
	*      {
	*        children: <TreeItemLayout>level 2, item 1</TreeItemLayout>,
	*      },
	*      {
	*        children: <TreeItemLayout>level 2, item 2</TreeItemLayout>,
	*      },
	*      {
	*        children: <TreeItemLayout>level 2, item 3</TreeItemLayout>,
	*      },
	*    ],
	*  },
	*  {
	*    children: <TreeItemLayout>level 1, item 2</TreeItemLayout>,
	*    subtree: [
	*      {
	*        children: <TreeItemLayout>level 2, item 1</TreeItemLayout>,
	*        subtree: [
	*          {
	*            children: <TreeItemLayout>level 3, item 1</TreeItemLayout>,
	*            subtree: [
	*              {
	*                children: <TreeItemLayout>level 4, item 1</TreeItemLayout>,
	*              },
	*            ],
	*          },
	*        ],
	*      },
	*    ],
	*  },
	* ]);
	* ```
	*/ const flattenTree_unstable = (items) => flattenTreeRecursive(items);

//#endregion
//#region node_modules/@fluentui/react-tags/lib/contexts/tagGroupContext.js
	const TagGroupContext = /* @__PURE__ */ react.createContext(void 0);
	const tagGroupContextDefaultValue = {
		handleTagDismiss: () => ({}),
		size: "medium",
		role: "toolbar",
		handleTagSelect: void 0
	};
	const TagGroupContextProvider = TagGroupContext.Provider;
	const useTagGroupContext_unstable = () => {
		var _React_useContext;
		return (_React_useContext = react.useContext(TagGroupContext)) !== null && _React_useContext !== void 0 ? _React_useContext : tagGroupContextDefaultValue;
	};

//#endregion
//#region node_modules/@fluentui/react-tags/lib/components/Tag/useTag.js
	const tagAvatarSizeMap = {
		medium: 28,
		small: 20,
		"extra-small": 16
	};
	const tagAvatarShapeMap = {
		rounded: "square",
		circular: "circular"
	};
	/**
	* Create the state required to render Tag.
	*
	* The returned state can be modified with hooks such as useTagStyles_unstable,
	* before being passed to renderTag_unstable.
	*
	* @param props - props from this instance of Tag
	* @param ref - reference to root HTMLSpanElement or HTMLButtonElement of Tag
	*/ const useTag_unstable = (props, ref) => {
		const { handleTagDismiss, size: contextSize, disabled: contextDisabled, appearance: contextAppearance, dismissible: contextDismissible, role: tagGroupRole } = useTagGroupContext_unstable();
		const id = useId("fui-Tag", props.id);
		const { appearance = contextAppearance !== null && contextAppearance !== void 0 ? contextAppearance : "filled", disabled = false, dismissible = contextDismissible !== null && contextDismissible !== void 0 ? contextDismissible : false, selected, shape = "rounded", size: size$2 = contextSize, value = id } = props;
		const dismissOnClick = useEventCallback((ev) => {
			var _props_onClick;
			(_props_onClick = props.onClick) === null || _props_onClick === void 0 || _props_onClick.call(props, ev);
			if (!ev.defaultPrevented) handleTagDismiss === null || handleTagDismiss === void 0 || handleTagDismiss(ev, { value });
		});
		const dismissOnKeyDown = useEventCallback((ev) => {
			var _props_onKeyDown;
			props === null || props === void 0 || (_props_onKeyDown = props.onKeyDown) == null || _props_onKeyDown.call(props, ev);
			if (!ev.defaultPrevented && (ev.key === Delete || ev.key === Backspace)) handleTagDismiss === null || handleTagDismiss === void 0 || handleTagDismiss(ev, { value });
		});
		const elementType = dismissible ? "button" : "span";
		const selectedProp = tagGroupRole === "listbox" ? "aria-selected" : "aria-pressed";
		const selectable = typeof selected === "boolean" || tagGroupRole === "listbox";
		return {
			appearance,
			avatarShape: tagAvatarShapeMap[shape],
			avatarSize: tagAvatarSizeMap[size$2],
			disabled: contextDisabled ? true : disabled,
			dismissible,
			selected: !!selected,
			shape,
			size: size$2,
			components: {
				root: elementType,
				media: "span",
				icon: "span",
				primaryText: "span",
				secondaryText: "span",
				dismissIcon: "span"
			},
			root: always(getIntrinsicElementProps(elementType, {
				ref,
				role: tagGroupRole === "listbox" ? "option" : void 0,
				[selectedProp]: selectable ? selected : void 0,
				...props,
				disabled: contextDisabled ? true : disabled,
				id,
				...dismissible && {
					onClick: dismissOnClick,
					onKeyDown: dismissOnKeyDown
				}
			}), {
				defaultProps: { type: elementType === "button" ? "button" : void 0 },
				elementType
			}),
			media: optional(props.media, { elementType: "span" }),
			icon: optional(props.icon, { elementType: "span" }),
			primaryText: optional(props.primaryText, {
				renderByDefault: true,
				defaultProps: { children: props.children },
				elementType: "span"
			}),
			secondaryText: optional(props.secondaryText, { elementType: "span" }),
			dismissIcon: optional(props.dismissIcon, {
				renderByDefault: dismissible,
				defaultProps: { children: /* @__PURE__ */ react.createElement(DismissRegular, null) },
				elementType: "span"
			})
		};
	};

//#endregion
//#region node_modules/@fluentui/react-tags/lib/components/Tag/renderTag.js
/**
	* Render the final JSX of Tag
	*/ const renderTag_unstable = (state, contextValues) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(state.root, { children: [
			state.media && /* @__PURE__ */ jsx(AvatarContextProvider, {
				value: contextValues.avatar,
				children: /* @__PURE__ */ jsx(state.media, {})
			}),
			state.icon && /* @__PURE__ */ jsx(state.icon, {}),
			state.primaryText && /* @__PURE__ */ jsx(state.primaryText, {}),
			state.secondaryText && /* @__PURE__ */ jsx(state.secondaryText, {}),
			state.dismissIcon && state.dismissible && /* @__PURE__ */ jsx(state.dismissIcon, {})
		] });
	};

//#endregion
//#region node_modules/@fluentui/react-tags/lib/components/Tag/useTagStyles.styles.js
	const tagClassNames = {
		root: "fui-Tag",
		media: "fui-Tag__media",
		icon: "fui-Tag__icon",
		primaryText: "fui-Tag__primaryText",
		secondaryText: "fui-Tag__secondaryText",
		dismissIcon: "fui-Tag__dismissIcon"
	};
	`${tokens.strokeWidthThin}${tokens.colorTransparentStroke}`;
	const useRootRoundedBaseClassName$1 = /* @__PURE__ */ __resetStyles("r18f5o0q", "r1u2q8zc", {
		r: [
			".r18f5o0q{font-family:inherit;padding:0px;-webkit-appearance:button;-moz-appearance:button;appearance:button;text-align:unset;display:inline-grid;align-items:center;grid-template-areas:\"media primary   dismissIcon\" \"media secondary dismissIcon\";box-sizing:border-box;width:fit-content;border:var(--strokeWidthThin) solid var(--colorTransparentStroke);border-radius:var(--borderRadiusMedium);}",
			".r18f5o0q[data-fui-focus-visible]{border-radius:var(--borderRadiusMedium);outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}",
			".r1u2q8zc{font-family:inherit;padding:0px;-webkit-appearance:button;-moz-appearance:button;appearance:button;text-align:unset;display:inline-grid;align-items:center;grid-template-areas:\"media primary   dismissIcon\" \"media secondary dismissIcon\";box-sizing:border-box;width:fit-content;border:var(--strokeWidthThin) solid var(--colorTransparentStroke);border-radius:var(--borderRadiusMedium);}",
			".r1u2q8zc[data-fui-focus-visible]{border-radius:var(--borderRadiusMedium);outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}"
		],
		s: ["@media (forced-colors: active){.r18f5o0q{position:relative;}.r18f5o0q::before{content:\"\";border-top:var(--strokeWidthThin) solid;position:absolute;inset:-1px;border-top-left-radius:var(--borderRadiusMedium);border-top-right-radius:var(--borderRadiusMedium);}}", "@media (forced-colors: active){.r1u2q8zc{position:relative;}.r1u2q8zc::before{content:\"\";border-top:var(--strokeWidthThin) solid;position:absolute;inset:-1px;border-top-right-radius:var(--borderRadiusMedium);border-top-left-radius:var(--borderRadiusMedium);}}"]
	});
	const useRootCircularBaseClassName$1 = /* @__PURE__ */ __resetStyles("r1mko7zc", "r1wx1e29", {
		r: [
			".r1mko7zc{font-family:inherit;padding:0px;-webkit-appearance:button;-moz-appearance:button;appearance:button;text-align:unset;display:inline-grid;align-items:center;grid-template-areas:\"media primary   dismissIcon\" \"media secondary dismissIcon\";box-sizing:border-box;width:fit-content;border:var(--strokeWidthThin) solid var(--colorTransparentStroke);border-radius:var(--borderRadiusCircular);}",
			".r1mko7zc[data-fui-focus-visible]{border-radius:var(--borderRadiusCircular);outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}",
			".r1wx1e29{font-family:inherit;padding:0px;-webkit-appearance:button;-moz-appearance:button;appearance:button;text-align:unset;display:inline-grid;align-items:center;grid-template-areas:\"media primary   dismissIcon\" \"media secondary dismissIcon\";box-sizing:border-box;width:fit-content;border:var(--strokeWidthThin) solid var(--colorTransparentStroke);border-radius:var(--borderRadiusCircular);}",
			".r1wx1e29[data-fui-focus-visible]{border-radius:var(--borderRadiusCircular);outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}"
		],
		s: ["@media (forced-colors: active){.r1mko7zc{position:relative;}.r1mko7zc::before{content:\"\";border-top:var(--strokeWidthThin) solid;border-left:var(--strokeWidthThin) solid;border-right:var(--strokeWidthThin) solid;position:absolute;inset:-1px;border-radius:var(--borderRadiusCircular);}}", "@media (forced-colors: active){.r1wx1e29{position:relative;}.r1wx1e29::before{content:\"\";border-top:var(--strokeWidthThin) solid;border-right:var(--strokeWidthThin) solid;border-left:var(--strokeWidthThin) solid;position:absolute;inset:-1px;border-radius:var(--borderRadiusCircular);}}"]
	});
	const useRootStyles$9 = /* @__PURE__ */ __styles({
		filled: {
			De3pzq: "f16xq7d1",
			sj55zd: "fkfq4zb"
		},
		outline: {
			De3pzq: "fhovq9v",
			sj55zd: "fkfq4zb",
			g2u3we: "fj3muxo",
			h3c5rm: ["f1akhkt", "f1lxtadh"],
			B9xav0g: "f1aperda",
			zhjwy3: ["f1lxtadh", "f1akhkt"]
		},
		brand: {
			De3pzq: "f16xkysk",
			sj55zd: "faj9fo0"
		},
		selected: {
			De3pzq: "ffp7eso",
			sj55zd: "f1phragk",
			g2u3we: "fk9qgl1",
			h3c5rm: ["f1vfbj5f", "f1qpacp7"],
			B9xav0g: "fdf0ba2",
			zhjwy3: ["f1qpacp7", "f1vfbj5f"],
			B8gzw0y: "f1h3a8gf",
			By8wz76: "f1nz3ub2",
			B7iucu3: "fqc85l4"
		},
		medium: { Bqenvij: "f1d2rq10" },
		small: { Bqenvij: "frvgh55" },
		"extra-small": {
			qhf8xq: "f10pi13n",
			Bqenvij: "fjamq6b",
			Ie5t1m: "fru8nlv",
			G6hvz8: "f5nasji",
			wgw0td: "f45hpys",
			Bbwa3xj: ["f1sbfcjn", "f1le4i14"],
			m3mfg4: "fq6y7a1",
			B9s7hj8: "f1jr4pq3",
			B9e1dac: "f1tfer7m"
		}
	}, {
		d: [
			".f16xq7d1{background-color:var(--colorNeutralBackground3);}",
			".fkfq4zb{color:var(--colorNeutralForeground2);}",
			".fhovq9v{background-color:var(--colorSubtleBackground);}",
			".fj3muxo{border-top-color:var(--colorNeutralStroke1);}",
			".f1akhkt{border-right-color:var(--colorNeutralStroke1);}",
			".f1lxtadh{border-left-color:var(--colorNeutralStroke1);}",
			".f1aperda{border-bottom-color:var(--colorNeutralStroke1);}",
			".f16xkysk{background-color:var(--colorBrandBackground2);}",
			".faj9fo0{color:var(--colorBrandForeground2);}",
			".ffp7eso{background-color:var(--colorBrandBackground);}",
			".f1phragk{color:var(--colorNeutralForegroundOnBrand);}",
			".fk9qgl1{border-top-color:var(--colorBrandStroke1);}",
			".f1vfbj5f{border-right-color:var(--colorBrandStroke1);}",
			".f1qpacp7{border-left-color:var(--colorBrandStroke1);}",
			".fdf0ba2{border-bottom-color:var(--colorBrandStroke1);}",
			".f1d2rq10{height:32px;}",
			".frvgh55{height:24px;}",
			".f10pi13n{position:relative;}",
			".fjamq6b{height:20px;}"
		],
		m: [
			["@media (forced-colors: active){.f1h3a8gf{forced-color-adjust:none;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1nz3ub2{background-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fqc85l4{color:HighlightText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: none){.fru8nlv:before,.fru8nlv:after{content:\"\";}}", { m: "(forced-colors: none)" }],
			["@media (forced-colors: none){.f5nasji:before,.f5nasji:after{position:absolute;}}", { m: "(forced-colors: none)" }],
			["@media (forced-colors: none){.f45hpys:before,.f45hpys:after{height:2px;}}", { m: "(forced-colors: none)" }],
			["@media (forced-colors: none){.f1le4i14:before,.f1le4i14:after{right:0;}.f1sbfcjn:before,.f1sbfcjn:after{left:0;}}", { m: "(forced-colors: none)" }],
			["@media (forced-colors: none){.fq6y7a1:before,.fq6y7a1:after{width:100%;}}", { m: "(forced-colors: none)" }],
			["@media (forced-colors: none){.f1jr4pq3:before{bottom:100%;}}", { m: "(forced-colors: none)" }],
			["@media (forced-colors: none){.f1tfer7m:after{top:100%;}}", { m: "(forced-colors: none)" }]
		]
	});
	const useRootDisabledStyles$1 = /* @__PURE__ */ __styles({
		filled: {
			Bceei9c: "fdrzuqr",
			De3pzq: "f1bg9a2p",
			sj55zd: "f1s2aq7o",
			g2u3we: "fgig46g",
			h3c5rm: ["f1mxt3zg", "fziff3p"],
			B9xav0g: "f250w3l",
			zhjwy3: ["fziff3p", "f1mxt3zg"]
		},
		outline: {
			Bceei9c: "fdrzuqr",
			De3pzq: "fhovq9v",
			sj55zd: "f1s2aq7o",
			g2u3we: "f1jj8ep1",
			h3c5rm: ["f15xbau", "fy0fskl"],
			B9xav0g: "f4ikngz",
			zhjwy3: ["fy0fskl", "f15xbau"]
		},
		brand: {
			Bceei9c: "fdrzuqr",
			De3pzq: "f1bg9a2p",
			sj55zd: "f1s2aq7o",
			g2u3we: "fgig46g",
			h3c5rm: ["f1mxt3zg", "fziff3p"],
			B9xav0g: "f250w3l",
			zhjwy3: ["fziff3p", "f1mxt3zg"]
		}
	}, { d: [
		".fdrzuqr{cursor:not-allowed;}",
		".f1bg9a2p{background-color:var(--colorNeutralBackgroundDisabled);}",
		".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}",
		".fgig46g{border-top-color:var(--colorTransparentStrokeDisabled);}",
		".f1mxt3zg{border-right-color:var(--colorTransparentStrokeDisabled);}",
		".fziff3p{border-left-color:var(--colorTransparentStrokeDisabled);}",
		".f250w3l{border-bottom-color:var(--colorTransparentStrokeDisabled);}",
		".fhovq9v{background-color:var(--colorSubtleBackground);}",
		".f1jj8ep1{border-top-color:var(--colorNeutralStrokeDisabled);}",
		".f15xbau{border-right-color:var(--colorNeutralStrokeDisabled);}",
		".fy0fskl{border-left-color:var(--colorNeutralStrokeDisabled);}",
		".f4ikngz{border-bottom-color:var(--colorNeutralStrokeDisabled);}"
	] });
	/**
	* Styles for root slot when Tag is without leading media/icon
	*/
	const useRootWithoutMediaStyles$1 = /* @__PURE__ */ __styles({
		medium: { uwmqm3: ["f1rtp3s9", "f18k1jr3"] },
		small: { uwmqm3: ["f15vdbe4", "fwiuce9"] },
		"extra-small": { uwmqm3: ["f15vdbe4", "fwiuce9"] }
	}, { d: [
		".f1rtp3s9{padding-left:7px;}",
		".f18k1jr3{padding-right:7px;}",
		".f15vdbe4{padding-left:5px;}",
		".fwiuce9{padding-right:5px;}"
	] });
	/**
	* Styles for root slot when Tag is without dismiss icon
	*/
	const useRootWithoutDismissStyles = /* @__PURE__ */ __styles({
		medium: { z189sj: ["f18k1jr3", "f1rtp3s9"] },
		small: { z189sj: ["fwiuce9", "f15vdbe4"] },
		"extra-small": { z189sj: ["fwiuce9", "f15vdbe4"] }
	}, { d: [
		".f18k1jr3{padding-right:7px;}",
		".f1rtp3s9{padding-left:7px;}",
		".fwiuce9{padding-right:5px;}",
		".f15vdbe4{padding-left:5px;}"
	] });
	const useIconStyles$5 = /* @__PURE__ */ __styles({
		base: {
			Bw0ie65: 0,
			Br312pm: 0,
			nk6f5a: 0,
			Ijaq50: 0,
			Bq1tomu: "fujjg13",
			mc9l5x: "f22iagw",
			B7ck84d: "f1e4lqlz"
		},
		medium: {
			uwmqm3: ["f1rtp3s9", "f18k1jr3"],
			z189sj: ["f7x41pl", "fruq291"],
			a9b677: "f64fuq3",
			Be2twd7: "fe5j1ua"
		},
		small: {
			uwmqm3: ["f15vdbe4", "fwiuce9"],
			z189sj: ["ffczdla", "fgiv446"],
			a9b677: "fjw5fx7",
			Be2twd7: "f4ybsrx"
		},
		"extra-small": {
			uwmqm3: ["f15vdbe4", "fwiuce9"],
			z189sj: ["ffczdla", "fgiv446"],
			a9b677: "frx94fk",
			Be2twd7: "f1ugzwwg"
		}
	}, { d: [
		[".fujjg13{grid-area:media;}", { p: -1 }],
		".f22iagw{display:flex;}",
		".f1e4lqlz{box-sizing:content-box;}",
		".f1rtp3s9{padding-left:7px;}",
		".f18k1jr3{padding-right:7px;}",
		".f7x41pl{padding-right:var(--spacingHorizontalXS);}",
		".fruq291{padding-left:var(--spacingHorizontalXS);}",
		".f64fuq3{width:20px;}",
		".fe5j1ua{font-size:20px;}",
		".f15vdbe4{padding-left:5px;}",
		".fwiuce9{padding-right:5px;}",
		".ffczdla{padding-right:var(--spacingHorizontalXXS);}",
		".fgiv446{padding-left:var(--spacingHorizontalXXS);}",
		".fjw5fx7{width:16px;}",
		".f4ybsrx{font-size:16px;}",
		".frx94fk{width:12px;}",
		".f1ugzwwg{font-size:12px;}"
	] });
	const useMediaStyles$1 = /* @__PURE__ */ __styles({
		base: {
			Bw0ie65: 0,
			Br312pm: 0,
			nk6f5a: 0,
			Ijaq50: 0,
			Bq1tomu: "fujjg13",
			mc9l5x: "f22iagw",
			uwmqm3: ["f10xn8zz", "f136y8j8"]
		},
		medium: { z189sj: ["f1vdfbxk", "f1f5gg8d"] },
		small: { z189sj: ["fdw0yi8", "fk8j09s"] },
		"extra-small": { z189sj: ["fdw0yi8", "fk8j09s"] }
	}, { d: [
		[".fujjg13{grid-area:media;}", { p: -1 }],
		".f22iagw{display:flex;}",
		".f10xn8zz{padding-left:1px;}",
		".f136y8j8{padding-right:1px;}",
		".f1vdfbxk{padding-right:var(--spacingHorizontalS);}",
		".f1f5gg8d{padding-left:var(--spacingHorizontalS);}",
		".fdw0yi8{padding-right:var(--spacingHorizontalSNudge);}",
		".fk8j09s{padding-left:var(--spacingHorizontalSNudge);}"
	] });
	const useDismissIconStyles = /* @__PURE__ */ __styles({
		base: {
			Bw0ie65: 0,
			Br312pm: 0,
			nk6f5a: 0,
			Ijaq50: 0,
			Bq1tomu: "f1k1gsvr",
			mc9l5x: "f22iagw",
			Bahaeuw: "f1v3eptx",
			Boo3t63: "f1rfz71x"
		},
		medium: {
			uwmqm3: ["fruq291", "f7x41pl"],
			z189sj: ["f18k1jr3", "f1rtp3s9"],
			Be2twd7: "fe5j1ua"
		},
		small: {
			uwmqm3: ["fgiv446", "ffczdla"],
			z189sj: ["fwiuce9", "f15vdbe4"],
			Be2twd7: "f4ybsrx"
		},
		"extra-small": {
			uwmqm3: ["fgiv446", "ffczdla"],
			z189sj: ["fwiuce9", "f15vdbe4"],
			Be2twd7: "f1ugzwwg"
		},
		filled: {
			eoavqd: "f8491dx",
			Bi91k9c: "f3ymbdj",
			lj723h: "fryz5bw"
		},
		outline: {
			eoavqd: "f8491dx",
			Bi91k9c: "f3ymbdj",
			lj723h: "fryz5bw"
		},
		brand: {
			eoavqd: "f8491dx",
			Bi91k9c: "f3ymbdj",
			lj723h: "fryz5bw"
		},
		selected: {
			Bi91k9c: "f1rq72xc",
			lj723h: "f18otbis"
		}
	}, {
		d: [
			[".f1k1gsvr{grid-area:dismissIcon;}", { p: -1 }],
			".f22iagw{display:flex;}",
			".fruq291{padding-left:var(--spacingHorizontalXS);}",
			".f7x41pl{padding-right:var(--spacingHorizontalXS);}",
			".f18k1jr3{padding-right:7px;}",
			".f1rtp3s9{padding-left:7px;}",
			".fe5j1ua{font-size:20px;}",
			".fgiv446{padding-left:var(--spacingHorizontalXXS);}",
			".ffczdla{padding-right:var(--spacingHorizontalXXS);}",
			".fwiuce9{padding-right:5px;}",
			".f15vdbe4{padding-left:5px;}",
			".f4ybsrx{font-size:16px;}",
			".f1ugzwwg{font-size:12px;}"
		],
		m: [["@media (forced-colors: active){.f1v3eptx:hover{color:Highlight;}}", { m: "(forced-colors: active)" }], ["@media (forced-colors: active){.f1rfz71x:active{color:Highlight;}}", { m: "(forced-colors: active)" }]],
		h: [
			".f8491dx:hover{cursor:pointer;}",
			".f3ymbdj:hover{color:var(--colorCompoundBrandForeground1Hover);}",
			".f1rq72xc:hover{color:var(--colorNeutralForegroundOnBrand);}"
		],
		a: [".fryz5bw:active{color:var(--colorCompoundBrandForeground1Pressed);}", ".f18otbis:active{color:var(--colorNeutralForegroundOnBrand);}"]
	});
	const usePrimaryTextStyles = /* @__PURE__ */ __styles({
		base: {
			Huce71: "fz5stix",
			uwmqm3: ["fgiv446", "ffczdla"],
			z189sj: ["ffczdla", "fgiv446"]
		},
		medium: {
			Bahqtrf: "fk6fouc",
			Be2twd7: "fkhj508",
			Bhrd7zp: "figsok6",
			Bg96gwp: "f1i3iumi"
		},
		small: {
			Bahqtrf: "fk6fouc",
			Be2twd7: "fy9rknc",
			Bhrd7zp: "figsok6",
			Bg96gwp: "fwrc4pm"
		},
		"extra-small": {
			Bahqtrf: "fk6fouc",
			Be2twd7: "fy9rknc",
			Bhrd7zp: "figsok6",
			Bg96gwp: "fwrc4pm"
		},
		withoutSecondaryText: {
			Br312pm: "faqcfhe",
			Ijaq50: "f1q3ipgb",
			nk6f5a: "fc0ab3q",
			Byoj8tv: "f1g03r3y"
		},
		withSecondaryText: {
			Bw0ie65: 0,
			Br312pm: 0,
			nk6f5a: 0,
			Ijaq50: 0,
			Bq1tomu: "f1ebragv",
			Bahqtrf: "fk6fouc",
			Be2twd7: "fy9rknc",
			Bhrd7zp: "figsok6",
			Bg96gwp: "fwrc4pm",
			B6of3ja: "f1ryq6si"
		}
	}, { d: [
		".fz5stix{white-space:nowrap;}",
		".fgiv446{padding-left:var(--spacingHorizontalXXS);}",
		".ffczdla{padding-right:var(--spacingHorizontalXXS);}",
		".fk6fouc{font-family:var(--fontFamilyBase);}",
		".fkhj508{font-size:var(--fontSizeBase300);}",
		".figsok6{font-weight:var(--fontWeightRegular);}",
		".f1i3iumi{line-height:var(--lineHeightBase300);}",
		".fy9rknc{font-size:var(--fontSizeBase200);}",
		".fwrc4pm{line-height:var(--lineHeightBase200);}",
		".faqcfhe{grid-column-start:primary;}",
		".f1q3ipgb{grid-row-start:primary;}",
		".fc0ab3q{grid-row-end:secondary;}",
		".f1g03r3y{padding-bottom:var(--spacingHorizontalXXS);}",
		[".f1ebragv{grid-area:primary;}", { p: -1 }],
		".f1ryq6si{margin-top:-2px;}"
	] });
	const useSecondaryTextBaseClassName = /* @__PURE__ */ __resetStyles("r7hv1ps", "rnrslm9", [".r7hv1ps{grid-area:secondary;padding-left:var(--spacingHorizontalXXS);padding-right:var(--spacingHorizontalXXS);font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase100);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase100);white-space:nowrap;}", ".rnrslm9{grid-area:secondary;padding-right:var(--spacingHorizontalXXS);padding-left:var(--spacingHorizontalXXS);font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase100);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase100);white-space:nowrap;}"]);
	/**
	* Apply styling to the Tag slots based on the state
	*/
	const useTagStyles_unstable = (state) => {
		"use no memo";
		const rootRoundedBaseClassName = useRootRoundedBaseClassName$1();
		const rootCircularBaseClassName = useRootCircularBaseClassName$1();
		const rootStyles = useRootStyles$9();
		const rootDisabledStyles = useRootDisabledStyles$1();
		const rootWithoutMediaStyles = useRootWithoutMediaStyles$1();
		const rootWithoutDismissStyles = useRootWithoutDismissStyles();
		const iconStyles = useIconStyles$5();
		const mediaStyles = useMediaStyles$1();
		const dismissIconStyles = useDismissIconStyles();
		const primaryTextStyles = usePrimaryTextStyles();
		const secondaryTextBaseClassName = useSecondaryTextBaseClassName();
		const { disabled, shape, size: size$2, appearance, selected } = state;
		state.root.className = mergeClasses(tagClassNames.root, shape === "rounded" ? rootRoundedBaseClassName : rootCircularBaseClassName, disabled ? rootDisabledStyles[appearance] : rootStyles[appearance], selected && !disabled && rootStyles.selected, rootStyles[size$2], !state.media && !state.icon && rootWithoutMediaStyles[size$2], !state.dismissIcon && rootWithoutDismissStyles[size$2], state.root.className);
		if (state.media) state.media.className = mergeClasses(tagClassNames.media, mediaStyles.base, mediaStyles[size$2], state.media.className);
		if (state.icon) state.icon.className = mergeClasses(tagClassNames.icon, iconStyles.base, iconStyles[size$2], state.icon.className);
		if (state.primaryText) state.primaryText.className = mergeClasses(tagClassNames.primaryText, primaryTextStyles.base, primaryTextStyles[size$2], state.secondaryText ? primaryTextStyles.withSecondaryText : primaryTextStyles.withoutSecondaryText, state.primaryText.className);
		if (state.secondaryText) state.secondaryText.className = mergeClasses(tagClassNames.secondaryText, secondaryTextBaseClassName, state.secondaryText.className);
		if (state.dismissIcon) state.dismissIcon.className = mergeClasses(tagClassNames.dismissIcon, dismissIconStyles.base, dismissIconStyles[size$2], !disabled && dismissIconStyles[appearance], selected && !disabled && dismissIconStyles.selected, state.dismissIcon.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-tags/lib/utils/useTagAvatarContextValues.js
	function useTagAvatarContextValues_unstable(state) {
		const { avatarSize, avatarShape } = state;
		return { avatar: react.useMemo(() => ({
			size: avatarSize,
			shape: avatarShape
		}), [avatarShape, avatarSize]) };
	}

//#endregion
//#region node_modules/@fluentui/react-tags/lib/components/Tag/Tag.js
/**
	* Tag component -  a visual representation of an attribute.
	* Provides visual attributes such as media, icon, primary and secondary text, as well as the ability to attach an action (by default it is dismiss)
	*/ const Tag = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useTag_unstable(props, ref);
		useTagStyles_unstable(state);
		useCustomStyleHook("useTagStyles_unstable")(state);
		return renderTag_unstable(state, useTagAvatarContextValues_unstable(state));
	});
	Tag.displayName = "Tag";

//#endregion
//#region node_modules/@fluentui/react-tags/lib/components/InteractionTag/useInteractionTag.js
/**
	* Create the state required to render InteractionTag.
	*
	* The returned state can be modified with hooks such as useInteractionTagStyles_unstable,
	* before being passed to renderInteractionTag_unstable.
	*
	* @param props - props from this instance of InteractionTag
	* @param ref - reference to root HTMLDivElement of InteractionTag
	*/ const useInteractionTag_unstable = (props, ref) => {
		const { handleTagDismiss, handleTagSelect, size: contextSize, disabled: contextDisabled, appearance: contextAppearance, selectedValues = [] } = useTagGroupContext_unstable();
		const id = useId("fui-InteractionTag-", props.id);
		const interactionTagPrimaryId = useId("fui-InteractionTagPrimary-");
		const { appearance = contextAppearance !== null && contextAppearance !== void 0 ? contextAppearance : "filled", disabled = false, selected = false, shape = "rounded", size: size$2 = contextSize, value = id } = props;
		return {
			appearance,
			disabled: contextDisabled ? true : disabled,
			handleTagDismiss,
			handleTagSelect,
			interactionTagPrimaryId,
			selected: selectedValues.includes(value) || selected,
			selectedValues,
			shape,
			size: size$2,
			value,
			components: { root: "div" },
			root: always(getIntrinsicElementProps("div", {
				ref,
				...props,
				disabled: contextDisabled ? true : disabled,
				id
			}), { elementType: "div" })
		};
	};

//#endregion
//#region node_modules/@fluentui/react-tags/lib/contexts/interactionTagContext.js
	const InteractionTagContext = /* @__PURE__ */ react.createContext(void 0);
	const interactionTagContextDefaultValue = {
		appearance: "filled",
		disabled: false,
		handleTagDismiss: () => ({}),
		handleTagSelect: () => ({}),
		interactionTagPrimaryId: "",
		selected: false,
		selectedValues: [],
		shape: "rounded",
		size: "medium",
		value: ""
	};
	const InteractionTagContextProvider = InteractionTagContext.Provider;
	const useInteractionTagContext_unstable = () => {
		var _React_useContext;
		return (_React_useContext = react.useContext(InteractionTagContext)) !== null && _React_useContext !== void 0 ? _React_useContext : interactionTagContextDefaultValue;
	};

//#endregion
//#region node_modules/@fluentui/react-tags/lib/components/InteractionTag/renderInteractionTag.js
/**
	* Render the final JSX of InteractionTag
	*/ const renderInteractionTag_unstable = (state, contextValues) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(InteractionTagContextProvider, {
			value: contextValues.interactionTag,
			children: /* @__PURE__ */ jsx(state.root, {})
		});
	};

//#endregion
//#region node_modules/@fluentui/react-tags/lib/components/InteractionTag/useInteractionTagStyles.styles.js
	const interactionTagClassNames = { root: "fui-InteractionTag" };
	const useRootBaseClassName$1 = /* @__PURE__ */ __resetStyles("r1y684pp", null, [".r1y684pp{display:inline-flex;align-items:center;box-sizing:border-box;width:fit-content;}"]);
	const useRootStyles$8 = /* @__PURE__ */ __styles({
		rounded: {
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "ft85np5"
		},
		circular: {
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "f44lkw9"
		},
		medium: { Bqenvij: "f1d2rq10" },
		small: { Bqenvij: "frvgh55" },
		"extra-small": { Bqenvij: "fjamq6b" }
	}, { d: [
		[".ft85np5{border-radius:var(--borderRadiusMedium);}", { p: -1 }],
		[".f44lkw9{border-radius:var(--borderRadiusCircular);}", { p: -1 }],
		".f1d2rq10{height:32px;}",
		".frvgh55{height:24px;}",
		".fjamq6b{height:20px;}"
	] });
	/**
	* Apply styling to the InteractionTag slots based on the state
	*/
	const useInteractionTagStyles_unstable = (state) => {
		"use no memo";
		const rootBaseClassName = useRootBaseClassName$1();
		const rootStyles = useRootStyles$8();
		const { shape, size: size$2 } = state;
		state.root.className = mergeClasses(interactionTagClassNames.root, rootBaseClassName, rootStyles[shape], rootStyles[size$2], state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-tags/lib/components/InteractionTag/useInteractionTagContextValues.js
	function useInteractionTagContextValues_unstable(state) {
		const { appearance, disabled, handleTagDismiss, handleTagSelect, interactionTagPrimaryId, selected, selectedValues, shape, size: size$2, value } = state;
		return { interactionTag: react.useMemo(() => ({
			appearance,
			disabled,
			handleTagDismiss,
			handleTagSelect,
			interactionTagPrimaryId,
			selected,
			selectedValues,
			shape,
			size: size$2,
			value
		}), [
			appearance,
			disabled,
			handleTagDismiss,
			handleTagSelect,
			interactionTagPrimaryId,
			selected,
			selectedValues,
			shape,
			size$2,
			value
		]) };
	}

//#endregion
//#region node_modules/@fluentui/react-tags/lib/components/InteractionTag/InteractionTag.js
/**
	* InteractionTag component - a visual representation of an attribute with primary and secondary actions.
	* Can have `InteractionTagPrimary` and `InteractionTagSecondary` components as its children.
	*/ const InteractionTag = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useInteractionTag_unstable(props, ref);
		useInteractionTagStyles_unstable(state);
		useCustomStyleHook("useInteractionTagStyles_unstable")(state);
		return renderInteractionTag_unstable(state, useInteractionTagContextValues_unstable(state));
	});
	InteractionTag.displayName = "InteractionTag";

//#endregion
//#region node_modules/@fluentui/react-tags/lib/components/InteractionTagPrimary/useInteractionTagPrimary.js
	const avatarSizeMap = {
		medium: 28,
		small: 20,
		"extra-small": 16
	};
	const avatarShapeMap = {
		rounded: "square",
		circular: "circular"
	};
	/**
	* Create the state required to render InteractionTagPrimary.
	*
	* The returned state can be modified with hooks such as useInteractionTagPrimaryStyles_unstable,
	* before being passed to renderInteractionTagPrimary_unstable.
	*
	* @param props - props from this instance of InteractionTagPrimary
	* @param ref - reference to root HTMLButtonElement of InteractionTagPrimary
	*/ const useInteractionTagPrimary_unstable = (props, ref) => {
		const { appearance, disabled, handleTagSelect, interactionTagPrimaryId, selected: contextSelected, selectedValues, shape, size: size$2, value } = useInteractionTagContext_unstable();
		const { hasSecondaryAction = false } = props;
		const onClick = useEventCallback(mergeCallbacks(props === null || props === void 0 ? void 0 : props.onClick, (event) => handleTagSelect === null || handleTagSelect === void 0 ? void 0 : handleTagSelect(event, {
			type: "click",
			event,
			value,
			selectedValues
		})));
		return {
			appearance,
			avatarShape: avatarShapeMap[shape],
			avatarSize: avatarSizeMap[size$2],
			disabled,
			hasSecondaryAction,
			selected: contextSelected,
			shape,
			size: size$2,
			components: {
				root: "button",
				media: "span",
				icon: "span",
				primaryText: "span",
				secondaryText: "span"
			},
			root: always(getIntrinsicElementProps("button", {
				ref,
				disabled,
				id: interactionTagPrimaryId,
				...handleTagSelect !== void 0 && { "aria-pressed": contextSelected },
				onClick,
				...props
			}), { elementType: "button" }),
			media: optional(props.media, { elementType: "span" }),
			icon: optional(props.icon, { elementType: "span" }),
			primaryText: optional(props.primaryText, {
				renderByDefault: true,
				defaultProps: { children: props.children },
				elementType: "span"
			}),
			secondaryText: optional(props.secondaryText, { elementType: "span" })
		};
	};

//#endregion
//#region node_modules/@fluentui/react-tags/lib/components/InteractionTagPrimary/renderInteractionTagPrimary.js
/**
	* Render the final JSX of InteractionTagPrimary
	*/ const renderInteractionTagPrimary_unstable = (state, contextValues) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(state.root, { children: [
			state.media && /* @__PURE__ */ jsx(AvatarContextProvider, {
				value: contextValues.avatar,
				children: /* @__PURE__ */ jsx(state.media, {})
			}),
			state.icon && /* @__PURE__ */ jsx(state.icon, {}),
			state.primaryText && /* @__PURE__ */ jsx(state.primaryText, {}),
			state.secondaryText && /* @__PURE__ */ jsx(state.secondaryText, {})
		] });
	};

//#endregion
//#region node_modules/@fluentui/react-tags/lib/components/InteractionTagPrimary/useInteractionTagPrimaryStyles.styles.js
	const interactionTagPrimaryClassNames = {
		root: "fui-InteractionTagPrimary",
		media: "fui-InteractionTagPrimary__media",
		icon: "fui-InteractionTagPrimary__icon",
		primaryText: "fui-InteractionTagPrimary__primaryText",
		secondaryText: "fui-InteractionTagPrimary__secondaryText"
	};
	`${tokens.strokeWidthThin}${tokens.colorTransparentStroke}`, { .../* @__PURE__ */ createCustomFocusIndicatorStyle({
		outline: `${tokens.strokeWidthThick} solid ${tokens.colorStrokeFocus2}`,
		zIndex: 1
	}) };
	const useRootRoundedBaseClassName = /* @__PURE__ */ __resetStyles("r22quyo", "r1yd8tpa", {
		r: [
			".r22quyo{color:inherit;font-family:inherit;padding:0px;border-style:none;-webkit-appearance:button;-moz-appearance:button;appearance:button;text-align:unset;background-color:transparent;display:inline-grid;height:100%;align-items:center;grid-template-areas:\"media primary  \" \"media secondary\";border:var(--strokeWidthThin) solid var(--colorTransparentStroke);border-radius:var(--borderRadiusMedium);}",
			".r22quyo[data-fui-focus-visible]{outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);z-index:1;}",
			".r1yd8tpa{color:inherit;font-family:inherit;padding:0px;border-style:none;-webkit-appearance:button;-moz-appearance:button;appearance:button;text-align:unset;background-color:transparent;display:inline-grid;height:100%;align-items:center;grid-template-areas:\"media primary  \" \"media secondary\";border:var(--strokeWidthThin) solid var(--colorTransparentStroke);border-radius:var(--borderRadiusMedium);}",
			".r1yd8tpa[data-fui-focus-visible]{outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);z-index:1;}"
		],
		s: ["@media (forced-colors: active){.r22quyo{position:relative;}.r22quyo::before{content:\"\";border-top:var(--strokeWidthThin) solid;position:absolute;inset:-1px;border-top-left-radius:var(--borderRadiusMedium);border-top-right-radius:var(--borderRadiusMedium);}}", "@media (forced-colors: active){.r1yd8tpa{position:relative;}.r1yd8tpa::before{content:\"\";border-top:var(--strokeWidthThin) solid;position:absolute;inset:-1px;border-top-right-radius:var(--borderRadiusMedium);border-top-left-radius:var(--borderRadiusMedium);}}"]
	});
	const useRootCircularBaseClassName = /* @__PURE__ */ __resetStyles("r132q0f6", "r15qe99u", {
		r: [
			".r132q0f6{color:inherit;font-family:inherit;padding:0px;border-style:none;-webkit-appearance:button;-moz-appearance:button;appearance:button;text-align:unset;background-color:transparent;display:inline-grid;height:100%;align-items:center;grid-template-areas:\"media primary  \" \"media secondary\";border:var(--strokeWidthThin) solid var(--colorTransparentStroke);border-radius:var(--borderRadiusCircular);}",
			".r132q0f6[data-fui-focus-visible]{outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);z-index:1;}",
			".r15qe99u{color:inherit;font-family:inherit;padding:0px;border-style:none;-webkit-appearance:button;-moz-appearance:button;appearance:button;text-align:unset;background-color:transparent;display:inline-grid;height:100%;align-items:center;grid-template-areas:\"media primary  \" \"media secondary\";border:var(--strokeWidthThin) solid var(--colorTransparentStroke);border-radius:var(--borderRadiusCircular);}",
			".r15qe99u[data-fui-focus-visible]{outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);z-index:1;}"
		],
		s: ["@media (forced-colors: active){.r132q0f6{position:relative;}.r132q0f6::before{content:\"\";border-top:var(--strokeWidthThin) solid;border-left:var(--strokeWidthThin) solid;position:absolute;inset:-1px;border-top-left-radius:var(--borderRadiusCircular);border-bottom-left-radius:var(--borderRadiusCircular);}}", "@media (forced-colors: active){.r15qe99u{position:relative;}.r15qe99u::before{content:\"\";border-top:var(--strokeWidthThin) solid;border-right:var(--strokeWidthThin) solid;position:absolute;inset:-1px;border-top-right-radius:var(--borderRadiusCircular);border-bottom-right-radius:var(--borderRadiusCircular);}}"]
	});
	/**
	* Style override for pseudo element that draws the border for windows high contrast mode
	*/
	const useRootCircularContrastStyles = /* @__PURE__ */ __styles({ withoutSecondaryAction: {
		Bvgf1ty: "f135udas",
		Cqojjj: 0,
		dd5wkx: 0,
		Bdzpf8n: 0,
		ibz501: ["f1i3lrd2", "fbpt94e"],
		Bs8828g: ["f14bn3u", "fdhx3t9"],
		Bn0yx1x: ["fu87gj3", "f631p13"]
	} }, { m: [
		["@media (forced-colors: active){.f135udas{position:relative;}}", { m: "(forced-colors: active)" }],
		["@media (forced-colors: active){.f1i3lrd2::before{border-right:var(--strokeWidthThin) solid transparent;}.fbpt94e::before{border-left:var(--strokeWidthThin) solid transparent;}}", {
			p: -1,
			m: "(forced-colors: active)"
		}],
		["@media (forced-colors: active){.f14bn3u::before{border-top-right-radius:var(--borderRadiusCircular);}.fdhx3t9::before{border-top-left-radius:var(--borderRadiusCircular);}}", { m: "(forced-colors: active)" }],
		["@media (forced-colors: active){.f631p13::before{border-bottom-left-radius:var(--borderRadiusCircular);}.fu87gj3::before{border-bottom-right-radius:var(--borderRadiusCircular);}}", { m: "(forced-colors: active)" }]
	] });
	const useRootStyles$7 = /* @__PURE__ */ __styles({
		filled: {
			De3pzq: "f16xq7d1",
			sj55zd: "fkfq4zb",
			eoavqd: "f8491dx",
			Jwef8y: "f1h648pw",
			Bi91k9c: "fnwyq0v",
			ecr2s2: "fwdzr64",
			lj723h: "flvvhsy",
			Bbkh6qg: "fkiggi6",
			Cnge2b: "f8zknr1"
		},
		outline: {
			De3pzq: "fhovq9v",
			sj55zd: "fkfq4zb",
			g2u3we: "fj3muxo",
			h3c5rm: ["f1akhkt", "f1lxtadh"],
			B9xav0g: "f1aperda",
			zhjwy3: ["f1lxtadh", "f1akhkt"],
			eoavqd: "f8491dx",
			Jwef8y: "f1t94bn6",
			Bi91k9c: "fnwyq0v",
			Bk3fhr4: "ft1hn21",
			I6i3kg: "fqbfmpb",
			Bmfj8id: "fuxngvv",
			ecr2s2: "f1wfn5kd",
			lj723h: "flvvhsy",
			Bnrwwps: "fvpl5sy",
			weioyw: "f1xblose",
			Bpre390: "f8upcvr",
			Bbkh6qg: "fkiggi6",
			Cnge2b: "f8zknr1"
		},
		brand: {
			De3pzq: "f16xkysk",
			sj55zd: "faj9fo0",
			eoavqd: "f8491dx",
			Jwef8y: "f1yj72w4",
			Bi91k9c: "f3ymbdj",
			ecr2s2: "fy3sl2y",
			lj723h: "fryz5bw",
			Bbkh6qg: "fkiggi6",
			Cnge2b: "f8zknr1"
		},
		selected: {
			Bgh53k4: 0,
			B2eet1l: 0,
			De3pzq: 0,
			Bcmaq0h: 0,
			gk0gix: 0,
			B20660r: 0,
			B8a6bjv: 0,
			Bpptf2m: 0,
			e5kdtc: 0,
			Bkjc3bi: 0,
			ayd6f0: "f1tdnksq",
			sj55zd: "f1phragk",
			g2u3we: "fk9qgl1",
			h3c5rm: ["f1vfbj5f", "f1qpacp7"],
			B9xav0g: "fdf0ba2",
			zhjwy3: ["f1qpacp7", "f1vfbj5f"],
			B8gzw0y: "f1h3a8gf",
			By8wz76: "f1nz3ub2",
			B7iucu3: "fqc85l4",
			Jwef8y: "f15wkkf3",
			Bi91k9c: "f1rq72xc",
			I6i3kg: "f10jvnl4",
			Bbkh6qg: "f1tx4pjd",
			Bahaeuw: "fu37p9p",
			ecr2s2: "fsp1bjw",
			lj723h: "f18otbis",
			weioyw: "f3wpj5r",
			Cnge2b: "f16z8z4r",
			Boo3t63: "f7ydw7o"
		},
		medium: { z189sj: ["f18k1jr3", "f1rtp3s9"] },
		small: { z189sj: ["fwiuce9", "f15vdbe4"] },
		"extra-small": {
			z189sj: ["fwiuce9", "f15vdbe4"],
			qhf8xq: "f10pi13n",
			Ie5t1m: "fru8nlv",
			G6hvz8: "f5nasji",
			wgw0td: "f45hpys",
			Bbwa3xj: ["f1sbfcjn", "f1le4i14"],
			m3mfg4: "fq6y7a1",
			B9s7hj8: "f1jr4pq3",
			B9e1dac: "f1tfer7m"
		}
	}, {
		d: [
			".f16xq7d1{background-color:var(--colorNeutralBackground3);}",
			".fkfq4zb{color:var(--colorNeutralForeground2);}",
			".fhovq9v{background-color:var(--colorSubtleBackground);}",
			".fj3muxo{border-top-color:var(--colorNeutralStroke1);}",
			".f1akhkt{border-right-color:var(--colorNeutralStroke1);}",
			".f1lxtadh{border-left-color:var(--colorNeutralStroke1);}",
			".f1aperda{border-bottom-color:var(--colorNeutralStroke1);}",
			".f16xkysk{background-color:var(--colorBrandBackground2);}",
			".faj9fo0{color:var(--colorBrandForeground2);}",
			[".f1tdnksq{background:var(--colorBrandBackground);}", { p: -2 }],
			".f1phragk{color:var(--colorNeutralForegroundOnBrand);}",
			".fk9qgl1{border-top-color:var(--colorBrandStroke1);}",
			".f1vfbj5f{border-right-color:var(--colorBrandStroke1);}",
			".f1qpacp7{border-left-color:var(--colorBrandStroke1);}",
			".fdf0ba2{border-bottom-color:var(--colorBrandStroke1);}",
			".f18k1jr3{padding-right:7px;}",
			".f1rtp3s9{padding-left:7px;}",
			".fwiuce9{padding-right:5px;}",
			".f15vdbe4{padding-left:5px;}",
			".f10pi13n{position:relative;}"
		],
		h: [
			".f8491dx:hover{cursor:pointer;}",
			".f1h648pw:hover{background-color:var(--colorNeutralBackground3Hover);}",
			".fnwyq0v:hover{color:var(--colorNeutralForeground2Hover);}",
			".f1t94bn6:hover{background-color:var(--colorSubtleBackgroundHover);}",
			".ft1hn21:hover .fui-Icon-filled{display:inline;}",
			".fqbfmpb:hover .fui-Icon-filled{color:var(--colorNeutralForeground2BrandHover);}",
			".fuxngvv:hover .fui-Icon-regular{display:none;}",
			".f1yj72w4:hover{background-color:var(--colorBrandBackground2Hover);}",
			".f3ymbdj:hover{color:var(--colorCompoundBrandForeground1Hover);}",
			".f15wkkf3:hover{background-color:var(--colorBrandBackgroundHover);}",
			".f1rq72xc:hover{color:var(--colorNeutralForegroundOnBrand);}",
			".f10jvnl4:hover .fui-Icon-filled{color:var(--colorNeutralForegroundOnBrand);}"
		],
		a: [
			".fwdzr64:active{background-color:var(--colorNeutralBackground3Pressed);}",
			".flvvhsy:active{color:var(--colorNeutralForeground2Pressed);}",
			".f1wfn5kd:active{background-color:var(--colorSubtleBackgroundPressed);}",
			".fvpl5sy:active .fui-Icon-filled{display:inline;}",
			".f1xblose:active .fui-Icon-filled{color:var(--colorNeutralForeground2BrandPressed);}",
			".f8upcvr:active .fui-Icon-regular{display:none;}",
			".fy3sl2y:active{background-color:var(--colorBrandBackground2Pressed);}",
			".fryz5bw:active{color:var(--colorCompoundBrandForeground1Pressed);}",
			".fsp1bjw:active{background-color:var(--colorBrandBackgroundPressed);}",
			".f18otbis:active{color:var(--colorNeutralForegroundOnBrand);}",
			".f3wpj5r:active .fui-Icon-filled{color:var(--colorNeutralForegroundOnBrand);}"
		],
		m: [
			["@media (forced-colors: active){.fkiggi6:hover{background-color:HighlightText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f8zknr1:active{background-color:HighlightText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1h3a8gf{forced-color-adjust:none;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1nz3ub2{background-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fqc85l4{color:HighlightText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1tx4pjd:hover{background-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fu37p9p:hover{color:HighlightText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f16z8z4r:active{background-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f7ydw7o:active{color:HighlightText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: none){.fru8nlv:before,.fru8nlv:after{content:\"\";}}", { m: "(forced-colors: none)" }],
			["@media (forced-colors: none){.f5nasji:before,.f5nasji:after{position:absolute;}}", { m: "(forced-colors: none)" }],
			["@media (forced-colors: none){.f45hpys:before,.f45hpys:after{height:2px;}}", { m: "(forced-colors: none)" }],
			["@media (forced-colors: none){.f1le4i14:before,.f1le4i14:after{right:0;}.f1sbfcjn:before,.f1sbfcjn:after{left:0;}}", { m: "(forced-colors: none)" }],
			["@media (forced-colors: none){.fq6y7a1:before,.fq6y7a1:after{width:100%;}}", { m: "(forced-colors: none)" }],
			["@media (forced-colors: none){.f1jr4pq3:before{bottom:100%;}}", { m: "(forced-colors: none)" }],
			["@media (forced-colors: none){.f1tfer7m:after{top:100%;}}", { m: "(forced-colors: none)" }]
		]
	});
	const useRootDisabledAppearances = /* @__PURE__ */ __styles({
		filled: {
			Bceei9c: "fdrzuqr",
			De3pzq: "f1bg9a2p",
			sj55zd: "f1s2aq7o",
			g2u3we: "fgig46g",
			h3c5rm: ["f1mxt3zg", "fziff3p"],
			B9xav0g: "f250w3l",
			zhjwy3: ["fziff3p", "f1mxt3zg"]
		},
		outline: {
			Bceei9c: "fdrzuqr",
			De3pzq: "fhovq9v",
			sj55zd: "f1s2aq7o",
			g2u3we: "f1jj8ep1",
			h3c5rm: ["f15xbau", "fy0fskl"],
			B9xav0g: "f4ikngz",
			zhjwy3: ["fy0fskl", "f15xbau"]
		},
		brand: {
			Bceei9c: "fdrzuqr",
			De3pzq: "f1bg9a2p",
			sj55zd: "f1s2aq7o",
			g2u3we: "fgig46g",
			h3c5rm: ["f1mxt3zg", "fziff3p"],
			B9xav0g: "f250w3l",
			zhjwy3: ["fziff3p", "f1mxt3zg"]
		}
	}, { d: [
		".fdrzuqr{cursor:not-allowed;}",
		".f1bg9a2p{background-color:var(--colorNeutralBackgroundDisabled);}",
		".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}",
		".fgig46g{border-top-color:var(--colorTransparentStrokeDisabled);}",
		".f1mxt3zg{border-right-color:var(--colorTransparentStrokeDisabled);}",
		".fziff3p{border-left-color:var(--colorTransparentStrokeDisabled);}",
		".f250w3l{border-bottom-color:var(--colorTransparentStrokeDisabled);}",
		".fhovq9v{background-color:var(--colorSubtleBackground);}",
		".f1jj8ep1{border-top-color:var(--colorNeutralStrokeDisabled);}",
		".f15xbau{border-right-color:var(--colorNeutralStrokeDisabled);}",
		".fy0fskl{border-left-color:var(--colorNeutralStrokeDisabled);}",
		".f4ikngz{border-bottom-color:var(--colorNeutralStrokeDisabled);}"
	] });
	/**
	* Styles for InteractionTagPrimary without leading media/icon
	*/
	const useRootWithoutMediaStyles = /* @__PURE__ */ __styles({
		medium: { uwmqm3: ["f1rtp3s9", "f18k1jr3"] },
		small: { uwmqm3: ["f15vdbe4", "fwiuce9"] },
		"extra-small": { uwmqm3: ["f15vdbe4", "fwiuce9"] }
	}, { d: [
		".f1rtp3s9{padding-left:7px;}",
		".f18k1jr3{padding-right:7px;}",
		".f15vdbe4{padding-left:5px;}",
		".fwiuce9{padding-right:5px;}"
	] });
	/**
	* Styles for InteractionTagPrimary when InteractionTag has a Secondary button
	*/
	const useRootWithSecondaryActionStyles = /* @__PURE__ */ __styles({
		base: {
			B7oj6ja: ["f3fg2lr", "f13av6d4"],
			Bbmb7ep: ["fzi6hpg", "fyowgf4"],
			vrafjx: ["f1n71otn", "f1deefiw"],
			B6xbmo0: ["f146y5a9", "f1k2ftg"],
			kdpuga: ["f1ndz5i7", "f1co4qro"],
			Bs8828g: ["fyvfifd", "fbkbt8g"]
		},
		medium: { z189sj: ["f1vdfbxk", "f1f5gg8d"] },
		small: { z189sj: ["fdw0yi8", "fk8j09s"] },
		"extra-small": { z189sj: ["fdw0yi8", "fk8j09s"] }
	}, {
		d: [
			".f3fg2lr{border-top-right-radius:var(--borderRadiusNone);}",
			".f13av6d4{border-top-left-radius:var(--borderRadiusNone);}",
			".fzi6hpg{border-bottom-right-radius:var(--borderRadiusNone);}",
			".fyowgf4{border-bottom-left-radius:var(--borderRadiusNone);}",
			".f1n71otn{border-right-style:none;}",
			".f1deefiw{border-left-style:none;}",
			".f146y5a9[data-fui-focus-visible]{border-top-right-radius:var(--borderRadiusNone);}",
			".f1k2ftg[data-fui-focus-visible]{border-top-left-radius:var(--borderRadiusNone);}",
			".f1ndz5i7[data-fui-focus-visible]{border-bottom-right-radius:var(--borderRadiusNone);}",
			".f1co4qro[data-fui-focus-visible]{border-bottom-left-radius:var(--borderRadiusNone);}",
			".f1vdfbxk{padding-right:var(--spacingHorizontalS);}",
			".f1f5gg8d{padding-left:var(--spacingHorizontalS);}",
			".fdw0yi8{padding-right:var(--spacingHorizontalSNudge);}",
			".fk8j09s{padding-left:var(--spacingHorizontalSNudge);}"
		],
		m: [["@media (forced-colors: active){.fbkbt8g::before{border-top-left-radius:0;}.fyvfifd::before{border-top-right-radius:0;}}", { m: "(forced-colors: active)" }]]
	});
	const useInteractionTagPrimaryStyles_unstable = (state) => {
		"use no memo";
		const rootRoundedBaseClassName = useRootRoundedBaseClassName();
		const rootCircularBaseClassName = useRootCircularBaseClassName();
		const rootStyles = useRootStyles$7();
		const rootDisabledAppearances = useRootDisabledAppearances();
		const rootWithoutMediaStyles = useRootWithoutMediaStyles();
		const rootWithSecondaryActionStyles = useRootWithSecondaryActionStyles();
		const iconStyles = useIconStyles$5();
		const mediaStyles = useMediaStyles$1();
		const primaryTextStyles = usePrimaryTextStyles();
		const secondaryTextBaseClassName = useSecondaryTextBaseClassName();
		const rootCircularContrastStyles = useRootCircularContrastStyles();
		const { disabled, shape, size: size$2, appearance, selected } = state;
		state.root.className = mergeClasses(interactionTagPrimaryClassNames.root, shape === "rounded" ? rootRoundedBaseClassName : rootCircularBaseClassName, shape === "circular" && !state.hasSecondaryAction && rootCircularContrastStyles.withoutSecondaryAction, disabled ? rootDisabledAppearances[appearance] : rootStyles[appearance], selected && !disabled && rootStyles.selected, rootStyles[size$2], !state.media && !state.icon && rootWithoutMediaStyles[size$2], state.hasSecondaryAction && rootWithSecondaryActionStyles.base, state.hasSecondaryAction && rootWithSecondaryActionStyles[size$2], state.root.className);
		if (state.media) state.media.className = mergeClasses(interactionTagPrimaryClassNames.media, mediaStyles.base, mediaStyles[size$2], state.media.className);
		if (state.icon) state.icon.className = mergeClasses(interactionTagPrimaryClassNames.icon, iconStyles.base, iconStyles[size$2], state.icon.className);
		if (state.primaryText) state.primaryText.className = mergeClasses(interactionTagPrimaryClassNames.primaryText, primaryTextStyles.base, primaryTextStyles[size$2], state.secondaryText ? primaryTextStyles.withSecondaryText : primaryTextStyles.withoutSecondaryText, state.primaryText.className);
		if (state.secondaryText) state.secondaryText.className = mergeClasses(interactionTagPrimaryClassNames.secondaryText, secondaryTextBaseClassName, state.secondaryText.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-tags/lib/components/InteractionTagPrimary/InteractionTagPrimary.js
/**
	* InteractionTagPrimary component - used as the first child of the `InteractionTag` component.
	* Provides visual attributes such as media, icon, primary and secondary text, as well as the ability to attach a primary action.
	*/ const InteractionTagPrimary = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useInteractionTagPrimary_unstable(props, ref);
		useInteractionTagPrimaryStyles_unstable(state);
		useCustomStyleHook("useInteractionTagPrimaryStyles_unstable")(state);
		return renderInteractionTagPrimary_unstable(state, useTagAvatarContextValues_unstable(state));
	});
	InteractionTagPrimary.displayName = "InteractionTagPrimary";

//#endregion
//#region node_modules/@fluentui/react-tags/lib/components/InteractionTagSecondary/useInteractionTagSecondary.js
/**
	* Create the state required to render InteractionTagSecondary.
	*
	* The returned state can be modified with hooks such as useInteractionTagSecondaryStyles_unstable,
	* before being passed to renderInteractionTagSecondary_unstable.
	*
	* @param props - props from this instance of InteractionTagSecondary
	* @param ref - reference to root HTMLButtonElement of InteractionTagSecondary
	*/ const useInteractionTagSecondary_unstable = (props, ref) => {
		const { appearance, disabled, handleTagDismiss, interactionTagPrimaryId, selected, shape, size: size$2, value } = useInteractionTagContext_unstable();
		const id = useId("fui-InteractionTagSecondary-", props.id);
		const onClick = useEventCallback((ev) => {
			var _props_onClick;
			props === null || props === void 0 || (_props_onClick = props.onClick) == null || _props_onClick.call(props, ev);
			if (!ev.defaultPrevented) handleTagDismiss === null || handleTagDismiss === void 0 || handleTagDismiss(ev, { value });
		});
		const onKeyDown = useEventCallback((ev) => {
			var _props_onKeyDown;
			props === null || props === void 0 || (_props_onKeyDown = props.onKeyDown) == null || _props_onKeyDown.call(props, ev);
			if (!ev.defaultPrevented && (ev.key === Delete || ev.key === Backspace)) handleTagDismiss === null || handleTagDismiss === void 0 || handleTagDismiss(ev, { value });
		});
		return {
			appearance,
			disabled,
			selected,
			shape,
			size: size$2,
			components: { root: "button" },
			root: always(getIntrinsicElementProps("button", {
				children: /* @__PURE__ */ react.createElement(DismissRegular, null),
				type: "button",
				disabled,
				ref,
				"aria-labelledby": `${interactionTagPrimaryId} ${id}`,
				...props,
				id,
				onClick,
				onKeyDown
			}), { elementType: "button" })
		};
	};

//#endregion
//#region node_modules/@fluentui/react-tags/lib/components/InteractionTagSecondary/renderInteractionTagSecondary.js
/**
	* Render the final JSX of InteractionTagSecondary
	*/ const renderInteractionTagSecondary_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, {});
	};

//#endregion
//#region node_modules/@fluentui/react-tags/lib/components/InteractionTagSecondary/useInteractionTagSecondaryStyles.styles.js
	const interactionTagSecondaryClassNames = { root: "fui-InteractionTagSecondary" };
	const useRootBaseClassName = /* @__PURE__ */ __resetStyles("rxqbxwz", "rdjx360", [
		".rxqbxwz{color:inherit;font-family:inherit;padding:0px;border-style:none;-webkit-appearance:button;-moz-appearance:button;appearance:button;text-align:unset;background-color:transparent;display:flex;height:100%;align-items:center;border:var(--strokeWidthThin) solid var(--colorTransparentStroke);border-left-color:var(--colorNeutralStroke1);border-top-left-radius:var(--borderRadiusNone);border-bottom-left-radius:var(--borderRadiusNone);}",
		".rxqbxwz[data-fui-focus-visible]{outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}",
		".rdjx360{color:inherit;font-family:inherit;padding:0px;border-style:none;-webkit-appearance:button;-moz-appearance:button;appearance:button;text-align:unset;background-color:transparent;display:flex;height:100%;align-items:center;border:var(--strokeWidthThin) solid var(--colorTransparentStroke);border-right-color:var(--colorNeutralStroke1);border-top-right-radius:var(--borderRadiusNone);border-bottom-right-radius:var(--borderRadiusNone);}",
		".rdjx360[data-fui-focus-visible]{outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}"
	]);
	const useRootStyles$6 = /* @__PURE__ */ __styles({
		filled: {
			De3pzq: "f16xq7d1",
			sj55zd: "fkfq4zb",
			B4j52fo: "fre7gi1",
			Bn0qgzm: "fqdk4by",
			eoavqd: "f8491dx",
			Jwef8y: "f1h648pw",
			Bi91k9c: "f139oj5f",
			ecr2s2: "fwdzr64",
			lj723h: "f19au66r",
			kr9cjb: "fmvl6o9",
			u9orzk: "fb8cdra",
			Bbkh6qg: "fkiggi6",
			Cnge2b: "f8zknr1"
		},
		outline: {
			De3pzq: "fhovq9v",
			sj55zd: "fkfq4zb",
			g2u3we: "fj3muxo",
			h3c5rm: ["f1akhkt", "f1lxtadh"],
			B9xav0g: "f1aperda",
			zhjwy3: ["f1lxtadh", "f1akhkt"],
			eoavqd: "f8491dx",
			Jwef8y: "f1t94bn6",
			Bi91k9c: "f139oj5f",
			ecr2s2: "f1wfn5kd",
			lj723h: "f19au66r",
			Bbkh6qg: "fkiggi6",
			Cnge2b: "f8zknr1"
		},
		brand: {
			De3pzq: "f16xkysk",
			sj55zd: "faj9fo0",
			zhjwy3: ["f1sl6hi9", "f1c8dzaj"],
			B4j52fo: "fre7gi1",
			Bn0qgzm: "fqdk4by",
			eoavqd: "f8491dx",
			Jwef8y: "f1yj72w4",
			Bi91k9c: "f3ymbdj",
			ecr2s2: "fy3sl2y",
			lj723h: "fryz5bw",
			kr9cjb: "fmvl6o9",
			u9orzk: "fb8cdra",
			Bbkh6qg: "fkiggi6",
			Cnge2b: "f8zknr1"
		},
		selected: {
			Bgh53k4: 0,
			B2eet1l: 0,
			De3pzq: 0,
			Bcmaq0h: 0,
			gk0gix: 0,
			B20660r: 0,
			B8a6bjv: 0,
			Bpptf2m: 0,
			e5kdtc: 0,
			Bkjc3bi: 0,
			ayd6f0: "f1tdnksq",
			sj55zd: "f1phragk",
			g2u3we: "fk9qgl1",
			h3c5rm: ["f1vfbj5f", "f1qpacp7"],
			B9xav0g: "fdf0ba2",
			zhjwy3: ["f4j9k2g", "f1mg2euo"],
			B8gzw0y: "f1h3a8gf",
			By8wz76: "f1nz3ub2",
			B7iucu3: "fqc85l4",
			Jwef8y: "f15wkkf3",
			Bi91k9c: "f1rq72xc",
			Bbkh6qg: "f1tx4pjd",
			Bahaeuw: "fu37p9p",
			ecr2s2: "fsp1bjw",
			lj723h: "f18otbis",
			Cnge2b: "f16z8z4r",
			Boo3t63: "f7ydw7o"
		},
		rounded: {
			B7oj6ja: ["f1jar5jt", "fyu767a"],
			Bbmb7ep: ["f1aa9q02", "f16jpd5f"]
		},
		circular: {
			B7oj6ja: ["f1djnp8u", "f1s8kh49"],
			Bbmb7ep: ["f8fbkgy", "f1nfllo7"]
		},
		medium: {
			Be2twd7: "fe5j1ua",
			uwmqm3: ["f15vdbe4", "fwiuce9"],
			z189sj: ["fwiuce9", "f15vdbe4"]
		},
		small: {
			Be2twd7: "f4ybsrx",
			uwmqm3: ["f2lugmd", "f6zblan"],
			z189sj: ["f6zblan", "f2lugmd"]
		},
		"extra-small": {
			Be2twd7: "f1ugzwwg",
			uwmqm3: ["f15vdbe4", "fwiuce9"],
			z189sj: ["fwiuce9", "f15vdbe4"],
			qhf8xq: "f10pi13n",
			Ie5t1m: "fru8nlv",
			G6hvz8: "f5nasji",
			wgw0td: "f45hpys",
			Bbwa3xj: ["f1sbfcjn", "f1le4i14"],
			m3mfg4: "fq6y7a1",
			B9s7hj8: "f1jr4pq3",
			B9e1dac: "f1tfer7m"
		}
	}, {
		d: [
			".f16xq7d1{background-color:var(--colorNeutralBackground3);}",
			".fkfq4zb{color:var(--colorNeutralForeground2);}",
			".fre7gi1{border-top-width:0;}",
			".fqdk4by{border-bottom-width:0;}",
			".fhovq9v{background-color:var(--colorSubtleBackground);}",
			".fj3muxo{border-top-color:var(--colorNeutralStroke1);}",
			".f1akhkt{border-right-color:var(--colorNeutralStroke1);}",
			".f1lxtadh{border-left-color:var(--colorNeutralStroke1);}",
			".f1aperda{border-bottom-color:var(--colorNeutralStroke1);}",
			".f16xkysk{background-color:var(--colorBrandBackground2);}",
			".faj9fo0{color:var(--colorBrandForeground2);}",
			".f1sl6hi9{border-left-color:var(--colorBrandStroke2);}",
			".f1c8dzaj{border-right-color:var(--colorBrandStroke2);}",
			[".f1tdnksq{background:var(--colorBrandBackground);}", { p: -2 }],
			".f1phragk{color:var(--colorNeutralForegroundOnBrand);}",
			".fk9qgl1{border-top-color:var(--colorBrandStroke1);}",
			".f1vfbj5f{border-right-color:var(--colorBrandStroke1);}",
			".f1qpacp7{border-left-color:var(--colorBrandStroke1);}",
			".fdf0ba2{border-bottom-color:var(--colorBrandStroke1);}",
			".f4j9k2g{border-left-color:var(--colorNeutralStrokeOnBrand2);}",
			".f1mg2euo{border-right-color:var(--colorNeutralStrokeOnBrand2);}",
			".f1jar5jt{border-top-right-radius:var(--borderRadiusMedium);}",
			".fyu767a{border-top-left-radius:var(--borderRadiusMedium);}",
			".f1aa9q02{border-bottom-right-radius:var(--borderRadiusMedium);}",
			".f16jpd5f{border-bottom-left-radius:var(--borderRadiusMedium);}",
			".f1djnp8u{border-top-right-radius:var(--borderRadiusCircular);}",
			".f1s8kh49{border-top-left-radius:var(--borderRadiusCircular);}",
			".f8fbkgy{border-bottom-right-radius:var(--borderRadiusCircular);}",
			".f1nfllo7{border-bottom-left-radius:var(--borderRadiusCircular);}",
			".fe5j1ua{font-size:20px;}",
			".f15vdbe4{padding-left:5px;}",
			".fwiuce9{padding-right:5px;}",
			".f4ybsrx{font-size:16px;}",
			".f2lugmd{padding-left:3px;}",
			".f6zblan{padding-right:3px;}",
			".f1ugzwwg{font-size:12px;}",
			".f10pi13n{position:relative;}"
		],
		h: [
			".f8491dx:hover{cursor:pointer;}",
			".f1h648pw:hover{background-color:var(--colorNeutralBackground3Hover);}",
			".f139oj5f:hover{color:var(--colorNeutralForeground2BrandHover);}",
			".f1t94bn6:hover{background-color:var(--colorSubtleBackgroundHover);}",
			".f1yj72w4:hover{background-color:var(--colorBrandBackground2Hover);}",
			".f3ymbdj:hover{color:var(--colorCompoundBrandForeground1Hover);}",
			".f15wkkf3:hover{background-color:var(--colorBrandBackgroundHover);}",
			".f1rq72xc:hover{color:var(--colorNeutralForegroundOnBrand);}"
		],
		a: [
			".fwdzr64:active{background-color:var(--colorNeutralBackground3Pressed);}",
			".f19au66r:active{color:var(--colorNeutralForeground2BrandPressed);}",
			".f1wfn5kd:active{background-color:var(--colorSubtleBackgroundPressed);}",
			".fy3sl2y:active{background-color:var(--colorBrandBackground2Pressed);}",
			".fryz5bw:active{color:var(--colorCompoundBrandForeground1Pressed);}",
			".fsp1bjw:active{background-color:var(--colorBrandBackgroundPressed);}",
			".f18otbis:active{color:var(--colorNeutralForegroundOnBrand);}"
		],
		m: [
			["@media (forced-colors: active){.fmvl6o9{border-top-width:var(--strokeWidthThin);}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fb8cdra{border-bottom-width:var(--strokeWidthThin);}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fkiggi6:hover{background-color:HighlightText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f8zknr1:active{background-color:HighlightText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1h3a8gf{forced-color-adjust:none;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1nz3ub2{background-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fqc85l4{color:HighlightText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1tx4pjd:hover{background-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fu37p9p:hover{color:HighlightText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f16z8z4r:active{background-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f7ydw7o:active{color:HighlightText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: none){.fru8nlv:before,.fru8nlv:after{content:\"\";}}", { m: "(forced-colors: none)" }],
			["@media (forced-colors: none){.f5nasji:before,.f5nasji:after{position:absolute;}}", { m: "(forced-colors: none)" }],
			["@media (forced-colors: none){.f45hpys:before,.f45hpys:after{height:2px;}}", { m: "(forced-colors: none)" }],
			["@media (forced-colors: none){.f1le4i14:before,.f1le4i14:after{right:0;}.f1sbfcjn:before,.f1sbfcjn:after{left:0;}}", { m: "(forced-colors: none)" }],
			["@media (forced-colors: none){.fq6y7a1:before,.fq6y7a1:after{width:100%;}}", { m: "(forced-colors: none)" }],
			["@media (forced-colors: none){.f1jr4pq3:before{bottom:100%;}}", { m: "(forced-colors: none)" }],
			["@media (forced-colors: none){.f1tfer7m:after{top:100%;}}", { m: "(forced-colors: none)" }]
		]
	});
	const useRootDisabledStyles = /* @__PURE__ */ __styles({
		filled: {
			Bceei9c: "fdrzuqr",
			De3pzq: "f1bg9a2p",
			sj55zd: "f1s2aq7o",
			g2u3we: "fgig46g",
			h3c5rm: ["f1mxt3zg", "fziff3p"],
			B9xav0g: "f250w3l",
			zhjwy3: ["fy0fskl", "f15xbau"]
		},
		outline: {
			Bceei9c: "fdrzuqr",
			De3pzq: "fhovq9v",
			sj55zd: "f1s2aq7o",
			g2u3we: "f1jj8ep1",
			h3c5rm: ["f15xbau", "fy0fskl"],
			B9xav0g: "f4ikngz",
			zhjwy3: ["fy0fskl", "f15xbau"]
		},
		brand: {
			Bceei9c: "fdrzuqr",
			De3pzq: "f1bg9a2p",
			sj55zd: "f1s2aq7o",
			g2u3we: "fgig46g",
			h3c5rm: ["f1mxt3zg", "fziff3p"],
			B9xav0g: "f250w3l",
			zhjwy3: ["fy0fskl", "f15xbau"]
		}
	}, { d: [
		".fdrzuqr{cursor:not-allowed;}",
		".f1bg9a2p{background-color:var(--colorNeutralBackgroundDisabled);}",
		".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}",
		".fgig46g{border-top-color:var(--colorTransparentStrokeDisabled);}",
		".f1mxt3zg{border-right-color:var(--colorTransparentStrokeDisabled);}",
		".fziff3p{border-left-color:var(--colorTransparentStrokeDisabled);}",
		".f250w3l{border-bottom-color:var(--colorTransparentStrokeDisabled);}",
		".fy0fskl{border-left-color:var(--colorNeutralStrokeDisabled);}",
		".f15xbau{border-right-color:var(--colorNeutralStrokeDisabled);}",
		".fhovq9v{background-color:var(--colorSubtleBackground);}",
		".f1jj8ep1{border-top-color:var(--colorNeutralStrokeDisabled);}",
		".f4ikngz{border-bottom-color:var(--colorNeutralStrokeDisabled);}"
	] });
	const useInteractionTagSecondaryStyles_unstable = (state) => {
		"use no memo";
		const rootBaseClassName = useRootBaseClassName();
		const rootStyles = useRootStyles$6();
		const rootDisabledStyles = useRootDisabledStyles();
		const { disabled, selected, shape, size: size$2, appearance } = state;
		state.root.className = mergeClasses(interactionTagSecondaryClassNames.root, rootBaseClassName, disabled ? rootDisabledStyles[appearance] : rootStyles[appearance], rootStyles[shape], rootStyles[size$2], selected && !disabled && rootStyles.selected, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-tags/lib/components/InteractionTagSecondary/InteractionTagSecondary.js
/**
	* InteractionTagSecondary component - used as the second child of the `InteractionTag` component and provides the secondary action, which is dismiss by default.
	*/ const InteractionTagSecondary = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useInteractionTagSecondary_unstable(props, ref);
		useInteractionTagSecondaryStyles_unstable(state);
		useCustomStyleHook("useInteractionTagSecondaryStyles_unstable")(state);
		return renderInteractionTagSecondary_unstable(state);
	});
	InteractionTagSecondary.displayName = "InteractionTagSecondary";

//#endregion
//#region node_modules/@fluentui/react-tags/lib/components/TagGroup/useTagGroup.js
/**
	* Create the state required to render TagGroup.
	*
	* The returned state can be modified with hooks such as useTagGroupStyles_unstable,
	* before being passed to renderTagGroup_unstable.
	*
	* @param props - props from this instance of TagGroup
	* @param ref - reference to root HTMLDivElement of TagGroup
	*/ const useTagGroup_unstable = (props, ref) => {
		const { onDismiss, disabled = false, defaultSelectedValues, size: size$2 = "medium", appearance = "filled", dismissible = false, role = "toolbar", onTagSelect, selectedValues, ...rest } = props;
		const innerRef = react.useRef(void 0);
		const { targetDocument } = useFluent();
		const { findNextFocusable, findPrevFocusable } = useFocusFinders();
		const [items, setItems] = useControllableState({
			defaultState: defaultSelectedValues,
			state: selectedValues,
			initialState: []
		});
		const handleTagDismiss = useEventCallback((e, data) => {
			var _innerRef_current;
			onDismiss === null || onDismiss === void 0 || onDismiss(e, data);
			const activeElement = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.activeElement;
			if ((_innerRef_current = innerRef.current) === null || _innerRef_current === void 0 ? void 0 : _innerRef_current.contains(activeElement)) {
				const next$1 = findNextFocusable(activeElement, { container: innerRef.current });
				if (next$1) {
					next$1.focus();
					return;
				}
				if (activeElement === null || activeElement === void 0 ? void 0 : activeElement.className.includes(interactionTagSecondaryClassNames.root)) {
					const prev$1 = findPrevFocusable(activeElement.parentElement, { container: innerRef.current });
					prev$1 === null || prev$1 === void 0 || prev$1.focus();
				} else {
					const prev$1 = findPrevFocusable(activeElement, { container: innerRef.current });
					prev$1 === null || prev$1 === void 0 || prev$1.focus();
				}
			}
		});
		const handleTagSelect = useEventCallback(mergeCallbacks(onTagSelect, (_, data) => {
			if (items.includes(data.value)) setItems(items.filter((item) => item !== data.value));
			else setItems([...items, data.value]);
		}));
		const arrowNavigationProps = useArrowNavigationGroup({
			circular: true,
			axis: "both",
			memorizeCurrent: true
		});
		return {
			handleTagDismiss,
			handleTagSelect: onTagSelect ? handleTagSelect : void 0,
			selectedValues: items,
			role,
			size: size$2,
			disabled,
			appearance,
			dismissible,
			components: { root: "div" },
			root: always(getIntrinsicElementProps("div", {
				ref: useMergedRefs(ref, innerRef),
				role,
				"aria-disabled": disabled,
				...arrowNavigationProps,
				...rest
			}), { elementType: "div" })
		};
	};

//#endregion
//#region node_modules/@fluentui/react-tags/lib/components/TagGroup/renderTagGroup.js
/**
	* Render the final JSX of TagGroup
	*/ const renderTagGroup_unstable = (state, contextValue) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(TagGroupContextProvider, {
			value: contextValue.tagGroup,
			children: /* @__PURE__ */ jsx(state.root, {})
		});
	};

//#endregion
//#region node_modules/@fluentui/react-tags/lib/components/TagGroup/useTagGroupStyles.styles.js
	const tagGroupClassNames = { root: "fui-TagGroup" };
	/**
	* Styles for the root slot
	*/
	const useRootStyles$5 = /* @__PURE__ */ __styles({
		base: { mc9l5x: "ftuwxu6" },
		medium: { i8kkvl: "fsnqrgy" },
		small: { i8kkvl: "f1rjii52" },
		"extra-small": { i8kkvl: "f1ufnopg" }
	}, { d: [
		".ftuwxu6{display:inline-flex;}",
		".fsnqrgy{column-gap:var(--spacingHorizontalS);}",
		".f1rjii52{column-gap:var(--spacingHorizontalSNudge);}",
		".f1ufnopg{column-gap:var(--spacingHorizontalXS);}"
	] });
	/**
	* Apply styling to the TagGroup slots based on the state
	*/
	const useTagGroupStyles_unstable = (state) => {
		"use no memo";
		const styles = useRootStyles$5();
		const { size: size$2 } = state;
		state.root.className = mergeClasses(tagGroupClassNames.root, styles.base, styles[size$2], state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-tags/lib/components/TagGroup/useTagGroupContextValues.js
	function useTagGroupContextValues_unstable(state) {
		const { handleTagDismiss, handleTagSelect, selectedValues, size: size$2, disabled, appearance, dismissible, role } = state;
		return { tagGroup: react.useMemo(() => ({
			handleTagDismiss,
			handleTagSelect,
			selectedValues,
			size: size$2,
			disabled,
			appearance,
			dismissible,
			role
		}), [
			handleTagDismiss,
			handleTagSelect,
			selectedValues,
			size$2,
			disabled,
			appearance,
			dismissible,
			role
		]) };
	}

//#endregion
//#region node_modules/@fluentui/react-tags/lib/components/TagGroup/TagGroup.js
/**
	* TagGroup component - a container for multiple tags.
	* Provides context to size or dismiss children tags.
	*/ const TagGroup = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useTagGroup_unstable(props, ref);
		useTagGroupStyles_unstable(state);
		useCustomStyleHook("useTagGroupStyles_unstable")(state);
		return renderTagGroup_unstable(state, useTagGroupContextValues_unstable(state));
	});
	TagGroup.displayName = "TagGroup";

//#endregion
//#region node_modules/@fluentui/react-message-bar/lib/components/MessageBar/getIntentIcon.js
	function getIntentIcon(intent) {
		switch (intent) {
			case "info": return /* @__PURE__ */ react.createElement(InfoFilled, null);
			case "warning": return /* @__PURE__ */ react.createElement(WarningFilled, null);
			case "error": return /* @__PURE__ */ react.createElement(DismissCircleFilled, null);
			case "success": return /* @__PURE__ */ react.createElement(CheckmarkCircleFilled, null);
			default: return null;
		}
	}

//#endregion
//#region node_modules/@fluentui/react-message-bar/lib/components/MessageBar/useMessageBarReflow.js
	function useMessageBarReflow(enabled = false) {
		const { targetDocument } = useFluent();
		const forceUpdate = react.useReducer(() => ({}), {})[1];
		const reflowingRef = react.useRef(false);
		const resizeObserverRef = react.useRef(null);
		const prevInlineSizeRef = react.useRef(-1);
		const handleResize = react.useCallback((entries) => {
			var _entry_borderBoxSize_, _entry_borderBoxSize;
			if (entries.length > 1) console.error([
				"useMessageBarReflow: Resize observer should only have one entry. ",
				"If multiple entries are observed, the first entry will be used.",
				"This is a bug, please report it to the Fluent UI team."
			].join(" "));
			const entry = entries[0];
			var _entry_borderBoxSize__inlineSize;
			const inlineSize = (_entry_borderBoxSize__inlineSize = entry === null || entry === void 0 ? void 0 : (_entry_borderBoxSize = entry.borderBoxSize) === null || _entry_borderBoxSize === void 0 ? void 0 : (_entry_borderBoxSize_ = _entry_borderBoxSize[0]) === null || _entry_borderBoxSize_ === void 0 ? void 0 : _entry_borderBoxSize_.inlineSize) !== null && _entry_borderBoxSize__inlineSize !== void 0 ? _entry_borderBoxSize__inlineSize : entry === null || entry === void 0 ? void 0 : entry.target.getBoundingClientRect().width;
			if (inlineSize === void 0 || !entry) return;
			const { target } = entry;
			if (!isHTMLElement(target)) return;
			let nextReflowing;
			if (reflowingRef.current) {
				if (prevInlineSizeRef.current < inlineSize) nextReflowing = false;
			} else if (inlineSize < target.scrollWidth) nextReflowing = true;
			prevInlineSizeRef.current = inlineSize;
			if (typeof nextReflowing !== "undefined" && reflowingRef.current !== nextReflowing) {
				reflowingRef.current = nextReflowing;
				forceUpdate();
			}
		}, [forceUpdate]);
		const ref = react.useCallback((el) => {
			var _resizeObserverRef_current;
			if (!enabled || !el || !(targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView)) return;
			(_resizeObserverRef_current = resizeObserverRef.current) === null || _resizeObserverRef_current === void 0 || _resizeObserverRef_current.disconnect();
			const resizeObserver = new targetDocument.defaultView.ResizeObserver(handleResize);
			resizeObserverRef.current = resizeObserver;
			resizeObserver.observe(el, { box: "border-box" });
		}, [
			targetDocument,
			handleResize,
			enabled
		]);
		react.useEffect(() => {
			return () => {
				var _resizeObserverRef_current;
				(_resizeObserverRef_current = resizeObserverRef.current) === null || _resizeObserverRef_current === void 0 || _resizeObserverRef_current.disconnect();
			};
		}, []);
		return {
			ref,
			reflowing: reflowingRef.current
		};
	}

//#endregion
//#region node_modules/@fluentui/react-message-bar/lib/contexts/messageBarTransitionContext.js
	const messageBarTransitionContext = react.createContext(void 0);
	/**
	* @internal
	*/ const messageBarTransitionContextDefaultValue = {
		className: "",
		nodeRef: react.createRef()
	};
	/**
	* Context to pass nodeRef for animation to MessageBar components
	* @internal
	*/ const MessageBarTransitionContextProvider = messageBarTransitionContext.Provider;
	/**
	* @internal
	*/ const useMessageBarTransitionContext = () => {
		var _React_useContext;
		return (_React_useContext = react.useContext(messageBarTransitionContext)) !== null && _React_useContext !== void 0 ? _React_useContext : messageBarTransitionContextDefaultValue;
	};

//#endregion
//#region node_modules/@fluentui/react-message-bar/lib/components/MotionRefForwarder.js
	const MotionRefForwarderContext = /* @__PURE__ */ react.createContext(void 0);
	/**
	* @internal
	*/ function useMotionForwardedRef() {
		return react.useContext(MotionRefForwarderContext);
	}
	/**
	* A component that forwards a ref to its children via a React context.
	*
	* @internal
	*/ const MotionRefForwarder = /* @__PURE__ */ react.forwardRef((props, ref) => {
		return /* @__PURE__ */ react.createElement(MotionRefForwarderContext.Provider, { value: ref }, props.children);
	});

//#endregion
//#region node_modules/@fluentui/react-message-bar/lib/components/MessageBar/useMessageBar.js
/**
	* Create the state required to render MessageBar.
	*
	* The returned state can be modified with hooks such as useMessageBarStyles_unstable,
	* before being passed to renderMessageBar_unstable.
	*
	* @param props - props from this instance of MessageBar
	* @param ref - reference to root HTMLElement of MessageBar
	*/ const useMessageBar_unstable = (props, ref) => {
		const { layout = "auto", intent = "info", politeness, shape = "rounded" } = props;
		const computedPoliteness = (politeness !== null && politeness !== void 0 ? politeness : intent === "info") ? "polite" : "assertive";
		const autoReflow = layout === "auto";
		const { ref: reflowRef, reflowing } = useMessageBarReflow(autoReflow);
		const computedLayout = autoReflow ? reflowing ? "multiline" : "singleline" : layout;
		const { className: transitionClassName, nodeRef } = useMessageBarTransitionContext();
		const motionRef = useMotionForwardedRef();
		const actionsRef = react.useRef(null);
		const bodyRef = react.useRef(null);
		const { announce } = useAnnounce();
		const titleId = useId();
		react.useEffect(() => {
			var _bodyRef_current, _actionsRef_current;
			announce([(_bodyRef_current = bodyRef.current) === null || _bodyRef_current === void 0 ? void 0 : _bodyRef_current.textContent, (_actionsRef_current = actionsRef.current) === null || _actionsRef_current === void 0 ? void 0 : _actionsRef_current.textContent].filter(Boolean).join(","), {
				polite: computedPoliteness === "polite",
				alert: computedPoliteness === "assertive"
			});
		}, [
			bodyRef,
			actionsRef,
			announce,
			computedPoliteness
		]);
		return {
			components: {
				root: "div",
				icon: "div",
				bottomReflowSpacer: "div"
			},
			root: always(getIntrinsicElementProps("div", {
				ref: useMergedRefs(ref, reflowRef, nodeRef, motionRef),
				role: "group",
				"aria-labelledby": titleId,
				...props
			}), { elementType: "div" }),
			icon: optional(props.icon, {
				renderByDefault: true,
				elementType: "div",
				defaultProps: { children: getIntentIcon(intent) }
			}),
			bottomReflowSpacer: optional(props.bottomReflowSpacer, {
				renderByDefault: computedLayout === "multiline",
				elementType: "div"
			}),
			layout: computedLayout,
			intent,
			transitionClassName,
			actionsRef,
			bodyRef,
			titleId,
			shape
		};
	};

//#endregion
//#region node_modules/@fluentui/react-message-bar/lib/contexts/messageBarContext.js
	const messageBarContext = react.createContext(void 0);
	const messageBarContextDefaultValue = {
		titleId: "",
		layout: "singleline",
		actionsRef: react.createRef(),
		bodyRef: react.createRef()
	};
	const MessageBarContextProvider = messageBarContext.Provider;
	const useMessageBarContext = () => {
		var _React_useContext;
		return (_React_useContext = react.useContext(messageBarContext)) !== null && _React_useContext !== void 0 ? _React_useContext : messageBarContextDefaultValue;
	};

//#endregion
//#region node_modules/@fluentui/react-message-bar/lib/components/MessageBar/renderMessageBar.js
/**
	* Render the final JSX of MessageBar
	*/ const renderMessageBar_unstable = (state, contexts) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(MessageBarContextProvider, {
			value: contexts.messageBar,
			children: /* @__PURE__ */ jsxs(state.root, { children: [
				state.icon && /* @__PURE__ */ jsx(state.icon, {}),
				state.root.children,
				state.bottomReflowSpacer && /* @__PURE__ */ jsx(state.bottomReflowSpacer, {})
			] })
		});
	};

//#endregion
//#region node_modules/@fluentui/react-message-bar/lib/components/MessageBar/useMessageBarStyles.styles.js
	const messageBarClassNames = {
		root: "fui-MessageBar",
		icon: "fui-MessageBar__icon",
		bottomReflowSpacer: "fui-MessageBar__bottomReflowSpacer"
	};
	const useRootBaseStyles$5 = /* @__PURE__ */ __resetStyles("r2oyxsj", "r1wuyrhw", [".r2oyxsj{white-space:nowrap;display:grid;grid-template-columns:auto 1fr auto auto;grid-template-rows:1fr;grid-template-areas:\"icon body secondaryActions actions\";padding-left:var(--spacingHorizontalM);border:var(--strokeWidthThin) solid var(--colorNeutralStroke1);border-radius:var(--borderRadiusMedium);align-items:center;min-height:36px;box-sizing:border-box;background-color:var(--colorNeutralBackground3);}", ".r1wuyrhw{white-space:nowrap;display:grid;grid-template-columns:auto 1fr auto auto;grid-template-rows:1fr;grid-template-areas:\"icon body secondaryActions actions\";padding-right:var(--spacingHorizontalM);border:var(--strokeWidthThin) solid var(--colorNeutralStroke1);border-radius:var(--borderRadiusMedium);align-items:center;min-height:36px;box-sizing:border-box;background-color:var(--colorNeutralBackground3);}"]);
	const useIconBaseStyles = /* @__PURE__ */ __resetStyles("r1df1z33", "rivnfjc", [".r1df1z33{grid-area:icon;font-size:var(--fontSizeBase500);margin-right:var(--spacingHorizontalS);color:var(--colorNeutralForeground3);display:flex;align-items:center;}", ".rivnfjc{grid-area:icon;font-size:var(--fontSizeBase500);margin-left:var(--spacingHorizontalS);color:var(--colorNeutralForeground3);display:flex;align-items:center;}"]);
	const useReflowSpacerBaseStyles = /* @__PURE__ */ __resetStyles("r1vx593n", null, [".r1vx593n{margin-bottom:var(--spacingVerticalS);grid-area:secondaryActions;}"]);
	const useStyles$53 = /* @__PURE__ */ __styles({
		rootMultiline: {
			Huce71: "f6juhto",
			Bt984gj: "f1s2louj",
			z8tnut: "f1ngh7ph",
			Budl1dq: "f17g0uqy",
			zoa1oz: "f1w7oly7"
		},
		secondaryActionsMultiline: {
			Brf1p80: "f1e8xxv9",
			B6of3ja: "f1gaxbfw",
			jrapky: "fqcjy3b",
			t21cq0: ["fibjyge", "f9yszdx"]
		},
		square: {
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "fokr779"
		}
	}, { d: [
		".f6juhto{white-space:normal;}",
		".f1s2louj{align-items:start;}",
		".f1ngh7ph{padding-top:var(--spacingVerticalMNudge);}",
		".f17g0uqy{grid-template-columns:auto 1fr auto;}",
		".f1w7oly7{grid-template-areas:\"icon body actions\" \"secondaryActions secondaryActions secondaryActions\";}",
		".f1e8xxv9{justify-content:end;}",
		".f1gaxbfw{margin-top:var(--spacingVerticalMNudge);}",
		".fqcjy3b{margin-bottom:var(--spacingVerticalS);}",
		".fibjyge{margin-right:0px;}",
		".f9yszdx{margin-left:0px;}",
		[".fokr779{border-radius:0;}", { p: -1 }]
	] });
	const useIconIntentStyles = /* @__PURE__ */ __styles({
		info: {},
		error: { sj55zd: "f1ca9wz" },
		warning: { sj55zd: "f14a4cve" },
		success: { sj55zd: "f36rra6" }
	}, { d: [
		".f1ca9wz{color:var(--colorStatusDangerForeground1);}",
		".f14a4cve{color:var(--colorStatusWarningForeground3);}",
		".f36rra6{color:var(--colorStatusSuccessForeground1);}"
	] });
	const useRootIntentStyles = /* @__PURE__ */ __styles({
		info: {},
		error: {
			De3pzq: "f1eon7jj",
			g2u3we: "f1f8dvr7",
			h3c5rm: ["f1g1ijmo", "f1nxacbt"],
			B9xav0g: "fo25q1j",
			zhjwy3: ["f1nxacbt", "f1g1ijmo"]
		},
		warning: {
			De3pzq: "f13ftzij",
			g2u3we: "frd1ypx",
			h3c5rm: ["f1gyjrma", "f18qd5xz"],
			B9xav0g: "fqyqtrt",
			zhjwy3: ["f18qd5xz", "f1gyjrma"]
		},
		success: {
			De3pzq: "f64thcm",
			g2u3we: "f1b4u7v",
			h3c5rm: ["f1nyd2b1", "f70v3om"],
			B9xav0g: "fk173vo",
			zhjwy3: ["f70v3om", "f1nyd2b1"]
		}
	}, { d: [
		".f1eon7jj{background-color:var(--colorStatusDangerBackground1);}",
		".f1f8dvr7{border-top-color:var(--colorStatusDangerBorder1);}",
		".f1g1ijmo{border-right-color:var(--colorStatusDangerBorder1);}",
		".f1nxacbt{border-left-color:var(--colorStatusDangerBorder1);}",
		".fo25q1j{border-bottom-color:var(--colorStatusDangerBorder1);}",
		".f13ftzij{background-color:var(--colorStatusWarningBackground1);}",
		".frd1ypx{border-top-color:var(--colorStatusWarningBorder1);}",
		".f1gyjrma{border-right-color:var(--colorStatusWarningBorder1);}",
		".f18qd5xz{border-left-color:var(--colorStatusWarningBorder1);}",
		".fqyqtrt{border-bottom-color:var(--colorStatusWarningBorder1);}",
		".f64thcm{background-color:var(--colorStatusSuccessBackground1);}",
		".f1b4u7v{border-top-color:var(--colorStatusSuccessBorder1);}",
		".f1nyd2b1{border-right-color:var(--colorStatusSuccessBorder1);}",
		".f70v3om{border-left-color:var(--colorStatusSuccessBorder1);}",
		".fk173vo{border-bottom-color:var(--colorStatusSuccessBorder1);}"
	] });
	/**
	* Apply styling to the MessageBar slots based on the state
	*/
	const useMessageBarStyles_unstable = (state) => {
		"use no memo";
		const rootBaseStyles = useRootBaseStyles$5();
		const iconBaseStyles = useIconBaseStyles();
		const iconIntentStyles = useIconIntentStyles();
		const rootIntentStyles = useRootIntentStyles();
		const reflowSpacerStyles = useReflowSpacerBaseStyles();
		const styles = useStyles$53();
		state.root.className = mergeClasses(messageBarClassNames.root, rootBaseStyles, state.layout === "multiline" && styles.rootMultiline, state.shape === "square" && styles.square, rootIntentStyles[state.intent], state.root.className);
		if (state.icon) state.icon.className = mergeClasses(messageBarClassNames.icon, iconBaseStyles, iconIntentStyles[state.intent], state.icon.className);
		if (state.bottomReflowSpacer) state.bottomReflowSpacer.className = mergeClasses(messageBarClassNames.bottomReflowSpacer, reflowSpacerStyles);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-message-bar/lib/components/MessageBar/useMessageBarContextValues.js
	function useMessageBarContextValue_unstable(state) {
		const { layout, actionsRef, bodyRef, titleId } = state;
		return { messageBar: react.useMemo(() => ({
			layout,
			actionsRef,
			bodyRef,
			titleId
		}), [
			layout,
			actionsRef,
			bodyRef,
			titleId
		]) };
	}

//#endregion
//#region node_modules/@fluentui/react-message-bar/lib/components/MessageBar/MessageBar.js
/**
	* MessageBar component
	*/ const MessageBar = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useMessageBar_unstable(props, ref);
		useMessageBarStyles_unstable(state);
		useCustomStyleHook("useMessageBarStyles_unstable")(state);
		return renderMessageBar_unstable(state, useMessageBarContextValue_unstable(state));
	});
	MessageBar.displayName = "MessageBar";

//#endregion
//#region node_modules/@fluentui/react-message-bar/lib/components/MessageBarTitle/useMessageBarTitle.js
/**
	* Create the state required to render MessageBarTitle.
	*
	* The returned state can be modified with hooks such as useMessageBarTitleStyles_unstable,
	* before being passed to renderMessageBarTitle_unstable.
	*
	* @param props - props from this instance of MessageBarTitle
	* @param ref - reference to root HTMLElement of MessageBarTitle
	*/ const useMessageBarTitle_unstable = (props, ref) => {
		const { titleId } = useMessageBarContext();
		return {
			components: { root: "span" },
			root: always(getIntrinsicElementProps("span", {
				ref,
				id: titleId,
				...props
			}), { elementType: "span" })
		};
	};

//#endregion
//#region node_modules/@fluentui/react-message-bar/lib/components/MessageBarTitle/renderMessageBarTitle.js
/**
	* Render the final JSX of MessageBarTitle
	*/ const renderMessageBarTitle_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, {});
	};

//#endregion
//#region node_modules/@fluentui/react-message-bar/lib/components/MessageBarTitle/useMessageBarTitleStyles.styles.js
	const messageBarTitleClassNames = { root: "fui-MessageBarTitle" };
	/**
	* Styles for the root slot
	*/
	const useRootBaseStyles$4 = /* @__PURE__ */ __resetStyles("r168xkm9", null, [".r168xkm9{font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase300);font-weight:var(--fontWeightSemibold);line-height:var(--lineHeightBase300);}", ".r168xkm9::after{content:\" \";}"]);
	/**
	* Apply styling to the MessageBarTitle slots based on the state
	*/
	const useMessageBarTitleStyles_unstable = (state) => {
		"use no memo";
		const rootBaseStyles = useRootBaseStyles$4();
		state.root.className = mergeClasses(messageBarTitleClassNames.root, rootBaseStyles, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-message-bar/lib/components/MessageBarTitle/MessageBarTitle.js
/**
	* MessageBarTitle component
	*/ const MessageBarTitle = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useMessageBarTitle_unstable(props, ref);
		useMessageBarTitleStyles_unstable(state);
		useCustomStyleHook("useMessageBarTitleStyles_unstable")(state);
		return renderMessageBarTitle_unstable(state);
	});
	MessageBarTitle.displayName = "MessageBarTitle";

//#endregion
//#region node_modules/@fluentui/react-message-bar/lib/components/MessageBarActions/useMessageBarActions.js
/**
	* Create the state required to render MessageBarActions.
	*
	* The returned state can be modified with hooks such as useMessageBarActionsStyles_unstable,
	* before being passed to renderMessageBarActions_unstable.
	*
	* @param props - props from this instance of MessageBarActions
	* @param ref - reference to root HTMLElement of MessageBarActions
	*/ const useMessageBarActions_unstable = (props, ref) => {
		const { layout = "singleline", actionsRef } = useMessageBarContext();
		return {
			components: {
				root: "div",
				containerAction: "div"
			},
			containerAction: optional(props.containerAction, {
				renderByDefault: false,
				elementType: "div"
			}),
			root: always(getIntrinsicElementProps("div", {
				ref: useMergedRefs(ref, actionsRef),
				...props
			}), { elementType: "div" }),
			layout,
			hasActions: !!props.children
		};
	};

//#endregion
//#region node_modules/@fluentui/react-message-bar/lib/components/MessageBarActions/renderMessageBarActions.js
/**
	* Render the final JSX of MessageBarActions
	*/ const renderMessageBarActions_unstable = (state, contexts) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(ButtonContextProvider, {
			value: contexts.button,
			children: [
				state.layout === "multiline" && state.containerAction && /* @__PURE__ */ jsx(state.containerAction, {}, "containerAction"),
				/* @__PURE__ */ jsx(state.root, {}),
				state.layout !== "multiline" && state.containerAction && /* @__PURE__ */ jsx(state.containerAction, {}, "containerAction")
			]
		});
	};

//#endregion
//#region node_modules/@fluentui/react-message-bar/lib/components/MessageBarActions/useMessageBarActionsStyles.styles.js
	const messageBarActionsClassNames = {
		root: "fui-MessageBarActions",
		containerAction: "fui-MessageBarActions__containerAction"
	};
	/**
	* Styles for the root slot
	*/
	const useRootBaseStyles$3 = /* @__PURE__ */ __resetStyles("r1t4x98y", "r15utzv5", [".r1t4x98y{grid-area:secondaryActions;display:flex;column-gap:var(--spacingHorizontalM);padding-right:var(--spacingHorizontalM);}", ".r15utzv5{grid-area:secondaryActions;display:flex;column-gap:var(--spacingHorizontalM);padding-left:var(--spacingHorizontalM);}"]);
	const useContainerActionBaseStyles = /* @__PURE__ */ __resetStyles("rgzw8nq", "r13ur29z", [".rgzw8nq{grid-area:actions;padding-right:var(--spacingHorizontalM);}", ".r13ur29z{grid-area:actions;padding-left:var(--spacingHorizontalM);}"]);
	const useMultilineStyles = /* @__PURE__ */ __styles({
		root: {
			Brf1p80: "f1e8xxv9",
			B6of3ja: "f1gaxbfw",
			jrapky: "fqcjy3b",
			t21cq0: ["fibjyge", "f9yszdx"],
			z189sj: ["f1p3vkop", "f8cewkv"]
		},
		noActions: { mc9l5x: "fjseox" }
	}, { d: [
		".f1e8xxv9{justify-content:end;}",
		".f1gaxbfw{margin-top:var(--spacingVerticalMNudge);}",
		".fqcjy3b{margin-bottom:var(--spacingVerticalS);}",
		".fibjyge{margin-right:0px;}",
		".f9yszdx{margin-left:0px;}",
		".f1p3vkop{padding-right:var(--spacingVerticalM);}",
		".f8cewkv{padding-left:var(--spacingVerticalM);}",
		".fjseox{display:none;}"
	] });
	/**
	* Apply styling to the MessageBarActions slots based on the state
	*/
	const useMessageBarActionsStyles_unstable = (state) => {
		"use no memo";
		const rootBaseStyles = useRootBaseStyles$3();
		const containerActionBaseStyles = useContainerActionBaseStyles();
		const multilineStyles = useMultilineStyles();
		state.root.className = mergeClasses(messageBarActionsClassNames.root, rootBaseStyles, state.layout === "multiline" && multilineStyles.root, !state.hasActions && multilineStyles.noActions, state.root.className);
		if (state.containerAction) state.containerAction.className = mergeClasses(messageBarActionsClassNames.containerAction, containerActionBaseStyles, state.containerAction.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-message-bar/lib/components/MessageBarActions/useMessageBarActionsContextValues.js
	function useMessageBarActionsContextValue_unstable() {
		return { button: react.useMemo(() => ({ size: "small" }), []) };
	}

//#endregion
//#region node_modules/@fluentui/react-message-bar/lib/components/MessageBarActions/MessageBarActions.js
/**
	* MessageBarActions component
	*/ const MessageBarActions = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useMessageBarActions_unstable(props, ref);
		useMessageBarActionsStyles_unstable(state);
		useCustomStyleHook("useMessageBarActionsStyles_unstable")(state);
		return renderMessageBarActions_unstable(state, useMessageBarActionsContextValue_unstable());
	});
	MessageBarActions.displayName = "MessageBarActions";

//#endregion
//#region node_modules/@fluentui/react-message-bar/lib/components/MessageBarBody/useMessageBarBody.js
/**
	* Create the state required to render MessageBarBody.
	*
	* The returned state can be modified with hooks such as useMessageBarBodyStyles_unstable,
	* before being passed to renderMessageBarBody_unstable.
	*
	* @param props - props from this instance of MessageBarBody
	* @param ref - reference to root HTMLElement of MessageBarBody
	*/ const useMessageBarBody_unstable = (props, ref) => {
		const { bodyRef } = useMessageBarContext();
		return {
			components: { root: "div" },
			root: always(getIntrinsicElementProps("div", {
				ref: useMergedRefs(ref, bodyRef),
				...props
			}), { elementType: "div" })
		};
	};

//#endregion
//#region node_modules/@fluentui/react-message-bar/lib/components/MessageBarBody/renderMessageBarBody.js
/**
	* Render the final JSX of MessageBarBody
	*/ const renderMessageBarBody_unstable = (state, contextValues) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(LinkContextProvider, {
			value: contextValues.link,
			children: /* @__PURE__ */ jsx(state.root, {})
		});
	};

//#endregion
//#region node_modules/@fluentui/react-message-bar/lib/components/MessageBarBody/useMessageBarBodyStyles.styles.js
	const messageBarBodyClassNames = { root: "fui-MessageBarBody" };
	const useRootBaseStyles$2 = /* @__PURE__ */ __resetStyles("rtatq2b", "re2rary", [".rtatq2b{font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase300);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase300);grid-area:body;padding-right:var(--spacingHorizontalM);}", ".re2rary{font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase300);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase300);grid-area:body;padding-left:var(--spacingHorizontalM);}"]);
	/**
	* Apply styling to the MessageBarBody slots based on the state
	*/
	const useMessageBarBodyStyles_unstable = (state) => {
		"use no memo";
		const rootBaseStyles = useRootBaseStyles$2();
		state.root.className = mergeClasses(messageBarBodyClassNames.root, rootBaseStyles, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-message-bar/lib/components/MessageBarBody/useMessageBarBodyContextValues.js
	function useMessageBarBodyContextValues_unstable(state) {
		return { link: react.useMemo(() => ({ inline: true }), []) };
	}

//#endregion
//#region node_modules/@fluentui/react-message-bar/lib/components/MessageBarBody/MessageBarBody.js
/**
	* MessageBarBody component
	*/ const MessageBarBody = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useMessageBarBody_unstable(props, ref);
		const ctx = useMessageBarBodyContextValues_unstable(state);
		useMessageBarBodyStyles_unstable(state);
		useCustomStyleHook("useMessageBarBodyStyles_unstable")(state);
		return renderMessageBarBody_unstable(state, ctx);
	});
	MessageBarBody.displayName = "MessageBarBody";

//#endregion
//#region node_modules/@fluentui/react-message-bar/lib/components/MessageBarGroup/useMessageBarGroup.js
/**
	* Create the state required to render MessageBarGroup.
	*
	* The returned state can be modified with hooks such as useMessageBarGroupStyles_unstable,
	* before being passed to renderMessageBarGroup_unstable.
	*
	* @param props - props from this instance of MessageBarGroup
	* @param ref - reference to root HTMLElement of MessageBarGroup
	*/ const useMessageBarGroup_unstable = (props, ref) => {
		react.Children.forEach(props.children, (c) => {
			if (!react.isValidElement(c) || c.type === react.Fragment) throw new Error("MessageBarGroup: children must be valid MessageBar components. Please ensure you're not using fragments. ");
		});
		var _props_children;
		const children = react.Children.map((_props_children = props.children) !== null && _props_children !== void 0 ? _props_children : [], (c) => react.isValidElement(c) && c.type !== react.Fragment ? c : null).filter(Boolean);
		var _props_animate;
		return {
			components: { root: "div" },
			root: always(getIntrinsicElementProps("div", {
				ref,
				...props
			}), { elementType: "div" }),
			children,
			animate: (_props_animate = props.animate) !== null && _props_animate !== void 0 ? _props_animate : "exit-only",
			enterStyles: "",
			exitStyles: ""
		};
	};

//#endregion
//#region node_modules/@fluentui/react-message-bar/lib/components/MessageBarGroup/MessageBarGroup.motions.js
/**
	* A presence component for a MessageBar to enter and exit from a MessageBarGroup.
	* It has an optional enter transition of a slide-in and fade-in,
	* when the `animate` prop is set to `'both'`.
	* It always has an exit transition of a fade-out.
	*/ const MessageBarMotion = createPresenceComponent(({ animate }) => {
		const duration = motionTokens.durationGentle;
		return {
			enter: animate === "both" ? [fadeAtom({
				direction: "enter",
				duration
			}), slideAtom({
				direction: "enter",
				fromY: "-100%",
				duration
			})] : [],
			exit: fadeAtom({
				direction: "exit",
				duration
			})
		};
	});

//#endregion
//#region node_modules/@fluentui/react-message-bar/lib/components/MessageBarGroup/renderMessageBarGroup.js
/**
	* Render the final JSX of MessageBarGroup
	*/ const renderMessageBarGroup_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, { children: /* @__PURE__ */ jsx(PresenceGroup, { children: state.children.map((child) => /* @__PURE__ */ jsx(MessageBarMotion, {
			animate: state.animate,
			unmountOnExit: true,
			children: /* @__PURE__ */ jsx(MotionRefForwarder, { children: child })
		}, child.key)) }) });
	};

//#endregion
//#region node_modules/@fluentui/react-message-bar/lib/components/MessageBarGroup/useMessageBarGroupStyles.styles.js
	const messageBarGroupClassNames = { root: "fui-MessageBarGroup" };
	/**
	* Apply styling to the MessageBarGroup slots based on the state
	*/
	const useMessageBarGroupStyles_unstable = (state) => {
		"use no memo";
		state.root.className = mergeClasses(messageBarGroupClassNames.root, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-message-bar/lib/components/MessageBarGroup/MessageBarGroup.js
/**
	* MessageBarGroup component
	*/ const MessageBarGroup = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useMessageBarGroup_unstable(props, ref);
		useMessageBarGroupStyles_unstable(state);
		useCustomStyleHook("useMessageBarGroupStyles_unstable")(state);
		return renderMessageBarGroup_unstable(state);
	});
	MessageBarGroup.displayName = "MessageBarGroup";

//#endregion
//#region node_modules/@fluentui/react-infolabel/lib/components/InfoLabel/renderInfoLabel.js
/**
	* Render the final JSX of InfoLabel
	*/ const renderInfoLabel_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(state.root, { children: [/* @__PURE__ */ jsx(state.label, {}), state.infoButton && /* @__PURE__ */ jsx(state.infoButton, {})] });
	};

//#endregion
//#region node_modules/@fluentui/react-infolabel/lib/components/InfoButton/renderInfoButton.js
/**
	* Render the final JSX of InfoButton
	*/ const renderInfoButton_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(state.popover, { children: [/* @__PURE__ */ jsx(PopoverTrigger, { children: /* @__PURE__ */ jsx(state.root, {}) }), /* @__PURE__ */ jsx(state.info, {})] });
	};

//#endregion
//#region node_modules/@fluentui/react-infolabel/lib/components/InfoButton/DefaultInfoButtonIcons.js
	const DefaultInfoButtonIcon12 = bundleIcon_default(Info12Filled, Info12Regular);
	const DefaultInfoButtonIcon16 = bundleIcon_default(Info16Filled, Info16Regular);
	const DefaultInfoButtonIcon20 = bundleIcon_default(Info20Filled, Info20Regular);

//#endregion
//#region node_modules/@fluentui/react-infolabel/lib/components/InfoButton/useInfoButton.js
	const infoButtonIconMap = {
		small: /* @__PURE__ */ react.createElement(DefaultInfoButtonIcon12, null),
		medium: /* @__PURE__ */ react.createElement(DefaultInfoButtonIcon16, null),
		large: /* @__PURE__ */ react.createElement(DefaultInfoButtonIcon20, null)
	};
	const popoverSizeMap = {
		small: "small",
		medium: "small",
		large: "medium"
	};
	/**
	* Create the state required to render InfoButton.
	*
	* The returned state can be modified with hooks such as useInfoButtonStyles_unstable,
	* before being passed to renderInfoButton_unstable.
	*
	* @param props - props from this instance of InfoButton
	* @param ref - reference to root HTMLButtonElement of InfoButton
	*/ const useInfoButton_unstable = (props, ref) => {
		const { size: size$2 = "medium", inline = true, popover, info, ...rest } = props;
		const rootRef = useMergedRefs(ref);
		const state = {
			inline,
			size: size$2,
			components: {
				root: "button",
				popover: Popover,
				info: PopoverSurface
			},
			root: always(getIntrinsicElementProps("button", {
				children: infoButtonIconMap[size$2],
				type: "button",
				"aria-label": "information",
				...rest,
				ref: rootRef
			}), { elementType: "button" }),
			popover: always(popover, {
				defaultProps: {
					inline,
					positioning: "above-start",
					size: popoverSizeMap[size$2],
					withArrow: true
				},
				elementType: Popover
			}),
			info: always(info, {
				defaultProps: {
					role: "note",
					tabIndex: -1
				},
				elementType: PopoverSurface
			})
		};
		const [popoverOpen, setPopoverOpen] = useControllableState({
			state: state.popover.open,
			defaultState: state.popover.defaultOpen,
			initialState: false
		});
		state.popover.open = popoverOpen;
		state.popover.onOpenChange = mergeCallbacks(state.popover.onOpenChange, (e, data) => setPopoverOpen(data.open));
		const infoRef = useMergedRefs(state.info.ref);
		state.info.ref = infoRef;
		const onBlurButtonOrInfo = (e) => {
			const nextFocused = e.relatedTarget;
			if (nextFocused && rootRef.current !== nextFocused && !elementContains(infoRef.current, nextFocused)) setPopoverOpen(false);
		};
		state.root.onBlur = useEventCallback(mergeCallbacks(state.root.onBlur, onBlurButtonOrInfo));
		state.info.onBlurCapture = useEventCallback(mergeCallbacks(state.info.onBlurCapture, onBlurButtonOrInfo));
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-infolabel/lib/components/InfoButton/useInfoButtonStyles.styles.js
	const infoButtonClassNames = {
		root: "fui-InfoButton",
		popover: "fui-InfoButton__popover",
		info: "fui-InfoButton__info"
	};
	/**
	* Styles for the root slot
	*/
	const useButtonStyles = /* @__PURE__ */ __styles({
		base: {
			Bt984gj: "f122n59",
			B7ck84d: "f1ewtqcl",
			mc9l5x: "ftuwxu6",
			Brf1p80: "f4d9j23",
			w71qe1: "f1iuv45f",
			ha4doy: "fmrv4ls",
			qhf8xq: "f10pi13n",
			De3pzq: "f1c21dwh",
			sj55zd: "fkfq4zb",
			icvyot: "f1ern45e",
			vrafjx: ["f1n71otn", "f1deefiw"],
			oivjwe: "f1h8hb77",
			wvpqe5: ["f1deefiw", "f1n71otn"],
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "ft85np5",
			jrapky: 0,
			Frg6f3: 0,
			t21cq0: 0,
			B6of3ja: 0,
			B74szlk: "f1s184ao",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f16d74zd",
			D0sxk3: "f16u1re",
			t6yez3: "f1rw4040",
			Jwef8y: "fjxutwb",
			Bi91k9c: "f139oj5f",
			eoavqd: "f8491dx",
			Bk3fhr4: "f1jpd6y0",
			Bmfj8id: "fuxngvv",
			iro3zm: "fwiml72",
			B2d53fq: "f1fg1p5m"
		},
		selected: {
			De3pzq: "f1q9pm1r",
			sj55zd: "f1qj7y59",
			D0sxk3: "fgzdkf0",
			t6yez3: "f15q0o9g",
			By8wz76: "f1nz3ub2",
			B7iucu3: "f1205bnn"
		},
		highContrast: {
			B7iucu3: "fslfhp6",
			Bfsdueo: "f11s1vgy",
			pb71ee: "f12b7wpn",
			ik86qs: "f1u668rv"
		},
		focusIndicator: {
			Brovlpu: "ftqa4ok",
			B486eqv: "f2hkw1w",
			B8q5s1w: "f8hki3x",
			Bci5o5g: ["f1d2448m", "ffh67wi"],
			n8qw10: "f1bjia2o",
			Bdrgwmp: ["ffh67wi", "f1d2448m"],
			Bqhya38: "f1j6vpng",
			Bwxa6fj: ["f1pniga2", "f1ffjurs"],
			Bdhvstf: "f987i1v",
			B7zbvrb: ["f1ffjurs", "f1pniga2"],
			Bm4h7ae: "f15bsgw9",
			B7ys5i9: "f14e48fq",
			Busjfv9: "f18yb2kv",
			Bhk32uz: "fd6o370",
			f6g5ot: 0,
			Boxcth7: 0,
			Bhdgwq3: 0,
			hgwjuy: 0,
			Bshpdp8: 0,
			Bsom6fd: 0,
			Blkhhs4: 0,
			Bonggc9: 0,
			Ddfuxk: 0,
			i03rao: 0,
			kclons: 0,
			clg4pj: 0,
			Bpqj9nj: 0,
			B6dhp37: 0,
			Bf4ptjt: 0,
			Bqtpl0w: 0,
			i4rwgc: "ffwy5si",
			Dah5zi: 0,
			B1tsrr9: 0,
			qqdqy8: 0,
			Bkh64rk: 0,
			e3fwne: "f3znvyf",
			J0r882: "f57olzd",
			Bule8hv: ["f4stah7", "fs1por5"],
			Bjwuhne: "f480a47",
			Ghsupd: ["fs1por5", "f4stah7"]
		},
		large: {
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f1kx978o"
		}
	}, {
		d: [
			".f122n59{align-items:center;}",
			".f1ewtqcl{box-sizing:border-box;}",
			".ftuwxu6{display:inline-flex;}",
			".f4d9j23{justify-content:center;}",
			".f1iuv45f{text-decoration-line:none;}",
			".fmrv4ls{vertical-align:middle;}",
			".f10pi13n{position:relative;}",
			".f1c21dwh{background-color:var(--colorTransparentBackground);}",
			".fkfq4zb{color:var(--colorNeutralForeground2);}",
			".f1ern45e{border-top-style:none;}",
			".f1n71otn{border-right-style:none;}",
			".f1deefiw{border-left-style:none;}",
			".f1h8hb77{border-bottom-style:none;}",
			[".ft85np5{border-radius:var(--borderRadiusMedium);}", { p: -1 }],
			[".f1s184ao{margin:0;}", { p: -1 }],
			[".f16d74zd{padding:var(--spacingVerticalXS) var(--spacingHorizontalXS);}", { p: -1 }],
			".f16u1re .fui-Icon-filled{display:none;}",
			".f1rw4040 .fui-Icon-regular{display:inline-flex;}",
			".f1q9pm1r{background-color:var(--colorTransparentBackgroundSelected);}",
			".f1qj7y59{color:var(--colorNeutralForeground2BrandSelected);}",
			".fgzdkf0 .fui-Icon-filled{display:inline-flex;}",
			".f15q0o9g .fui-Icon-regular{display:none;}",
			".f8hki3x[data-fui-focus-visible]{border-top-color:transparent;}",
			".f1d2448m[data-fui-focus-visible]{border-right-color:transparent;}",
			".ffh67wi[data-fui-focus-visible]{border-left-color:transparent;}",
			".f1bjia2o[data-fui-focus-visible]{border-bottom-color:transparent;}",
			".f15bsgw9[data-fui-focus-visible]::after{content:\"\";}",
			".f14e48fq[data-fui-focus-visible]::after{position:absolute;}",
			".f18yb2kv[data-fui-focus-visible]::after{pointer-events:none;}",
			".fd6o370[data-fui-focus-visible]::after{z-index:1;}",
			[".ffwy5si[data-fui-focus-visible]::after{border:2px solid var(--colorStrokeFocus2);}", { p: -2 }],
			[".f3znvyf[data-fui-focus-visible]::after{border-radius:var(--borderRadiusMedium);}", { p: -1 }],
			".f57olzd[data-fui-focus-visible]::after{top:calc(2px * -1);}",
			".f4stah7[data-fui-focus-visible]::after{right:calc(2px * -1);}",
			".fs1por5[data-fui-focus-visible]::after{left:calc(2px * -1);}",
			".f480a47[data-fui-focus-visible]::after{bottom:calc(2px * -1);}",
			[".f1kx978o{padding:var(--spacingVerticalXXS) var(--spacingVerticalXXS);}", { p: -1 }]
		],
		h: [
			".fjxutwb:hover{background-color:var(--colorTransparentBackgroundHover);}",
			".f139oj5f:hover{color:var(--colorNeutralForeground2BrandHover);}",
			".f8491dx:hover{cursor:pointer;}",
			".f1jpd6y0:hover .fui-Icon-filled{display:inline-flex;}",
			".fuxngvv:hover .fui-Icon-regular{display:none;}",
			".fwiml72:hover:active{background-color:var(--colorTransparentBackgroundPressed);}",
			".f1fg1p5m:hover:active{color:var(--colorNeutralForeground2BrandPressed);}"
		],
		m: [
			["@media (forced-colors: active){.f1nz3ub2{background-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1205bnn{color:Canvas;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fslfhp6{color:CanvasText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f11s1vgy:hover,.f11s1vgy:hover:active{forced-color-adjust:none;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f12b7wpn:hover,.f12b7wpn:hover:active{background-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1u668rv:hover,.f1u668rv:hover:active{color:Canvas;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1j6vpng[data-fui-focus-visible]::after{border-top-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1ffjurs[data-fui-focus-visible]::after{border-left-color:Highlight;}.f1pniga2[data-fui-focus-visible]::after{border-right-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f987i1v[data-fui-focus-visible]::after{border-bottom-color:Highlight;}}", { m: "(forced-colors: active)" }]
		],
		f: [".ftqa4ok:focus{outline-style:none;}"],
		i: [".f2hkw1w:focus-visible{outline-style:none;}"]
	});
	const usePopoverSurfaceStyles = /* @__PURE__ */ __styles({
		base: { B2u0y6b: "f1qmtlvf" },
		smallMedium: {
			Bahqtrf: "fk6fouc",
			Be2twd7: "fy9rknc",
			Bhrd7zp: "figsok6",
			Bg96gwp: "fwrc4pm"
		},
		large: {
			Bahqtrf: "fk6fouc",
			Be2twd7: "fkhj508",
			Bhrd7zp: "figsok6",
			Bg96gwp: "f1i3iumi"
		}
	}, { d: [
		".f1qmtlvf{max-width:264px;}",
		".fk6fouc{font-family:var(--fontFamilyBase);}",
		".fy9rknc{font-size:var(--fontSizeBase200);}",
		".figsok6{font-weight:var(--fontWeightRegular);}",
		".fwrc4pm{line-height:var(--lineHeightBase200);}",
		".fkhj508{font-size:var(--fontSizeBase300);}",
		".f1i3iumi{line-height:var(--lineHeightBase300);}"
	] });
	/**
	* Apply styling to the InfoButton slots based on the state
	*/
	const useInfoButtonStyles_unstable = (state) => {
		"use no memo";
		const { size: size$2 } = state;
		const { open } = state.popover;
		const buttonStyles = useButtonStyles();
		const popoverSurfaceStyles = usePopoverSurfaceStyles();
		state.info.className = mergeClasses(infoButtonClassNames.info, popoverSurfaceStyles.base, size$2 === "large" ? popoverSurfaceStyles.large : popoverSurfaceStyles.smallMedium, state.info.className);
		state.root.className = mergeClasses(infoButtonClassNames.root, buttonStyles.base, buttonStyles.highContrast, buttonStyles.focusIndicator, open && buttonStyles.selected, size$2 === "large" && buttonStyles.large, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-infolabel/lib/components/InfoButton/InfoButton.js
/**
	* InfoButtons provide a way to display additional information about a form field or an area in the UI.
	*/ const InfoButton = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useInfoButton_unstable(props, ref);
		useInfoButtonStyles_unstable(state);
		useCustomStyleHook("useInfoButtonStyles_unstable")(state);
		return renderInfoButton_unstable(state);
	});
	InfoButton.displayName = "InfoButton";

//#endregion
//#region node_modules/@fluentui/react-infolabel/lib/components/InfoLabel/useInfoLabel.js
/**
	* Create the state required to render InfoLabel.
	*
	* The returned state can be modified with hooks such as useInfoLabelStyles_unstable,
	* before being passed to renderInfoLabel_unstable.
	*
	* @param props - props from this instance of InfoLabel
	* @param ref - reference to label element of InfoLabel
	*/ const useInfoLabel_unstable = (props, ref) => {
		const { root: rootShorthand, label: labelShorthand, infoButton: infoButtonShorthand, info, size: size$2, className, style, ...labelProps } = props;
		const baseId = useId("infolabel-");
		const [open, setOpen] = react.useState(false);
		const root = always(rootShorthand, {
			defaultProps: {
				className,
				style
			},
			elementType: "span"
		});
		const label = always(labelShorthand, {
			defaultProps: {
				id: baseId + "__label",
				ref,
				size: size$2,
				...labelProps
			},
			elementType: Label
		});
		const infoButton = optional(infoButtonShorthand, {
			renderByDefault: !!info,
			defaultProps: {
				id: baseId + "__infoButton",
				size: size$2,
				info
			},
			elementType: InfoButton
		});
		const infoButtonPopover = always(infoButton === null || infoButton === void 0 ? void 0 : infoButton.popover, { elementType: "div" });
		infoButtonPopover.onOpenChange = useEventCallback(mergeCallbacks(infoButtonPopover.onOpenChange, (_$1, data) => {
			setOpen(data.open);
		}));
		if (infoButton) {
			var _infoButton, _arialabelledby;
			infoButton.popover = infoButtonPopover;
			const infoPopupId = baseId + "__info";
			infoButton.info = optional(infoButton === null || infoButton === void 0 ? void 0 : infoButton.info, {
				defaultProps: {
					id: infoPopupId,
					"aria-labelledby": infoPopupId
				},
				elementType: "div"
			});
			var _;
			(_ = (_infoButton = infoButton)[_arialabelledby = "aria-labelledby"]) !== null && _ !== void 0 || (_infoButton[_arialabelledby] = `${label.id} ${infoButton.id}`);
			if (open) {
				var _infoButton_info;
				var _root, _ariaowns;
				var _1;
				(_1 = (_root = root)[_ariaowns = "aria-owns"]) !== null && _1 !== void 0 || (_root[_ariaowns] = (_infoButton_info = infoButton.info) === null || _infoButton_info === void 0 ? void 0 : _infoButton_info.id);
			}
		}
		return {
			size: size$2,
			components: {
				root: "span",
				label: Label,
				infoButton: InfoButton
			},
			root,
			label,
			infoButton
		};
	};

//#endregion
//#region node_modules/@fluentui/react-infolabel/lib/components/InfoLabel/useInfoLabelStyles.styles.js
	const infoLabelClassNames = {
		root: "fui-InfoLabel",
		label: "fui-InfoLabel__label",
		infoButton: "fui-InfoLabel__infoButton"
	};
	const useLabelStyles$1 = /* @__PURE__ */ __styles({ base: {
		ha4doy: "f12kltsn",
		Bceei9c: "fpo1scq",
		sj55zd: "f1ym3bx4"
	} }, { d: [
		".f12kltsn{vertical-align:top;}",
		".fpo1scq{cursor:inherit;}",
		".f1ym3bx4{color:inherit;}"
	] });
	const useInfoButtonStyles = /* @__PURE__ */ __styles({
		base: {
			ha4doy: "f12kltsn",
			B6of3ja: "f1bmzb36",
			jrapky: "f1nyzk09"
		},
		large: {
			B6of3ja: "fkrn0sh",
			jrapky: "fmxx68s"
		}
	}, { d: [
		".f12kltsn{vertical-align:top;}",
		".f1bmzb36{margin-top:calc(0px - var(--spacingVerticalXXS));}",
		".f1nyzk09{margin-bottom:calc(0px - var(--spacingVerticalXXS));}",
		".fkrn0sh{margin-top:-1px;}",
		".fmxx68s{margin-bottom:-1px;}"
	] });
	/**
	* Apply styling to the InfoLabel slots based on the state
	*/
	const useInfoLabelStyles_unstable = (state) => {
		"use no memo";
		state.root.className = mergeClasses(infoLabelClassNames.root, state.root.className);
		const labelStyles = useLabelStyles$1();
		state.label.className = mergeClasses(infoLabelClassNames.label, labelStyles.base, state.label.className);
		const infoButtonStyles = useInfoButtonStyles();
		if (state.infoButton) state.infoButton.className = mergeClasses(infoLabelClassNames.infoButton, infoButtonStyles.base, state.size === "large" && infoButtonStyles.large, state.infoButton.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-infolabel/lib/components/InfoLabel/InfoLabel.js
/**
	* InfoLabel component
	*/ const InfoLabel = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useInfoLabel_unstable(props, ref);
		useInfoLabelStyles_unstable(state);
		useCustomStyleHook("useInfoLabelStyles_unstable")(state);
		return renderInfoLabel_unstable(state);
	});
	InfoLabel.displayName = "InfoLabel";

//#endregion
//#region node_modules/@fluentui/react-drawer/lib/contexts/drawerContext.js
	const defaultContextValue = {
		scrollState: "none",
		setScrollState: () => ({})
	};
	const drawerContext = react.createContext(void 0);
	const DrawerProvider = drawerContext.Provider;
	const useDrawerContext_unstable = () => {
		var _React_useContext;
		return (_React_useContext = react.useContext(drawerContext)) !== null && _React_useContext !== void 0 ? _React_useContext : defaultContextValue;
	};
	const useDrawerContextValue = () => {
		const [scrollState, setScrollState] = react.useState("none");
		return {
			setScrollState,
			scrollState
		};
	};

//#endregion
//#region node_modules/@fluentui/react-drawer/lib/shared/useDrawerBaseStyles.styles.js
/**
	* CSS variable names used internally for uniform styling in Drawer.
	*/
	const drawerCSSVars = { drawerSizeVar: "--fui-Drawer--size" };
	/**
	* Default shared styles for the Drawer component
	*/
	const drawerDefaultStyles = {
		overflow: "hidden",
		width: `var(${drawerCSSVars.drawerSizeVar})`,
		maxWidth: "100vw",
		height: "auto",
		maxHeight: "100vh",
		boxSizing: "border-box",
		display: "flex",
		flexDirection: "column",
		alignItems: "flex-start",
		justifyContent: "flex-start",
		backgroundColor: tokens.colorNeutralBackground1,
		color: tokens.colorNeutralForeground1
	};
	/**
	* Shared dynamic styles for the Drawer component
	*/
	const useDrawerStyles = /* @__PURE__ */ __styles({
		start: {
			h3c5rm: 0,
			vrafjx: 0,
			Bekrc4i: 0,
			u1mtju: ["f1xteiwb", "fsqykmd"],
			oyh7mz: ["f1vgc2s3", "f1e31b4d"],
			j35jbq: ["fvfyk4", "frppm18"]
		},
		end: {
			zhjwy3: 0,
			wvpqe5: 0,
			ibv6hh: 0,
			B4g9neb: ["fsqykmd", "f1xteiwb"],
			j35jbq: ["f1e31b4d", "f1vgc2s3"],
			oyh7mz: ["frppm18", "fvfyk4"]
		},
		bottom: {
			B5kzvoi: "f1yab3r1",
			Bhzewxz: "f198g47y"
		},
		small: { Bjr0ffy: "f1exhnwo" },
		medium: { Bjr0ffy: "fqofjzu" },
		large: { Bjr0ffy: "fce6y3m" },
		full: { Bjr0ffy: "fsdmzs6" }
	}, { d: [
		[".f1xteiwb{border-right:var(--strokeWidthThin) solid var(--colorTransparentStroke);}", { p: -1 }],
		[".fsqykmd{border-left:var(--strokeWidthThin) solid var(--colorTransparentStroke);}", { p: -1 }],
		".f1vgc2s3{left:0;}",
		".f1e31b4d{right:0;}",
		".fvfyk4{right:auto;}",
		".frppm18{left:auto;}",
		[".fsqykmd{border-left:var(--strokeWidthThin) solid var(--colorTransparentStroke);}", { p: -1 }],
		[".f1xteiwb{border-right:var(--strokeWidthThin) solid var(--colorTransparentStroke);}", { p: -1 }],
		".f1yab3r1{bottom:0;}",
		".f198g47y{top:auto;}",
		".f1exhnwo{--fui-Drawer--size:320px;}",
		".fqofjzu{--fui-Drawer--size:592px;}",
		".fce6y3m{--fui-Drawer--size:940px;}",
		".fsdmzs6{--fui-Drawer--size:100vw;}"
	] });
	const useDrawerBottomBaseStyles = /* @__PURE__ */ __styles({
		small: { Bjr0ffy: "f1exhnwo" },
		medium: { Bjr0ffy: "fqofjzu" },
		large: { Bjr0ffy: "fce6y3m" },
		full: { Bjr0ffy: "f1rat34m" }
	}, { d: [
		".f1exhnwo{--fui-Drawer--size:320px;}",
		".fqofjzu{--fui-Drawer--size:592px;}",
		".fce6y3m{--fui-Drawer--size:940px;}",
		".f1rat34m{--fui-Drawer--size:100%;}"
	] });
	const useDrawerBaseClassNames = ({ position: position$1, size: size$2 }) => {
		const baseStyles = useDrawerStyles();
		const bottomBaseStyles = useDrawerBottomBaseStyles();
		return mergeClasses(baseStyles[position$1], position$1 === "bottom" && bottomBaseStyles[size$2], position$1 !== "bottom" && baseStyles[size$2]);
	};

//#endregion
//#region node_modules/@fluentui/react-drawer/lib/shared/drawerMotions.js
	const durations = {
		small: motionTokens.durationGentle,
		medium: motionTokens.durationSlow,
		large: motionTokens.durationSlower,
		full: motionTokens.durationUltraSlow
	};
	/**
	* @internal
	*/ function getPositionTransform(position$1, sizeVar, dir) {
		const leftToRightTransform = `translate3d(var(${sizeVar}), 0, 0)`;
		const rightToLeftTransform = `translate3d(calc(var(${sizeVar}) * -1), 0, 0)`;
		const bottomToTopTransform = `translate3d(0, var(${sizeVar}), 0)`;
		if (position$1 === "start") return dir === "ltr" ? rightToLeftTransform : leftToRightTransform;
		if (position$1 === "end") return dir === "ltr" ? leftToRightTransform : rightToLeftTransform;
		if (position$1 === "bottom") return bottomToTopTransform;
		return "translate3d(0, 0, 0)";
	}
	/**
	* @internal
	*/ const InlineDrawerMotion = createPresenceComponent(({ position: position$1, size: size$2, dir }) => {
		const keyframes = [{
			transform: getPositionTransform(position$1, drawerCSSVars.drawerSizeVar, dir),
			opacity: 0
		}, {
			transform: "translate3d(0, 0, 0)",
			opacity: 1
		}];
		const duration = durations[size$2];
		return {
			enter: {
				keyframes,
				duration,
				easing: motionTokens.curveDecelerateMid
			},
			exit: {
				keyframes: [...keyframes].reverse(),
				duration,
				easing: motionTokens.curveAccelerateMin
			}
		};
	});
	/**
	* @internal
	*/ const OverlayDrawerMotion = createPresenceComponent(({ position: position$1, size: size$2, dir }) => {
		const keyframes = [{
			transform: getPositionTransform(position$1, drawerCSSVars.drawerSizeVar, dir),
			boxShadow: `0px ${tokens.colorTransparentBackground}`,
			opacity: 0
		}, {
			transform: "translate3d(0, 0, 0)",
			boxShadow: tokens.shadow64,
			opacity: 1
		}];
		const duration = durations[size$2];
		return {
			enter: {
				keyframes,
				duration,
				easing: motionTokens.curveDecelerateMid
			},
			exit: {
				keyframes: [...keyframes].reverse(),
				duration,
				easing: motionTokens.curveAccelerateMin
			}
		};
	});
	/**
	* @internal
	*/ const OverlaySurfaceBackdropMotion = createPresenceComponent(({ size: size$2 }) => {
		const duration = durations[size$2];
		const easing = motionTokens.curveLinear;
		return {
			enter: fadeAtom({
				direction: "enter",
				duration,
				easing
			}),
			exit: fadeAtom({
				direction: "exit",
				duration,
				easing
			})
		};
	});

//#endregion
//#region node_modules/@fluentui/react-drawer/lib/shared/useDrawerDefaultProps.js
	function useDrawerDefaultProps(props) {
		const { open = false, size: size$2 = "small", position: position$1 = "start", unmountOnClose = true } = props;
		return {
			size: size$2,
			position: position$1,
			open,
			unmountOnClose
		};
	}

//#endregion
//#region node_modules/@fluentui/react-drawer/lib/components/OverlayDrawer/OverlayDrawerSurface/useOverlayDrawerSurfaceStyles.styles.js
/**
	* Styles for the backdrop slot
	*/
	const useBackdropResetStyles = /* @__PURE__ */ __resetStyles("rl76ifk", null, [".rl76ifk{inset:0px;position:fixed;background-color:var(--colorBackgroundOverlay);}"]);
	const useBackdropStyles = /* @__PURE__ */ __styles({
		nested: { De3pzq: "f1c21dwh" },
		drawerHidden: { Bkecrkj: "f1aehjj5" }
	}, { d: [".f1c21dwh{background-color:var(--colorTransparentBackground);}", ".f1aehjj5{pointer-events:none;}"] });
	/**
	* Apply styling to the OverlayDrawerSurface slots based on the state
	*/
	const useOverlayDrawerSurfaceStyles_unstable = (state) => {
		"use no memo";
		const { isNestedDialog, backdrop, open, unmountOnClose } = state;
		const backdropResetStyles = useBackdropResetStyles();
		const backdropStyles = useBackdropStyles();
		const mountedAndClosed = !unmountOnClose && !open;
		if (backdrop) backdrop.className = mergeClasses(backdropResetStyles, isNestedDialog && backdropStyles.nested, mountedAndClosed && backdropStyles.drawerHidden, backdrop.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-drawer/lib/components/OverlayDrawer/OverlayDrawerSurface/OverlayDrawerSurface.js
/**
	* @internal
	* OverlayDrawerSurface is a proxy for DialogSurface as is only meant to be used internally for Drawer.
	*/ const OverlayDrawerSurface = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const dialogSurfaceState = useDialogSurface_unstable({
			...props,
			as: props.as
		}, ref);
		const dialogSurfaceContextValues = useDialogSurfaceContextValues_unstable(dialogSurfaceState);
		useOverlayDrawerSurfaceStyles_unstable(dialogSurfaceState);
		useCustomStyleHook("useOverlayDrawerSurfaceStyles_unstable")(dialogSurfaceState);
		return renderDialogSurface_unstable(dialogSurfaceState, dialogSurfaceContextValues);
	});
	OverlayDrawerSurface.displayName = "OverlayDrawerSurface";

//#endregion
//#region node_modules/@fluentui/react-drawer/lib/shared/drawerMotionUtils.js
/**
	* @internal
	* @todo Drawer is a first component to use this pattern, we should move this to a shared package if it will be used in more components
	*/ function mergePresenceSlots(inputSlot, Component, params) {
		if (inputSlot === null) return null;
		return {
			...inputSlot,
			children: (_, props) => {
				if (inputSlot === null || inputSlot === void 0 ? void 0 : inputSlot.children) return inputSlot.children(Component, {
					...props,
					...params
				});
				return /* @__PURE__ */ react.createElement(Component, {
					...props,
					...params
				}, props.children);
			}
		};
	}

//#endregion
//#region node_modules/@fluentui/react-drawer/lib/components/OverlayDrawer/useOverlayDrawer.js
	const STATIC_MOTION$1 = {
		active: true,
		canRender: true,
		ref: /* @__PURE__ */ react.createRef(),
		type: "idle"
	};
	/**
	* Create the state required to render OverlayDrawer.
	*
	* The returned state can be modified with hooks such as useOverlayDrawerStyles_unstable,
	* before being passed to renderOverlayDrawer_unstable.
	*
	* @param props - props from this instance of OverlayDrawer
	* @param ref - reference to root HTMLElement of OverlayDrawer
	*/ const useOverlayDrawer_unstable = (props, ref) => {
		const { open, size: size$2, position: position$1, unmountOnClose } = useDrawerDefaultProps(props);
		const { modalType = "modal", inertTrapFocus, onOpenChange, backdropMotion, surfaceMotion, mountNode } = props;
		const { dir, targetDocument } = useFluent();
		const { element: mountNodeElement } = toMountNodeProps(mountNode);
		const hasMountNodeElement = Boolean(mountNodeElement && (targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.body) !== mountNodeElement);
		const backdropProps = resolveShorthand$1(props.backdrop);
		const hasCustomBackdrop = modalType !== "non-modal" && backdropProps !== null;
		const root = always({
			...props,
			ref,
			unmountOnClose,
			backdrop: hasCustomBackdrop ? { ...backdropProps } : null,
			backdropMotion: mergePresenceSlots(backdropMotion, OverlaySurfaceBackdropMotion, { size: size$2 })
		}, { elementType: OverlayDrawerSurface });
		const dialog = always({
			open,
			onOpenChange,
			inertTrapFocus,
			modalType,
			unmountOnClose,
			surfaceMotion: mergePresenceSlots(surfaceMotion, OverlayDrawerMotion, {
				position: position$1,
				size: size$2,
				dir
			}),
			children: null
		}, { elementType: Dialog });
		return {
			components: {
				root: OverlayDrawerSurface,
				dialog: Dialog
			},
			root,
			dialog,
			open,
			size: size$2,
			position: position$1,
			hasMountNodeElement,
			unmountOnClose,
			mountNode,
			motion: STATIC_MOTION$1
		};
	};

//#endregion
//#region node_modules/@fluentui/react-drawer/lib/components/OverlayDrawer/renderOverlayDrawer.js
/**
	* Render the final JSX of OverlayDrawer
	*/ const renderOverlayDrawer_unstable = (state, contextValue) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(DrawerProvider, {
			value: contextValue,
			children: /* @__PURE__ */ jsx(state.dialog, { children: /* @__PURE__ */ jsx(state.root, {}) })
		});
	};

//#endregion
//#region node_modules/@fluentui/react-drawer/lib/components/OverlayDrawer/useOverlayDrawerStyles.styles.js
	const overlayDrawerClassNames = {
		root: "fui-OverlayDrawer",
		backdrop: "fui-OverlayDrawer__backdrop"
	};
	/**
	* Styles for the root slot
	*/
	const useDrawerResetStyles$1 = /* @__PURE__ */ __resetStyles("r7dfyj8", "rmx02j7", {
		r: [
			".r7dfyj8{overflow:hidden;width:var(--fui-Drawer--size);max-width:100vw;height:auto;max-height:100vh;box-sizing:border-box;display:flex;flex-direction:column;align-items:flex-start;justify-content:flex-start;background-color:var(--colorNeutralBackground1);color:var(--colorNeutralForeground1);position:fixed;top:0;bottom:0;}",
			".r7dfyj8:focus{outline-style:none;}",
			".r7dfyj8:focus-visible{outline-style:none;}",
			".r7dfyj8[data-fui-focus-visible]{border-top-color:transparent;border-right-color:transparent;border-bottom-color:transparent;border-left-color:transparent;}",
			".r7dfyj8[data-fui-focus-visible]::after{content:\"\";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);right:calc(2px * -1);bottom:calc(2px * -1);left:calc(2px * -1);}",
			".rmx02j7{overflow:hidden;width:var(--fui-Drawer--size);max-width:100vw;height:auto;max-height:100vh;box-sizing:border-box;display:flex;flex-direction:column;align-items:flex-start;justify-content:flex-start;background-color:var(--colorNeutralBackground1);color:var(--colorNeutralForeground1);position:fixed;top:0;bottom:0;}",
			".rmx02j7:focus{outline-style:none;}",
			".rmx02j7:focus-visible{outline-style:none;}",
			".rmx02j7[data-fui-focus-visible]{border-top-color:transparent;border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent;}",
			".rmx02j7[data-fui-focus-visible]::after{content:\"\";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);left:calc(2px * -1);bottom:calc(2px * -1);right:calc(2px * -1);}"
		],
		s: ["@media (forced-colors: active){.r7dfyj8[data-fui-focus-visible]::after{border-top-color:Highlight;border-right-color:Highlight;border-bottom-color:Highlight;border-left-color:Highlight;}}", "@media (forced-colors: active){.rmx02j7[data-fui-focus-visible]::after{border-top-color:Highlight;border-left-color:Highlight;border-bottom-color:Highlight;border-right-color:Highlight;}}"]
	});
	const useDrawerRootStyles$1 = /* @__PURE__ */ __styles({
		start: {},
		end: {},
		bottom: {
			Bhzewxz: "f198g47y",
			Bqenvij: "fub80nq",
			a9b677: "fr97h3j"
		},
		absolute: { qhf8xq: "f1euv43f" }
	}, { d: [
		".f198g47y{top:auto;}",
		".fub80nq{height:var(--fui-Drawer--size);}",
		".fr97h3j{width:100vw;}",
		".f1euv43f{position:absolute;}"
	] });
	/**
	* Apply styling to the OverlayDrawer slots based on the state
	*/
	const useOverlayDrawerStyles_unstable = (state) => {
		"use no memo";
		const baseClassNames = useDrawerBaseClassNames(state);
		const resetStyles = useDrawerResetStyles$1();
		const rootStyles = useDrawerRootStyles$1();
		const absoluteStyles = state.hasMountNodeElement && rootStyles.absolute;
		const backdrop = state.root.backdrop;
		state.root.className = mergeClasses(overlayDrawerClassNames.root, baseClassNames, resetStyles, rootStyles[state.position], absoluteStyles, state.root.className);
		if (backdrop) backdrop.className = mergeClasses(overlayDrawerClassNames.backdrop, absoluteStyles, backdrop.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-drawer/lib/components/OverlayDrawer/OverlayDrawer.js
/**
	* OverlayDrawer contains supplementary content and are used for complex creation, edit, or management experiences.
	*/ const OverlayDrawer = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useOverlayDrawer_unstable(props, ref);
		const contextValue = useDrawerContextValue();
		useOverlayDrawerStyles_unstable(state);
		useCustomStyleHook("useDrawerOverlayStyles_unstable")(state);
		useCustomStyleHook("useOverlayDrawerStyles_unstable")(state);
		return renderOverlayDrawer_unstable(state, contextValue);
	});
	OverlayDrawer.displayName = "OverlayDrawer";

//#endregion
//#region node_modules/@fluentui/react-drawer/lib/components/InlineDrawer/useInlineDrawer.js
	const STATIC_MOTION = {
		active: true,
		canRender: true,
		ref: react.createRef(),
		type: "idle"
	};
	/**
	* Create the state required to render InlineDrawer.
	*
	* The returned state can be modified with hooks such as useInlineDrawerStyles_unstable,
	* before being passed to renderInlineDrawer_unstable.
	*
	* @param props - props from this instance of InlineDrawer
	* @param ref - reference to root HTMLElement of InlineDrawer
	*/ const useInlineDrawer_unstable = (props, ref) => {
		const { size: size$2, position: position$1, open, unmountOnClose } = useDrawerDefaultProps(props);
		const { separator = false, surfaceMotion } = props;
		const { dir } = useFluent();
		const [animationDirection, setAnimationDirection] = react.useState(open ? "enter" : "exit");
		return {
			components: {
				root: "div",
				surfaceMotion: InlineDrawerMotion
			},
			root: always(getIntrinsicElementProps("div", {
				...props,
				ref,
				"aria-hidden": !unmountOnClose && !open ? true : void 0
			}), { elementType: "div" }),
			open,
			position: position$1,
			size: size$2,
			separator,
			unmountOnClose,
			animationDirection,
			surfaceMotion: presenceMotionSlot(surfaceMotion, {
				elementType: InlineDrawerMotion,
				defaultProps: {
					position: position$1,
					size: size$2,
					dir,
					visible: open,
					appear: unmountOnClose,
					unmountOnExit: unmountOnClose,
					onMotionFinish: (_, { direction }) => setAnimationDirection(direction),
					onMotionStart: (_, { direction }) => {
						if (direction === "enter") setAnimationDirection("enter");
					}
				}
			}),
			motion: STATIC_MOTION
		};
	};

//#endregion
//#region node_modules/@fluentui/react-drawer/lib/components/InlineDrawer/renderInlineDrawer.js
/**
	* Render the final JSX of InlineDrawer
	*/ const renderInlineDrawer_unstable = (state, contextValue) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(DrawerProvider, {
			value: contextValue,
			children: /* @__PURE__ */ jsx(state.surfaceMotion, { children: /* @__PURE__ */ jsx(state.root, {}) })
		});
	};

//#endregion
//#region node_modules/@fluentui/react-drawer/lib/components/InlineDrawer/useInlineDrawerStyles.styles.js
	const inlineDrawerClassNames = { root: "fui-InlineDrawer" };
	const useDrawerResetStyles = /* @__PURE__ */ __resetStyles("rkjj3x6", null, [".rkjj3x6{overflow:hidden;width:var(--fui-Drawer--size);max-width:100vw;height:auto;max-height:100vh;box-sizing:border-box;display:flex;flex-direction:column;align-items:flex-start;justify-content:flex-start;background-color:var(--colorNeutralBackground1);color:var(--colorNeutralForeground1);position:relative;}"]);
	`${tokens.colorNeutralBackground3}`;
	const useDrawerRootStyles = /* @__PURE__ */ __styles({
		separatorStart: {
			h3c5rm: 0,
			vrafjx: 0,
			Bekrc4i: 0,
			u1mtju: ["f1cxmi7i", "f1j970fk"]
		},
		separatorEnd: {
			zhjwy3: 0,
			wvpqe5: 0,
			ibv6hh: 0,
			B4g9neb: ["f1j970fk", "f1cxmi7i"]
		},
		separatorBottom: {
			g2u3we: 0,
			icvyot: 0,
			B4j52fo: 0,
			i8vvqc: "f1n3kblk"
		},
		start: {},
		end: {},
		bottom: {
			a9b677: "fly5x3f",
			Bqenvij: "fub80nq"
		},
		animationExitStart: {
			a9b677: "f3tsq5r",
			Bgfg5da: 0,
			B9xav0g: 0,
			oivjwe: 0,
			Bn0qgzm: 0,
			B4g9neb: 0,
			zhjwy3: 0,
			wvpqe5: 0,
			ibv6hh: 0,
			u1mtju: 0,
			h3c5rm: 0,
			vrafjx: 0,
			Bekrc4i: 0,
			i8vvqc: 0,
			g2u3we: 0,
			icvyot: 0,
			B4j52fo: 0,
			irswps: "f3bhgqh"
		},
		animationExitEnd: {
			a9b677: "f3tsq5r",
			Bgfg5da: 0,
			B9xav0g: 0,
			oivjwe: 0,
			Bn0qgzm: 0,
			B4g9neb: 0,
			zhjwy3: 0,
			wvpqe5: 0,
			ibv6hh: 0,
			u1mtju: 0,
			h3c5rm: 0,
			vrafjx: 0,
			Bekrc4i: 0,
			i8vvqc: 0,
			g2u3we: 0,
			icvyot: 0,
			B4j52fo: 0,
			irswps: "f3bhgqh"
		},
		animationExitBottom: {
			Bqenvij: "fniina8",
			Bgfg5da: 0,
			B9xav0g: 0,
			oivjwe: 0,
			Bn0qgzm: 0,
			B4g9neb: 0,
			zhjwy3: 0,
			wvpqe5: 0,
			ibv6hh: 0,
			u1mtju: 0,
			h3c5rm: 0,
			vrafjx: 0,
			Bekrc4i: 0,
			i8vvqc: 0,
			g2u3we: 0,
			icvyot: 0,
			B4j52fo: 0,
			irswps: "f3bhgqh"
		}
	}, { d: [
		[".f1cxmi7i{border-right:1px solid var(--colorNeutralBackground3);}", { p: -1 }],
		[".f1j970fk{border-left:1px solid var(--colorNeutralBackground3);}", { p: -1 }],
		[".f1j970fk{border-left:1px solid var(--colorNeutralBackground3);}", { p: -1 }],
		[".f1cxmi7i{border-right:1px solid var(--colorNeutralBackground3);}", { p: -1 }],
		[".f1n3kblk{border-top:1px solid var(--colorNeutralBackground3);}", { p: -1 }],
		".fly5x3f{width:100%;}",
		".fub80nq{height:var(--fui-Drawer--size);}",
		".f3tsq5r{width:0;}",
		[".f3bhgqh{border:none;}", { p: -2 }],
		[".f3bhgqh{border:none;}", { p: -2 }],
		".fniina8{height:0;}",
		[".f3bhgqh{border:none;}", { p: -2 }]
	] });
	function getSeparatorClass(state, classNames) {
		if (!state.separator) return;
		switch (state.position) {
			case "start": return classNames.separatorStart;
			case "end": return classNames.separatorEnd;
			case "bottom": return classNames.separatorBottom;
			default: return;
		}
	}
	function getAnimationExitClass(state, classNames) {
		switch (state.position) {
			case "start": return classNames.animationExitStart;
			case "end": return classNames.animationExitEnd;
			case "bottom": return classNames.animationExitBottom;
			default: return;
		}
	}
	/**
	* Apply styling to the InlineDrawer slots based on the state
	*/
	const useInlineDrawerStyles_unstable = (state) => {
		"use no memo";
		const resetStyles = useDrawerResetStyles();
		const baseClassNames = useDrawerBaseClassNames(state);
		const rootStyles = useDrawerRootStyles();
		state.root.className = mergeClasses(inlineDrawerClassNames.root, resetStyles, baseClassNames, getSeparatorClass(state, rootStyles), rootStyles[state.position], state.animationDirection === "exit" && getAnimationExitClass(state, rootStyles), state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-drawer/lib/components/InlineDrawer/InlineDrawer.js
/**
	* InlineDrawer is often used for navigation that is not dismissible. As it is on the same level as
	* the main surface, users can still interact with other UI elements.
	*/ const InlineDrawer = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useInlineDrawer_unstable(props, ref);
		const contextValue = useDrawerContextValue();
		useInlineDrawerStyles_unstable(state);
		useCustomStyleHook("useDrawerInlineStyles_unstable")(state);
		useCustomStyleHook("useInlineDrawerStyles_unstable")(state);
		return renderInlineDrawer_unstable(state, contextValue);
	});
	InlineDrawer.displayName = "InlineDrawer";

//#endregion
//#region node_modules/@fluentui/react-drawer/lib/components/Drawer/useDrawer.js
/**
	* Create the state required to render Drawer.
	*
	* The returned state can be modified with hooks such as useDrawerStyles_unstable,
	* before being passed to renderDrawer_unstable.
	*
	* @param props - props from this instance of Drawer
	* @param ref - reference to root HTMLElement of Drawer
	*/ const useDrawer_unstable = (props, ref) => {
		const elementType = props.type === "inline" ? InlineDrawer : OverlayDrawer;
		const root = always({
			ref,
			...props
		}, { elementType });
		return {
			components: { root: elementType },
			root
		};
	};

//#endregion
//#region node_modules/@fluentui/react-drawer/lib/components/Drawer/renderDrawer.js
/**
	* Render the final JSX of Drawer
	*/ const renderDrawer_unstable = (state, contextValue) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(DrawerProvider, {
			value: contextValue,
			children: /* @__PURE__ */ jsx(state.root, {})
		});
	};

//#endregion
//#region node_modules/@fluentui/react-drawer/lib/components/Drawer/useDrawerStyles.styles.js
	const drawerClassNames = { root: "fui-Drawer" };
	/**
	* Apply styling to the Drawer slots based on the state
	*/
	const useDrawerStyles_unstable = (state) => {
		"use no memo";
		state.root.className = mergeClasses(drawerClassNames.root, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-drawer/lib/components/Drawer/Drawer.js
/**
	* Drawer contains supplementary content and are used for complex creation, edit, or management experiences.
	*/ const Drawer = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useDrawer_unstable(props, ref);
		const contextValue = useDrawerContextValue();
		useDrawerStyles_unstable(state);
		useCustomStyleHook("useDrawerStyles_unstable")(state);
		return renderDrawer_unstable(state, contextValue);
	});
	Drawer.displayName = "Drawer";

//#endregion
//#region node_modules/@fluentui/react-drawer/lib/components/DrawerBody/useDrawerBody.js
/**
	* @internal
	*
	* Get the current scroll state of the DrawerBody.
	*
	* @param element - HTMLElement to check scroll state of
	*/ const getScrollState = ({ scrollTop, scrollHeight, clientHeight }) => {
		if (scrollHeight <= clientHeight) return "none";
		if (scrollTop === 0) return "top";
		if (scrollTop + clientHeight === scrollHeight) return "bottom";
		return "middle";
	};
	/**
	* Create the state required to render DrawerBody.
	*
	* The returned state can be modified with hooks such as useDrawerBodyStyles_unstable,
	* before being passed to renderDrawerBody_unstable.
	*
	* @param props - props from this instance of DrawerBody
	* @param ref - reference to root HTMLElement of DrawerBody
	*/ const useDrawerBody_unstable = (props, ref) => {
		const { targetDocument } = useFluent();
		const win = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView;
		const { setScrollState } = useDrawerContext_unstable();
		const scrollRef = react.useRef(null);
		const mergedRef = useMergedRefs(ref, scrollRef);
		const [setScrollAnimationFrame, cancelScrollAnimationFrame] = useAnimationFrame();
		const [setResizeAnimationFrame, cancelResizeAnimationFrame] = useAnimationFrame();
		const updateScrollState = react.useCallback(() => {
			if (!scrollRef.current) return;
			setScrollState(getScrollState(scrollRef.current));
		}, [setScrollState]);
		const onScroll = react.useCallback(() => {
			cancelScrollAnimationFrame();
			setScrollAnimationFrame(updateScrollState);
		}, [
			cancelScrollAnimationFrame,
			setScrollAnimationFrame,
			updateScrollState
		]);
		useIsomorphicLayoutEffect(updateScrollState, [props.children, updateScrollState]);
		useIsomorphicLayoutEffect(() => {
			if (!scrollRef.current || !(win === null || win === void 0 ? void 0 : win.ResizeObserver)) return;
			const observer = new win.ResizeObserver(() => setResizeAnimationFrame(updateScrollState));
			observer.observe(scrollRef.current);
			return () => {
				observer.disconnect();
				cancelResizeAnimationFrame();
			};
		}, [
			setResizeAnimationFrame,
			cancelResizeAnimationFrame,
			updateScrollState,
			win
		]);
		return {
			components: { root: "div" },
			root: always(getIntrinsicElementProps("div", {
				ref: mergedRef,
				...props,
				onScroll: mergeCallbacks(props.onScroll, onScroll)
			}), { elementType: "div" })
		};
	};

//#endregion
//#region node_modules/@fluentui/react-drawer/lib/components/DrawerBody/renderDrawerBody.js
/**
	* Render the final JSX of DrawerBody
	*/ const renderDrawerBody_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, {});
	};

//#endregion
//#region node_modules/@fluentui/react-drawer/lib/components/DrawerBody/useDrawerBodyStyles.styles.js
	const drawerBodyClassNames = { root: "fui-DrawerBody" };
	/**
	* Styles for the root slot
	*/
	const useStyles$52 = /* @__PURE__ */ __resetStyles("ri6rvx7", null, [
		".ri6rvx7{padding:0 var(--spacingHorizontalXXL);flex:1;align-self:stretch;position:relative;z-index:1;overflow:auto;}",
		".ri6rvx7:last-child{padding-bottom:calc(var(--spacingHorizontalXXL) + 1px);}",
		".ri6rvx7:first-child{padding-top:calc(var(--spacingHorizontalXXL) + 1px);}"
	]);
	/**
	* Apply styling to the DrawerBody slots based on the state
	*/
	const useDrawerBodyStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$52();
		state.root.className = mergeClasses(drawerBodyClassNames.root, styles, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-drawer/lib/components/DrawerBody/DrawerBody.js
/**
	* DrawerBody provides with a container for the main content of a Drawer.
	*/ const DrawerBody = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useDrawerBody_unstable(props, ref);
		useDrawerBodyStyles_unstable(state);
		useCustomStyleHook("useDrawerBodyStyles_unstable")(state);
		return renderDrawerBody_unstable(state);
	});
	DrawerBody.displayName = "DrawerBody";

//#endregion
//#region node_modules/@fluentui/react-drawer/lib/components/DrawerHeader/useDrawerHeader.js
/**
	* Create the state required to render DrawerHeader.
	*
	* The returned state can be modified with hooks such as useDrawerHeaderStyles_unstable,
	* before being passed to renderDrawerHeader_unstable.
	*
	* @param props - props from this instance of DrawerHeader
	* @param ref - reference to root HTMLElement of DrawerHeader
	*/ const useDrawerHeader_unstable = (props, ref) => {
		const { scrollState } = useDrawerContext_unstable();
		return {
			components: { root: "header" },
			root: always(getIntrinsicElementProps("header", {
				ref,
				role: "none",
				...props
			}), { elementType: "header" }),
			scrollState
		};
	};

//#endregion
//#region node_modules/@fluentui/react-drawer/lib/components/DrawerHeader/renderDrawerHeader.js
/**
	* Render the final JSX of DrawerHeader
	*/ const renderDrawerHeader_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, {});
	};

//#endregion
//#region node_modules/@fluentui/react-drawer/lib/components/DrawerHeader/useDrawerHeaderStyles.styles.js
	const drawerHeaderClassNames = { root: "fui-DrawerHeader" };
	/**
	* Styles for the root slot
	*/
	const useStyles$51 = /* @__PURE__ */ __resetStyles("r3ovn4i", null, [".r3ovn4i{width:100%;max-width:100%;padding:var(--spacingVerticalXXL) var(--spacingHorizontalXXL) var(--spacingVerticalS);gap:var(--spacingHorizontalS);align-self:stretch;display:flex;flex-direction:column;box-sizing:border-box;position:relative;z-index:2;}"]);
	const useDrawerHeaderStyles = /* @__PURE__ */ __styles({
		separator: {
			Dlnsje: "fxnjyrl",
			E3zdtr: "f1mdlcz9",
			B1piin3: ["f15yvnhg", "f1n6gb5g"],
			Eqx8gd: ["f1n6gb5g", "f15yvnhg"],
			Bp15pi3: "f1564nw5",
			Bjyk6c5: "fdlpgxj",
			F2fol1: "f15cmg8x",
			Ba2ppi3: "f3f8dgl",
			B1dyfl9: "fjvo4va",
			Bsft5z2: "f13zj6fq",
			By385i5: "fo72kxq"
		},
		separatorVisible: { Bp15pi3: "fjsqi2x" }
	}, { d: [
		".fxnjyrl::after{height:1px;}",
		".f1mdlcz9::after{position:absolute;}",
		".f15yvnhg::after{right:0;}",
		".f1n6gb5g::after{left:0;}",
		".f1564nw5::after{opacity:0;}",
		".fdlpgxj::after{background-color:var(--colorNeutralStroke1);}",
		".f15cmg8x::after{transition-duration:var(--durationNormal);}",
		".f3f8dgl::after{transition-property:opacity;}",
		".fjvo4va::after{transition-timing-function:var(--curveEasyEase);}",
		".f13zj6fq::after{content:\"\";}",
		".fo72kxq::after{bottom:0;}",
		".fjsqi2x::after{opacity:1;}"
	] });
	/**
	* Apply styling to the DrawerHeader slots based on the state
	*/
	const useDrawerHeaderStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$51();
		const rootStyles = useDrawerHeaderStyles();
		state.root.className = mergeClasses(drawerHeaderClassNames.root, styles, state.scrollState !== "none" && rootStyles.separator, ["middle", "bottom"].includes(state.scrollState) && rootStyles.separatorVisible, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-drawer/lib/components/DrawerHeader/DrawerHeader.js
/**
	* DrawerHeader provides a structured header for the drawer component.
	*/ const DrawerHeader = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useDrawerHeader_unstable(props, ref);
		useDrawerHeaderStyles_unstable(state);
		useCustomStyleHook("useDrawerHeaderStyles_unstable")(state);
		return renderDrawerHeader_unstable(state);
	});
	DrawerHeader.displayName = "DrawerHeader";

//#endregion
//#region node_modules/@fluentui/react-drawer/lib/components/DrawerHeaderTitle/useDrawerHeaderTitle.js
/**
	* Create the state required to render DrawerHeaderTitle.
	*
	* The returned state can be modified with hooks such as useDrawerHeaderTitleStyles_unstable,
	* before being passed to renderDrawerHeaderTitle_unstable.
	*
	* @param props - props from this instance of DrawerHeaderTitle
	* @param ref - reference to root HTMLElement of DrawerHeaderTitle
	*/ const useDrawerHeaderTitle_unstable = (props, ref) => {
		const { children, heading } = props;
		const headingId = useDialogContext_unstable((ctx) => ctx.dialogTitleId);
		return {
			components: {
				root: "div",
				heading: "h2",
				action: "div"
			},
			root: always(getIntrinsicElementProps("div", {
				ref,
				...props
			}), { elementType: "div" }),
			heading: optional(heading, {
				defaultProps: {
					id: headingId,
					children
				},
				renderByDefault: true,
				elementType: "h2"
			}),
			action: optional(props.action, { elementType: "div" })
		};
	};

//#endregion
//#region node_modules/@fluentui/react-drawer/lib/components/DrawerHeaderTitle/renderDrawerHeaderTitle.js
/**
	* Render the final JSX of DrawerHeaderTitle
	*/ const renderDrawerHeaderTitle_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(state.root, { children: [state.heading && /* @__PURE__ */ jsx(state.heading, {}), state.action && /* @__PURE__ */ jsx(state.action, {})] });
	};

//#endregion
//#region node_modules/@fluentui/react-drawer/lib/components/DrawerHeaderTitle/useDrawerHeaderTitleStyles.styles.js
	const drawerHeaderTitleClassNames = {
		root: "fui-DrawerHeaderTitle",
		heading: "fui-DrawerHeaderTitle__heading",
		action: "fui-DrawerHeaderTitle__action"
	};
	/**
	* Styles for the root slot
	*/
	const useStyles$50 = /* @__PURE__ */ __styles({
		root: {
			mc9l5x: "f22iagw",
			Brf1p80: "f1869bpl",
			Bt984gj: "f122n59",
			i8kkvl: "fsnqrgy"
		},
		action: { t21cq0: ["faqnl2i", "fd75udd"] }
	}, { d: [
		".f22iagw{display:flex;}",
		".f1869bpl{justify-content:space-between;}",
		".f122n59{align-items:center;}",
		".fsnqrgy{column-gap:var(--spacingHorizontalS);}",
		".faqnl2i{margin-right:calc(var(--spacingHorizontalS) * -1);}",
		".fd75udd{margin-left:calc(var(--spacingHorizontalS) * -1);}"
	] });
	/**
	* Apply styling to the DrawerHeaderTitle slots based on the state
	*/
	const useDrawerHeaderTitleStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$50();
		const { heading: root = {}, action, components } = state;
		useDialogTitleStyles_unstable({
			components: {
				root: components.heading,
				action: components.action
			},
			root,
			action
		});
		state.root.className = mergeClasses(drawerHeaderTitleClassNames.root, styles.root, state.root.className);
		if (state.heading) state.heading.className = mergeClasses(drawerHeaderTitleClassNames.heading, state.heading.className);
		if (state.action) state.action.className = mergeClasses(drawerHeaderTitleClassNames.action, styles.action, state.action.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-drawer/lib/components/DrawerHeaderTitle/DrawerHeaderTitle.js
/**
	* DrawerHeader provides a structured header for the drawer component.
	*/ const DrawerHeaderTitle = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useDrawerHeaderTitle_unstable(props, ref);
		useDrawerHeaderTitleStyles_unstable(state);
		useCustomStyleHook("useDrawerHeaderTitleStyles_unstable")(state);
		return renderDrawerHeaderTitle_unstable(state);
	});
	DrawerHeaderTitle.displayName = "DrawerHeaderTitle";

//#endregion
//#region node_modules/@fluentui/react-drawer/lib/components/DrawerHeaderNavigation/useDrawerHeaderNavigation.js
/**
	* Create the state required to render DrawerHeaderNavigation.
	*
	* The returned state can be modified with hooks such as useDrawerHeaderNavigationStyles_unstable,
	* before being passed to renderDrawerHeaderNavigation_unstable.
	*
	* @param props - props from this instance of DrawerHeaderNavigation
	* @param ref - reference to root HTMLElement of DrawerHeaderNavigation
	*/ const useDrawerHeaderNavigation_unstable = (props, ref) => {
		return {
			components: { root: "nav" },
			root: always(getIntrinsicElementProps("nav", {
				ref,
				...props
			}), { elementType: "nav" })
		};
	};

//#endregion
//#region node_modules/@fluentui/react-drawer/lib/components/DrawerHeaderNavigation/renderDrawerHeaderNavigation.js
/**
	* Render the final JSX of DrawerHeaderNavigation
	*/ const renderDrawerHeaderNavigation_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, {});
	};

//#endregion
//#region node_modules/@fluentui/react-drawer/lib/components/DrawerHeaderNavigation/useDrawerHeaderNavigationStyles.styles.js
	const drawerHeaderNavigationClassNames = { root: "fui-DrawerHeaderNavigation" };
	/**
	* Styles for the root slot
	*/
	const useStyles$49 = /* @__PURE__ */ __resetStyles("r1ig4pwh", null, [".r1ig4pwh{margin:calc(var(--spacingVerticalS) * -1) calc(var(--spacingHorizontalL) * -1);}"]);
	/**
	* Apply styling to the DrawerHeaderNavigation slots based on the state
	*/
	const useDrawerHeaderNavigationStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$49();
		state.root.className = mergeClasses(drawerHeaderNavigationClassNames.root, styles, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-drawer/lib/components/DrawerHeaderNavigation/DrawerHeaderNavigation.js
/**
	* DrawerHeaderNavigation provides a header navigation area for the Drawer.
	*/ const DrawerHeaderNavigation = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useDrawerHeaderNavigation_unstable(props, ref);
		useDrawerHeaderNavigationStyles_unstable(state);
		useCustomStyleHook("useDrawerHeaderNavigationStyles_unstable")(state);
		return renderDrawerHeaderNavigation_unstable(state);
	});
	DrawerHeaderNavigation.displayName = "DrawerHeaderNavigation";

//#endregion
//#region node_modules/@fluentui/react-drawer/lib/components/DrawerFooter/useDrawerFooter.js
/**
	* Create the state required to render DrawerFooter.
	*
	* The returned state can be modified with hooks such as useDrawerFooterStyles_unstable,
	* before being passed to renderDrawerFooter_unstable.
	*
	* @param props - props from this instance of DrawerFooter
	* @param ref - reference to root HTMLElement of DrawerFooter
	*/ const useDrawerFooter_unstable = (props, ref) => {
		const { scrollState } = useDrawerContext_unstable();
		return {
			components: { root: "footer" },
			root: always(getIntrinsicElementProps("footer", {
				ref,
				role: "none",
				...props
			}), { elementType: "footer" }),
			scrollState
		};
	};

//#endregion
//#region node_modules/@fluentui/react-drawer/lib/components/DrawerFooter/renderDrawerFooter.js
/**
	* Render the final JSX of DrawerFooter
	*/ const renderDrawerFooter_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, {});
	};

//#endregion
//#region node_modules/@fluentui/react-drawer/lib/components/DrawerFooter/useDrawerFooterStyles.styles.js
	const drawerFooterClassNames = { root: "fui-DrawerFooter" };
	/**
	* Styles for the root slot
	*/
	const useStyles$48 = /* @__PURE__ */ __resetStyles("r1snvl2j", null, [".r1snvl2j{width:100%;max-width:100%;padding:var(--spacingVerticalL) var(--spacingHorizontalXXL) var(--spacingVerticalXXL);display:flex;justify-content:flex-start;align-items:center;column-gap:var(--spacingHorizontalS);box-sizing:border-box;position:relative;z-index:2;}"]);
	const useDrawerFooterStyles = /* @__PURE__ */ __styles({
		separator: {
			Baz25je: "f16b62f1",
			Brfgrao: "f1j7ml58",
			mdwyqc: ["f1f351id", "f1fzr1x6"],
			Fbdkly: ["f1fzr1x6", "f1f351id"],
			vz82u: "f1dhznln",
			cmx5o7: "f1p5zmk",
			h7gv66: "f1ljjo4k",
			B8bqphf: "ffd2d9j",
			wjn42g: "ffdt3s5",
			Ftih45: "f1wl9k8s",
			Bciustq: "ffi060y"
		},
		separatorVisible: { vz82u: "f1b3qyzu" }
	}, { d: [
		".f16b62f1::before{height:1px;}",
		".f1j7ml58::before{position:absolute;}",
		".f1f351id::before{right:0;}",
		".f1fzr1x6::before{left:0;}",
		".f1dhznln::before{opacity:0;}",
		".f1p5zmk::before{background-color:var(--colorNeutralStroke1);}",
		".f1ljjo4k::before{transition-duration:var(--durationNormal);}",
		".ffd2d9j::before{transition-property:opacity;}",
		".ffdt3s5::before{transition-timing-function:var(--curveEasyEase);}",
		".f1wl9k8s::before{content:\"\";}",
		".ffi060y::before{top:0;}",
		".f1b3qyzu::before{opacity:1;}"
	] });
	/**
	* Apply styling to the DrawerFooter slots based on the state
	*/
	const useDrawerFooterStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$48();
		const rootStyles = useDrawerFooterStyles();
		state.root.className = mergeClasses(drawerFooterClassNames.root, styles, state.scrollState !== "none" && rootStyles.separator, ["middle", "top"].includes(state.scrollState) && rootStyles.separatorVisible, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-drawer/lib/components/DrawerFooter/DrawerFooter.js
/**
	* DrawerFooter provides a structured footer for the drawer component.
	*/ const DrawerFooter = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useDrawerFooter_unstable(props, ref);
		useDrawerFooterStyles_unstable(state);
		useCustomStyleHook("useDrawerFooterStyles_unstable")(state);
		return renderDrawerFooter_unstable(state);
	});
	DrawerFooter.displayName = "DrawerFooter";

//#endregion
//#region node_modules/@fluentui/react-breadcrumb/lib/components/Breadcrumb/useBreadcrumb.js
/**
	* Create the state required to render Breadcrumb.
	*
	* The returned state can be modified with hooks such as useBreadcrumbStyles_unstable,
	* before being passed to renderBreadcrumb_unstable.
	*
	* @param props - props from this instance of Breadcrumb
	* @param ref - reference to root HTMLElement of Breadcrumb
	*/ const useBreadcrumb_unstable = (props, ref) => {
		const { focusMode = "tab", size: size$2 = "medium", list, ...rest } = props;
		const focusAttributes = useArrowNavigationGroup({
			circular: true,
			axis: "horizontal",
			memorizeCurrent: true
		});
		var _props_arialabel;
		return {
			components: {
				root: "nav",
				list: "ol"
			},
			root: always(getIntrinsicElementProps("nav", {
				ref,
				"aria-label": (_props_arialabel = props["aria-label"]) !== null && _props_arialabel !== void 0 ? _props_arialabel : "breadcrumb",
				...focusMode === "arrow" ? focusAttributes : {},
				...rest
			}), { elementType: "nav" }),
			list: optional(list, {
				renderByDefault: true,
				defaultProps: { role: "list" },
				elementType: "ol"
			}),
			size: size$2
		};
	};

//#endregion
//#region node_modules/@fluentui/react-breadcrumb/lib/components/Breadcrumb/BreadcrumbContext.js
	const BreadcrumbContext = react.createContext(void 0);
	/**
	* @internal
	*/ const breadcrumbDefaultValue = { size: "medium" };
	/**
	* @internal
	*/ const BreadcrumbProvider = BreadcrumbContext.Provider;
	/**
	* @internal
	*/ const useBreadcrumbContext_unstable = () => {
		var _React_useContext;
		return (_React_useContext = react.useContext(BreadcrumbContext)) !== null && _React_useContext !== void 0 ? _React_useContext : breadcrumbDefaultValue;
	};

//#endregion
//#region node_modules/@fluentui/react-breadcrumb/lib/components/Breadcrumb/renderBreadcrumb.js
/**
	* Render the final JSX of Breadcrumb
	*/ const renderBreadcrumb_unstable = (state, contextValues) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, { children: /* @__PURE__ */ jsx(BreadcrumbProvider, {
			value: contextValues,
			children: state.list && /* @__PURE__ */ jsx(state.list, { children: state.root.children })
		}) });
	};

//#endregion
//#region node_modules/@fluentui/react-breadcrumb/lib/components/Breadcrumb/useBreadcrumbStyles.styles.js
	const breadcrumbClassNames = {
		root: "fui-Breadcrumb",
		list: "fui-Breadcrumb__list"
	};
	const useListClassName = /* @__PURE__ */ __resetStyles("rc5rb6b", null, [".rc5rb6b{list-style-type:none;display:flex;align-items:center;margin:0;padding:0;}"]);
	/**
	* Apply styling to the Breadcrumb slots based on the state
	*/
	const useBreadcrumbStyles_unstable = (state) => {
		"use no memo";
		const listBaseClassName = useListClassName();
		state.root.className = mergeClasses(breadcrumbClassNames.root, state.root.className);
		if (state.list) state.list.className = mergeClasses(listBaseClassName, breadcrumbClassNames.list, state.list.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-breadcrumb/lib/components/Breadcrumb/useBreadcrumbContextValue.js
	function useBreadcrumbContextValues_unstable(state) {
		const { size: size$2 } = state;
		return react.useMemo(() => ({ size: size$2 }), [size$2]);
	}

//#endregion
//#region node_modules/@fluentui/react-breadcrumb/lib/components/Breadcrumb/Breadcrumb.js
/**
	* Breadcrumb component - TODO: add more docs
	*/ const Breadcrumb = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useBreadcrumb_unstable(props, ref);
		const contextValues = useBreadcrumbContextValues_unstable(state);
		useBreadcrumbStyles_unstable(state);
		useCustomStyleHook("useBreadcrumbStyles_unstable")(state);
		return renderBreadcrumb_unstable(state, contextValues);
	});
	Breadcrumb.displayName = "Breadcrumb";

//#endregion
//#region node_modules/@fluentui/react-breadcrumb/lib/components/BreadcrumbDivider/useBreadcrumbDivider.js
/**
	* Create the state required to render BreadcrumbDivider.
	*
	* The returned state can be modified with hooks such as useBreadcrumbDividerStyles_unstable,
	* before being passed to renderBreadcrumbDivider_unstable.
	*
	* @param props - props from this instance of BreadcrumbDivider
	* @param ref - reference to root HTMLElement of BreadcrumbDivider
	*/ const useBreadcrumbDivider_unstable = (props, ref) => {
		const { size: size$2 } = useBreadcrumbContext_unstable();
		const { dir } = useFluent();
		const icon = getDividerIcon(dir);
		return {
			components: { root: "li" },
			root: always(getIntrinsicElementProps("li", {
				ref,
				"aria-hidden": true,
				children: icon,
				...props
			}), { elementType: "li" }),
			size: size$2
		};
	};
	/**
	* Get icon of the divider
	*
	* @param dir - RTL or LTR
	*/ function getDividerIcon(dir) {
		return dir === "rtl" ? /* @__PURE__ */ react.createElement(ChevronLeftRegular, null) : /* @__PURE__ */ react.createElement(ChevronRightRegular, null);
	}

//#endregion
//#region node_modules/@fluentui/react-breadcrumb/lib/components/BreadcrumbDivider/renderBreadcrumbDivider.js
/**
	* Render the final JSX of BreadcrumbDivider
	*/ const renderBreadcrumbDivider_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, {});
	};

//#endregion
//#region node_modules/@fluentui/react-breadcrumb/lib/components/BreadcrumbDivider/useBreadcrumbDividerStyles.styles.js
	const breadcrumbDividerClassNames = { root: "fui-BreadcrumbDivider" };
	/**
	* Styles for the root slot
	*/
	const useStyles$47 = /* @__PURE__ */ __resetStyles("rk008qs", null, [".rk008qs{display:flex;}"]);
	const useIconStyles$4 = /* @__PURE__ */ __styles({
		small: { Be2twd7: "f1ugzwwg" },
		medium: { Be2twd7: "f4ybsrx" },
		large: { Be2twd7: "fe5j1ua" }
	}, { d: [
		".f1ugzwwg{font-size:12px;}",
		".f4ybsrx{font-size:16px;}",
		".fe5j1ua{font-size:20px;}"
	] });
	/**
	* Apply styling to the BreadcrumbDivider slots based on the state
	*/
	const useBreadcrumbDividerStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$47();
		const iconStyles = useIconStyles$4();
		const { size: size$2 = "medium" } = state;
		state.root.className = mergeClasses(breadcrumbDividerClassNames.root, styles, iconStyles[size$2], state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-breadcrumb/lib/components/BreadcrumbDivider/BreadcrumbDivider.js
/**
	* A divider component which is used inside the Breadcrumb
	*/ const BreadcrumbDivider = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useBreadcrumbDivider_unstable(props, ref);
		useBreadcrumbDividerStyles_unstable(state);
		useCustomStyleHook("useBreadcrumbDividerStyles_unstable")(state);
		return renderBreadcrumbDivider_unstable(state);
	});
	BreadcrumbDivider.displayName = "BreadcrumbDivider";

//#endregion
//#region node_modules/@fluentui/react-breadcrumb/lib/components/BreadcrumbItem/useBreadcrumbItem.js
/**
	* Create the state required to render BreadcrumbItem.
	*
	* The returned state can be modified with hooks such as useBreadcrumbItemStyles_unstable,
	* before being passed to renderBreadcrumbItem_unstable.
	*
	* @param props - props from this instance of BreadcrumbItem
	* @param ref - reference to root HTMLElement of BreadcrumbItem
	*/ const useBreadcrumbItem_unstable = (props, ref) => {
		const { size: size$2 } = useBreadcrumbContext_unstable();
		return {
			components: { root: "li" },
			root: always(getIntrinsicElementProps("li", {
				ref,
				...props
			}), { elementType: "li" }),
			size: size$2
		};
	};

//#endregion
//#region node_modules/@fluentui/react-breadcrumb/lib/components/BreadcrumbItem/renderBreadcrumbItem.js
/**
	* Render the final JSX of BreadcrumbItem
	*/ const renderBreadcrumbItem_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, { children: state.root.children });
	};

//#endregion
//#region node_modules/@fluentui/react-breadcrumb/lib/components/BreadcrumbItem/useBreadcrumbItemStyles.styles.js
	const breadcrumbItemClassNames = { root: "fui-BreadcrumbItem" };
	const useBreadcrumbItemResetStyles = /* @__PURE__ */ __resetStyles("r1tl60rs", null, [".r1tl60rs{display:flex;align-items:center;color:var(--colorNeutralForeground2);box-sizing:border-box;text-wrap:nowrap;}"]);
	/**
	* Apply styling to the BreadcrumbItem slots based on the state
	*/
	const useBreadcrumbItemStyles_unstable = (state) => {
		"use no memo";
		const resetStyles = useBreadcrumbItemResetStyles();
		state.root.className = mergeClasses(breadcrumbItemClassNames.root, resetStyles, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-breadcrumb/lib/components/BreadcrumbItem/BreadcrumbItem.js
/**
	* BreadcrumbItem component is a wrapper for BreadcrumbLink and BreadcrumbButton.
	* It can be used as a non-interactive item.
	*/ const BreadcrumbItem = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useBreadcrumbItem_unstable(props, ref);
		useBreadcrumbItemStyles_unstable(state);
		useCustomStyleHook("useBreadcrumbItemStyles_unstable")(state);
		return renderBreadcrumbItem_unstable(state);
	});
	BreadcrumbItem.displayName = "BreadcrumbItem";

//#endregion
//#region node_modules/@fluentui/react-breadcrumb/lib/utils/partitionBreadcrumbItems.js
	const DEFAULT_OVERFLOW_INDEX = 1;
	const DEFAULT_MAX_DISPLAYED_ITEMS = 6;
	/**
	* Get the displayed items and overflowing items based on the array of BreadcrumbItems needed for Breadcrumb.
	*
	* @param options - Configure the partition options
	*
	* @returns Three arrays split into displayed items and overflow items based on maxDisplayedItems.
	*/ const partitionBreadcrumbItems = (options) => {
		let startDisplayedItems;
		let overflowItems;
		let endDisplayedItems;
		const { items = [] } = options;
		const itemsCount = items.length;
		const maxDisplayedItems = getMaxDisplayedItems(options.maxDisplayedItems);
		var _options_overflowIndex;
		let overflowIndex = (_options_overflowIndex = options.overflowIndex) !== null && _options_overflowIndex !== void 0 ? _options_overflowIndex : DEFAULT_OVERFLOW_INDEX;
		startDisplayedItems = items.slice(0, overflowIndex);
		const numberItemsToHide = itemsCount - maxDisplayedItems;
		if (numberItemsToHide > 0) {
			overflowIndex = overflowIndex >= maxDisplayedItems ? maxDisplayedItems - 1 : overflowIndex;
			const menuLastItemIdx = overflowIndex + numberItemsToHide;
			startDisplayedItems = startDisplayedItems.slice(0, overflowIndex);
			overflowItems = items.slice(overflowIndex, menuLastItemIdx);
			if (menuLastItemIdx < itemsCount) endDisplayedItems = items.slice(menuLastItemIdx, itemsCount);
		} else if (overflowIndex < itemsCount) endDisplayedItems = items.slice(overflowIndex, itemsCount);
		return {
			startDisplayedItems,
			overflowItems,
			endDisplayedItems
		};
	};
	function getMaxDisplayedItems(maxDisplayedItems) {
		return maxDisplayedItems && maxDisplayedItems >= 0 ? maxDisplayedItems : DEFAULT_MAX_DISPLAYED_ITEMS;
	}

//#endregion
//#region node_modules/@fluentui/react-breadcrumb/lib/utils/truncateBreadcrumb.js
	const MAX_NAME_LENGTH = 30;
	const MAX_TOOLTIP_LENGTH = 80;
	const truncateBreadcrumb = (content, maxLength) => {
		return isTruncatableBreadcrumbContent(content, maxLength) ? content.trim().slice(0, maxLength).concat("...") : content;
	};
	const isTruncatableBreadcrumbContent = (content, maxLength) => {
		return content.length > maxLength;
	};
	const truncateBreadcrumbLongName = (content, maxLength) => {
		return truncateBreadcrumb(content, maxLength || MAX_NAME_LENGTH);
	};
	const truncateBreadcrumLongTooltip = (content, maxLength) => {
		return truncateBreadcrumb(content, maxLength || MAX_TOOLTIP_LENGTH);
	};

//#endregion
//#region node_modules/@fluentui/react-breadcrumb/lib/components/BreadcrumbButton/useBreadcrumbButton.js
/**
	* Create the state required to render BreadcrumbButton.
	*
	* The returned state can be modified with hooks such as useBreadcrumbButtonStyles_unstable,
	* before being passed to renderBreadcrumbButton_unstable.
	*
	* @param props - props from this instance of BreadcrumbButton
	* @param ref - reference to root HTMLElement of BreadcrumbButton
	*/ const useBreadcrumbButton_unstable = (props, ref) => {
		const { size: size$2 } = useBreadcrumbContext_unstable();
		const { current = false, as, ...rest } = props;
		const controlType = (as !== null && as !== void 0 ? as : props.href) ? "a" : "button";
		var _props_ariacurrent, _props_ariadisabled;
		return {
			...useButton_unstable({
				appearance: "subtle",
				role: void 0,
				type: void 0,
				as: controlType,
				iconPosition: "before",
				"aria-current": current ? (_props_ariacurrent = props["aria-current"]) !== null && _props_ariacurrent !== void 0 ? _props_ariacurrent : "page" : void 0,
				"aria-disabled": current ? (_props_ariadisabled = props["aria-disabled"]) !== null && _props_ariadisabled !== void 0 ? _props_ariadisabled : true : void 0,
				...rest
			}, ref),
			current,
			size: size$2
		};
	};

//#endregion
//#region node_modules/@fluentui/react-breadcrumb/lib/components/BreadcrumbButton/renderBreadcrumbButton.js
/**
	* Render the final JSX of BreadcrumbButton
	*/ const renderBreadcrumbButton_unstable = (state) => {
		return renderButton_unstable(state);
	};

//#endregion
//#region node_modules/@fluentui/react-breadcrumb/lib/components/BreadcrumbButton/useBreadcrumbButtonStyles.styles.js
/**
	* Static CSS class names used internally for the component slots.
	*/
	const breadcrumbButtonClassNames = {
		root: "fui-BreadcrumbButton",
		icon: "fui-BreadcrumbButton__icon"
	};
	const useIconStyles$3 = /* @__PURE__ */ __styles({
		base: {
			Be2twd7: "fsj74e5",
			Bqenvij: "f1qfv4wv",
			Bg96gwp: "f15xapk4",
			a9b677: "f17j33op",
			t21cq0: ["fm0x6gh", "fbyavb5"]
		},
		small: {
			u3h8gg: "f1qfi7kw",
			Biu6dll: "f1876atl"
		},
		medium: {
			u3h8gg: "f1h9446d",
			Biu6dll: "f10xfswh"
		},
		large: {
			u3h8gg: "f5hcofs",
			Biu6dll: "f1a6v6zl"
		}
	}, { d: [
		".fsj74e5{font-size:var(--fui-Breadcrumb--icon-size);}",
		".f1qfv4wv{height:var(--fui-Breadcrumb--icon-size);}",
		".f15xapk4{line-height:var(--fui-Breadcrumb--icon-line-height);}",
		".f17j33op{width:var(--fui-Breadcrumb--icon-size);}",
		".fm0x6gh{margin-right:var(--spacingHorizontalXS);}",
		".fbyavb5{margin-left:var(--spacingHorizontalXS);}",
		".f1qfi7kw{--fui-Breadcrumb--icon-size:12px;}",
		".f1876atl{--fui-Breadcrumb--icon-line-height:var(--lineHeightBase200);}",
		".f1h9446d{--fui-Breadcrumb--icon-size:16px;}",
		".f10xfswh{--fui-Breadcrumb--icon-line-height:var(--lineHeightBase400);}",
		".f5hcofs{--fui-Breadcrumb--icon-size:20px;}",
		".f1a6v6zl{--fui-Breadcrumb--icon-line-height:var(--lineHeightBase600);}"
	] });
	tokens.colorTransparentBackground, tokens.colorNeutralForeground2, `${buttonClassNames.icon}`, `${iconFilledClassName}`, `${iconRegularClassName}`;
	const useStyles$46 = /* @__PURE__ */ __styles({
		root: {
			Bf4jedk: "f18p0k4z",
			j4b8c3: "fv6wr3j"
		},
		small: {
			Bqenvij: "frvgh55",
			Bahqtrf: "fk6fouc",
			Be2twd7: "fy9rknc",
			Bhrd7zp: "figsok6",
			Bg96gwp: "fwrc4pm",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f1r1wyb6"
		},
		medium: {
			Bqenvij: "f1d2rq10",
			Bahqtrf: "fk6fouc",
			Be2twd7: "fkhj508",
			Bhrd7zp: "figsok6",
			Bg96gwp: "f1i3iumi",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f1r1wyb6"
		},
		large: {
			Bqenvij: "fbhnoac",
			Bahqtrf: "fk6fouc",
			Be2twd7: "fod5ikn",
			Bhrd7zp: "figsok6",
			Bg96gwp: "faaz57k",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f1bnz8pu"
		},
		current: {
			Jwef8y: "f9ql6rf",
			Bi91k9c: "f3p8bqa",
			eoavqd: "f14w7a5u",
			Bbdnnc7: "f1irjp3o",
			Bk3fhr4: "f19vpps7",
			Bmfj8id: "fv5swzo",
			iro3zm: "f3h1zc4",
			B2d53fq: "f1xkgyln",
			c3iz72: "f17wbbfx",
			x3br3k: "fofxw0a",
			em6i61: "f1ol4fw6",
			vm6p8p: "f1q1lw4e",
			Bszkowt: "ff24m",
			Dyrjrp: "ft5r8e9",
			ezr58z: "f1cbpfqp",
			nhk3du: "f1motppv",
			Bfrek18: "fi9vkhg",
			G209fr: "f1fg3nnv"
		},
		currentSmall: {
			Bahqtrf: "fk6fouc",
			Be2twd7: "fy9rknc",
			Bhrd7zp: "fl43uef",
			Bg96gwp: "fwrc4pm"
		},
		currentMedium: {
			Bahqtrf: "fk6fouc",
			Be2twd7: "fkhj508",
			Bhrd7zp: "fl43uef",
			Bg96gwp: "f1i3iumi"
		},
		currentLarge: {
			Bahqtrf: "fk6fouc",
			Be2twd7: "fod5ikn",
			Bhrd7zp: "fl43uef",
			Bg96gwp: "faaz57k"
		}
	}, {
		d: [
			".f18p0k4z{min-width:unset;}",
			".fv6wr3j{text-wrap:nowrap;}",
			".frvgh55{height:24px;}",
			".fk6fouc{font-family:var(--fontFamilyBase);}",
			".fy9rknc{font-size:var(--fontSizeBase200);}",
			".figsok6{font-weight:var(--fontWeightRegular);}",
			".fwrc4pm{line-height:var(--lineHeightBase200);}",
			[".f1r1wyb6{padding:var(--spacingHorizontalSNudge);}", { p: -1 }],
			".f1d2rq10{height:32px;}",
			".fkhj508{font-size:var(--fontSizeBase300);}",
			".f1i3iumi{line-height:var(--lineHeightBase300);}",
			[".f1r1wyb6{padding:var(--spacingHorizontalSNudge);}", { p: -1 }],
			".fbhnoac{height:40px;}",
			".fod5ikn{font-size:var(--fontSizeBase400);}",
			".faaz57k{line-height:var(--lineHeightBase400);}",
			[".f1bnz8pu{padding:var(--spacingHorizontalS);}", { p: -1 }],
			".ff24m:disabled{background-color:var(--colorTransparentBackground);}",
			".ft5r8e9:disabled{color:var(--colorNeutralForeground2);}",
			".f1cbpfqp:disabled{cursor:auto;}",
			".f1motppv:disabled .fui-Button__icon{color:unset;}",
			".fi9vkhg:disabled .fui-Icon-filled{display:none;}",
			".f1fg3nnv:disabled .fui-Icon-regular{display:inline;}",
			".fl43uef{font-weight:var(--fontWeightSemibold);}"
		],
		h: [
			".f9ql6rf:hover{background-color:var(--colorTransparentBackground);}",
			".f3p8bqa:hover{color:var(--colorNeutralForeground2);}",
			".f14w7a5u:hover{cursor:auto;}",
			".f1irjp3o:hover .fui-Button__icon{color:unset;}",
			".f19vpps7:hover .fui-Icon-filled{display:none;}",
			".fv5swzo:hover .fui-Icon-regular{display:inline;}",
			".f3h1zc4:hover:active{background-color:var(--colorTransparentBackground);}",
			".f1xkgyln:hover:active{color:var(--colorNeutralForeground2);}",
			".f17wbbfx:hover:active{cursor:auto;}",
			".fofxw0a:hover:active .fui-Button__icon{color:unset;}",
			".f1ol4fw6:hover:active .fui-Icon-filled{display:none;}",
			".f1q1lw4e:hover:active .fui-Icon-regular{display:inline;}"
		]
	});
	/**
	* Apply styling to the BreadcrumbButton slots based on the state
	*/
	const useBreadcrumbButtonStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$46();
		const iconStyles = useIconStyles$3();
		const currentSizeMap = {
			small: styles.currentSmall,
			medium: styles.currentMedium,
			large: styles.currentLarge
		};
		state.root.className = mergeClasses(breadcrumbButtonClassNames.root, styles[state.size], styles.root, state.current && currentSizeMap[state.size], state.current && styles.current, state.root.className);
		if (state.icon) state.icon.className = mergeClasses(iconStyles.base, iconStyles[state.size], state.icon.className);
		useButtonStyles_unstable(state);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-breadcrumb/lib/components/BreadcrumbButton/BreadcrumbButton.js
/**
	* A button component which is used inside the Breadcrumb.
	*/ const BreadcrumbButton = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useBreadcrumbButton_unstable(props, ref);
		useBreadcrumbButtonStyles_unstable(state);
		useCustomStyleHook("useBreadcrumbButtonStyles_unstable")(state);
		return renderBreadcrumbButton_unstable(state);
	});
	BreadcrumbButton.displayName = "BreadcrumbButton";

//#endregion
//#region node_modules/@fluentui/react-rating/lib/contexts/RatingItemContext.js
/**
	* RatingContext is provided by Rating, and is consumed by Rating to determine default values of some props.
	*/ const RatingItemContext = /* @__PURE__ */ react.createContext(void 0);
	const ratingItemContextDefaultValue = {
		color: "neutral",
		iconFilled: StarFilled,
		iconOutline: StarRegular,
		step: 1,
		size: "medium"
	};
	const RatingItemProvider = RatingItemContext.Provider;
	/**
	* Get the value of the RatingContext.
	*/ const useRatingItemContextValue_unstable = () => react.useContext(RatingItemContext) || ratingItemContextDefaultValue;

//#endregion
//#region node_modules/@fluentui/react-rating/lib/components/RatingItem/useRatingItem.js
	const defaultItemLabel = (num) => num + "";
	/**
	* Create the state required to render RatingItem.
	*
	* The returned state can be modified with hooks such as useRatingItemStyles_unstable,
	* before being passed to renderRatingItem_unstable.
	*
	* @param props - props from this instance of RatingItem
	* @param ref - reference to root HTMLElement of RatingItem
	*/ const useRatingItem_unstable = (props, ref) => {
		const context = useRatingItemContextValue_unstable();
		const { value = 0 } = props;
		const { itemLabel = defaultItemLabel, iconFilled: IconFilled, iconOutline: IconOutline } = context;
		const ratingValue = Math.round((context.value || 0) * 2) / 2;
		var _context_hoveredValue;
		const displayedRatingValue = (_context_hoveredValue = context.hoveredValue) !== null && _context_hoveredValue !== void 0 ? _context_hoveredValue : ratingValue;
		const appearance = context.interactive ? "outline" : "filled";
		let iconFillWidth;
		if (context.compact || displayedRatingValue >= value) iconFillWidth = 1;
		else if (displayedRatingValue >= value - .5) iconFillWidth = .5;
		else iconFillWidth = 0;
		const root = always(getIntrinsicElementProps("span", {
			ref: useMergedRefs(useFocusWithin(), ref),
			...props
		}), { elementType: "span" });
		let unselectedIcon;
		if (iconFillWidth < 1) unselectedIcon = always(props.unselectedIcon, {
			defaultProps: {
				children: appearance === "filled" ? /* @__PURE__ */ react.createElement(IconFilled, null) : /* @__PURE__ */ react.createElement(IconOutline, null),
				"aria-hidden": true
			},
			elementType: "div"
		});
		let selectedIcon;
		if (iconFillWidth > 0) selectedIcon = always(props.selectedIcon, {
			defaultProps: {
				children: /* @__PURE__ */ react.createElement(IconFilled, null),
				"aria-hidden": true
			},
			elementType: "div"
		});
		let halfValueInput;
		if (context.interactive && context.step === .5) halfValueInput = always(props.halfValueInput, {
			defaultProps: {
				type: "radio",
				name: context.name,
				value: value - .5,
				checked: ratingValue === value - .5,
				"aria-label": itemLabel(value - .5),
				onChange: () => {}
			},
			elementType: "input"
		});
		let fullValueInput;
		if (context.interactive) fullValueInput = always(props.fullValueInput, {
			defaultProps: {
				type: "radio",
				name: context.name,
				value,
				checked: ratingValue === value,
				"aria-label": itemLabel(value),
				onChange: () => {}
			},
			elementType: "input"
		});
		return {
			appearance,
			color: context.color,
			step: context.step,
			size: context.size,
			iconFillWidth,
			value,
			components: {
				root: "span",
				selectedIcon: "div",
				unselectedIcon: "div",
				halfValueInput: "input",
				fullValueInput: "input"
			},
			root,
			selectedIcon,
			unselectedIcon,
			halfValueInput,
			fullValueInput
		};
	};

//#endregion
//#region node_modules/@fluentui/react-rating/lib/components/RatingItem/renderRatingItem.js
/**
	* Render the final JSX of RatingItem
	*/ const renderRatingItem_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(state.root, { children: [
			state.halfValueInput && /* @__PURE__ */ jsx(state.halfValueInput, {}),
			state.fullValueInput && /* @__PURE__ */ jsx(state.fullValueInput, {}),
			state.unselectedIcon && /* @__PURE__ */ jsx(state.unselectedIcon, {}),
			state.selectedIcon && /* @__PURE__ */ jsx(state.selectedIcon, {})
		] });
	};

//#endregion
//#region node_modules/@fluentui/react-rating/lib/components/RatingItem/useRatingItemStyles.styles.js
	const ratingItemClassNames = {
		root: "fui-RatingItem",
		selectedIcon: "fui-RatingItem__selectedIcon",
		unselectedIcon: "fui-RatingItem__unselectedIcon",
		halfValueInput: "fui-RatingItem__halfValueInput",
		fullValueInput: "fui-RatingItem__fullValueInput"
	};
	/**
	* Styles for the root slot
	*/
	const useStyles$45 = /* @__PURE__ */ __styles({
		root: {
			qhf8xq: "f10pi13n",
			Brovlpu: "ftqa4ok",
			B486eqv: "f2hkw1w",
			Bssx7fj: "f1b1k54r",
			uh7if5: ["f4ne723", "fqqcjud"],
			clntm0: "fh7aioi",
			Dlk2r6: ["fqqcjud", "f4ne723"],
			h6p2u: "f1ufm4qn",
			I6qiy5: ["f1qnwcb4", "fgrk5zm"],
			yzno9d: "fi52z01",
			By0wis0: ["fgrk5zm", "f1qnwcb4"],
			B2j2mmj: "ffht0p2",
			wigs8: "f1p0ul1q",
			pbfy6t: "f1c901ms",
			B0v4ure: "f1alokd7",
			Byrf0fs: 0,
			Bsiemmq: 0,
			Bwckmig: 0,
			skfxo0: 0,
			Iidy0u: 0,
			B98u21t: 0,
			Bvwlmkc: 0,
			jo1ztg: 0,
			Ba1iezr: 0,
			Blmvk6g: 0,
			B24cy0v: 0,
			Bil7v7r: 0,
			Br3gin4: 0,
			nr063g: 0,
			ghq09: 0,
			Bbgo44z: 0,
			Bseh09z: "fmj8fco",
			az1dzo: 0,
			Ba3ybja: 0,
			B6352mv: 0,
			vppk2z: 0,
			Biaj6j7: "f1iwowo3",
			B2pnrqr: "f1spmvte",
			B29w5g4: ["fgp7k2s", "f13pb23"],
			Bhhzhcn: "f1ihbrwi",
			Bec0n69: ["f13pb23", "fgp7k2s"]
		},
		small: {
			Be2twd7: "f1ugzwwg",
			a9b677: "frx94fk",
			Bqenvij: "fvblgha"
		},
		medium: {
			Be2twd7: "f4ybsrx",
			a9b677: "fjw5fx7",
			Bqenvij: "fd461yt"
		},
		large: {
			Be2twd7: "fe5j1ua",
			a9b677: "f64fuq3",
			Bqenvij: "fjamq6b"
		},
		"extra-large": {
			Be2twd7: "f24l1pt",
			a9b677: "f1w9dchk",
			Bqenvij: "fxldao9"
		}
	}, {
		d: [
			".f10pi13n{position:relative;}",
			".f1b1k54r[data-fui-focus-within]:focus-within{border-top-color:transparent;}",
			".f4ne723[data-fui-focus-within]:focus-within{border-right-color:transparent;}",
			".fqqcjud[data-fui-focus-within]:focus-within{border-left-color:transparent;}",
			".fh7aioi[data-fui-focus-within]:focus-within{border-bottom-color:transparent;}",
			".ffht0p2[data-fui-focus-within]:focus-within::after{content:\"\";}",
			".f1p0ul1q[data-fui-focus-within]:focus-within::after{position:absolute;}",
			".f1c901ms[data-fui-focus-within]:focus-within::after{pointer-events:none;}",
			".f1alokd7[data-fui-focus-within]:focus-within::after{z-index:1;}",
			[".fmj8fco[data-fui-focus-within]:focus-within::after{border:2px solid var(--colorStrokeFocus2);}", { p: -2 }],
			[".f1iwowo3[data-fui-focus-within]:focus-within::after{border-radius:var(--borderRadiusMedium);}", { p: -1 }],
			".f1spmvte[data-fui-focus-within]:focus-within::after{top:calc(2px * -1);}",
			".fgp7k2s[data-fui-focus-within]:focus-within::after{right:calc(2px * -1);}",
			".f13pb23[data-fui-focus-within]:focus-within::after{left:calc(2px * -1);}",
			".f1ihbrwi[data-fui-focus-within]:focus-within::after{bottom:calc(2px * -1);}",
			".f1ugzwwg{font-size:12px;}",
			".frx94fk{width:12px;}",
			".fvblgha{height:12px;}",
			".f4ybsrx{font-size:16px;}",
			".fjw5fx7{width:16px;}",
			".fd461yt{height:16px;}",
			".fe5j1ua{font-size:20px;}",
			".f64fuq3{width:20px;}",
			".fjamq6b{height:20px;}",
			".f24l1pt{font-size:28px;}",
			".f1w9dchk{width:28px;}",
			".fxldao9{height:28px;}"
		],
		f: [".ftqa4ok:focus{outline-style:none;}"],
		i: [".f2hkw1w:focus-visible{outline-style:none;}"],
		m: [
			["@media (forced-colors: active){.f1ufm4qn[data-fui-focus-within]:focus-within::after{border-top-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1qnwcb4[data-fui-focus-within]:focus-within::after{border-right-color:Highlight;}.fgrk5zm[data-fui-focus-within]:focus-within::after{border-left-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fi52z01[data-fui-focus-within]:focus-within::after{border-bottom-color:Highlight;}}", { m: "(forced-colors: active)" }]
		]
	});
	const useInputBaseClassName = /* @__PURE__ */ __resetStyles("r1qfsv1p", "rh8pzaz", [".r1qfsv1p{position:absolute;left:0;top:0;right:0;bottom:0;box-sizing:border-box;margin:0;opacity:0;cursor:pointer;height:100%;}", ".rh8pzaz{position:absolute;right:0;top:0;left:0;bottom:0;box-sizing:border-box;margin:0;opacity:0;cursor:pointer;height:100%;}"]);
	const useInputStyles$3 = /* @__PURE__ */ __styles({
		lowerHalf: { j35jbq: ["ffenbu1", "f1ktbn1t"] },
		upperHalf: { oyh7mz: ["f1ktbn1t", "ffenbu1"] }
	}, { d: [".ffenbu1{right:50%;}", ".f1ktbn1t{left:50%;}"] });
	const useIndicatorBaseClassName = /* @__PURE__ */ __resetStyles("r1420l2m", "r1yt29v5", [".r1420l2m{display:flex;overflow:hidden;color:var(--colorNeutralForeground1);fill:currentColor;pointer-events:none;position:absolute;left:0;right:0;top:0;bottom:0;}", ".r1yt29v5{display:flex;overflow:hidden;color:var(--colorNeutralForeground1);fill:currentColor;pointer-events:none;position:absolute;right:0;left:0;top:0;bottom:0;}"]);
	const useIndicatorStyles$1 = /* @__PURE__ */ __styles({
		lowerHalf: {
			j35jbq: ["ffenbu1", "f1ktbn1t"],
			l5kjut: 0,
			uoufgc: 0,
			v39lw8: 0,
			Bbwb3tu: "f10jwh99"
		},
		upperHalf: {
			oyh7mz: ["f1ktbn1t", "ffenbu1"],
			Frg6f3: ["fbm7ezh", "f3ev47i"]
		},
		brand: { sj55zd: "f16muhyy" },
		marigold: { sj55zd: "f1whvut0" },
		filled: {
			sj55zd: "f1qaymga",
			ojy3ng: "f13qq9og",
			B7iucu3: "f1205bnn",
			Biw2w6l: "f1nocmko"
		},
		brandFilled: { sj55zd: "f1kdv6iu" },
		marigoldFilled: { sj55zd: "f1ymbmfq" }
	}, {
		d: [
			".ffenbu1{right:50%;}",
			".f1ktbn1t{left:50%;}",
			[".f10jwh99>svg{flex:0 0 auto;}", { p: -1 }],
			".fbm7ezh{margin-left:-50%;}",
			".f3ev47i{margin-right:-50%;}",
			".f16muhyy{color:var(--colorBrandForeground1);}",
			".f1whvut0{color:var(--colorPaletteMarigoldBorderActive);}",
			".f1qaymga{color:var(--colorNeutralBackground6);}",
			".f13qq9og{stroke:var(--colorTransparentStroke);}",
			".f1kdv6iu{color:var(--colorBrandBackground2);}",
			".f1ymbmfq{color:var(--colorPaletteMarigoldBackground2);}"
		],
		m: [["@media (forced-colors: active){.f1205bnn{color:Canvas;}}", { m: "(forced-colors: active)" }], ["@media (forced-colors: active){.f1nocmko{stroke:CanvasText;}}", { m: "(forced-colors: active)" }]]
	});
	/**
	* Apply styling to the RatingItem slots based on the state
	*/
	const useRatingItemStyles_unstable = (state) => {
		"use no memo";
		const { color: color$1, size: size$2, iconFillWidth, appearance } = state;
		const styles = useStyles$45();
		const inputBaseClassName = useInputBaseClassName();
		const inputStyles = useInputStyles$3();
		const indicatorBaseClassName = useIndicatorBaseClassName();
		const indicatorStyles = useIndicatorStyles$1();
		state.root.className = mergeClasses(ratingItemClassNames.root, styles.root, styles[size$2], state.root.className);
		if (state.halfValueInput) state.halfValueInput.className = mergeClasses(ratingItemClassNames.halfValueInput, inputBaseClassName, inputStyles.lowerHalf, state.halfValueInput.className);
		if (state.fullValueInput) state.fullValueInput.className = mergeClasses(ratingItemClassNames.fullValueInput, inputBaseClassName, state.halfValueInput && inputStyles.upperHalf, state.fullValueInput.className);
		if (state.unselectedIcon) state.unselectedIcon.className = mergeClasses(ratingItemClassNames.unselectedIcon, indicatorBaseClassName, appearance === "filled" && indicatorStyles.filled, color$1 === "brand" && (appearance === "filled" ? indicatorStyles.brandFilled : indicatorStyles.brand), color$1 === "marigold" && (appearance === "filled" ? indicatorStyles.marigoldFilled : indicatorStyles.marigold), iconFillWidth === .5 && indicatorStyles.upperHalf, state.unselectedIcon.className);
		if (state.selectedIcon) state.selectedIcon.className = mergeClasses(ratingItemClassNames.selectedIcon, indicatorBaseClassName, color$1 === "brand" && indicatorStyles.brand, color$1 === "marigold" && indicatorStyles.marigold, iconFillWidth === .5 && indicatorStyles.lowerHalf, state.selectedIcon.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-rating/lib/components/RatingItem/RatingItem.js
/**
	* RatingItem is an item that will be used to set or display a rating value.
	*/ const RatingItem = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useRatingItem_unstable(props, ref);
		useRatingItemStyles_unstable(state);
		useCustomStyleHook("useRatingItemStyles_unstable")(state);
		return renderRatingItem_unstable(state);
	});
	RatingItem.displayName = "RatingItem";

//#endregion
//#region node_modules/@fluentui/react-rating/lib/components/Rating/useRating.js
/**
	* Create the state required to render Rating.
	*
	* The returned state can be modified with hooks such as useRatingStyles_unstable,
	* before being passed to renderRating_unstable.
	*
	* @param props - props from this instance of Rating
	* @param ref - reference to root HTMLElement of Rating
	*/ const useRating_unstable = (props, ref) => {
		const generatedName = useId("rating-");
		const { color: color$1 = "neutral", iconFilled = StarFilled, iconOutline = StarRegular, max: max$1 = 5, name = generatedName, onChange, step = 1, size: size$2 = "extra-large", itemLabel } = props;
		const [value, setValue] = useControllableState({
			state: props.value,
			defaultState: props.defaultValue,
			initialState: 0
		});
		const isRatingRadioItem = (target) => isHTMLElement(target, { constructorName: "HTMLInputElement" }) && target.type === "radio" && target.name === name;
		const [hoveredValue, setHoveredValue] = react.useState(void 0);
		const rootChildren = react.useMemo(() => {
			return Array.from(Array(max$1), (_, i) => /* @__PURE__ */ react.createElement(RatingItem, {
				value: i + 1,
				key: i + 1
			}));
		}, [max$1]);
		const state = {
			color: color$1,
			iconFilled,
			iconOutline,
			name,
			step,
			size: size$2,
			itemLabel,
			value,
			hoveredValue,
			components: { root: "div" },
			root: always(getIntrinsicElementProps("div", {
				ref,
				children: rootChildren,
				role: "radiogroup",
				...props
			}, ["onChange"]), { elementType: "div" })
		};
		state.root.onChange = (ev) => {
			if (isRatingRadioItem(ev.target)) {
				const newValue = parseFloat(ev.target.value);
				if (!isNaN(newValue)) {
					setValue(newValue);
					onChange === null || onChange === void 0 || onChange(ev, {
						type: "change",
						event: ev,
						value: newValue
					});
				}
			}
		};
		state.root.onMouseOver = mergeCallbacks(props.onMouseOver, (ev) => {
			if (isRatingRadioItem(ev.target)) {
				const newValue = parseFloat(ev.target.value);
				if (!isNaN(newValue)) setHoveredValue(newValue);
			}
		});
		state.root.onMouseLeave = mergeCallbacks(props.onMouseLeave, (ev) => {
			setHoveredValue(void 0);
		});
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-rating/lib/components/Rating/renderRating.js
/**
	* Render the final JSX of Rating
	*/ const renderRating_unstable = (state, contextValues) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(RatingItemProvider, {
			value: contextValues.ratingItem,
			children: /* @__PURE__ */ jsx(state.root, {})
		});
	};

//#endregion
//#region node_modules/@fluentui/react-rating/lib/components/Rating/useRatingStyles.styles.js
	const ratingClassNames = { root: "fui-Rating" };
	/**
	* Styles for the root slot
	*/
	const useRootClassName$1 = /* @__PURE__ */ __resetStyles("r2imjyh", null, [".r2imjyh{display:flex;flex-wrap:wrap;}"]);
	/**
	* Apply styling to the Rating slots based on the state
	*/
	const useRatingStyles_unstable = (state) => {
		"use no memo";
		const rootClassName = useRootClassName$1();
		state.root.className = mergeClasses(ratingClassNames.root, rootClassName, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-rating/lib/components/Rating/useRatingContextValues.js
	const useRatingContextValues = (ratingState) => {
		const { color: color$1, hoveredValue, iconFilled, iconOutline, itemLabel, name, step, size: size$2, value } = ratingState;
		return { ratingItem: react.useMemo(() => ({
			color: color$1,
			hoveredValue,
			iconFilled,
			iconOutline,
			interactive: true,
			itemLabel,
			name,
			step,
			size: size$2,
			value
		}), [
			color$1,
			hoveredValue,
			iconFilled,
			iconOutline,
			itemLabel,
			name,
			step,
			size$2,
			value
		]) };
	};

//#endregion
//#region node_modules/@fluentui/react-rating/lib/components/Rating/Rating.js
/**
	* Rating is a wrapper for one or more rating items that will be used to set a rating value.
	*/ const Rating = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useRating_unstable(props, ref);
		const contextValues = useRatingContextValues(state);
		useRatingStyles_unstable(state);
		useCustomStyleHook("useRatingStyles_unstable")(state);
		return renderRating_unstable(state, contextValues);
	});
	Rating.displayName = "Rating";

//#endregion
//#region node_modules/@fluentui/react-rating/lib/components/RatingDisplay/useRatingDisplay.js
/**
	* Create the state required to render RatingDisplay.
	*
	* The returned state can be modified with hooks such as useRatingDisplayStyles_unstable,
	* before being passed to renderRatingDisplay_unstable.
	*
	* @param props - props from this instance of RatingDisplay
	* @param ref - reference to root HTMLDivElement of RatingDisplay
	*/ const useRatingDisplay_unstable = (props, ref) => {
		const { color: color$1 = "neutral", count, compact = false, icon = StarFilled, max: max$1 = 5, size: size$2 = "medium", value } = props;
		const valueTextId = useId("rating-value-");
		const countTextId = useId("rating-count-");
		const rootChildren = react.useMemo(() => {
			return compact ? /* @__PURE__ */ react.createElement(RatingItem, {
				value: 1,
				key: 1,
				"aria-hidden": true
			}) : Array.from(Array(max$1), (_, i) => /* @__PURE__ */ react.createElement(RatingItem, {
				value: i + 1,
				key: i + 1,
				"aria-hidden": true
			}));
		}, [compact, max$1]);
		const state = {
			color: color$1,
			compact,
			icon,
			max: max$1,
			size: size$2,
			value,
			components: {
				root: "div",
				valueText: "span",
				countText: "span"
			},
			root: always(getIntrinsicElementProps("div", {
				ref,
				children: rootChildren,
				role: "img",
				...props
			}), { elementType: "div" }),
			valueText: optional(props.valueText, {
				renderByDefault: value !== void 0,
				defaultProps: {
					children: value,
					id: valueTextId,
					"aria-hidden": true
				},
				elementType: "span"
			}),
			countText: optional(props.countText, {
				renderByDefault: count !== void 0,
				defaultProps: {
					children: count === null || count === void 0 ? void 0 : count.toLocaleString(),
					id: countTextId,
					"aria-hidden": true
				},
				elementType: "span"
			})
		};
		if (!state.root["aria-label"] && !state.root["aria-labelledby"]) {
			var _state_valueText, _state_countText;
			state.root["aria-labelledby"] = [(_state_valueText = state.valueText) === null || _state_valueText === void 0 ? void 0 : _state_valueText.id, (_state_countText = state.countText) === null || _state_countText === void 0 ? void 0 : _state_countText.id].filter(Boolean).join(" ");
		}
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-rating/lib/components/RatingDisplay/renderRatingDisplay.js
/**
	* Render the final JSX of RatingDisplay
	*/ const renderRatingDisplay_unstable = (state, contextValues) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(RatingItemProvider, {
			value: contextValues.ratingItem,
			children: /* @__PURE__ */ jsxs(state.root, { children: [
				state.root.children,
				state.valueText && /* @__PURE__ */ jsx(state.valueText, {}),
				state.countText && /* @__PURE__ */ jsx(state.countText, {})
			] })
		});
	};

//#endregion
//#region node_modules/@fluentui/react-rating/lib/components/RatingDisplay/useRatingDisplayStyles.styles.js
	const ratingDisplayClassNames = {
		root: "fui-RatingDisplay",
		valueText: "fui-RatingDisplay__valueText",
		countText: "fui-RatingDisplay__countText"
	};
	/**
	* Styles for the root slot
	*/
	const useRootClassName = /* @__PURE__ */ __resetStyles("rxxdqwu", null, [".rxxdqwu{display:flex;flex-wrap:wrap;align-items:center;}"]);
	const useLabelClassName = /* @__PURE__ */ __resetStyles("rkwnos5", "rwei36a", [".rkwnos5{color:var(--colorNeutralForeground1);margin-left:var(--spacingHorizontalXS);font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase200);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase200);}", ".rwei36a{color:var(--colorNeutralForeground1);margin-right:var(--spacingHorizontalXS);font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase200);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase200);}"]);
	const useLabelStyles = /* @__PURE__ */ __styles({
		large: {
			Be2twd7: "fkhj508",
			Bg96gwp: "f1i3iumi",
			Frg6f3: ["f1t5qyk5", "f1ikr372"]
		},
		extraLarge: {
			Be2twd7: "fod5ikn",
			Bg96gwp: "faaz57k",
			Frg6f3: ["foyynoy", "f1vcna3q"]
		},
		strong: { Bhrd7zp: "fl43uef" },
		divider: { Ftih45: "f169p45e" }
	}, { d: [
		".fkhj508{font-size:var(--fontSizeBase300);}",
		".f1i3iumi{line-height:var(--lineHeightBase300);}",
		".f1t5qyk5{margin-left:var(--spacingHorizontalSNudge);}",
		".f1ikr372{margin-right:var(--spacingHorizontalSNudge);}",
		".fod5ikn{font-size:var(--fontSizeBase400);}",
		".faaz57k{line-height:var(--lineHeightBase400);}",
		".foyynoy{margin-left:var(--spacingHorizontalS);}",
		".f1vcna3q{margin-right:var(--spacingHorizontalS);}",
		".fl43uef{font-weight:var(--fontWeightSemibold);}",
		".f169p45e::before{content:\" \";}"
	] });
	/**
	* Apply styling to the RatingDisplay slots based on the state
	*/
	const useRatingDisplayStyles_unstable = (state) => {
		"use no memo";
		const { size: size$2 } = state;
		const rootClassName = useRootClassName();
		state.root.className = mergeClasses(ratingDisplayClassNames.root, rootClassName, state.root.className);
		const labelClassName = useLabelClassName();
		const labelStyles = useLabelStyles();
		if (state.valueText) state.valueText.className = mergeClasses(ratingDisplayClassNames.valueText, labelClassName, labelStyles.strong, size$2 === "large" && labelStyles.large, size$2 === "extra-large" && labelStyles.extraLarge, state.valueText.className);
		if (state.countText) state.countText.className = mergeClasses(ratingDisplayClassNames.countText, labelClassName, size$2 === "large" && labelStyles.large, size$2 === "extra-large" && labelStyles.extraLarge, state.valueText && labelStyles.divider, state.countText.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-rating/lib/components/RatingDisplay/useRatingDisplayContextValues.js
	const useRatingDisplayContextValues = (state) => {
		const { color: color$1, compact, icon, size: size$2, value } = state;
		return { ratingItem: react.useMemo(() => ({
			color: color$1,
			compact,
			iconFilled: icon,
			iconOutline: icon,
			interactive: false,
			step: .5,
			size: size$2,
			value
		}), [
			color$1,
			compact,
			icon,
			size$2,
			value
		]) };
	};

//#endregion
//#region node_modules/@fluentui/react-rating/lib/components/RatingDisplay/RatingDisplay.js
/**
	* RatingDisplay is a wrapper for one or more rating items that will be used to display a rating value
	* as well as the label for the rating.
	*/ const RatingDisplay = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useRatingDisplay_unstable(props, ref);
		const contextValues = useRatingDisplayContextValues(state);
		useRatingDisplayStyles_unstable(state);
		useCustomStyleHook("useRatingDisplayStyles_unstable")(state);
		return renderRatingDisplay_unstable(state, contextValues);
	});
	RatingDisplay.displayName = "RatingDisplay";

//#endregion
//#region node_modules/@fluentui/react-search/lib/components/SearchBox/useSearchBox.js
/**
	* Create the state required to render SearchBox.
	*
	* The returned state can be modified with hooks such as useSearchBoxStyles_unstable,
	* before being passed to renderSearchBox_unstable.
	*
	* @param props - props from this instance of SearchBox
	* @param ref - reference to root HTMLElement of SearchBox
	*/ const useSearchBox_unstable = (props, ref) => {
		const { size: size$2 = "medium", disabled = false, root, contentBefore, dismiss, contentAfter, value, defaultValue, ...inputProps } = props;
		const searchBoxRootRef = react.useRef(null);
		const searchBoxRef = react.useRef(null);
		const [internalValue, setInternalValue] = useControllableState({
			state: value,
			defaultState: defaultValue,
			initialState: ""
		});
		const [focused, setFocused] = react.useState(false);
		const onFocus = react.useCallback(() => {
			setFocused(true);
		}, [setFocused]);
		const onBlur = react.useCallback((ev) => {
			var _searchBoxRootRef_current;
			setFocused(!!((_searchBoxRootRef_current = searchBoxRootRef.current) === null || _searchBoxRootRef_current === void 0 ? void 0 : _searchBoxRootRef_current.contains(ev.relatedTarget)));
		}, [setFocused]);
		const rootProps = resolveShorthand$1(root);
		const handleDismissClick = useEventCallback((event) => {
			var _props_onChange, _searchBoxRef_current;
			if (isResolvedShorthand(dismiss)) {
				var _dismiss_onClick;
				(_dismiss_onClick = dismiss.onClick) === null || _dismiss_onClick === void 0 || _dismiss_onClick.call(dismiss, event);
			}
			const newValue = "";
			setInternalValue(newValue);
			(_props_onChange = props.onChange) === null || _props_onChange === void 0 || _props_onChange.call(props, event, { value: newValue });
			(_searchBoxRef_current = searchBoxRef.current) === null || _searchBoxRef_current === void 0 || _searchBoxRef_current.focus();
		});
		const inputState = useInput_unstable({
			type: "search",
			disabled,
			size: size$2,
			value: internalValue,
			root: always({
				...rootProps,
				ref: useMergedRefs(rootProps === null || rootProps === void 0 ? void 0 : rootProps.ref, searchBoxRootRef),
				onFocus: mergeCallbacks(rootProps === null || rootProps === void 0 ? void 0 : rootProps.onFocus, onFocus),
				onBlur: mergeCallbacks(rootProps === null || rootProps === void 0 ? void 0 : rootProps.onBlur, onBlur)
			}, { elementType: "span" }),
			contentBefore: optional(contentBefore, {
				renderByDefault: true,
				defaultProps: { children: /* @__PURE__ */ react.createElement(SearchRegular, null) },
				elementType: "span"
			}),
			contentAfter: optional(contentAfter, {
				renderByDefault: true,
				elementType: "span"
			}),
			...inputProps,
			onChange: useEventCallback((ev) => {
				var _props_onChange;
				const newValue = ev.target.value;
				(_props_onChange = props.onChange) === null || _props_onChange === void 0 || _props_onChange.call(props, ev, { value: newValue });
				setInternalValue(newValue);
			})
		}, useMergedRefs(searchBoxRef, ref));
		const state = {
			...inputState,
			components: {
				...inputState.components,
				dismiss: "span"
			},
			dismiss: optional(dismiss, {
				defaultProps: {
					children: /* @__PURE__ */ react.createElement(DismissRegular, null),
					role: "button",
					"aria-label": "clear",
					tabIndex: -1
				},
				renderByDefault: true,
				elementType: "span"
			}),
			disabled,
			focused,
			size: size$2
		};
		if (state.dismiss) state.dismiss.onClick = handleDismissClick;
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-search/lib/components/SearchBox/renderSearchBox.js
/**
	* Render the final JSX of SearchBox
	*/ const renderSearchBox_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(state.root, { children: [
			state.contentBefore && /* @__PURE__ */ jsx(state.contentBefore, {}),
			/* @__PURE__ */ jsx(state.input, {}),
			state.contentAfter && /* @__PURE__ */ jsxs(state.contentAfter, { children: [state.contentAfter.children, state.dismiss && /* @__PURE__ */ jsx(state.dismiss, {})] })
		] });
	};

//#endregion
//#region node_modules/@fluentui/react-search/lib/components/SearchBox/useSearchBoxStyles.styles.js
	const searchBoxClassNames = {
		root: "fui-SearchBox",
		dismiss: "fui-SearchBox__dismiss",
		contentAfter: "fui-SearchBox__contentAfter",
		contentBefore: "fui-SearchBox__contentBefore",
		input: "fui-SearchBox__input"
	};
	/**
	* Styles for the root slot
	*/
	const useRootStyles$4 = /* @__PURE__ */ __styles({
		small: {
			i8kkvl: "fjuset5",
			B2u0y6b: "f1xzfw5u",
			uwmqm3: ["fk8j09s", "fdw0yi8"],
			z189sj: ["fdw0yi8", "fk8j09s"]
		},
		medium: {
			i8kkvl: "fjuset5",
			B2u0y6b: "f1xzfw5u",
			uwmqm3: ["f1f5gg8d", "f1vdfbxk"],
			z189sj: ["f1vdfbxk", "f1f5gg8d"]
		},
		large: {
			i8kkvl: "fjuset5",
			B2u0y6b: "f1xzfw5u",
			uwmqm3: ["f1ng84yb", "f11gcy0p"],
			z189sj: ["f11gcy0p", "f1ng84yb"]
		},
		input: {
			uwmqm3: ["fk8j09s", "fdw0yi8"],
			z189sj: ["fhxju0i", "f1cnd47f"],
			Boqhc8c: "f18izjht",
			B8uat0v: "fcoa6sg"
		},
		unfocusedNoContentAfter: { z189sj: ["fhxju0i", "f1cnd47f"] }
	}, { d: [
		".fjuset5{column-gap:0;}",
		".f1xzfw5u{max-width:468px;}",
		".fk8j09s{padding-left:var(--spacingHorizontalSNudge);}",
		".fdw0yi8{padding-right:var(--spacingHorizontalSNudge);}",
		".f1f5gg8d{padding-left:var(--spacingHorizontalS);}",
		".f1vdfbxk{padding-right:var(--spacingHorizontalS);}",
		".f1ng84yb{padding-left:var(--spacingHorizontalMNudge);}",
		".f11gcy0p{padding-right:var(--spacingHorizontalMNudge);}",
		".fhxju0i{padding-right:0;}",
		".f1cnd47f{padding-left:0;}",
		".f18izjht::-webkit-search-decoration{display:none;}",
		".fcoa6sg::-webkit-search-cancel-button{display:none;}"
	] });
	const useInputStyles$2 = /* @__PURE__ */ __styles({
		small: { z189sj: ["fdw0yi8", "fk8j09s"] },
		medium: { z189sj: ["f1vdfbxk", "f1f5gg8d"] },
		large: { z189sj: ["f11gcy0p", "f1ng84yb"] }
	}, { d: [
		".fdw0yi8{padding-right:var(--spacingHorizontalSNudge);}",
		".fk8j09s{padding-left:var(--spacingHorizontalSNudge);}",
		".f1vdfbxk{padding-right:var(--spacingHorizontalS);}",
		".f1f5gg8d{padding-left:var(--spacingHorizontalS);}",
		".f11gcy0p{padding-right:var(--spacingHorizontalMNudge);}",
		".f1ng84yb{padding-left:var(--spacingHorizontalMNudge);}"
	] });
	const useContentAfterStyles = /* @__PURE__ */ __styles({
		contentAfter: {
			uwmqm3: ["f1uw59to", "fw5db7e"],
			i8kkvl: "f1ufnopg"
		},
		rest: {
			Bqenvij: "fniina8",
			a9b677: "f3tsq5r",
			uwmqm3: ["f1cnd47f", "fhxju0i"],
			B68tc82: 0,
			Bmxbyg5: 0,
			Bpg54ce: "f1a3p1vp"
		}
	}, { d: [
		".f1uw59to{padding-left:var(--spacingHorizontalM);}",
		".fw5db7e{padding-right:var(--spacingHorizontalM);}",
		".f1ufnopg{column-gap:var(--spacingHorizontalXS);}",
		".fniina8{height:0;}",
		".f3tsq5r{width:0;}",
		".f1cnd47f{padding-left:0;}",
		".fhxju0i{padding-right:0;}",
		[".f1a3p1vp{overflow:hidden;}", { p: -1 }]
	] });
	const useDismissClassName = /* @__PURE__ */ __resetStyles("r1pvzcuu", null, [".r1pvzcuu{box-sizing:border-box;color:var(--colorNeutralForeground3);display:flex;cursor:pointer;}", ".r1pvzcuu>svg{font-size:20px;}"]);
	const useDismissStyles = /* @__PURE__ */ __styles({
		disabled: { sj55zd: "f1s2aq7o" },
		small: { Duoase: "f3qv9w" },
		medium: {},
		large: { Duoase: "f16u2scb" }
	}, { d: [
		".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}",
		".f3qv9w>svg{font-size:16px;}",
		".f16u2scb>svg{font-size:24px;}"
	] });
	/**
	* Apply styling to the SearchBox slots based on the state
	*/
	const useSearchBoxStyles_unstable = (state) => {
		"use no memo";
		const { disabled, focused, size: size$2 } = state;
		const rootStyles = useRootStyles$4();
		const inputStyles = useInputStyles$2();
		const contentAfterStyles = useContentAfterStyles();
		const dismissClassName = useDismissClassName();
		const dismissStyles = useDismissStyles();
		state.root.className = mergeClasses(searchBoxClassNames.root, rootStyles[size$2], !focused && rootStyles.unfocusedNoContentAfter, state.root.className);
		state.input.className = mergeClasses(searchBoxClassNames.input, rootStyles.input, !focused && inputStyles[size$2], state.input.className);
		if (state.dismiss) state.dismiss.className = mergeClasses(searchBoxClassNames.dismiss, dismissClassName, disabled && dismissStyles.disabled, dismissStyles[size$2], state.dismiss.className);
		if (state.contentBefore) state.contentBefore.className = mergeClasses(searchBoxClassNames.contentBefore, state.contentBefore.className);
		if (state.contentAfter) state.contentAfter.className = mergeClasses(searchBoxClassNames.contentAfter, contentAfterStyles.contentAfter, !focused && contentAfterStyles.rest, state.contentAfter.className);
		else if (state.dismiss) state.dismiss.className = mergeClasses(state.dismiss.className, contentAfterStyles.contentAfter);
		useInputStyles_unstable(state);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-search/lib/components/SearchBox/SearchBox.js
/**
	* SearchBox component - TODO: add more docs
	*/ const SearchBox = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useSearchBox_unstable(props, ref);
		useSearchBoxStyles_unstable(state);
		useCustomStyleHook("useSearchBoxStyles_unstable")(state);
		return renderSearchBox_unstable(state);
	});
	SearchBox.displayName = "SearchBox";

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverHeader/useTeachingPopoverHeader.js
/**
	* Returns the props and state required to render the component
	* @param props - TeachingPopoverHeader properties
	* @param ref - reference to root HTMLElement of TeachingPopoverHeader
	*/ const useTeachingPopoverHeader_unstable = (props, ref) => {
		const { dismissButton, icon } = props;
		const setOpen = usePopoverContext_unstable((context) => context.setOpen);
		const triggerRef = usePopoverContext_unstable((context) => context.triggerRef);
		const appearance = usePopoverContext_unstable((context) => context.appearance);
		const onDismissButtonClick = useEventCallback((ev) => {
			if (!ev.defaultPrevented) setOpen(ev, false);
			if (triggerRef.current) triggerRef.current.focus();
		});
		return {
			appearance,
			components: {
				root: "div",
				dismissButton: "button",
				icon: "div"
			},
			root: always(getIntrinsicElementProps("div", {
				ref,
				...props
			}), { elementType: "div" }),
			icon: optional(icon, {
				renderByDefault: true,
				defaultProps: {
					children: /* @__PURE__ */ react.createElement(Lightbulb16Regular, null),
					"aria-hidden": true
				},
				elementType: "div"
			}),
			dismissButton: optional(dismissButton, {
				renderByDefault: true,
				defaultProps: {
					children: /* @__PURE__ */ react.createElement(Dismiss12Regular, null),
					role: "button",
					"aria-label": "dismiss",
					onClick: onDismissButtonClick
				},
				elementType: "button"
			})
		};
	};

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverHeader/renderTeachingPopoverHeader.js
/**
	* Render the final JSX of TeachingPopoverHeader
	*/ const renderTeachingPopoverHeader_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(state.root, { children: [
			state.icon && /* @__PURE__ */ jsx(state.icon, {}),
			state.root.children,
			state.dismissButton && /* @__PURE__ */ jsx(state.dismissButton, {})
		] });
	};

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverHeader/useTeachingPopoverHeaderStyles.styles.js
	const teachingPopoverHeaderClassNames = {
		root: "fui-TeachingPopoverHeader",
		dismissButton: "fui-TeachingPopoverHeader__dismissButton",
		icon: "fui-TeachingPopoverHeader__icon"
	};
	const useStyles$44 = /* @__PURE__ */ __styles({
		root: {
			mc9l5x: "f22iagw",
			Beiy3e4: "f1063pyq",
			sj55zd: "f11d4kpn",
			Bhrd7zp: "fl43uef",
			Be2twd7: "fy9rknc",
			Bg96gwp: "fwrc4pm",
			Byoj8tv: "f14wxoun",
			Bt984gj: "f122n59",
			B6of3ja: "f1jkagg5",
			jrapky: "fi2ljxd"
		},
		rootBrand: { sj55zd: "f1phragk" },
		dismissButton: {
			sj55zd: "fkfq4zb",
			qhf8xq: "f10pi13n",
			Bgfg5da: 0,
			B9xav0g: 0,
			oivjwe: 0,
			Bn0qgzm: 0,
			B4g9neb: 0,
			zhjwy3: 0,
			wvpqe5: 0,
			ibv6hh: 0,
			u1mtju: 0,
			h3c5rm: 0,
			vrafjx: ["f1n71otn", "f1deefiw"],
			Bekrc4i: 0,
			i8vvqc: 0,
			g2u3we: 0,
			icvyot: 0,
			B4j52fo: 0,
			irswps: "f88035w",
			mc9l5x: "f22iagw",
			Bt984gj: "f122n59",
			Bceei9c: "f1k6fduh",
			Bahqtrf: "fk6fouc",
			Be2twd7: "fkhj508",
			Bhrd7zp: "figsok6",
			Bg96gwp: "f1i3iumi",
			De3pzq: "f1c21dwh",
			B7ck84d: "f1ewtqcl",
			B7oj6ja: ["f3fg2lr", "f13av6d4"],
			Bbmb7ep: ["fzi6hpg", "fyowgf4"],
			Jyy4pa: "f1lfeew",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f16d74zd",
			Bfpq7zp: 0,
			g9k6zt: 0,
			Bn4voq9: 0,
			giviqs: "f89hs3r",
			Bw81rd7: 0,
			kdpuga: 0,
			dm238s: 0,
			B6xbmo0: 0,
			B3whbx2: "f2krc9w",
			B8q5s1w: "f8hki3x",
			Bci5o5g: ["f1d2448m", "ffh67wi"],
			n8qw10: "f1bjia2o",
			Bdrgwmp: ["ffh67wi", "f1d2448m"]
		},
		dismissBrand: { sj55zd: "f1phragk" },
		icon: {
			Bqenvij: "fsv12xs",
			a9b677: "f19bqwv",
			Bg96gwp: "fwrc4pm",
			Be2twd7: "fy9rknc",
			Bt984gj: "f122n59",
			B7ck84d: "f1e4lqlz",
			mc9l5x: "ftuwxu6",
			Brf1p80: "f4d9j23",
			w71qe1: "f1iuv45f",
			ha4doy: "fmrv4ls",
			qhf8xq: "f10pi13n",
			De3pzq: "f1c21dwh",
			sj55zd: "fkfq4zb",
			Bokbzmb: "fpvr8q1"
		},
		iconBrand: { sj55zd: "f1phragk" }
	}, { d: [
		".f22iagw{display:flex;}",
		".f1063pyq{flex-direction:row;}",
		".f11d4kpn{color:var(--colorNeutralForeground3);}",
		".fl43uef{font-weight:var(--fontWeightSemibold);}",
		".fy9rknc{font-size:var(--fontSizeBase200);}",
		".fwrc4pm{line-height:var(--lineHeightBase200);}",
		".f14wxoun{padding-bottom:var(--spacingVerticalXS);}",
		".f122n59{align-items:center;}",
		".f1jkagg5{margin-top:var(--spacingHorizontalNone);}",
		".fi2ljxd{margin-bottom:var(--spacingHorizontalNone);}",
		".f1phragk{color:var(--colorNeutralForegroundOnBrand);}",
		".fkfq4zb{color:var(--colorNeutralForeground2);}",
		".f10pi13n{position:relative;}",
		[".f88035w{border:var(--strokeWidthThin) solid var(--colorTransparentStroke);}", { p: -2 }],
		".f1k6fduh{cursor:pointer;}",
		".fk6fouc{font-family:var(--fontFamilyBase);}",
		".fkhj508{font-size:var(--fontSizeBase300);}",
		".figsok6{font-weight:var(--fontWeightRegular);}",
		".f1i3iumi{line-height:var(--lineHeightBase300);}",
		".f1c21dwh{background-color:var(--colorTransparentBackground);}",
		".f1ewtqcl{box-sizing:border-box;}",
		".f3fg2lr{border-top-right-radius:var(--borderRadiusNone);}",
		".f13av6d4{border-top-left-radius:var(--borderRadiusNone);}",
		".fzi6hpg{border-bottom-right-radius:var(--borderRadiusNone);}",
		".fyowgf4{border-bottom-left-radius:var(--borderRadiusNone);}",
		".f1n71otn{border-right-style:none;}",
		".f1deefiw{border-left-style:none;}",
		".f1lfeew{-webkit-margin-start:auto;margin-inline-start:auto;}",
		[".f16d74zd{padding:var(--spacingVerticalXS) var(--spacingHorizontalXS);}", { p: -1 }],
		[".f89hs3r[data-fui-focus-visible]{outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}", { p: -1 }],
		[".f2krc9w[data-fui-focus-visible]{border-radius:var(--borderRadiusMedium);}", { p: -1 }],
		".f8hki3x[data-fui-focus-visible]{border-top-color:transparent;}",
		".f1d2448m[data-fui-focus-visible]{border-right-color:transparent;}",
		".ffh67wi[data-fui-focus-visible]{border-left-color:transparent;}",
		".f1bjia2o[data-fui-focus-visible]{border-bottom-color:transparent;}",
		".fsv12xs{height:var(--fontSizeBase200);}",
		".f19bqwv{width:var(--fontSizeBase200);}",
		".f1e4lqlz{box-sizing:content-box;}",
		".ftuwxu6{display:inline-flex;}",
		".f4d9j23{justify-content:center;}",
		".f1iuv45f{text-decoration-line:none;}",
		".fmrv4ls{vertical-align:middle;}",
		".fpvr8q1{-webkit-margin-end:var(--spacingHorizontalXS);margin-inline-end:var(--spacingHorizontalXS);}"
	] });
	/** Applies style classnames to slots */
	const useTeachingPopoverHeaderStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$44();
		const { appearance } = state;
		state.root.className = mergeClasses(teachingPopoverHeaderClassNames.root, styles.root, appearance === "brand" && styles.rootBrand, state.root.className);
		if (state.dismissButton) state.dismissButton.className = mergeClasses(teachingPopoverHeaderClassNames.dismissButton, styles.dismissButton, appearance === "brand" ? styles.dismissBrand : void 0, state.dismissButton.className);
		if (state.icon) state.icon.className = mergeClasses(teachingPopoverHeaderClassNames.icon, styles.icon, appearance === "brand" ? styles.iconBrand : void 0, state.icon.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverHeader/TeachingPopoverHeader.js
/**
	* Define a styled TeachingPopoverHeader, using the `useTeachingPopoverHeader_unstable` and `useTeachingPopoverHeaderStyles_unstable`
	* hooks.
	*
	* TeachingPopoverHeader is an info subtitle located at the top of the popover, it provides a dismiss button by default (can be nulled)
	* and an info-tip icon that can be overridden or removed, subtitle displayed will be the children elements of TeachingPopoverHeader.
	*/ const TeachingPopoverHeader = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useTeachingPopoverHeader_unstable(props, ref);
		useTeachingPopoverHeaderStyles_unstable(state);
		useCustomStyleHook("useTeachingPopoverHeaderStyles_unstable")(state);
		return renderTeachingPopoverHeader_unstable(state);
	});
	TeachingPopoverHeader.displayName = "TeachingPopoverHeader";

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverBody/useTeachingPopoverBody.js
/**
	* Returns the props and state required to render the component
	* @param props - TeachingPopoverBody properties
	* @param ref - reference to root HTMLElement of TeachingPopoverBody
	*/ const useTeachingPopoverBody_unstable = (props, ref) => {
		const { mediaLength } = props;
		return {
			components: {
				root: "div",
				media: "span"
			},
			root: always(getIntrinsicElementProps("div", {
				ref,
				...props
			}), { elementType: "div" }),
			media: optional(props.media, { elementType: "span" }),
			mediaLength: mediaLength !== null && mediaLength !== void 0 ? mediaLength : "short"
		};
	};

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverBody/renderTeachingPopoverBody.js
/**
	* Render the final JSX of TeachingPopoverBody
	*/ const renderTeachingPopoverBody_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(state.root, { children: [state.media && /* @__PURE__ */ jsx(state.media, {}), state.root.children] });
	};

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverBody/useTeachingPopoverBodyStyles.styles.js
	const teachingPopoverBodyClassNames = {
		root: "fui-TeachingPopoverBody",
		media: "fui-TeachingPopoverBody__media"
	};
	const useMediaStyles = /* @__PURE__ */ __styles({
		base: {
			Bw0ie65: 0,
			Br312pm: 0,
			nk6f5a: 0,
			Ijaq50: 0,
			Bq1tomu: "fujjg13",
			B68tc82: 0,
			Bmxbyg5: 0,
			Bpg54ce: "f1a3p1vp",
			a9b677: "f14z66ap",
			jrapky: "f1jlhsmd",
			ha4doy: "fmrv4ls",
			Brf1p80: "f4d9j23",
			mc9l5x: "f22iagw"
		},
		short: {
			Bubjx69: "f1taewuw",
			Bfd67p1: "f2f587x"
		},
		medium: {
			Bubjx69: "f7da563",
			Bfd67p1: "fmwcswg"
		},
		tall: {
			Bubjx69: "f9ikmtg",
			Bfd67p1: "f1gv48o"
		}
	}, {
		d: [
			[".fujjg13{grid-area:media;}", { p: -1 }],
			[".f1a3p1vp{overflow:hidden;}", { p: -1 }],
			".f14z66ap{width:auto;}",
			".f1jlhsmd{margin-bottom:12px;}",
			".fmrv4ls{vertical-align:middle;}",
			".f4d9j23{justify-content:center;}",
			".f22iagw{display:flex;}",
			".f1taewuw{aspect-ratio:2.4615384615384617;}",
			".f7da563{aspect-ratio:1.6363636363636365;}",
			".f9ikmtg{aspect-ratio:1;}"
		],
		t: [
			"@supports not (aspect-ratio){.f2f587x{height:117px;}}",
			"@supports not (aspect-ratio){.fmwcswg{height:176px;}}",
			"@supports not (aspect-ratio){.f1gv48o{height:288px;}}"
		]
	});
	const useStyles$43 = /* @__PURE__ */ __styles({ root: {
		mc9l5x: "f22iagw",
		Beiy3e4: "f1vx9l62",
		Byoj8tv: "fpe6lb7"
	} }, { d: [
		".f22iagw{display:flex;}",
		".f1vx9l62{flex-direction:column;}",
		".fpe6lb7{padding-bottom:12px;}"
	] });
	/** Applies style classnames to slots */
	const useTeachingPopoverBodyStyles_unstable = (state) => {
		"use no memo";
		const { mediaLength } = state;
		const styles = useStyles$43();
		const mediaStyles = useMediaStyles();
		state.root.className = mergeClasses(teachingPopoverBodyClassNames.root, styles.root, state.root.className);
		if (state.media) state.media.className = mergeClasses(teachingPopoverBodyClassNames.media, mediaStyles.base, mediaStyles[mediaLength], state.media.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverBody/TeachingPopoverBody.js
/**
	* Define a styled TeachingPopoverBody, using the `useTeachingPopoverBody_unstable` and `useTeachingPopoverBodyStyles_unstable`
	* hooks.
	*
	* TeachingPopoverBody is used to host content within a TeachingPopover, and provides a standardized media slot
	*/ const TeachingPopoverBody = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useTeachingPopoverBody_unstable(props, ref);
		useTeachingPopoverBodyStyles_unstable(state);
		useCustomStyleHook("useTeachingPopoverBodyStyles_unstable")(state);
		return renderTeachingPopoverBody_unstable(state);
	});
	TeachingPopoverBody.displayName = "TeachingPopoverBody";

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/Carousel/createCarouselStore.js
	const createCarouselStore = () => {
		let values = [];
		let listeners = [];
		const carouselStore = {
			clear() {
				values = [];
				emitChange();
			},
			addValue(value) {
				values = [...values, value];
				emitChange();
			},
			insertValue(value, prev$1) {
				if (!prev$1) values = [value, ...values];
				else {
					const pos = values.indexOf(prev$1);
					values.splice(pos + 1, 0, value);
					values = [...values];
				}
				emitChange();
			},
			removeValue(value) {
				const pos = values.indexOf(value);
				values.splice(pos, 1);
				values = [...values];
				emitChange();
			},
			subscribe(listener) {
				listeners = [...listeners, listener];
				return () => {
					listeners = listeners.filter((l) => l !== listener);
				};
			},
			getSnapshot() {
				return values;
			}
		};
		function emitChange() {
			for (const listener of listeners) listener();
		}
		return carouselStore;
	};

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/Carousel/CarouselContext.js
	const carouselContextDefaultValue$1 = {
		store: createCarouselStore(),
		value: null,
		selectPageByDirection: () => {
			/** noop */		},
		selectPageByValue: () => {
			/** noop */		}
	};
	const CarouselContext$1 = createContext(void 0);
	const CarouselProvider$1 = CarouselContext$1.Provider;
	const useCarouselContext_unstable$1 = (selector) => useContextSelector(CarouselContext$1, (ctx = carouselContextDefaultValue$1) => selector(ctx));

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/Carousel/constants.js
	const CAROUSEL_ITEM = "data-carousel-item";
	const CAROUSEL_ACTIVE_ITEM = "data-carousel-active-item";

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/Carousel/CarouselItem/useCarouselItem.js
	const useCarouselItem_unstable = (props, ref) => {
		const { value } = props;
		const visible = useCarouselContext_unstable$1((c) => c.value === value);
		const state = {
			value,
			visible,
			components: { root: "div" },
			root: always(getIntrinsicElementProps("div", {
				ref,
				[CAROUSEL_ITEM]: value,
				[CAROUSEL_ACTIVE_ITEM]: visible,
				hidden: !visible,
				...props
			}), { elementType: "div" })
		};
		if (!visible) state.root.children = null;
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/Carousel/CarouselItem/renderCarouselItem.js
/**
	* Render the final JSX of TeachingPopoverCarousel
	*/ const renderCarouselItem_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, {});
	};

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/Carousel/CarouselItem/Carouseltem.js
/**
	* Define a CarouselItem, using the `useCarouselItem_unstable` and 'renderCarouselItem_unstable' hooks.
	* It has no styling opinions.
	*/ const CarouselItem = /* @__PURE__ */ react.forwardRef((props, ref) => {
		return renderCarouselItem_unstable(useCarouselItem_unstable(props, ref));
	});
	CarouselItem.displayName = "CarouselItem";

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselCard/useTeachingPopoverCarouselCard.js
/**
	* Returns the props and state required to render the component
	* @param props - TeachingPopoverCarouselCard properties
	* @param ref - reference to root HTMLElement of TeachingPopoverCarouselCard
	*/ const useTeachingPopoverCarouselCard_unstable = (props, ref) => {
		const { value } = props;
		return {
			value,
			components: { root: CarouselItem },
			root: always({
				...getIntrinsicElementProps("div", {
					ref,
					...props
				}),
				value
			}, { elementType: CarouselItem })
		};
	};

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselCard/renderTeachingPopoverCarouselCard.js
/**
	* Render the final JSX of TeachingPopoverCarouselCard
	*/ const renderTeachingPopoverCarouselCard_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, {});
	};

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselCard/useTeachingPopoverCarouselCardStyles.styles.js
	const teachingPopoverCarouselCardClassNames = { root: "fui-TeachingPopoverCarouselCard" };
	const useStyles$42 = /* @__PURE__ */ __styles({ root: {} }, {});
	/** Applies style classnames to slots */
	const useTeachingPopoverCarouselCardStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$42();
		state.root.className = mergeClasses(teachingPopoverCarouselCardClassNames.root, styles.root, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselCard/TeachingPopoverCarouselCard.js
/**
	* Define a styled TeachingPopoverCarouselCard, using the `useTeachingPopoverCarouselCard_unstable` and `useTeachingPopoverCarouselCardStyles_unstable`
	* hooks.
	*
	* TeachingPopoverCarouselCard is the definition of a single page view within the carousel, they are shown one at a time and can be navigated through sequentially.
	*/ const TeachingPopoverCarouselCard = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useTeachingPopoverCarouselCard_unstable(props, ref);
		useTeachingPopoverCarouselCardStyles_unstable(state);
		useCustomStyleHook("useTeachingPopoverCarouselCardStyles_unstable")(state);
		return renderTeachingPopoverCarouselCard_unstable(state);
	});
	TeachingPopoverCarouselCard.displayName = "TeachingPopoverCarouselCard";

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/Carousel/useCarouselWalker.js
	const useCarouselWalker_unstable = () => {
		const { targetDocument } = useFluent();
		const treeWalkerRef = react.useRef(targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.createTreeWalker(targetDocument.body));
		const htmlRef = react.useRef(null);
		return {
			ref: react.useCallback((el) => {
				if (!targetDocument) return;
				if (!el) return;
				htmlRef.current = el;
				treeWalkerRef.current = targetDocument.createTreeWalker(el, NodeFilter.SHOW_ELEMENT, { acceptNode(node$1) {
					if (!isHTMLElement(node$1)) return NodeFilter.FILTER_SKIP;
					return node$1.hasAttribute(CAROUSEL_ITEM) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
				} });
			}, [targetDocument]),
			walker: react.useMemo(() => ({
				active() {
					if (!htmlRef.current) return null;
					const activeEl = htmlRef.current.querySelector(`[${CAROUSEL_ACTIVE_ITEM}="true"]`);
					if (isHTMLElement(activeEl)) return {
						el: activeEl,
						value: activeEl.getAttribute(CAROUSEL_ITEM)
					};
					return null;
				},
				find(value) {
					var _treeWalkerRef_current;
					if (!((_treeWalkerRef_current = treeWalkerRef.current) === null || _treeWalkerRef_current === void 0 ? void 0 : _treeWalkerRef_current.currentNode) || !htmlRef.current) return null;
					treeWalkerRef.current.currentNode = htmlRef.current;
					let nextNode = null;
					while (nextNode = treeWalkerRef.current.nextNode()) {
						if (!isHTMLElement(nextNode)) continue;
						if (nextNode.getAttribute(CAROUSEL_ITEM) === value) return {
							el: nextNode,
							value: nextNode.getAttribute(CAROUSEL_ITEM)
						};
					}
					return null;
				},
				nextPage(value) {
					var _treeWalkerRef_current;
					const res = this.find(value);
					if (!res || !((_treeWalkerRef_current = treeWalkerRef.current) === null || _treeWalkerRef_current === void 0 ? void 0 : _treeWalkerRef_current.currentNode)) return null;
					treeWalkerRef.current.currentNode = res.el;
					const next$1 = treeWalkerRef.current.nextNode();
					if (isHTMLElement(next$1)) return {
						el: next$1,
						value: next$1.getAttribute(CAROUSEL_ITEM)
					};
					return null;
				},
				prevPage(value) {
					var _treeWalkerRef_current;
					const res = this.find(value);
					if (!res || !((_treeWalkerRef_current = treeWalkerRef.current) === null || _treeWalkerRef_current === void 0 ? void 0 : _treeWalkerRef_current.currentNode)) return null;
					treeWalkerRef.current.currentNode = res.el;
					const next$1 = treeWalkerRef.current.previousNode();
					if (isHTMLElement(next$1)) return {
						el: next$1,
						value: next$1.getAttribute(CAROUSEL_ITEM)
					};
					return null;
				}
			}), [])
		};
	};

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/Carousel/Carousel.js
	function useCarousel_unstable$1(options) {
		"use no memo";
		const { announcement, onValueChange, onFinish } = options;
		const { targetDocument } = useFluent();
		const win = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView;
		const { ref: carouselRef, walker: carouselWalker } = useCarouselWalker_unstable();
		const [store] = react.useState(() => createCarouselStore());
		const [value, setValue] = useControllableState({
			defaultState: options.defaultValue,
			state: options.value,
			initialState: null
		});
		const rootRef = react.useRef(null);
		const { announce } = useAnnounce();
		react.useEffect(() => {
			if (value === null) console.error("useCarousel: Carousel needs to have a `defaultValue` or `value` prop set. If you want to control the value, use the `value` prop.");
		}, [value]);
		react.useEffect(() => {
			var _rootRef_current;
			const allItems = (_rootRef_current = rootRef.current) === null || _rootRef_current === void 0 ? void 0 : _rootRef_current.querySelectorAll(`[${CAROUSEL_ITEM}]`);
			for (let i = 0; i < allItems.length; i++) store.addValue(allItems.item(i).getAttribute(CAROUSEL_ITEM));
			return () => {
				store.clear();
			};
		}, [store]);
		react.useEffect(() => {
			if (!win) return;
			const config = {
				attributes: true,
				attributeFilter: [CAROUSEL_ITEM],
				childList: true,
				subtree: true
			};
			const callback = (mutationList) => {
				for (const mutation of mutationList) {
					for (const addedNode of Array.from(mutation.addedNodes)) if (isHTMLElement(addedNode) && addedNode.hasAttribute(CAROUSEL_ITEM)) {
						const newValue = addedNode.getAttribute(CAROUSEL_ITEM);
						const newNode = carouselWalker.find(newValue);
						if (!(newNode === null || newNode === void 0 ? void 0 : newNode.value)) return;
						const previousNode = carouselWalker.prevPage(newNode === null || newNode === void 0 ? void 0 : newNode.value);
						var _previousNode_value;
						store.insertValue(newValue, (_previousNode_value = previousNode === null || previousNode === void 0 ? void 0 : previousNode.value) !== null && _previousNode_value !== void 0 ? _previousNode_value : null);
					}
					for (const removedNode of Array.from(mutation.removedNodes)) if (isHTMLElement(removedNode) && (removedNode === null || removedNode === void 0 ? void 0 : removedNode.hasAttribute(CAROUSEL_ITEM))) {
						const removedValue = removedNode.getAttribute(CAROUSEL_ITEM);
						store.removeValue(removedValue);
					}
				}
			};
			const observer = new win.MutationObserver(callback);
			observer.observe(rootRef.current, config);
			return () => {
				observer.disconnect();
			};
		}, [
			carouselWalker,
			store,
			win
		]);
		const updateSlide = useEventCallback((event, newValue) => {
			setValue(newValue);
			onValueChange === null || onValueChange === void 0 || onValueChange(event, {
				event,
				type: "click",
				value: newValue
			});
			const announceText = announcement === null || announcement === void 0 ? void 0 : announcement(newValue);
			if (announceText) announce(announceText, { polite: true });
		});
		const selectPageByDirection = useEventCallback((event, direction) => {
			const active = carouselWalker.active();
			if (!(active === null || active === void 0 ? void 0 : active.value)) return;
			const newPage = direction === "prev" ? carouselWalker.prevPage(active.value) : carouselWalker.nextPage(active.value);
			if (newPage) updateSlide(event, newPage === null || newPage === void 0 ? void 0 : newPage.value);
			else onFinish === null || onFinish === void 0 || onFinish(event, {
				event,
				type: "click",
				value: active === null || active === void 0 ? void 0 : active.value
			});
		});
		return {
			carouselRef: useMergedRefs(rootRef, carouselRef),
			carousel: {
				store,
				value,
				selectPageByDirection,
				selectPageByValue: updateSlide
			}
		};
	}

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/useTeachingPopoverCarousel.js
	const useTeachingPopoverCarousel_unstable = (props, ref) => {
		const toggleOpen = usePopoverContext_unstable((c) => c.toggleOpen);
		const handleFinish = useEventCallback((event, data) => {
			var _props_onFinish;
			(_props_onFinish = props.onFinish) === null || _props_onFinish === void 0 || _props_onFinish.call(props, event, data);
			toggleOpen(event);
		});
		const { carousel, carouselRef } = useCarousel_unstable$1({
			announcement: props.announcement,
			defaultValue: props.defaultValue,
			value: props.value,
			onValueChange: props.onValueChange,
			onFinish: handleFinish
		});
		return {
			appearance: usePopoverContext_unstable((context) => context.appearance),
			components: { root: "div" },
			root: always(getIntrinsicElementProps("div", {
				ref: useMergedRefs(ref, carouselRef),
				...props
			}), { elementType: "div" }),
			...carousel
		};
	};

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/renderTeachingPopoverCarousel.js
/**
	* Render the final JSX of TeachingPopoverCarousel
	*/ const renderTeachingPopoverCarousel_unstable = (state, contextValues) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(CarouselProvider$1, {
			value: contextValues.carousel,
			children: /* @__PURE__ */ jsx(state.root, {})
		});
	};

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/useTeachingPopoverCarouselStyles.styles.js
	const teachingPopoverCarouselClassNames = { root: "fui-TeachingPopoverCarousel" };
	const useStyles$41 = /* @__PURE__ */ __styles({ root: {} }, {});
	/** Applies style classnames to slots */
	const useTeachingPopoverCarouselStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$41();
		state.root.className = mergeClasses(teachingPopoverCarouselClassNames.root, styles.root, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/useTeachingPopoverCarouselContextValues.js
	function useTeachingPopoverCarouselContextValues_unstable(state) {
		const { store, value, selectPageByValue, selectPageByDirection } = state;
		return { carousel: {
			store,
			value,
			selectPageByDirection,
			selectPageByValue
		} };
	}

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/TeachingPopoverCarousel.js
/**
	* Define a styled TeachingPopoverCarousel, using the `useTeachingPopoverCarousel_unstable` and `useTeachingPopoverCarouselStyles_unstable`
	* hooks.
	*
	* TeachingPopoverCarousel injects context providers that are required for TeachingPopoverCarouselCard display and navigation functionality
	*/ const TeachingPopoverCarousel = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useTeachingPopoverCarousel_unstable(props, ref);
		useTeachingPopoverCarouselStyles_unstable(state);
		useCustomStyleHook("useTeachingPopoverCarouselStyles_unstable")(state);
		return renderTeachingPopoverCarousel_unstable(state, useTeachingPopoverCarouselContextValues_unstable(state));
	});
	TeachingPopoverCarousel.displayName = "TeachingPopoverCarousel";

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/Carousel/useCarouselValues.js
	function useCarouselValues_unstable(getSnapshot) {
		const store = useCarouselContext_unstable$1((c) => c.store);
		return (0, import_shim.useSyncExternalStore)(store.subscribe, () => getSnapshot(store.getSnapshot()));
	}

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselFooterButton/useTeachingPopoverCarouselFooterButton.js
/**
	* Create the state required to render TeachingPopoverCarouselFooterButton.
	*
	* The returned state can be modified with hooks such as useTeachingPopoverCarouselFooterButtonStyles_unstable,
	* before being passed to renderTeachingPopoverCarouselFooterButton_unstable.
	*
	* @param props - props from this instance of TeachingPopoverCarouselFooterButton
	* @param ref - reference to root HTMLDivElement of TeachingPopoverCarouselFooterButton
	*/ const useTeachingPopoverCarouselFooterButton_unstable = (props, ref) => {
		const { navType, altText } = props;
		const popoverAppearance = usePopoverContext_unstable((context) => context.appearance);
		const selectPageByDirection = useCarouselContext_unstable$1((c) => c.selectPageByDirection);
		const values = useCarouselValues_unstable((snapshot) => snapshot);
		const activeValue = useCarouselContext_unstable$1((c) => c.value);
		const handleClick = (event) => {
			if (event.isDefaultPrevented()) return;
			selectPageByDirection(event, navType);
		};
		const handleButtonClick = useEventCallback(mergeCallbacks(handleClick, props.onClick));
		const isTrailing = react.useMemo(() => {
			if (!activeValue) return false;
			if (navType === "prev") return values.indexOf(activeValue) === 0;
			return values.indexOf(activeValue) === values.length - 1;
		}, [
			navType,
			activeValue,
			values
		]);
		let buttonAppearanceType;
		if (navType === "next") buttonAppearanceType = popoverAppearance === "brand" ? void 0 : "primary";
		else buttonAppearanceType = popoverAppearance === "brand" ? "outline" : void 0;
		let buttonChild = props.children;
		if (isTrailing) buttonChild = altText;
		return {
			...useButton_unstable({
				appearance: buttonAppearanceType,
				...props
			}, ref),
			navType,
			popoverAppearance,
			altText,
			root: always(getIntrinsicElementProps("button", {
				ref,
				appearance: buttonAppearanceType,
				...props,
				onClick: handleButtonClick,
				children: buttonChild
			}), { elementType: "button" })
		};
	};

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselFooterButton/renderTeachingPopoverCarouselFooterButton.js
/**
	* Render the final JSX of TeachingPopoverCarouselFooterButton
	*/ const renderTeachingPopoverCarouselFooterButton_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, {});
	};

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselFooterButton/useTeachingPopoverCarouselFooterButtonStyles.styles.js
	const teachingPopoverCarouselFooterButtonClassNames = { root: "fui-TeachingPopoverCarouselFooterButton" };
	const useStyles$40 = /* @__PURE__ */ __styles({
		root: { Bf4jedk: "f14es27b" },
		brandNext: {
			sj55zd: "f16muhyy",
			De3pzq: "f10s6wn9",
			g2u3we: "f1iimpp0",
			h3c5rm: ["f19uhqvu", "f1nx14hx"],
			B9xav0g: "fnqa90p",
			zhjwy3: ["f1nx14hx", "f19uhqvu"],
			Bi91k9c: "f3ymbdj",
			Jwef8y: "f1rgtb95",
			B2d53fq: "f1pu27ff",
			iro3zm: "f1d5c7in"
		},
		brandPrevious: {
			sj55zd: "f1phragk",
			De3pzq: "ffp7eso",
			g2u3we: "fm1ebug",
			h3c5rm: ["f28omuz", "f1uhflii"],
			B9xav0g: "f1ixw5o4",
			zhjwy3: ["f1uhflii", "f28omuz"],
			Bi91k9c: "f1rq72xc",
			Bgoe8wy: "f1bg5g8r",
			Bwzppfd: ["f1h9bnsk", "f12x9t0k"],
			oetu4i: "f19ervry",
			gg5e9n: ["f12x9t0k", "f1h9bnsk"],
			Jwef8y: "f15wkkf3",
			B2d53fq: "f1d6v5y2",
			b661bw: "f1565b9n",
			Bk6r4ia: ["fm07gvo", "fwlsg72"],
			B9zn80p: "fzw6fmy",
			Bpld233: ["fwlsg72", "fm07gvo"],
			iro3zm: "fnp9lpt"
		}
	}, {
		d: [
			".f14es27b{min-width:96px;}",
			".f16muhyy{color:var(--colorBrandForeground1);}",
			".f10s6wn9{background-color:var(--colorNeutralForegroundOnBrand);}",
			".f1iimpp0{border-top-color:var(--colorTransparentBackground);}",
			".f19uhqvu{border-right-color:var(--colorTransparentBackground);}",
			".f1nx14hx{border-left-color:var(--colorTransparentBackground);}",
			".fnqa90p{border-bottom-color:var(--colorTransparentBackground);}",
			".f1phragk{color:var(--colorNeutralForegroundOnBrand);}",
			".ffp7eso{background-color:var(--colorBrandBackground);}",
			".fm1ebug{border-top-color:var(--colorNeutralForegroundOnBrand);}",
			".f28omuz{border-right-color:var(--colorNeutralForegroundOnBrand);}",
			".f1uhflii{border-left-color:var(--colorNeutralForegroundOnBrand);}",
			".f1ixw5o4{border-bottom-color:var(--colorNeutralForegroundOnBrand);}"
		],
		h: [
			".f3ymbdj:hover{color:var(--colorCompoundBrandForeground1Hover);}",
			".f1rgtb95:hover{background-color:var(--colorNeutralForegroundOnBrand);}",
			".f1pu27ff:hover:active{color:var(--colorCompoundBrandForeground1Pressed);}",
			".f1d5c7in:hover:active{background-color:var(--colorNeutralForegroundOnBrand);}",
			".f1rq72xc:hover{color:var(--colorNeutralForegroundOnBrand);}",
			".f1bg5g8r:hover{border-top-color:var(--colorNeutralForegroundOnBrand);}",
			".f1h9bnsk:hover{border-right-color:var(--colorNeutralForegroundOnBrand);}",
			".f12x9t0k:hover{border-left-color:var(--colorNeutralForegroundOnBrand);}",
			".f19ervry:hover{border-bottom-color:var(--colorNeutralForegroundOnBrand);}",
			".f15wkkf3:hover{background-color:var(--colorBrandBackgroundHover);}",
			".f1d6v5y2:hover:active{color:var(--colorNeutralForegroundOnBrand);}",
			".f1565b9n:hover:active{border-top-color:var(--colorNeutralForegroundOnBrand);}",
			".fm07gvo:hover:active{border-right-color:var(--colorNeutralForegroundOnBrand);}",
			".fwlsg72:hover:active{border-left-color:var(--colorNeutralForegroundOnBrand);}",
			".fzw6fmy:hover:active{border-bottom-color:var(--colorNeutralForegroundOnBrand);}",
			".fnp9lpt:hover:active{background-color:var(--colorBrandBackgroundPressed);}"
		]
	});
	/**
	* Apply styling to the TeachingPopoverCarouselFooterButton slots based on the state
	*/
	const useTeachingPopoverCarouselFooterButtonStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$40();
		const { navType, popoverAppearance } = state;
		state = {
			...state,
			...useButtonStyles_unstable(state)
		};
		state.root.className = mergeClasses(teachingPopoverCarouselFooterButtonClassNames.root, styles.root, navType === "prev" && popoverAppearance === "brand" && styles.brandPrevious, navType === "next" && popoverAppearance === "brand" && styles.brandNext, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselFooterButton/TeachingPopoverCarouselFooterButton.js
/**
	* TeachingPopoverCarouselFooterButton component
	*
	* TeachingPopoverCarouselFooterButton extends Button and injects additional styling and onClick functionality
	* to match the context provided by TeachingPopover & TeachingPopoverCarousel
	*/ const TeachingPopoverCarouselFooterButton = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useTeachingPopoverCarouselFooterButton_unstable(props, ref);
		useTeachingPopoverCarouselFooterButtonStyles_unstable(state);
		useCustomStyleHook("useTeachingPopoverCarouselFooterButtonStyles_unstable")(state);
		return renderTeachingPopoverCarouselFooterButton_unstable(state);
	});
	TeachingPopoverCarouselFooterButton.displayName = "TeachingPopoverCarouselFooterButton";

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselFooter/useTeachingPopoverCarouselFooter.js
	const useTeachingPopoverCarouselFooter_unstable = (props, ref) => {
		const { layout = "centered", initialStepText, finalStepText } = props;
		const previous = optional(props.previous, {
			defaultProps: {
				navType: "prev",
				altText: initialStepText
			},
			renderByDefault: true,
			elementType: TeachingPopoverCarouselFooterButton
		});
		const next$1 = always(props.next, {
			defaultProps: {
				navType: "next",
				altText: finalStepText
			},
			elementType: TeachingPopoverCarouselFooterButton
		});
		return {
			layout,
			components: {
				root: "div",
				next: TeachingPopoverCarouselFooterButton,
				previous: TeachingPopoverCarouselFooterButton
			},
			root: always(getIntrinsicElementProps("div", {
				ref,
				...props
			}), { elementType: "div" }),
			previous,
			next: next$1
		};
	};

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselFooter/renderTeachingPopoverCarouselFooter.js
/**
	* Render the final JSX of TeachingPopoverCarouselFooter
	*/ const renderTeachingPopoverCarouselFooter_unstable = (state) => {
		assertSlots(state);
		const { layout } = state;
		return /* @__PURE__ */ jsxs(state.root, { children: [
			layout === "centered" && state.previous && /* @__PURE__ */ jsx(state.previous, {}),
			state.root.children,
			layout === "offset" && state.previous && /* @__PURE__ */ jsx(state.previous, {}),
			/* @__PURE__ */ jsx(state.next, {})
		] });
	};

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselFooter/useTeachingPopoverCarouselFooterStyles.styles.js
	const teachingPopoverCarouselFooterClassNames = {
		root: "fui-TeachingPopoverCarouselFooter",
		previous: "fui-TeachingPopoverCarouselFooter__previous",
		next: "fui-TeachingPopoverCarouselFooter__next"
	};
	const useStyles$39 = /* @__PURE__ */ __styles({
		root: {
			mc9l5x: "f22iagw",
			Beiy3e4: "f1063pyq"
		},
		rootCentered: {
			Brf1p80: "f1869bpl",
			i8kkvl: 0,
			Belr9w4: 0,
			rmohyg: "f19gb1f4"
		},
		rootRightAligned: {
			i8kkvl: 0,
			Belr9w4: 0,
			rmohyg: "f19gb1f4",
			Bp34fd5: "f1y65ohq"
		}
	}, { d: [
		".f22iagw{display:flex;}",
		".f1063pyq{flex-direction:row;}",
		".f1869bpl{justify-content:space-between;}",
		[".f19gb1f4{gap:8px;}", { p: -1 }],
		[".f19gb1f4{gap:8px;}", { p: -1 }],
		".f1y65ohq :first-child{-webkit-margin-end:auto;margin-inline-end:auto;}"
	] });
	/** Applies style classnames to slots */
	const useTeachingPopoverCarouselFooterStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$39();
		const { layout } = state;
		state.root.className = mergeClasses(teachingPopoverCarouselFooterClassNames.root, styles.root, layout === "centered" ? styles.rootCentered : styles.rootRightAligned, state.root.className);
		if (state.previous) state.previous.className = mergeClasses(teachingPopoverCarouselFooterClassNames.previous, state.previous.className);
		state.next.className = mergeClasses(teachingPopoverCarouselFooterClassNames.next, state.next.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselFooter/TeachingPopoverCarouselFooter.js
/**
	* Define a styled TeachingPopoverCarouselFooter, using the `useTeachingPopoverCarouselFooter_unstable` and `useTeachingPopoverCarouselFooterStyles_unstable`
	* hooks.
	*
	* TeachingPopoverCarouselFooter contains previous/next buttons configured for carousel navigation, and a root slot for page count and/or page index navigation.
	*/ const TeachingPopoverCarouselFooter = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useTeachingPopoverCarouselFooter_unstable(props, ref);
		useTeachingPopoverCarouselFooterStyles_unstable(state);
		useCustomStyleHook("useTeachingPopoverCarouselFooterStyles_unstable")(state);
		return renderTeachingPopoverCarouselFooter_unstable(state);
	});
	TeachingPopoverCarouselFooter.displayName = "TeachingPopoverCarouselFooter";

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselNav/useTeachingPopoverCarouselNav.js
/**
	* Returns the props and state required to render the component
	* @param props - TeachingPopoverCarouselNav properties
	* @param ref - reference to root HTMLElement of TeachingPopoverCarouselNav
	*/ const useTeachingPopoverCarouselNav_unstable = (props, ref) => {
		const focusableGroupAttr = useArrowNavigationGroup({
			circular: false,
			axis: "horizontal",
			memorizeCurrent: false,
			unstable_hasDefault: true
		});
		return {
			values: useCarouselValues_unstable((snapshot) => snapshot),
			renderNavButton: props.children,
			components: { root: "div" },
			root: always(getIntrinsicElementProps("div", {
				ref,
				role: "tablist",
				tabIndex: 0,
				...props,
				...focusableGroupAttr,
				children: null
			}), { elementType: "div" })
		};
	};

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselNav/valueIdContext.js
	const valueIdContext = react.createContext(void 0);
	const valueIdContextDefaultValue = "";
	const useValueIdContext = () => {
		var _React_useContext;
		return (_React_useContext = react.useContext(valueIdContext)) !== null && _React_useContext !== void 0 ? _React_useContext : valueIdContextDefaultValue;
	};
	const ValueIdContextProvider = valueIdContext.Provider;

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselNav/renderTeachingPopoverCarouselNav.js
/**
	* Render the final JSX of TeachingPopoverCarouselNav
	*/ const renderTeachingPopoverCarouselNav_unstable = (state) => {
		assertSlots(state);
		const { values, renderNavButton } = state;
		return /* @__PURE__ */ jsx(state.root, { children: values.map((value) => /* @__PURE__ */ jsx(ValueIdContextProvider, {
			value,
			children: renderNavButton(value)
		}, value)) });
	};

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselNav/useTeachingPopoverCarouselNavStyles.styles.js
	const teachingPopoverCarouselNavClassNames = { root: "fui-TeachingPopoverCarouselNav" };
	const useStyles$38 = /* @__PURE__ */ __styles({ root: {
		mc9l5x: "f22iagw",
		Beiy3e4: "f1063pyq",
		i8kkvl: "f1ufnopg",
		Bt984gj: "f122n59",
		Brf1p80: "f4d9j23",
		Bfpq7zp: 0,
		g9k6zt: 0,
		Bn4voq9: 0,
		giviqs: "f89hs3r",
		Bw81rd7: 0,
		kdpuga: 0,
		dm238s: 0,
		B6xbmo0: 0,
		B3whbx2: "f2krc9w",
		B8q5s1w: "f8hki3x",
		Bci5o5g: ["f1d2448m", "ffh67wi"],
		n8qw10: "f1bjia2o",
		Bdrgwmp: ["ffh67wi", "f1d2448m"]
	} }, { d: [
		".f22iagw{display:flex;}",
		".f1063pyq{flex-direction:row;}",
		".f1ufnopg{column-gap:var(--spacingHorizontalXS);}",
		".f122n59{align-items:center;}",
		".f4d9j23{justify-content:center;}",
		[".f89hs3r[data-fui-focus-visible]{outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}", { p: -1 }],
		[".f2krc9w[data-fui-focus-visible]{border-radius:var(--borderRadiusMedium);}", { p: -1 }],
		".f8hki3x[data-fui-focus-visible]{border-top-color:transparent;}",
		".f1d2448m[data-fui-focus-visible]{border-right-color:transparent;}",
		".ffh67wi[data-fui-focus-visible]{border-left-color:transparent;}",
		".f1bjia2o[data-fui-focus-visible]{border-bottom-color:transparent;}"
	] });
	/** Applies style classnames to slots */
	const useTeachingPopoverCarouselNavStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$38();
		state.root.className = mergeClasses(teachingPopoverCarouselNavClassNames.root, styles.root, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselNav/TeachingPopoverCarouselNav.js
/**
	* Define a styled TeachingPopoverCarouselNav, using the `useTeachingPopoverCarouselNav_unstable` and `useTeachingPopoverCarouselNavStyles_unstable`
	* hooks.
	*
	* TeachingPopoverCarouselNav provides an index-based pagination list to jump to any page within the carousel.
	*/ const TeachingPopoverCarouselNav = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useTeachingPopoverCarouselNav_unstable(props, ref);
		useTeachingPopoverCarouselNavStyles_unstable(state);
		useCustomStyleHook("useTeachingPopoverCarouselNavStyles_unstable")(state);
		return renderTeachingPopoverCarouselNav_unstable(state);
	});
	TeachingPopoverCarouselNav.displayName = "TeachingPopoverCarouselNav";

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselNavButton/useTeachingPopoverCarouselNavButton.js
/**
	* Create the state required to render TeachingPopoverCarouselNavButton.
	*
	* The returned state can be modified with hooks such as useTeachingPopoverCarouselNavButtonStyles_unstable,
	* before being passed to renderTeachingPopoverCarouselNavButton_unstable.
	*
	* @param props - props from this instance of TeachingPopoverCarouselNavButton
	* @param ref - reference to root HTMLElement of TeachingPopoverCarouselNavButton
	*/ const useTeachingPopoverCarouselNavButton_unstable = (props, ref) => {
		const { onClick, as = "a" } = props;
		const value = useValueIdContext();
		const appearance = usePopoverContext_unstable((context) => context.appearance);
		const selectPageByValue = useCarouselContext_unstable$1((c) => c.selectPageByValue);
		const isSelected = useCarouselContext_unstable$1((c) => c.value === value);
		const handleClick = useEventCallback((event) => {
			onClick === null || onClick === void 0 || onClick(event);
			if (!event.defaultPrevented && isHTMLElement(event.target)) selectPageByValue(event, value);
		});
		const defaultTabProps = useTabsterAttributes({ focusable: { isDefault: isSelected } });
		const _carouselButton = always(getIntrinsicElementProps(as, useARIAButtonProps(props.as, props)), {
			elementType: "button",
			defaultProps: {
				ref,
				role: "tab",
				type: "button",
				"aria-selected": `${!!isSelected}`,
				...defaultTabProps
			}
		});
		_carouselButton.onClick = handleClick;
		return {
			isSelected,
			appearance,
			components: { root: "button" },
			root: _carouselButton
		};
	};

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselNavButton/renderTeachingPopoverCarouselNavButton.js
/**
	* Render the final JSX of TeachingPopoverCarouselNavButton
	*/ const renderTeachingPopoverCarouselNavButton_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, {});
	};

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselNavButton/useTeachingPopoverCarouselNavButtonStyles.styles.js
	const teachingPopoverCarouselNavButtonClassNames = { root: "fui-TeachingPopoverCarouselNavButton" };
	/**
	* Styles for the root slot
	*/
	const useStyles$37 = /* @__PURE__ */ __styles({
		root: {
			mc9l5x: "f22iagw",
			Bceei9c: "f1k6fduh",
			B7ck84d: "f1ewtqcl",
			Bqenvij: "f1x82gua",
			a9b677: "f1o3cbw4",
			De3pzq: "ffp7eso"
		},
		rootUnselected: {
			Bgfg5da: 0,
			B9xav0g: 0,
			oivjwe: 0,
			Bn0qgzm: 0,
			B4g9neb: 0,
			zhjwy3: 0,
			wvpqe5: 0,
			ibv6hh: 0,
			u1mtju: 0,
			h3c5rm: 0,
			vrafjx: 0,
			Bekrc4i: 0,
			i8vvqc: 0,
			g2u3we: 0,
			icvyot: 0,
			B4j52fo: 0,
			irswps: "f3bhgqh",
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "f5q2cvs",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f1c5fvqg",
			Bw0xxkn: 0,
			oeaueh: 0,
			Bpd4iqm: 0,
			Befb4lg: "f71xx7",
			Bfpq7zp: 0,
			g9k6zt: 0,
			Bn4voq9: 0,
			giviqs: "f89hs3r",
			Bw81rd7: 0,
			kdpuga: 0,
			dm238s: 0,
			B6xbmo0: 0,
			B3whbx2: "f2krc9w",
			B8q5s1w: "f8hki3x",
			Bci5o5g: ["f1d2448m", "ffh67wi"],
			n8qw10: "f1bjia2o",
			Bdrgwmp: ["ffh67wi", "f1d2448m"],
			De3pzq: "frgiif3",
			o2ey54: "fawpdd5",
			C3llkk: "feyhbel"
		},
		rootSelected: {
			Bw0xxkn: 0,
			oeaueh: 0,
			Bpd4iqm: 0,
			Befb4lg: "f71xx7",
			a9b677: "fjw5fx7",
			Bgfg5da: 0,
			B9xav0g: 0,
			oivjwe: 0,
			Bn0qgzm: 0,
			B4g9neb: 0,
			zhjwy3: 0,
			wvpqe5: 0,
			ibv6hh: 0,
			u1mtju: 0,
			h3c5rm: 0,
			vrafjx: 0,
			Bekrc4i: 0,
			i8vvqc: 0,
			g2u3we: 0,
			icvyot: 0,
			B4j52fo: 0,
			irswps: "f3bhgqh",
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "ff3glw6",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f1c5fvqg",
			Bfpq7zp: 0,
			g9k6zt: 0,
			Bn4voq9: 0,
			giviqs: "f89hs3r",
			Bw81rd7: 0,
			kdpuga: 0,
			dm238s: 0,
			B6xbmo0: 0,
			B3whbx2: "f2krc9w",
			B8q5s1w: "f8hki3x",
			Bci5o5g: ["f1d2448m", "ffh67wi"],
			n8qw10: "f1bjia2o",
			Bdrgwmp: ["ffh67wi", "f1d2448m"],
			By8wz76: "f1wgxgin"
		},
		rootBrand: { De3pzq: "f10s6wn9" },
		rootBrandUnselected: {
			De3pzq: "frxe7el",
			o2ey54: "fawpdd5",
			C3llkk: "feyhbel"
		}
	}, {
		d: [
			".f22iagw{display:flex;}",
			".f1k6fduh{cursor:pointer;}",
			".f1ewtqcl{box-sizing:border-box;}",
			".f1x82gua{height:8px;}",
			".f1o3cbw4{width:8px;}",
			".ffp7eso{background-color:var(--colorBrandBackground);}",
			[".f3bhgqh{border:none;}", { p: -2 }],
			[".f5q2cvs{border-radius:50%;}", { p: -1 }],
			[".f1c5fvqg{padding:0px;}", { p: -1 }],
			[".f71xx7{outline:var(--strokeWidthThin) solid transparent;}", { p: -1 }],
			[".f89hs3r[data-fui-focus-visible]{outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}", { p: -1 }],
			[".f2krc9w[data-fui-focus-visible]{border-radius:var(--borderRadiusMedium);}", { p: -1 }],
			".f8hki3x[data-fui-focus-visible]{border-top-color:transparent;}",
			".f1d2448m[data-fui-focus-visible]{border-right-color:transparent;}",
			".ffh67wi[data-fui-focus-visible]{border-left-color:transparent;}",
			".f1bjia2o[data-fui-focus-visible]{border-bottom-color:transparent;}",
			".frgiif3{background-color:color-mix(in srgb, var(--colorBrandBackground) 30%, transparent);}",
			[".f71xx7{outline:var(--strokeWidthThin) solid transparent;}", { p: -1 }],
			".fjw5fx7{width:16px;}",
			[".f3bhgqh{border:none;}", { p: -2 }],
			[".ff3glw6{border-radius:4px;}", { p: -1 }],
			[".f1c5fvqg{padding:0px;}", { p: -1 }],
			[".f89hs3r[data-fui-focus-visible]{outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}", { p: -1 }],
			[".f2krc9w[data-fui-focus-visible]{border-radius:var(--borderRadiusMedium);}", { p: -1 }],
			".f10s6wn9{background-color:var(--colorNeutralForegroundOnBrand);}",
			".frxe7el{background-color:color-mix(in srgb, var(--colorNeutralForegroundOnBrand) 30%, transparent);}"
		],
		t: ["@supports not (color: color-mix(in lch, white, black)){.fawpdd5{opacity:0.3;}}", "@supports not (color: color-mix(in lch, white, black)){.feyhbel{background-color:var(--colorBrandBackground);}}"],
		m: [["@media (forced-colors: active){.f1wgxgin{background-color:CanvasText;}}", { m: "(forced-colors: active)" }]]
	});
	/**
	* Apply styling to the TeachingPopoverCarouselNavButton slots based on the state
	*/
	const useTeachingPopoverCarouselNavButtonStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$37();
		const { appearance, isSelected } = state;
		const brandStyles = isSelected ? styles.rootBrand : styles.rootBrandUnselected;
		state.root.className = mergeClasses(teachingPopoverCarouselNavButtonClassNames.root, styles.root, isSelected ? styles.rootSelected : styles.rootUnselected, appearance === "brand" && brandStyles, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselNavButton/TeachingPopoverCarouselNavButton.js
/**
	* TeachingPopoverCarouselNavButton is a button to jump to a single page within TeachingPopoverCarousel
	*
	* It's value is injected via context and must be wrapped with a ValueIdContextProvider (automatically handled via TeachingPopoverCarouselNav)
	*/ const TeachingPopoverCarouselNavButton = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useTeachingPopoverCarouselNavButton_unstable(props, ref);
		useTeachingPopoverCarouselNavButtonStyles_unstable(state);
		useCustomStyleHook("useTeachingPopoverCarouselNavButtonStyles_unstable")(state);
		return renderTeachingPopoverCarouselNavButton_unstable(state);
	});
	TeachingPopoverCarouselNavButton.displayName = "TeachingPopoverCarouselNavButton";

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverSurface/useTeachingPopoverSurface.js
/**
	* Create the state required to render TeachingPopoverSurface.
	*
	* The returned state can be modified with hooks such as useTeachingPopoverSurfaceStyles_unstable,
	* before being passed to renderTeachingPopoverSurface_unstable.
	*
	* @param props - props from this instance of TeachingPopoverSurface
	* @param ref - reference to root HTMLDivElement of TeachingPopoverSurface
	*/ const useTeachingPopoverSurface_unstable = (props, ref) => {
		return usePopoverSurface_unstable(props, ref);
	};

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverSurface/useTeachingPopoverSurfaceStyles.styles.js
	const teachingPopoverSurfaceClassNames = { root: "fui-TeachingPopoverSurface" };
	const useStyles$36 = /* @__PURE__ */ __styles({ root: {
		Byoj8tv: 0,
		uwmqm3: 0,
		z189sj: 0,
		z8tnut: 0,
		B0ocmuz: "f23zza1",
		Beyfa6y: 0,
		Bbmb7ep: 0,
		Btl43ni: 0,
		B7oj6ja: 0,
		Dimara: "f1kijzfu",
		Bf4jedk: "f14hp5dx",
		B7ck84d: "f1ewtqcl"
	} }, { d: [
		[".f23zza1{padding:var(--spacingVerticalL) var(--spacingVerticalL);}", { p: -1 }],
		[".f1kijzfu{border-radius:var(--borderRadiusXLarge);}", { p: -1 }],
		".f14hp5dx{min-width:320px;}",
		".f1ewtqcl{box-sizing:border-box;}"
	] });
	/**
	* Apply styling to the TeachingPopoverSurface slots based on the state
	*/
	const useTeachingPopoverSurfaceStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$36();
		state.root.className = mergeClasses(teachingPopoverSurfaceClassNames.root, styles.root, state.root.className);
		return usePopoverSurfaceStyles_unstable(state);
	};

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverSurface/renderTeachingPopoverSurface.js
/**
	* Render the final JSX of PopoverSurface
	*/ const renderTeachingPopoverSurface_unstable = (state) => {
		assertSlots(state);
		return renderPopoverSurface_unstable(state);
	};

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverSurface/TeachingPopoverSurface.js
/**
	* TeachingPopoverSurface component renders react children in a positioned box
	*
	* TeachingPopoverSurface is a direct extension of PopoverSurface, with it's own styling context hooks available.
	*/ const TeachingPopoverSurface = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useTeachingPopoverSurface_unstable(props, ref);
		useTeachingPopoverSurfaceStyles_unstable(state);
		useCustomStyleHook("useTeachingPopoverSurfaceStyles_unstable")(state);
		return renderTeachingPopoverSurface_unstable(state);
	});
	TeachingPopoverSurface.displayName = "TeachingPopoverSurface";

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverTitle/useTeachingPopoverTitle.js
	const DismissIcon = bundleIcon_default(DismissFilled, DismissRegular);
	/**
	* Returns the props and state required to render the component
	* @param props - TeachingPopoverTitle properties
	* @param ref - reference to root HTMLElement of TeachingPopoverTitle
	*/ const useTeachingPopoverTitle_unstable = (props, ref) => {
		const { dismissButton } = props;
		const setOpen = usePopoverContext_unstable((context) => context.setOpen);
		const triggerRef = usePopoverContext_unstable((context) => context.triggerRef);
		const appearance = usePopoverContext_unstable((context) => context.appearance);
		const onDismissButtonClick = useEventCallback((ev) => {
			if (!ev.defaultPrevented) setOpen(ev, false);
			if (triggerRef.current) triggerRef.current.focus();
		});
		return {
			appearance,
			components: {
				root: "h2",
				dismissButton: "button"
			},
			root: always(getIntrinsicElementProps("h2", {
				ref,
				...props
			}), { elementType: "h2" }),
			dismissButton: optional(dismissButton, {
				renderByDefault: false,
				defaultProps: {
					children: /* @__PURE__ */ react.createElement(DismissIcon, null),
					onClick: onDismissButtonClick,
					"aria-label": "dismiss",
					"aria-hidden": true
				},
				elementType: "button"
			})
		};
	};

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverTitle/renderTeachingPopoverTitle.js
/**
	* Render the final JSX of TeachingPopoverTitle
	*/ const renderTeachingPopoverTitle_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(state.root, { children: [state.root.children, state.dismissButton && /* @__PURE__ */ jsx(state.dismissButton, {})] });
	};

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverTitle/useTeachingPopoverTitleStyles.styles.js
	const teachingPopoverTitleClassNames = {
		root: "fui-TeachingPopoverTitle",
		dismissButton: "fui-TeachingPopoverTitle__dismissButton"
	};
	const useStyles$35 = /* @__PURE__ */ __styles({
		root: {
			mc9l5x: "f22iagw",
			Beiy3e4: "f1063pyq",
			Brf1p80: "f1869bpl",
			Be2twd7: "fod5ikn",
			Bhrd7zp: "fl43uef",
			sj55zd: "f19n0e5",
			Bg96gwp: "faaz57k",
			Byoj8tv: "f5b47ha",
			B6of3ja: "f1jkagg5",
			jrapky: "fi2ljxd"
		},
		rootBrand: { sj55zd: "f1phragk" },
		dismissButton: {
			qhf8xq: "f10pi13n",
			Bgfg5da: 0,
			B9xav0g: 0,
			oivjwe: 0,
			Bn0qgzm: 0,
			B4g9neb: 0,
			zhjwy3: 0,
			wvpqe5: 0,
			ibv6hh: 0,
			u1mtju: 0,
			h3c5rm: 0,
			vrafjx: ["f1n71otn", "f1deefiw"],
			Bekrc4i: 0,
			i8vvqc: 0,
			g2u3we: 0,
			icvyot: 0,
			B4j52fo: 0,
			irswps: "f88035w",
			mc9l5x: "f22iagw",
			Bt984gj: "f122n59",
			Bceei9c: "f1k6fduh",
			Bahqtrf: "fk6fouc",
			Be2twd7: "fkhj508",
			Bhrd7zp: "figsok6",
			Bg96gwp: "f1i3iumi",
			De3pzq: "f1c21dwh",
			B7ck84d: "f1ewtqcl",
			B7oj6ja: ["f3fg2lr", "f13av6d4"],
			Bbmb7ep: ["fzi6hpg", "fyowgf4"],
			Bfpq7zp: 0,
			g9k6zt: 0,
			Bn4voq9: 0,
			giviqs: "f89hs3r",
			Bw81rd7: 0,
			kdpuga: 0,
			dm238s: 0,
			B6xbmo0: 0,
			B3whbx2: "f2krc9w",
			B8q5s1w: "f8hki3x",
			Bci5o5g: ["f1d2448m", "ffh67wi"],
			n8qw10: "f1bjia2o",
			Bdrgwmp: ["ffh67wi", "f1d2448m"],
			Jyy4pa: "f1lfeew"
		},
		dismissBrand: { sj55zd: "f1phragk" }
	}, { d: [
		".f22iagw{display:flex;}",
		".f1063pyq{flex-direction:row;}",
		".f1869bpl{justify-content:space-between;}",
		".fod5ikn{font-size:var(--fontSizeBase400);}",
		".fl43uef{font-weight:var(--fontWeightSemibold);}",
		".f19n0e5{color:var(--colorNeutralForeground1);}",
		".faaz57k{line-height:var(--lineHeightBase400);}",
		".f5b47ha{padding-bottom:var(--spacingVerticalS);}",
		".f1jkagg5{margin-top:var(--spacingHorizontalNone);}",
		".fi2ljxd{margin-bottom:var(--spacingHorizontalNone);}",
		".f1phragk{color:var(--colorNeutralForegroundOnBrand);}",
		".f10pi13n{position:relative;}",
		[".f88035w{border:var(--strokeWidthThin) solid var(--colorTransparentStroke);}", { p: -2 }],
		".f122n59{align-items:center;}",
		".f1k6fduh{cursor:pointer;}",
		".fk6fouc{font-family:var(--fontFamilyBase);}",
		".fkhj508{font-size:var(--fontSizeBase300);}",
		".figsok6{font-weight:var(--fontWeightRegular);}",
		".f1i3iumi{line-height:var(--lineHeightBase300);}",
		".f1c21dwh{background-color:var(--colorTransparentBackground);}",
		".f1ewtqcl{box-sizing:border-box;}",
		".f3fg2lr{border-top-right-radius:var(--borderRadiusNone);}",
		".f13av6d4{border-top-left-radius:var(--borderRadiusNone);}",
		".fzi6hpg{border-bottom-right-radius:var(--borderRadiusNone);}",
		".fyowgf4{border-bottom-left-radius:var(--borderRadiusNone);}",
		".f1n71otn{border-right-style:none;}",
		".f1deefiw{border-left-style:none;}",
		[".f89hs3r[data-fui-focus-visible]{outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}", { p: -1 }],
		[".f2krc9w[data-fui-focus-visible]{border-radius:var(--borderRadiusMedium);}", { p: -1 }],
		".f8hki3x[data-fui-focus-visible]{border-top-color:transparent;}",
		".f1d2448m[data-fui-focus-visible]{border-right-color:transparent;}",
		".ffh67wi[data-fui-focus-visible]{border-left-color:transparent;}",
		".f1bjia2o[data-fui-focus-visible]{border-bottom-color:transparent;}",
		".f1lfeew{-webkit-margin-start:auto;margin-inline-start:auto;}"
	] });
	/** Applies style classnames to slots */
	const useTeachingPopoverTitleStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$35();
		const { appearance } = state;
		state.root.className = mergeClasses(teachingPopoverTitleClassNames.root, styles.root, appearance === "brand" && styles.rootBrand, state.root.className);
		if (state.dismissButton) state.dismissButton.className = mergeClasses(teachingPopoverTitleClassNames.dismissButton, styles.dismissButton, appearance === "brand" ? styles.dismissBrand : void 0, state.dismissButton.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverTitle/TeachingPopoverTitle.js
/**
	* Define a styled TeachingPopoverTitle, using the `useTeachingPopoverTitle_unstable` and `useTeachingPopoverTitleStyles_unstable`
	* hooks.
	*
	* TeachingPopoverTitle is similar to TeachingPopoverHeader, but it is intended to be placed within a TeachingPopoverBody
	* TeachingPopoverTitle can also optionally render a dismiss button, however this should only be enabled when there is no TeachingPopoverHeader/dismiss.
	*/ const TeachingPopoverTitle = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useTeachingPopoverTitle_unstable(props, ref);
		useTeachingPopoverTitleStyles_unstable(state);
		useCustomStyleHook("useTeachingPopoverTitleStyles_unstable")(state);
		return renderTeachingPopoverTitle_unstable(state);
	});
	TeachingPopoverTitle.displayName = "TeachingPopoverTitle";

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverTrigger/renderTeachingPopoverTrigger.js
/**
	* Render the final JSX of TeachingPopoverTrigger
	*/ const renderTeachingPopoverTrigger_unstable = (state) => {
		return state.children;
	};

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverTrigger/useTeachingPopoverTrigger.js
/**
	* Create the state required to render TeachingPopoverTrigger.
	*
	* @param props - props from this instance of TeachingPopoverTrigger
	*/ const useTeachingPopoverTrigger_unstable = (props) => {
		return usePopoverTrigger_unstable(props);
	};

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverTrigger/TeachingPopoverTrigger.js
/**
	* Direct extension of PopoverTrigger - Wraps a trigger element as an only child and adds the necessary event handling to open a teaching bubble.
	*/ const TeachingPopoverTrigger = (props) => {
		return renderTeachingPopoverTrigger_unstable(useTeachingPopoverTrigger_unstable(props));
	};
	TeachingPopoverTrigger.displayName = "TeachingPopoverTrigger";
	TeachingPopoverTrigger.isFluentTriggerComponent = true;

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopover/useTeachingPopover.js
	const useTeachingPopover_unstable = (props) => {
		const popoverState = usePopover_unstable(props);
		var _props_withArrow, _props_trapFocus;
		return {
			...popoverState,
			withArrow: (_props_withArrow = props.withArrow) !== null && _props_withArrow !== void 0 ? _props_withArrow : true,
			trapFocus: (_props_trapFocus = props.trapFocus) !== null && _props_trapFocus !== void 0 ? _props_trapFocus : true
		};
	};

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopover/renderTeachingPopover.js
/**
	* Render the final JSX of TeachingPopover
	*/ const renderTeachingPopover_unstable = renderPopover_unstable;

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopover/TeachingPopover.js
/**
	* An extension class of Popover which defaults to withArrow and FocusTrap enabled.
	*/ const TeachingPopover = (props) => {
		return renderTeachingPopover_unstable(useTeachingPopover_unstable(props));
	};
	TeachingPopover.displayName = "TeachingPopover";

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverFooter/useTeachingPopoverFooter.js
/**
	* Returns the props and state required to render the component
	* @param props - TeachingPopoverFooter properties
	* @param ref - reference to root HTMLElement of TeachingPopoverFooter
	*/ const useTeachingPopoverFooter_unstable = (props, ref) => {
		const appearance = usePopoverContext_unstable((context) => context.appearance);
		const toggleOpen = usePopoverContext_unstable((context) => context.toggleOpen);
		const handleButtonClick = useEventCallback((event) => {
			if (event.isDefaultPrevented()) return;
			toggleOpen(event);
		});
		const secondary = optional(props.secondary, {
			defaultProps: { appearance: appearance === "brand" ? "primary" : void 0 },
			renderByDefault: props.secondary !== void 0,
			elementType: Button
		});
		if (secondary) secondary.onClick = mergeCallbacks(handleButtonClick, secondary === null || secondary === void 0 ? void 0 : secondary.onClick);
		const primary = always(props.primary, {
			defaultProps: { appearance: appearance === "brand" ? void 0 : "primary" },
			elementType: Button
		});
		if (!secondary) primary.onClick = mergeCallbacks(handleButtonClick, primary === null || primary === void 0 ? void 0 : primary.onClick);
		var _props_footerLayout;
		return {
			footerLayout: (_props_footerLayout = props.footerLayout) !== null && _props_footerLayout !== void 0 ? _props_footerLayout : "horizontal",
			appearance,
			components: {
				root: "div",
				primary: Button,
				secondary: Button
			},
			root: always(getIntrinsicElementProps("div", {
				ref,
				...props
			}), { elementType: "div" }),
			secondary,
			primary
		};
	};

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverFooter/renderTeachingPopoverFooter.js
/**
	* Render the final JSX of TeachingPopoverFooter
	*/ const renderTeachingPopoverFooter_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(state.root, { children: [/* @__PURE__ */ jsx(state.primary, {}), state.secondary && /* @__PURE__ */ jsx(state.secondary, {})] });
	};

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverFooter/useTeachingPopoverFooterStyles.styles.js
	const teachingPopoverFooterClassNames = {
		root: "fui-TeachingPopoverFooter",
		primary: "fui-TeachingPopoverFooter__primary",
		secondary: "fui-TeachingPopoverFooter__secondary"
	};
	const useStyles$34 = /* @__PURE__ */ __styles({
		root: {
			mc9l5x: "f22iagw",
			i8kkvl: 0,
			Belr9w4: 0,
			rmohyg: "f19gb1f4",
			z8tnut: "f1kcqot9"
		},
		rootVertical: { Beiy3e4: "f1vx9l62" },
		rootHorizontal: {
			Beiy3e4: "f1063pyq",
			Brf1p80: "f9c4gz4"
		},
		buttonRootVertical: {
			a9b677: "f14z66ap",
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "ff3glw6"
		},
		buttonRootHorizontal: {
			Bf4jedk: "f14es27b",
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "ff3glw6"
		},
		brandSecondary: {
			g2u3we: "fm1ebug",
			h3c5rm: ["f28omuz", "f1uhflii"],
			B9xav0g: "f1ixw5o4",
			zhjwy3: ["f1uhflii", "f28omuz"]
		},
		brandPrimary: {
			sj55zd: "f16muhyy",
			De3pzq: "f10s6wn9",
			Bi91k9c: "f3ymbdj",
			Jwef8y: "f1rgtb95",
			B2d53fq: "f1pu27ff",
			iro3zm: "f1d5c7in"
		}
	}, {
		d: [
			".f22iagw{display:flex;}",
			[".f19gb1f4{gap:8px;}", { p: -1 }],
			".f1kcqot9{padding-top:12px;}",
			".f1vx9l62{flex-direction:column;}",
			".f1063pyq{flex-direction:row;}",
			".f9c4gz4{justify-content:flex-end;}",
			".f14z66ap{width:auto;}",
			[".ff3glw6{border-radius:4px;}", { p: -1 }],
			".f14es27b{min-width:96px;}",
			[".ff3glw6{border-radius:4px;}", { p: -1 }],
			".fm1ebug{border-top-color:var(--colorNeutralForegroundOnBrand);}",
			".f28omuz{border-right-color:var(--colorNeutralForegroundOnBrand);}",
			".f1uhflii{border-left-color:var(--colorNeutralForegroundOnBrand);}",
			".f1ixw5o4{border-bottom-color:var(--colorNeutralForegroundOnBrand);}",
			".f16muhyy{color:var(--colorBrandForeground1);}",
			".f10s6wn9{background-color:var(--colorNeutralForegroundOnBrand);}"
		],
		h: [
			".f3ymbdj:hover{color:var(--colorCompoundBrandForeground1Hover);}",
			".f1rgtb95:hover{background-color:var(--colorNeutralForegroundOnBrand);}",
			".f1pu27ff:hover:active{color:var(--colorCompoundBrandForeground1Pressed);}",
			".f1d5c7in:hover:active{background-color:var(--colorNeutralForegroundOnBrand);}"
		]
	});
	/** Applies style classnames to slots */
	const useTeachingPopoverFooterStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$34();
		const { appearance, footerLayout } = state;
		state.root.className = mergeClasses(teachingPopoverFooterClassNames.root, styles.root, footerLayout === "horizontal" ? styles.rootHorizontal : styles.rootVertical, state.root.className);
		if (state.secondary) state.secondary.className = mergeClasses(teachingPopoverFooterClassNames.secondary, footerLayout === "horizontal" ? styles.buttonRootHorizontal : styles.buttonRootVertical, appearance === "brand" ? styles.brandSecondary : void 0, state.secondary.className);
		state.primary.className = mergeClasses(teachingPopoverFooterClassNames.primary, footerLayout === "horizontal" ? styles.buttonRootHorizontal : styles.buttonRootVertical, appearance === "brand" ? styles.brandPrimary : void 0, state.primary.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverFooter/TeachingPopoverFooter.js
/**
	* Define a styled TeachingPopoverFooter, using the `useTeachingPopoverFooter_unstable` and `useTeachingPopoverFooterStyles_unstable`
	* hooks.
	*
	* TeachingPopoverFooter will provide both a secondary and primary button for the TeachingPopover,
	* and handle Popover functionality such as closing the popup.
	*
	* Users must provide the localized text for each button within the footer via slots.
	*/ const TeachingPopoverFooter = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useTeachingPopoverFooter_unstable(props, ref);
		useTeachingPopoverFooterStyles_unstable(state);
		useCustomStyleHook("useTeachingPopoverFooterStyles_unstable")(state);
		return renderTeachingPopoverFooter_unstable(state);
	});
	TeachingPopoverFooter.displayName = "TeachingPopoverFooter";

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselPageCount/useTeachingPopoverCarouselPageCount.js
/**
	* Create the state required to render TeachingPopoverCarouselPageCount.
	*
	* The returned state can be modified with hooks such as useTeachingPopoverCarouselPageCountStyles_unstable,
	* before being passed to renderTeachingPopoverCarouselPageCount_unstable.
	*
	* @param props - props from this instance of TeachingPopoverCarouselPageCount
	* @param ref - reference to root HTMLDivElement of TeachingPopoverCarouselPageCount
	*/ const useTeachingPopoverCarouselPageCount_unstable = (props, ref) => {
		const values = useCarouselValues_unstable((snapshot) => snapshot);
		var _useCarouselContext_unstable;
		const selectedValue = (_useCarouselContext_unstable = useCarouselContext_unstable$1((c) => c.value)) !== null && _useCarouselContext_unstable !== void 0 ? _useCarouselContext_unstable : values[0];
		const currentIndex = values.indexOf(selectedValue);
		const totalPages = values.length;
		return {
			currentIndex,
			totalPages,
			renderPageCount: props.children,
			components: { root: "div" },
			root: always(getIntrinsicElementProps("div", {
				ref,
				...props,
				children: props.children(currentIndex + 1, totalPages)
			}), { elementType: "div" })
		};
	};

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselPageCount/renderTeachingPopoverCarouselPageCount.js
/**
	* Render the final JSX of TeachingPopoverCarouselPageCount
	*/ const renderTeachingPopoverCarouselPageCount_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, {});
	};

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselPageCount/useTeachingPopoverCarouselPageCountStyles.styles.js
	const teachingPopoverCarouselPageCountClassNames = { root: "fui-TeachingPopoverCarouselPageCount" };
	/**
	* Styles for the root slot
	*/
	const useStyles$33 = /* @__PURE__ */ __styles({ root: {
		mc9l5x: "f22iagw",
		Bt984gj: "f122n59",
		Brf1p80: "f4d9j23"
	} }, { d: [
		".f22iagw{display:flex;}",
		".f122n59{align-items:center;}",
		".f4d9j23{justify-content:center;}"
	] });
	/**
	* Apply styling to the TeachingPopoverCarouselPageCount slots based on the state
	*/
	const useTeachingPopoverCarouselPageCountStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$33();
		state.root.className = mergeClasses(teachingPopoverCarouselPageCountClassNames.root, styles.root, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselPageCount/TeachingPopoverCarouselPageCount.js
/**
	* TeachingPopoverCarouselPageCount is a simple interface for rendering based on current and total page count
	*
	* The child render function will provide both current and total page numbers for customization.
	*/ const TeachingPopoverCarouselPageCount = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useTeachingPopoverCarouselPageCount_unstable(props, ref);
		useTeachingPopoverCarouselPageCountStyles_unstable(state);
		useCustomStyleHook("useTeachingPopoverCarouselPageCountStyles_unstable")(state);
		return renderTeachingPopoverCarouselPageCount_unstable(state);
	});
	TeachingPopoverCarouselPageCount.displayName = "TeachingPopoverCarouselPageCount";

//#endregion
//#region node_modules/@fluentui/react-tag-picker/lib/components/TagPicker/useTagPicker.js
	const fallbackPositions = [
		"above",
		"after",
		"after-top",
		"before",
		"before-top"
	];
	/**
	* Create the state required to render Picker.
	*
	* The returned state can be modified with hooks such as usePickerStyles_unstable,
	* before being passed to renderPicker_unstable.
	*
	* @param props - props from this instance of Picker
	*/ const useTagPicker_unstable = (props) => {
		const popoverId = useId("picker-listbox");
		const triggerInnerRef = react.useRef(null);
		const secondaryActionRef = react.useRef(null);
		const tagPickerGroupRef = react.useRef(null);
		const { positioning, size: size$2 = "medium", inline = false, noPopover = false } = props;
		const { targetRef, containerRef } = usePositioning({
			position: "below",
			align: "start",
			offset: {
				crossAxis: 0,
				mainAxis: 2
			},
			fallbackPositions,
			matchTargetSize: "width",
			...resolvePositioningShorthand(positioning)
		});
		const { controller: activeDescendantController, activeParentRef, listboxRef } = useActiveDescendant({ matchOption: (el) => el.classList.contains(optionClassNames.root) });
		const comboboxState = useComboboxBaseState({
			...props,
			onOptionSelect: useEventCallback((event, data) => {
				var _props_onOptionSelect;
				return (_props_onOptionSelect = props.onOptionSelect) === null || _props_onOptionSelect === void 0 ? void 0 : _props_onOptionSelect.call(props, event, {
					selectedOptions: data.selectedOptions,
					value: data.optionValue,
					type: event.type,
					event
				});
			}),
			onOpenChange: useEventCallback((event, data) => {
				var _props_onOpenChange;
				return (_props_onOpenChange = props.onOpenChange) === null || _props_onOpenChange === void 0 ? void 0 : _props_onOpenChange.call(props, event, {
					...data,
					type: event.type,
					event
				});
			}),
			activeDescendantController,
			editable: true,
			multiselect: true,
			size: "medium"
		});
		const { trigger, popover } = childrenToTriggerAndPopover(props.children, noPopover);
		return {
			activeDescendantController,
			components: {},
			trigger,
			popover: comboboxState.open || comboboxState.hasFocus ? popover : void 0,
			popoverId,
			noPopover,
			disabled: comboboxState.disabled,
			triggerRef: useMergedRefs(triggerInnerRef, activeParentRef),
			popoverRef: useMergedRefs(listboxRef, containerRef),
			secondaryActionRef,
			tagPickerGroupRef,
			targetRef,
			size: size$2,
			inline,
			open: comboboxState.open,
			mountNode: comboboxState.mountNode,
			onOptionClick: useEventCallback((event) => {
				comboboxState.onOptionClick(event);
				comboboxState.setOpen(event, false);
			}),
			appearance: comboboxState.appearance,
			clearSelection: comboboxState.clearSelection,
			getOptionById: comboboxState.getOptionById,
			getOptionsMatchingValue: comboboxState.getOptionsMatchingValue,
			registerOption: comboboxState.registerOption,
			selectedOptions: comboboxState.selectedOptions,
			selectOption: useEventCallback((event, data) => {
				if (comboboxState.selectedOptions.includes(data.value) && !elementContains(tagPickerGroupRef.current, event.target)) {
					var _props_onOptionSelect;
					(_props_onOptionSelect = props.onOptionSelect) === null || _props_onOptionSelect === void 0 || _props_onOptionSelect.call(props, event, {
						selectedOptions: comboboxState.selectedOptions,
						value: data.value,
						type: event.type,
						event
					});
					return;
				}
				comboboxState.selectOption(event, data);
			}),
			setHasFocus: comboboxState.setHasFocus,
			setOpen: comboboxState.setOpen,
			setValue: comboboxState.setValue,
			value: comboboxState.value
		};
	};
	const childrenToTriggerAndPopover = (children, noPopover) => {
		const childrenArray = react.Children.toArray(children);
		if (childrenArray.length === 0) console.warn("TagPicker must contain at least one child");
		if (childrenArray.length > 2) console.warn("TagPicker must contain at most two children");
		if (noPopover) return { trigger: childrenArray[0] };
		let trigger = void 0;
		let popover = void 0;
		if (childrenArray.length === 2) {
			trigger = childrenArray[0];
			popover = childrenArray[1];
		} else if (childrenArray.length === 1) popover = childrenArray[0];
		return {
			trigger,
			popover
		};
	};

//#endregion
//#region node_modules/@fluentui/react-tag-picker/lib/contexts/TagPickerContext.js
/**
	* @internal
	*/ const tagPickerContextDefaultValue = {
		triggerRef: react.createRef(),
		popoverRef: react.createRef(),
		targetRef: react.createRef(),
		tagPickerGroupRef: react.createRef(),
		secondaryActionRef: react.createRef(),
		open: false,
		clearSelection: () => null,
		getOptionById: () => void 0,
		selectedOptions: [],
		selectOption: () => null,
		setHasFocus: () => null,
		setOpen: () => null,
		setValue: () => null,
		value: void 0,
		popoverId: "",
		size: "medium",
		appearance: "outline",
		disabled: false
	};
	const TagPickerContext = createContext(void 0);
	const TagPickerContextProvider = TagPickerContext.Provider;
	const useTagPickerContext_unstable = (selector) => useContextSelector(TagPickerContext, (ctx = tagPickerContextDefaultValue) => selector(ctx));

//#endregion
//#region node_modules/@fluentui/react-tag-picker/lib/components/TagPicker/renderTagPicker.js
/**
	* Render the final JSX of Picker
	*/ const renderTagPicker_unstable = (state, contexts) => {
		assertSlots(state);
		return /* @__PURE__ */ react.createElement(TagPickerContextProvider, { value: contexts.picker }, /* @__PURE__ */ react.createElement(ActiveDescendantContextProvider, { value: contexts.activeDescendant }, /* @__PURE__ */ react.createElement(ListboxProvider, { value: contexts.listbox }, state.trigger, state.popover && (state.inline ? state.popover : /* @__PURE__ */ react.createElement(Portal, { mountNode: state.mountNode }, state.popover)))));
	};

//#endregion
//#region node_modules/@fluentui/react-tag-picker/lib/components/TagPicker/useTagPickerContextValues.js
	function useTagPickerContextValues(state) {
		const { onOptionClick, registerOption, selectedOptions, selectOption, value, triggerRef, secondaryActionRef, tagPickerGroupRef, targetRef, size: size$2, setValue, setOpen, setHasFocus, popoverRef, appearance, clearSelection, getOptionById, getOptionsMatchingValue, open, popoverId, disabled, noPopover } = state;
		return {
			activeDescendant: react.useMemo(() => ({ controller: state.activeDescendantController }), [state.activeDescendantController]),
			listbox: {
				onOptionClick,
				registerOption,
				getOptionById,
				getOptionsMatchingValue,
				selectedOptions,
				selectOption,
				focusVisible: false,
				setActiveOption: noop
			},
			picker: {
				value,
				triggerRef,
				targetRef,
				secondaryActionRef,
				tagPickerGroupRef,
				size: size$2,
				setValue,
				setOpen,
				setHasFocus,
				selectOption,
				popoverRef,
				selectedOptions,
				appearance,
				clearSelection,
				getOptionById,
				open,
				popoverId,
				disabled,
				noPopover
			}
		};
	}
	const noop = () => {
		/** noop */	};

//#endregion
//#region node_modules/@fluentui/react-tag-picker/lib/components/TagPicker/TagPicker.js
/**
	* TagPicker component -
	* A TagPicker is a composite component that allows users to pick tags from a list of options.
	*/ const TagPicker = /* @__PURE__ */ react.memo((props) => {
		const state = useTagPicker_unstable(props);
		return renderTagPicker_unstable(state, useTagPickerContextValues(state));
	});
	TagPicker.displayName = "TagPicker";

//#endregion
//#region node_modules/@fluentui/react-tag-picker/lib/utils/tokens.js
	const tagPickerInputCSSRules = { width: "--fluent-TagPickerInput__width" };
	const tagPickerInputTokens = { width: `var(${tagPickerInputCSSRules.width}, 0)` };

//#endregion
//#region node_modules/@fluentui/react-tag-picker/lib/components/TagPickerInput/useTagPickerInput.js
/**
	* Create the state required to render TagPickerInput.
	*
	* The returned state can be modified with hooks such as useTagPickerInputStyles_unstable,
	* before being passed to renderTagPickerInput_unstable.
	*
	* @param props - props from this instance of TagPickerInput
	* @param ref - reference to root HTMLDivElement of TagPickerInput
	*/ const useTagPickerInput_unstable = (propsArg, ref) => {
		const props = useFieldControlProps_unstable(propsArg, {
			supportsLabelFor: true,
			supportsRequired: true,
			supportsSize: true
		});
		const { controller: activeDescendantController } = useActiveDescendantContext();
		const size$2 = useTagPickerContext_unstable((ctx) => ctx.size);
		const contextDisabled = useTagPickerContext_unstable((ctx) => ctx.disabled);
		const tagPickerGroupRef = useTagPickerContext_unstable((ctx) => ctx.tagPickerGroupRef);
		const triggerRef = useTagPickerContext_unstable((ctx) => ctx.triggerRef);
		const selectedOptions = useTagPickerContext_unstable((ctx) => ctx.selectedOptions);
		const setValue = useTagPickerContext_unstable((ctx) => ctx.setValue);
		const setOpen = useTagPickerContext_unstable((ctx) => ctx.setOpen);
		const setHasFocus = useTagPickerContext_unstable((ctx) => ctx.setHasFocus);
		const clearSelection = useTagPickerContext_unstable((ctx) => ctx.clearSelection);
		const open = useTagPickerContext_unstable((ctx) => ctx.open);
		const popoverId = useTagPickerContext_unstable((ctx) => ctx.noPopover ? void 0 : ctx.popoverId);
		const selectOption = useTagPickerContext_unstable((ctx) => ctx.selectOption);
		const getOptionById = useTagPickerContext_unstable((ctx) => ctx.getOptionById);
		const contextValue = useTagPickerContext_unstable((ctx) => ctx.value);
		useIsomorphicLayoutEffect(() => {
			if (!triggerRef.current) return;
			setTagPickerInputStretchStyle(triggerRef.current);
		}, [selectedOptions, triggerRef]);
		useIsomorphicLayoutEffect(() => {
			if (triggerRef.current) {
				const input = triggerRef.current;
				const cb = () => setTagPickerInputStretchStyle(input);
				input.addEventListener("input", cb);
				return () => {
					input.removeEventListener("input", cb);
				};
			}
		}, [triggerRef]);
		const { value = contextValue, disabled = contextDisabled } = props;
		const { findLastFocusable } = useFocusFinders();
		const isTypingRef = react.useRef(false);
		return {
			components: { root: "input" },
			root: useInputTriggerSlot({
				type: "text",
				value: value !== null && value !== void 0 ? value : "",
				"aria-controls": open ? popoverId : void 0,
				disabled,
				...getIntrinsicElementProps("input", props),
				onKeyDown: useEventCallback((event) => {
					var _props_onKeyDown;
					(_props_onKeyDown = props.onKeyDown) === null || _props_onKeyDown === void 0 || _props_onKeyDown.call(props, event);
					if ((event.key === ArrowLeft || event.key === Backspace) && event.currentTarget.selectionStart === 0 && event.currentTarget.selectionEnd === 0 && tagPickerGroupRef.current) {
						var _findLastFocusable;
						(_findLastFocusable = findLastFocusable(tagPickerGroupRef.current)) === null || _findLastFocusable === void 0 || _findLastFocusable.focus();
					} else if (event.key === Space) {
						if (open && !isTypingRef.current) setOpen(event, false);
					} else if (event.key === Enter) if (open) react_dom.unstable_batchedUpdates(() => {
						setValue(void 0);
						setOpen(event, false);
					});
					else setOpen(event, true);
					isTypingRef.current = event.key.length === 1 && event.code !== Space && !event.altKey && !event.ctrlKey && !event.metaKey;
				})
			}, useMergedRefs(triggerRef, ref), {
				activeDescendantController,
				freeform: false,
				state: {
					clearSelection,
					getOptionById,
					open,
					selectedOptions,
					selectOption,
					setHasFocus,
					setOpen,
					setValue,
					multiselect: true,
					value: props.value
				}
			}),
			disabled,
			size: size$2
		};
	};
	/**
	* while typing the user might need a bit more of space to see the text,
	* which means the input should stretch to 100% width
	* occupying a whole new line.
	*
	* This function will set the CSS variable `--width` to `100%` if the scrollWidth is greater than the offsetWidth,
	* meaning the text is overflowing the input.
	*
	* @param input - input element to apply the style
	* @returns void
	*/ const setTagPickerInputStretchStyle = (input) => {
		input.style.removeProperty(tagPickerInputCSSRules.width);
		if (input.scrollWidth > input.offsetWidth + 1) input.style.setProperty(tagPickerInputCSSRules.width, "100%");
		else input.style.removeProperty(tagPickerInputCSSRules.width);
	};

//#endregion
//#region node_modules/@fluentui/react-tag-picker/lib/components/TagPickerInput/renderTagPickerInput.js
/**
	* Render the final JSX of TagPickerInput
	*/ const renderTagPickerInput_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, {});
	};

//#endregion
//#region node_modules/@fluentui/react-tag-picker/lib/components/TagPickerInput/useTagPickerInputStyles.styles.js
	const tagPickerInputClassNames = { root: "fui-TagPickerInput" };
	const useBaseStyle = /* @__PURE__ */ __resetStyles("r1hdk6fw", null, [
		".r1hdk6fw{background-color:var(--colorTransparentBackground);color:var(--colorNeutralForeground1);font-family:var(--fontFamilyBase);box-sizing:border-box;border:none;min-width:24px;max-width:100%;width:var(--fluent-TagPickerInput__width, 0);flex-grow:1;}",
		".r1hdk6fw:focus{outline-style:none;}",
		".r1hdk6fw::-webkit-input-placeholder{color:var(--colorNeutralForeground4);opacity:1;}",
		".r1hdk6fw::-moz-placeholder{color:var(--colorNeutralForeground4);opacity:1;}",
		".r1hdk6fw::placeholder{color:var(--colorNeutralForeground4);opacity:1;}",
		".r1hdk6fw::after{visibility:hidden;white-space:pre-wrap;}"
	]);
	/**
	* Styles for the root slot
	*/
	const useStyles$32 = /* @__PURE__ */ __styles({
		medium: {
			Bahqtrf: "fk6fouc",
			Be2twd7: "fkhj508",
			Bhrd7zp: "figsok6",
			Bg96gwp: "f1i3iumi",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "fa2pw7h"
		},
		large: {
			Bahqtrf: "fk6fouc",
			Be2twd7: "fkhj508",
			Bhrd7zp: "figsok6",
			Bg96gwp: "f1i3iumi",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "ft37c3"
		},
		"extra-large": {
			Bahqtrf: "fk6fouc",
			Be2twd7: "fkhj508",
			Bhrd7zp: "figsok6",
			Bg96gwp: "f1i3iumi",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f3abo53"
		},
		disabled: {
			sj55zd: "f1s2aq7o",
			De3pzq: "f1c21dwh",
			Bceei9c: "fdrzuqr",
			yvdlaj: "fahhnxm"
		}
	}, { d: [
		".fk6fouc{font-family:var(--fontFamilyBase);}",
		".fkhj508{font-size:var(--fontSizeBase300);}",
		".figsok6{font-weight:var(--fontWeightRegular);}",
		".f1i3iumi{line-height:var(--lineHeightBase300);}",
		[".fa2pw7h{padding:var(--spacingVerticalSNudge) 0 var(--spacingVerticalSNudge) 0;}", { p: -1 }],
		[".ft37c3{padding:var(--spacingVerticalMNudge) 0 var(--spacingVerticalMNudge) 0;}", { p: -1 }],
		[".f3abo53{padding:var(--spacingVerticalM) 0 var(--spacingVerticalM) 0;}", { p: -1 }],
		".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}",
		".f1c21dwh{background-color:var(--colorTransparentBackground);}",
		".fdrzuqr{cursor:not-allowed;}",
		".fahhnxm::-webkit-input-placeholder{color:var(--colorNeutralForegroundDisabled);}",
		".fahhnxm::-moz-placeholder{color:var(--colorNeutralForegroundDisabled);}"
	] });
	/**
	* Apply styling to the TagPickerInput slots based on the state
	*/
	const useTagPickerInputStyles_unstable = (state) => {
		"use no memo";
		const baseStyle = useBaseStyle();
		const styles = useStyles$32();
		state.root.className = mergeClasses(tagPickerInputClassNames.root, baseStyle, styles[state.size], state.disabled && styles.disabled, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-tag-picker/lib/components/TagPickerInput/TagPickerInput.js
/**
	* TagPickerInput component -
	* A TagPickerInput is a composite component that allows users to query tags.
	*/ const TagPickerInput = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useTagPickerInput_unstable(props, ref);
		useTagPickerInputStyles_unstable(state);
		useCustomStyleHook("useTagPickerInputStyles_unstable")(state);
		return renderTagPickerInput_unstable(state);
	});
	TagPickerInput.displayName = "TagPickerInput";

//#endregion
//#region node_modules/@fluentui/react-tag-picker/lib/components/TagPickerList/useTagPickerList.js
/**
	* Create the state required to render TagPickerList.
	*
	* The returned state can be modified with hooks such as useTagPickerListStyles_unstable,
	* before being passed to renderTagPickerList_unstable.
	*
	* @param props - props from this instance of TagPickerList
	* @param ref - reference to root HTMLDivElement of TagPickerList
	*/ const useTagPickerList_unstable = (props, ref) => {
		const triggerRef = useTagPickerContext_unstable((ctx) => ctx.triggerRef);
		const popoverRef = useTagPickerContext_unstable((ctx) => ctx.popoverRef);
		const popoverId = useTagPickerContext_unstable((ctx) => ctx.popoverId);
		return {
			open: useTagPickerContext_unstable((ctx) => ctx.open),
			components: { root: Listbox },
			root: always({
				...useListboxSlot(props, useMergedRefs(popoverRef, ref), {
					state: { multiselect: true },
					triggerRef,
					defaultProps: { id: popoverId }
				}),
				role: "listbox"
			}, { elementType: Listbox })
		};
	};

//#endregion
//#region node_modules/@fluentui/react-tag-picker/lib/components/TagPickerList/renderTagPickerList.js
/**
	* Render the final JSX of TagPickerList
	*/ const renderTagPickerList_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, {});
	};

//#endregion
//#region node_modules/@fluentui/react-tag-picker/lib/components/TagPickerList/useTagPickerListStyles.styles.js
	const tagPickerListClassNames = { root: "fui-TagPickerList" };
	/**
	* Styles for the root slot
	*/
	const useStyles$31 = /* @__PURE__ */ __styles({
		root: {
			E5pizo: "f1hg901r",
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "ft85np5",
			Bxyxcbc: "fmmk62d",
			B7ck84d: "f1ewtqcl"
		},
		collapsed: { mc9l5x: "fjseox" }
	}, { d: [
		".f1hg901r{box-shadow:var(--shadow16);}",
		[".ft85np5{border-radius:var(--borderRadiusMedium);}", { p: -1 }],
		".fmmk62d{max-height:80vh;}",
		".f1ewtqcl{box-sizing:border-box;}",
		".fjseox{display:none;}"
	] });
	/**
	* Apply styling to the TagPickerList slots based on the state
	*/
	const useTagPickerListStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$31();
		state.root.className = mergeClasses(tagPickerListClassNames.root, styles.root, !state.open && styles.collapsed, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-tag-picker/lib/components/TagPickerList/TagPickerList.js
/**
	* TagPickerList component -
	* A TagPickerList is a composite component that allows users to display a list of tag options to be selected.
	*/ const TagPickerList = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useTagPickerList_unstable(props, ref);
		useTagPickerListStyles_unstable(state);
		useCustomStyleHook("useTagPickerListStyles_unstable")(state);
		return renderTagPickerList_unstable(state);
	});
	TagPickerList.displayName = "TagPickerList";

//#endregion
//#region node_modules/@fluentui/react-tag-picker/lib/components/TagPickerButton/useTagPickerButton.js
/**
	* Create the state required to render PickerButton.
	*
	* The returned state can be modified with hooks such as usePickerButtonStyles_unstable,
	* before being passed to renderPickerButton_unstable.
	*
	* @param props - props from this instance of PickerButton
	* @param ref - reference to root HTMLDivElement of PickerButton
	*/ const useTagPickerButton_unstable = (props, ref) => {
		const { controller: activeDescendantController } = useActiveDescendantContext();
		const triggerRef = useTagPickerContext_unstable((ctx) => ctx.triggerRef);
		const open = useTagPickerContext_unstable((ctx) => ctx.open);
		const value = useTagPickerContext_unstable((ctx) => ctx.value);
		const hasSelectedOption = useTagPickerContext_unstable((ctx) => ctx.selectedOptions.length > 0);
		const popoverId = useTagPickerContext_unstable((ctx) => ctx.popoverId);
		const getOptionById = useTagPickerContext_unstable((ctx) => ctx.getOptionById);
		const selectOption = useTagPickerContext_unstable((ctx) => ctx.selectOption);
		const setHasFocus = useTagPickerContext_unstable((ctx) => ctx.setHasFocus);
		const setOpen = useTagPickerContext_unstable((ctx) => ctx.setOpen);
		return {
			components: { root: "button" },
			root: useButtonTriggerSlot(props, triggerRef, {
				activeDescendantController,
				defaultProps: {
					type: "button",
					tabIndex: 0,
					children: value || props.placeholder,
					"aria-controls": open ? popoverId : void 0,
					ref
				},
				state: {
					getOptionById,
					open,
					selectOption,
					setHasFocus,
					setOpen,
					multiselect: true
				}
			}),
			size: useTagPickerContext_unstable((ctx) => ctx.size),
			hasSelectedOption
		};
	};

//#endregion
//#region node_modules/@fluentui/react-tag-picker/lib/components/TagPickerButton/renderTagPickerButton.js
/**
	* Render the final JSX of PickerButton
	*/ const renderTagPickerButton_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, {});
	};

//#endregion
//#region node_modules/@fluentui/react-tag-picker/lib/components/TagPickerButton/useTagPickerButtonStyles.styles.js
	const tagPickerButtonClassNames = { root: "fui-TagPickerButton" };
	/**
	* Styles for the root slot
	*/
	const useStyles$30 = /* @__PURE__ */ __styles({
		button: {
			Bt984gj: "f122n59",
			sshi5w: "f1nxs5xn",
			De3pzq: "f1c21dwh",
			Bgfg5da: 0,
			B9xav0g: 0,
			oivjwe: 0,
			Bn0qgzm: 0,
			B4g9neb: 0,
			zhjwy3: 0,
			wvpqe5: 0,
			ibv6hh: 0,
			u1mtju: 0,
			h3c5rm: 0,
			vrafjx: 0,
			Bekrc4i: 0,
			i8vvqc: 0,
			g2u3we: 0,
			icvyot: 0,
			B4j52fo: 0,
			irswps: "f3bhgqh",
			B7ck84d: "f1ewtqcl",
			sj55zd: "f19n0e5",
			i8kkvl: "f14mj54c",
			Bceei9c: "f1k6fduh",
			Bahqtrf: "fk6fouc",
			fsow6f: ["f1o700av", "fes3tcz"],
			Bh6795r: "fqerorx",
			Brovlpu: "ftqa4ok"
		},
		placeholder: { sj55zd: "fxc4j92" },
		medium: {
			Bahqtrf: "fk6fouc",
			Be2twd7: "fy9rknc",
			Bhrd7zp: "figsok6",
			Bg96gwp: "fwrc4pm",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: ["fye6m5k", "f3cq2dl"]
		},
		large: {
			Bahqtrf: "fk6fouc",
			Be2twd7: "fkhj508",
			Bhrd7zp: "figsok6",
			Bg96gwp: "f1i3iumi",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: ["f14ev680", "f58uxzw"]
		},
		"extra-large": {
			i8kkvl: "f1rjii52",
			Bahqtrf: "fk6fouc",
			Be2twd7: "fod5ikn",
			Bhrd7zp: "figsok6",
			Bg96gwp: "faaz57k",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: ["f139mn7i", "f1v3q0m"]
		},
		outline: {
			De3pzq: "fxugw4r",
			Bgfg5da: 0,
			B9xav0g: "f1c1zstj",
			oivjwe: 0,
			Bn0qgzm: 0,
			B4g9neb: 0,
			zhjwy3: 0,
			wvpqe5: 0,
			ibv6hh: 0,
			u1mtju: 0,
			h3c5rm: 0,
			vrafjx: 0,
			Bekrc4i: 0,
			i8vvqc: 0,
			g2u3we: 0,
			icvyot: 0,
			B4j52fo: 0,
			irswps: "fhz96rm"
		},
		outlineInteractive: {
			Bgoe8wy: "fvcxoqz",
			Bwzppfd: ["f1ub3y4t", "f1m52nbi"],
			oetu4i: "flmw63s",
			gg5e9n: ["f1m52nbi", "f1ub3y4t"],
			B6oc9vd: "fvs00aa",
			ak43y8: ["f1assf6x", "f4ruux4"],
			wmxk5l: "fqhmt4z",
			B50zh58: ["f4ruux4", "f1assf6x"]
		},
		underline: {
			De3pzq: "f1c21dwh",
			B9xav0g: 0,
			oivjwe: 0,
			Bn0qgzm: 0,
			Bgfg5da: "f9ez7ne",
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "fokr779"
		},
		"filled-lighter": {
			De3pzq: "fxugw4r",
			Bgfg5da: 0,
			B9xav0g: 0,
			oivjwe: 0,
			Bn0qgzm: 0,
			B4g9neb: 0,
			zhjwy3: 0,
			wvpqe5: 0,
			ibv6hh: 0,
			u1mtju: 0,
			h3c5rm: 0,
			vrafjx: 0,
			Bekrc4i: 0,
			i8vvqc: 0,
			g2u3we: 0,
			icvyot: 0,
			B4j52fo: 0,
			irswps: "fs2rfia"
		},
		"filled-darker": {
			De3pzq: "f16xq7d1",
			Bgfg5da: 0,
			B9xav0g: 0,
			oivjwe: 0,
			Bn0qgzm: 0,
			B4g9neb: 0,
			zhjwy3: 0,
			wvpqe5: 0,
			ibv6hh: 0,
			u1mtju: 0,
			h3c5rm: 0,
			vrafjx: 0,
			Bekrc4i: 0,
			i8vvqc: 0,
			g2u3we: 0,
			icvyot: 0,
			B4j52fo: 0,
			irswps: "fs2rfia"
		},
		invalid: {
			tvckwq: "fs4k3qj",
			gk2u95: ["fcee079", "fmyw78r"],
			hhx65j: "f1fgmyf4",
			Bxowmz0: ["fmyw78r", "fcee079"]
		},
		invalidUnderline: { hhx65j: "f1fgmyf4" },
		disabled: {
			Bceei9c: "fdrzuqr",
			De3pzq: "f1c21dwh",
			g2u3we: "f1jj8ep1",
			h3c5rm: ["f15xbau", "fy0fskl"],
			B9xav0g: "f4ikngz",
			zhjwy3: ["fy0fskl", "f15xbau"],
			Bcq6wej: "f9dbb4x",
			Jcjdmf: ["f3qs60o", "f5u9ap2"],
			sc4o1m: "fwd1oij",
			Bosien3: ["f5u9ap2", "f3qs60o"]
		},
		disabledText: {
			sj55zd: "f1s2aq7o",
			Bceei9c: "fdrzuqr"
		},
		hidden: { mc9l5x: "fjseox" },
		visuallyHidden: {
			Bh84pgu: "f1ekcaio",
			Bqenvij: "f1mpe4l3",
			jrapky: 0,
			Frg6f3: 0,
			t21cq0: 0,
			B6of3ja: 0,
			B74szlk: "f1jlpb2r",
			B68tc82: 0,
			Bmxbyg5: 0,
			Bpg54ce: "f1a3p1vp",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f1c5fvqg",
			a9b677: "frkrog8",
			qhf8xq: "f1euv43f"
		}
	}, {
		d: [
			".f122n59{align-items:center;}",
			".f1nxs5xn{min-height:32px;}",
			".f1c21dwh{background-color:var(--colorTransparentBackground);}",
			[".f3bhgqh{border:none;}", { p: -2 }],
			".f1ewtqcl{box-sizing:border-box;}",
			".f19n0e5{color:var(--colorNeutralForeground1);}",
			".f14mj54c{column-gap:var(--spacingHorizontalXXS);}",
			".f1k6fduh{cursor:pointer;}",
			".fk6fouc{font-family:var(--fontFamilyBase);}",
			".f1o700av{text-align:left;}",
			".fes3tcz{text-align:right;}",
			".fqerorx{flex-grow:1;}",
			".fxc4j92{color:var(--colorNeutralForeground4);}",
			".fy9rknc{font-size:var(--fontSizeBase200);}",
			".figsok6{font-weight:var(--fontWeightRegular);}",
			".fwrc4pm{line-height:var(--lineHeightBase200);}",
			[".fye6m5k{padding:3px var(--spacingHorizontalSNudge) 3px calc(var(--spacingHorizontalSNudge) + var(--spacingHorizontalXXS));}", { p: -1 }],
			[".f3cq2dl{padding:3px calc(var(--spacingHorizontalSNudge) + var(--spacingHorizontalXXS)) 3px var(--spacingHorizontalSNudge);}", { p: -1 }],
			".fkhj508{font-size:var(--fontSizeBase300);}",
			".f1i3iumi{line-height:var(--lineHeightBase300);}",
			[".f14ev680{padding:5px var(--spacingHorizontalMNudge) 5px calc(var(--spacingHorizontalMNudge) + var(--spacingHorizontalXXS));}", { p: -1 }],
			[".f58uxzw{padding:5px calc(var(--spacingHorizontalMNudge) + var(--spacingHorizontalXXS)) 5px var(--spacingHorizontalMNudge);}", { p: -1 }],
			".f1rjii52{column-gap:var(--spacingHorizontalSNudge);}",
			".fod5ikn{font-size:var(--fontSizeBase400);}",
			".faaz57k{line-height:var(--lineHeightBase400);}",
			[".f139mn7i{padding:7px var(--spacingHorizontalM) 7px calc(var(--spacingHorizontalM) + var(--spacingHorizontalSNudge));}", { p: -1 }],
			[".f1v3q0m{padding:7px calc(var(--spacingHorizontalM) + var(--spacingHorizontalSNudge)) 7px var(--spacingHorizontalM);}", { p: -1 }],
			".fxugw4r{background-color:var(--colorNeutralBackground1);}",
			[".fhz96rm{border:var(--strokeWidthThin) solid var(--colorNeutralStroke1);}", { p: -2 }],
			".f1c1zstj{border-bottom-color:var(--colorNeutralStrokeAccessible);}",
			[".f9ez7ne{border-bottom:var(--strokeWidthThin) solid var(--colorNeutralStrokeAccessible);}", { p: -1 }],
			[".fokr779{border-radius:0;}", { p: -1 }],
			[".fs2rfia{border:var(--strokeWidthThin) solid transparent;}", { p: -2 }],
			".f16xq7d1{background-color:var(--colorNeutralBackground3);}",
			[".fs2rfia{border:var(--strokeWidthThin) solid transparent;}", { p: -2 }],
			".fs4k3qj:not(:focus-within),.fs4k3qj:hover:not(:focus-within){border-top-color:var(--colorPaletteRedBorder2);}",
			".fcee079:not(:focus-within),.fcee079:hover:not(:focus-within){border-right-color:var(--colorPaletteRedBorder2);}",
			".fmyw78r:not(:focus-within),.fmyw78r:hover:not(:focus-within){border-left-color:var(--colorPaletteRedBorder2);}",
			".f1fgmyf4:not(:focus-within),.f1fgmyf4:hover:not(:focus-within){border-bottom-color:var(--colorPaletteRedBorder2);}",
			".fdrzuqr{cursor:not-allowed;}",
			".f1jj8ep1{border-top-color:var(--colorNeutralStrokeDisabled);}",
			".f15xbau{border-right-color:var(--colorNeutralStrokeDisabled);}",
			".fy0fskl{border-left-color:var(--colorNeutralStrokeDisabled);}",
			".f4ikngz{border-bottom-color:var(--colorNeutralStrokeDisabled);}",
			".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}",
			".fjseox{display:none;}",
			".f1ekcaio{clip:rect(0px, 0px, 0px, 0px);}",
			".f1mpe4l3{height:1px;}",
			[".f1jlpb2r{margin:-1px;}", { p: -1 }],
			[".f1a3p1vp{overflow:hidden;}", { p: -1 }],
			[".f1c5fvqg{padding:0px;}", { p: -1 }],
			".frkrog8{width:1px;}",
			".f1euv43f{position:absolute;}"
		],
		f: [".ftqa4ok:focus{outline-style:none;}"],
		h: [
			".fvcxoqz:hover{border-top-color:var(--colorNeutralStroke1Hover);}",
			".f1ub3y4t:hover{border-right-color:var(--colorNeutralStroke1Hover);}",
			".f1m52nbi:hover{border-left-color:var(--colorNeutralStroke1Hover);}",
			".flmw63s:hover{border-bottom-color:var(--colorNeutralStrokeAccessible);}"
		],
		a: [
			".fvs00aa:active{border-top-color:var(--colorNeutralStroke1Pressed);}",
			".f1assf6x:active{border-right-color:var(--colorNeutralStroke1Pressed);}",
			".f4ruux4:active{border-left-color:var(--colorNeutralStroke1Pressed);}",
			".fqhmt4z:active{border-bottom-color:var(--colorNeutralStrokeAccessible);}"
		],
		m: [
			["@media (forced-colors: active){.f9dbb4x{border-top-color:GrayText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f3qs60o{border-right-color:GrayText;}.f5u9ap2{border-left-color:GrayText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fwd1oij{border-bottom-color:GrayText;}}", { m: "(forced-colors: active)" }]
		]
	});
	/**
	* Apply styling to the PickerButton slots based on the state
	*/
	const useTagPickerButtonStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$30();
		state.root.className = mergeClasses(tagPickerButtonClassNames.root, styles.button, styles[state.size], state.hasSelectedOption && styles.visuallyHidden, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-tag-picker/lib/components/TagPickerButton/TagPickerButton.js
/**
	* TagPickerButton component -
	* A TagPickerButton is an alternative to TagPickerInput that does not include an input field.
	*/ const TagPickerButton = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useTagPickerButton_unstable(props, ref);
		useTagPickerButtonStyles_unstable(state);
		useCustomStyleHook("useTagPickerButtonStyles_unstable")(state);
		return renderTagPickerButton_unstable(state);
	});
	TagPickerButton.displayName = "TagPickerButton";

//#endregion
//#region node_modules/@fluentui/react-tag-picker/lib/utils/useResizeObserverRef.js
	const useResizeObserverRef = (callback) => {
		const { targetDocument } = useFluent();
		const [observer] = react.useState(() => {
			var _targetDocument_defaultView;
			const ResizeObserverConstructor = targetDocument === null || targetDocument === void 0 ? void 0 : (_targetDocument_defaultView = targetDocument.defaultView) === null || _targetDocument_defaultView === void 0 ? void 0 : _targetDocument_defaultView.ResizeObserver;
			if (ResizeObserverConstructor) return new ResizeObserverConstructor(callback);
		});
		return react.useCallback((element) => {
			if (element) observer === null || observer === void 0 || observer.observe(element);
			else observer === null || observer === void 0 || observer.disconnect();
		}, [observer]);
	};

//#endregion
//#region node_modules/@fluentui/react-tag-picker/lib/components/TagPickerControl/useTagPickerControlStyles.styles.js
	const tagPickerControlClassNames = {
		root: "fui-TagPickerControl",
		expandIcon: "fui-TagPickerControl__expandIcon",
		secondaryAction: "fui-TagPickerControl__secondaryAction",
		aside: "fui-TagPickerControl__aside"
	};
	const tagPickerControlAsideWidthToken = "--fui-TagPickerControl-aside-width";
	/**
	* Styles for the root slot
	*/
	const useStyles$29 = /* @__PURE__ */ __styles({
		root: {
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "ft85np5",
			z189sj: ["f1d8q41i", "f8lqu5g"],
			uwmqm3: ["f1uw59to", "fw5db7e"],
			Bt984gj: "f122n59",
			i8kkvl: "f14mj54c",
			B7ck84d: "f1ewtqcl",
			mc9l5x: "f22iagw",
			Bf4jedk: "f1exfvgq",
			qhf8xq: "f10pi13n",
			Eh141a: "fni485r",
			Bbr2w1p: "f14a1fxs",
			Bduesf4: "f3e99gv",
			Bpq79vn: "fhljsf7",
			li1rpt: "f1gw3sf2",
			Bsft5z2: "f13zj6fq",
			E3zdtr: "f1mdlcz9",
			Eqx8gd: ["f1a7op3", "f1cjjd47"],
			By385i5: "f1gboi2j",
			B1piin3: ["f1cjjd47", "f1a7op3"],
			Dlnsje: "f145g4dw",
			d9w3h3: ["f1kp91vd", "f1ibwz09"],
			B3778ie: ["f1ibwz09", "f1kp91vd"],
			B1q35kw: 0,
			Bw17bha: 0,
			Bcgy8vk: 0,
			Bjuhk93: "f1mnjydx",
			Gjdm7m: "f13evtba",
			b1kco5: "f1yk9hq",
			Ba2ppi3: "fhwpy7i",
			F2fol1: "f14ee0xe",
			lck23g: "f1xhbsuh",
			wi16st: "fsrmcvb",
			ywj3b2: "f1t3k7v9",
			umuwi5: "fjw5xc1",
			Blcqepd: "f1xdyd5c",
			nplu4u: "fatpbeo",
			Bioka5o: "fb7uyps",
			Bnupc0a: "fx04xgm",
			bing71: "f1c7in40",
			Bercvud: "f1ibeo51"
		},
		listbox: {
			E5pizo: "f1hg901r",
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "ft85np5",
			Bxyxcbc: "fmmk62d",
			B7ck84d: "f1ewtqcl"
		},
		listboxCollapsed: { mc9l5x: "fjseox" },
		medium: { sshi5w: "f1nxs5xn" },
		large: { sshi5w: "f1w5jphr" },
		"extra-large": { sshi5w: "f5pgtk9" },
		outline: {
			De3pzq: "fxugw4r",
			Bgfg5da: 0,
			B9xav0g: "f1c1zstj",
			oivjwe: 0,
			Bn0qgzm: 0,
			B4g9neb: 0,
			zhjwy3: 0,
			wvpqe5: 0,
			ibv6hh: 0,
			u1mtju: 0,
			h3c5rm: 0,
			vrafjx: 0,
			Bekrc4i: 0,
			i8vvqc: 0,
			g2u3we: 0,
			icvyot: 0,
			B4j52fo: 0,
			irswps: "fhz96rm"
		},
		outlineInteractive: {
			Bgoe8wy: "fvcxoqz",
			Bwzppfd: ["f1ub3y4t", "f1m52nbi"],
			oetu4i: "f1l4zc64",
			gg5e9n: ["f1m52nbi", "f1ub3y4t"],
			B6oc9vd: "fvs00aa",
			ak43y8: ["f1assf6x", "f4ruux4"],
			wmxk5l: "f1z0osm6",
			B50zh58: ["f4ruux4", "f1assf6x"],
			Bvq3b66: "f1b473iu",
			Brahy3i: ["f381qr8", "ft4skwv"],
			zoxjo1: "f1qzcrsd",
			an54nd: ["ft4skwv", "f381qr8"]
		},
		underline: {
			De3pzq: "f1c21dwh",
			B9xav0g: 0,
			oivjwe: 0,
			Bn0qgzm: 0,
			Bgfg5da: "f9ez7ne",
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "fokr779"
		},
		"filled-lighter": {
			De3pzq: "fxugw4r",
			Bgfg5da: 0,
			B9xav0g: 0,
			oivjwe: 0,
			Bn0qgzm: 0,
			B4g9neb: 0,
			zhjwy3: 0,
			wvpqe5: 0,
			ibv6hh: 0,
			u1mtju: 0,
			h3c5rm: 0,
			vrafjx: 0,
			Bekrc4i: 0,
			i8vvqc: 0,
			g2u3we: 0,
			icvyot: 0,
			B4j52fo: 0,
			irswps: "f88035w"
		},
		"filled-darker": {
			De3pzq: "f16xq7d1",
			Bgfg5da: 0,
			B9xav0g: 0,
			oivjwe: 0,
			Bn0qgzm: 0,
			B4g9neb: 0,
			zhjwy3: 0,
			wvpqe5: 0,
			ibv6hh: 0,
			u1mtju: 0,
			h3c5rm: 0,
			vrafjx: 0,
			Bekrc4i: 0,
			i8vvqc: 0,
			g2u3we: 0,
			icvyot: 0,
			B4j52fo: 0,
			irswps: "f88035w"
		},
		invalid: {
			tvckwq: "fs4k3qj",
			gk2u95: ["fcee079", "fmyw78r"],
			hhx65j: "f1fgmyf4",
			Bxowmz0: ["fmyw78r", "fcee079"]
		},
		invalidUnderline: { hhx65j: "f1fgmyf4" },
		disabled: {
			Bceei9c: "fdrzuqr",
			De3pzq: "f1c21dwh",
			g2u3we: "f1jj8ep1",
			h3c5rm: ["f15xbau", "fy0fskl"],
			B9xav0g: "f4ikngz",
			zhjwy3: ["fy0fskl", "f15xbau"],
			Bcq6wej: "f9dbb4x",
			Jcjdmf: ["f3qs60o", "f5u9ap2"],
			sc4o1m: "fwd1oij",
			Bosien3: ["f5u9ap2", "f3qs60o"]
		}
	}, {
		d: [
			[".ft85np5{border-radius:var(--borderRadiusMedium);}", { p: -1 }],
			".f1d8q41i{padding-right:calc(var(--spacingHorizontalM) + var(--fui-TagPickerControl-aside-width, 0px));}",
			".f8lqu5g{padding-left:calc(var(--spacingHorizontalM) + var(--fui-TagPickerControl-aside-width, 0px));}",
			".f1uw59to{padding-left:var(--spacingHorizontalM);}",
			".fw5db7e{padding-right:var(--spacingHorizontalM);}",
			".f122n59{align-items:center;}",
			".f14mj54c{column-gap:var(--spacingHorizontalXXS);}",
			".f1ewtqcl{box-sizing:border-box;}",
			".f22iagw{display:flex;}",
			".f1exfvgq{min-width:250px;}",
			".f10pi13n{position:relative;}",
			".fni485r{flex-wrap:wrap;}",
			".f1gw3sf2::after{box-sizing:border-box;}",
			".f13zj6fq::after{content:\"\";}",
			".f1mdlcz9::after{position:absolute;}",
			".f1a7op3::after{left:-1px;}",
			".f1cjjd47::after{right:-1px;}",
			".f1gboi2j::after{bottom:-1px;}",
			".f145g4dw::after{height:max(2px, var(--borderRadiusMedium));}",
			".f1kp91vd::after{border-bottom-left-radius:var(--borderRadiusMedium);}",
			".f1ibwz09::after{border-bottom-right-radius:var(--borderRadiusMedium);}",
			[".f1mnjydx::after{border-bottom:var(--strokeWidthThick) solid var(--colorCompoundBrandStroke);}", { p: -1 }],
			".f13evtba::after{clip-path:inset(calc(100% - 2px) 0 0 0);}",
			".f1yk9hq::after{transform:scaleX(0);}",
			".fhwpy7i::after{transition-property:transform;}",
			".f14ee0xe::after{transition-duration:var(--durationUltraFast);}",
			".f1xhbsuh::after{transition-delay:var(--curveAccelerateMid);}",
			".f1hg901r{box-shadow:var(--shadow16);}",
			[".ft85np5{border-radius:var(--borderRadiusMedium);}", { p: -1 }],
			".fmmk62d{max-height:80vh;}",
			".fjseox{display:none;}",
			".f1nxs5xn{min-height:32px;}",
			".f1w5jphr{min-height:40px;}",
			".f5pgtk9{min-height:44px;}",
			".fxugw4r{background-color:var(--colorNeutralBackground1);}",
			[".fhz96rm{border:var(--strokeWidthThin) solid var(--colorNeutralStroke1);}", { p: -2 }],
			".f1c1zstj{border-bottom-color:var(--colorNeutralStrokeAccessible);}",
			".f1c21dwh{background-color:var(--colorTransparentBackground);}",
			[".f9ez7ne{border-bottom:var(--strokeWidthThin) solid var(--colorNeutralStrokeAccessible);}", { p: -1 }],
			[".fokr779{border-radius:0;}", { p: -1 }],
			[".f88035w{border:var(--strokeWidthThin) solid var(--colorTransparentStroke);}", { p: -2 }],
			".f16xq7d1{background-color:var(--colorNeutralBackground3);}",
			[".f88035w{border:var(--strokeWidthThin) solid var(--colorTransparentStroke);}", { p: -2 }],
			".fs4k3qj:not(:focus-within),.fs4k3qj:hover:not(:focus-within){border-top-color:var(--colorPaletteRedBorder2);}",
			".fcee079:not(:focus-within),.fcee079:hover:not(:focus-within){border-right-color:var(--colorPaletteRedBorder2);}",
			".fmyw78r:not(:focus-within),.fmyw78r:hover:not(:focus-within){border-left-color:var(--colorPaletteRedBorder2);}",
			".f1fgmyf4:not(:focus-within),.f1fgmyf4:hover:not(:focus-within){border-bottom-color:var(--colorPaletteRedBorder2);}",
			".fdrzuqr{cursor:not-allowed;}",
			".f1jj8ep1{border-top-color:var(--colorNeutralStrokeDisabled);}",
			".f15xbau{border-right-color:var(--colorNeutralStrokeDisabled);}",
			".fy0fskl{border-left-color:var(--colorNeutralStrokeDisabled);}",
			".f4ikngz{border-bottom-color:var(--colorNeutralStrokeDisabled);}"
		],
		w: [
			".f14a1fxs:focus-within{outline-width:2px;}",
			".f3e99gv:focus-within{outline-style:solid;}",
			".fhljsf7:focus-within{outline-color:transparent;}",
			".fjw5xc1:focus-within::after{transform:scaleX(1);}",
			".f1xdyd5c:focus-within::after{transition-property:transform;}",
			".fatpbeo:focus-within::after{transition-duration:var(--durationNormal);}",
			".fb7uyps:focus-within::after{transition-delay:var(--curveDecelerateMid);}",
			".f1ibeo51:focus-within:active::after{border-bottom-color:var(--colorCompoundBrandStrokePressed);}",
			".f1b473iu:focus-within{border-top-color:var(--colorNeutralStroke1Pressed);}",
			".f381qr8:focus-within{border-right-color:var(--colorNeutralStroke1Pressed);}",
			".ft4skwv:focus-within{border-left-color:var(--colorNeutralStroke1Pressed);}",
			".f1qzcrsd:focus-within{border-bottom-color:var(--colorNeutralStrokeAccessiblePressed);}"
		],
		m: [
			["@media screen and (prefers-reduced-motion: reduce){.fsrmcvb::after{transition-duration:0.01ms;}}", { m: "screen and (prefers-reduced-motion: reduce)" }],
			["@media screen and (prefers-reduced-motion: reduce){.f1t3k7v9::after{transition-delay:0.01ms;}}", { m: "screen and (prefers-reduced-motion: reduce)" }],
			["@media screen and (prefers-reduced-motion: reduce){.fx04xgm:focus-within::after{transition-duration:0.01ms;}}", { m: "screen and (prefers-reduced-motion: reduce)" }],
			["@media screen and (prefers-reduced-motion: reduce){.f1c7in40:focus-within::after{transition-delay:0.01ms;}}", { m: "screen and (prefers-reduced-motion: reduce)" }],
			["@media (forced-colors: active){.f9dbb4x{border-top-color:GrayText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f3qs60o{border-right-color:GrayText;}.f5u9ap2{border-left-color:GrayText;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fwd1oij{border-bottom-color:GrayText;}}", { m: "(forced-colors: active)" }]
		],
		h: [
			".fvcxoqz:hover{border-top-color:var(--colorNeutralStroke1Hover);}",
			".f1ub3y4t:hover{border-right-color:var(--colorNeutralStroke1Hover);}",
			".f1m52nbi:hover{border-left-color:var(--colorNeutralStroke1Hover);}",
			".f1l4zc64:hover{border-bottom-color:var(--colorNeutralStrokeAccessibleHover);}"
		],
		a: [
			".fvs00aa:active{border-top-color:var(--colorNeutralStroke1Pressed);}",
			".f1assf6x:active{border-right-color:var(--colorNeutralStroke1Pressed);}",
			".f4ruux4:active{border-left-color:var(--colorNeutralStroke1Pressed);}",
			".f1z0osm6:active{border-bottom-color:var(--colorNeutralStrokeAccessiblePressed);}"
		]
	});
	const useAsideStyles = /* @__PURE__ */ __styles({
		root: {
			mc9l5x: "f22iagw",
			qhf8xq: "f1euv43f",
			Bhzewxz: "f15twtuk",
			j35jbq: ["f8b87gs", "fedtrts"],
			Bqenvij: "f1l02sjl",
			Bceei9c: "f113hnb5"
		},
		medium: { sshi5w: "f1nxs5xn" },
		large: { sshi5w: "f1w5jphr" },
		"extra-large": { sshi5w: "f5pgtk9" }
	}, { d: [
		".f22iagw{display:flex;}",
		".f1euv43f{position:absolute;}",
		".f15twtuk{top:0;}",
		".f8b87gs{right:var(--spacingHorizontalM);}",
		".fedtrts{left:var(--spacingHorizontalM);}",
		".f1l02sjl{height:100%;}",
		".f113hnb5{cursor:text;}",
		".f1nxs5xn{min-height:32px;}",
		".f1w5jphr{min-height:40px;}",
		".f5pgtk9{min-height:44px;}"
	] });
	const useIconStyles$2 = /* @__PURE__ */ __styles({
		icon: {
			B7ck84d: "f1ewtqcl",
			sj55zd: "fxkbij4",
			Bceei9c: "f1k6fduh",
			mc9l5x: "f22iagw",
			Brf1p80: "f4d9j23",
			Bt984gj: "f122n59",
			qb2dma: "fjgzulp",
			Be2twd7: "f1pp30po",
			Bo70h7d: "fvc9v3g"
		},
		medium: {
			Be2twd7: "f4ybsrx",
			Frg6f3: ["f1h9en5y", "f1xk557c"],
			sshi5w: "f1nxs5xn"
		},
		large: {
			Be2twd7: "fe5j1ua",
			Frg6f3: ["f1h9en5y", "f1xk557c"],
			sshi5w: "f1w5jphr"
		},
		"extra-large": {
			Be2twd7: "f1rt2boy",
			Frg6f3: ["f1t5qyk5", "f1ikr372"],
			sshi5w: "f5pgtk9"
		},
		disabled: {
			sj55zd: "f1s2aq7o",
			Bceei9c: "fdrzuqr"
		}
	}, { d: [
		".f1ewtqcl{box-sizing:border-box;}",
		".fxkbij4{color:var(--colorNeutralStrokeAccessible);}",
		".f1k6fduh{cursor:pointer;}",
		".f22iagw{display:flex;}",
		".f4d9j23{justify-content:center;}",
		".f122n59{align-items:center;}",
		".fjgzulp{align-self:flex-start;}",
		".f1pp30po{font-size:var(--fontSizeBase500);}",
		".fvc9v3g svg{display:block;}",
		".f4ybsrx{font-size:16px;}",
		".f1h9en5y{margin-left:var(--spacingHorizontalXXS);}",
		".f1xk557c{margin-right:var(--spacingHorizontalXXS);}",
		".f1nxs5xn{min-height:32px;}",
		".fe5j1ua{font-size:20px;}",
		".f1w5jphr{min-height:40px;}",
		".f1rt2boy{font-size:24px;}",
		".f1t5qyk5{margin-left:var(--spacingHorizontalSNudge);}",
		".f1ikr372{margin-right:var(--spacingHorizontalSNudge);}",
		".f5pgtk9{min-height:44px;}",
		".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}",
		".fdrzuqr{cursor:not-allowed;}"
	] });
	const useSecondaryActionStyles = /* @__PURE__ */ __styles({ root: { mc9l5x: "f22iagw" } }, { d: [".f22iagw{display:flex;}"] });
	/**
	* Apply styling to the PickerControl slots based on the state
	*/
	const useTagPickerControlStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$29();
		const iconStyles = useIconStyles$2();
		const asideStyles = useAsideStyles();
		const secondaryActionStyles = useSecondaryActionStyles();
		state.root.className = mergeClasses(tagPickerControlClassNames.root, styles.root, styles[state.size], styles[state.appearance], !state.disabled && state.appearance === "outline" && styles.outlineInteractive, state.invalid && state.appearance !== "underline" && styles.invalid, state.invalid && state.appearance === "underline" && styles.invalidUnderline, state.disabled && styles.disabled, state.root.className);
		if (state.aside) state.aside.className = mergeClasses(tagPickerControlClassNames.aside, asideStyles.root, asideStyles[state.size], state.aside.className);
		if (state.expandIcon) state.expandIcon.className = mergeClasses(tagPickerControlClassNames.expandIcon, iconStyles.icon, iconStyles[state.size], state.disabled && iconStyles.disabled, state.expandIcon.className);
		if (state.secondaryAction) state.secondaryAction.className = mergeClasses(tagPickerControlClassNames.secondaryAction, secondaryActionStyles.root, state.secondaryAction.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-tag-picker/lib/utils/useExpandLabel.js
	function useExpandLabel(options) {
		const { tagPickerId, state } = options;
		const { targetDocument } = useFluent();
		const triggerRef = useTagPickerContext_unstable((ctx) => ctx.triggerRef);
		const expandIconRef = react.useRef(null);
		const hasExpandIcon = !!state.expandIcon;
		const { "aria-label": expandIconAriaLabel, "aria-labelledby": expandIconAriaLabelledby, id: expandIconId } = state.expandIcon || {};
		const getExpandLabel = react.useCallback((ariaLabel, ariaLabelledBy) => {
			let expandAriaLabel = void 0;
			let expandAriaLabelledBy = void 0;
			let expandId = void 0;
			if (hasExpandIcon) {
				const hasExpandLabel = expandIconAriaLabel || expandIconAriaLabelledby;
				const defaultOpenString = "Open";
				if (!hasExpandLabel) if (ariaLabelledBy) {
					expandAriaLabel = defaultOpenString;
					expandId = expandIconId !== null && expandIconId !== void 0 ? expandIconId : `${tagPickerId}-chevron`;
					expandAriaLabelledBy = `${expandId} ${ariaLabelledBy}`;
				} else if (ariaLabel) expandAriaLabel = `${defaultOpenString} ${ariaLabel}`;
				else expandAriaLabel = defaultOpenString;
			}
			return {
				expandAriaLabel,
				expandAriaLabelledBy,
				expandId
			};
		}, [
			expandIconAriaLabel,
			expandIconAriaLabelledby,
			expandIconId,
			hasExpandIcon,
			tagPickerId
		]);
		const setExpandLabel = react.useCallback(() => {
			var _triggerRef_current, _triggerRef_current1;
			const { expandAriaLabel, expandAriaLabelledBy, expandId } = getExpandLabel((_triggerRef_current = triggerRef.current) === null || _triggerRef_current === void 0 ? void 0 : _triggerRef_current.getAttribute("aria-label"), (_triggerRef_current1 = triggerRef.current) === null || _triggerRef_current1 === void 0 ? void 0 : _triggerRef_current1.getAttribute("aria-labelledby"));
			if (expandAriaLabelledBy) {
				var _expandIconRef_current;
				(_expandIconRef_current = expandIconRef.current) === null || _expandIconRef_current === void 0 || _expandIconRef_current.setAttribute("aria-labelledby", expandAriaLabelledBy);
			}
			if (expandAriaLabel) {
				var _expandIconRef_current1;
				(_expandIconRef_current1 = expandIconRef.current) === null || _expandIconRef_current1 === void 0 || _expandIconRef_current1.setAttribute("aria-label", expandAriaLabel);
			}
			if (expandId) {
				var _expandIconRef_current2;
				(_expandIconRef_current2 = expandIconRef.current) === null || _expandIconRef_current2 === void 0 || _expandIconRef_current2.setAttribute("id", expandId);
			}
		}, [getExpandLabel, triggerRef]);
		react.useEffect(() => {
			const hasExpandLabel = expandIconAriaLabel || expandIconAriaLabelledby;
			if (!(targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView) || !triggerRef.current || !hasExpandIcon || hasExpandLabel) return;
			const win = targetDocument.defaultView;
			setExpandLabel();
			const observer = new win.MutationObserver(setExpandLabel);
			observer.observe(triggerRef.current, {
				attributes: true,
				attributeFilter: ["aria-label", "aria-labelledby"]
			});
			return () => observer.disconnect();
		}, [
			getExpandLabel,
			setExpandLabel,
			expandIconAriaLabel,
			expandIconAriaLabelledby,
			hasExpandIcon,
			tagPickerId,
			triggerRef,
			targetDocument
		]);
		return expandIconRef;
	}

//#endregion
//#region node_modules/@fluentui/react-tag-picker/lib/components/TagPickerControl/useTagPickerControl.js
/**
	* Create the state required to render PickerControl.
	*
	* The returned state can be modified with hooks such as usePickerControlStyles_unstable,
	* before being passed to renderPickerControl_unstable.
	*
	* @param props - props from this instance of PickerControl
	* @param ref - reference to root HTMLDivElement of PickerControl
	*/ const useTagPickerControl_unstable = (props, ref) => {
		var _useFieldContext_unstable;
		const targetRef = useTagPickerContext_unstable((ctx) => ctx.targetRef);
		const triggerRef = useTagPickerContext_unstable((ctx) => ctx.triggerRef);
		const tagPickerGroupRef = useTagPickerContext_unstable((ctx) => ctx.tagPickerGroupRef);
		const open = useTagPickerContext_unstable((ctx) => ctx.open);
		const popoverId = useTagPickerContext_unstable((ctx) => ctx.popoverId);
		const setOpen = useTagPickerContext_unstable((ctx) => ctx.setOpen);
		const secondaryInnerActionRef = useTagPickerContext_unstable((ctx) => ctx.secondaryActionRef);
		const size$2 = useTagPickerContext_unstable((ctx) => ctx.size);
		const appearance = useTagPickerContext_unstable((ctx) => ctx.appearance);
		const disabled = useTagPickerContext_unstable((ctx) => ctx.disabled);
		const invalid = ((_useFieldContext_unstable = useFieldContext_unstable()) === null || _useFieldContext_unstable === void 0 ? void 0 : _useFieldContext_unstable.validationState) === "error";
		const noPopover = useTagPickerContext_unstable((ctx) => {
			var _ctx_noPopover;
			return (_ctx_noPopover = ctx.noPopover) !== null && _ctx_noPopover !== void 0 ? _ctx_noPopover : false;
		});
		const { targetDocument } = useFluent();
		const tagPickerId = useId("tagPicker-");
		const rafIdRef = react.useRef(null);
		const innerRef = react.useRef(null);
		const expandIconRef = react.useRef(null);
		const asideRef = react.useRef(null);
		const secondaryAction = optional(props.secondaryAction, { elementType: "span" });
		const secondaryActionRef = useMergedRefs(secondaryInnerActionRef, secondaryAction === null || secondaryAction === void 0 ? void 0 : secondaryAction.ref);
		if (secondaryAction) secondaryAction.ref = secondaryActionRef;
		const expandIcon = optional(props.expandIcon, {
			renderByDefault: !noPopover,
			defaultProps: {
				"aria-expanded": open,
				"aria-disabled": disabled ? "true" : void 0,
				children: /* @__PURE__ */ react.createElement(ChevronDownRegular, null),
				role: "button"
			},
			elementType: "span"
		});
		const expandIconMergeRef = useMergedRefs(expandIcon === null || expandIcon === void 0 ? void 0 : expandIcon.ref, expandIconRef);
		if (expandIcon) expandIcon.ref = expandIconMergeRef;
		const observerRef = useResizeObserverRef(([entry]) => {
			const targetWindow = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView;
			if (targetWindow) rafIdRef.current = targetWindow.requestAnimationFrame(() => {
				var _innerRef_current;
				(_innerRef_current = innerRef.current) === null || _innerRef_current === void 0 || _innerRef_current.style.setProperty(tagPickerControlAsideWidthToken, `${entry.contentRect.width}px`);
			});
		});
		const aside = optional(void 0, {
			elementType: "span",
			renderByDefault: Boolean(secondaryAction || expandIcon),
			defaultProps: { ref: observerRef }
		});
		const mergedAsideRefs = useMergedRefs(asideRef, aside === null || aside === void 0 ? void 0 : aside.ref);
		if (aside) aside.ref = mergedAsideRefs;
		const handleMouseDown = useEventCallback((event) => {
			if (event.isDefaultPrevented()) return;
			if (elementContains(expandIconRef.current, event.target) || event.target === innerRef.current || event.target === tagPickerGroupRef.current || event.target === asideRef.current) {
				var _triggerRef_current;
				event.preventDefault();
				setOpen(event, !open);
				(_triggerRef_current = triggerRef.current) === null || _triggerRef_current === void 0 || _triggerRef_current.focus();
			}
		});
		const state = {
			components: {
				root: "div",
				expandIcon: "span",
				secondaryAction: "span",
				aside: "span"
			},
			root: always(getIntrinsicElementProps("div", {
				ref: useMergedRefs(ref, targetRef, innerRef),
				"aria-owns": open && !noPopover ? popoverId : void 0,
				...props,
				onMouseDown: handleMouseDown
			}), { elementType: "div" }),
			aside,
			expandIcon,
			secondaryAction,
			size: size$2,
			appearance,
			disabled,
			invalid
		};
		const expandIconLabelRef = useExpandLabel({
			tagPickerId,
			state
		});
		const expandIconLabelMergeRef = useMergedRefs(expandIcon === null || expandIcon === void 0 ? void 0 : expandIcon.ref, expandIconLabelRef);
		if (state.expandIcon) state.expandIcon.ref = expandIconLabelMergeRef;
		react.useEffect(() => {
			if (rafIdRef.current && (targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView)) targetDocument.defaultView.cancelAnimationFrame(rafIdRef.current);
		}, [targetDocument]);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-tag-picker/lib/components/TagPickerControl/renderTagPickerControl.js
/**
	* Render the final JSX of PickerControl
	*/ const renderTagPickerControl_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(state.root, { children: [state.root.children, state.aside && /* @__PURE__ */ jsxs(state.aside, { children: [state.secondaryAction && /* @__PURE__ */ jsx(state.secondaryAction, {}), state.expandIcon && /* @__PURE__ */ jsx(state.expandIcon, {})] })] });
	};

//#endregion
//#region node_modules/@fluentui/react-tag-picker/lib/components/TagPickerControl/TagPickerControl.js
/**
	* TagPickerControl component -
	* A TagPickerControl is a composite component that controls actions and state for a TagPicker.
	*/ const TagPickerControl = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useTagPickerControl_unstable(props, ref);
		useTagPickerControlStyles_unstable(state);
		useCustomStyleHook("useTagPickerControlStyles_unstable")(state);
		return renderTagPickerControl_unstable(state);
	});
	TagPickerControl.displayName = "TagPickerControl";

//#endregion
//#region node_modules/@fluentui/react-tag-picker/lib/components/TagPickerOption/useTagPickerOption.js
/**
	* Create the state required to render TagPickerOption.
	*
	* The returned state can be modified with hooks such as useTagPickerOptionStyles_unstable,
	* before being passed to renderTagPickerOption_unstable.
	*
	* @param props - props from this instance of TagPickerOption
	* @param ref - reference to root HTMLDivElement of TagPickerOption
	*/ const useTagPickerOption_unstable = (props, ref) => {
		const optionState = useOption_unstable(props, ref);
		return {
			components: {
				...optionState.components,
				media: "div",
				secondaryContent: "span"
			},
			media: optional(props.media, { elementType: "div" }),
			secondaryContent: optional(props.secondaryContent, { elementType: "span" }),
			root: always({
				...optionState.root,
				role: "option",
				"aria-checked": props["aria-checked"]
			}, { elementType: "div" })
		};
	};

//#endregion
//#region node_modules/@fluentui/react-tag-picker/lib/components/TagPickerOption/renderTagPickerOption.js
/**
	* Render the final JSX of TagPickerOption
	*/ const renderTagPickerOption_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(state.root, { children: [
			state.media && /* @__PURE__ */ jsx(state.media, {}),
			state.root.children,
			state.secondaryContent && /* @__PURE__ */ jsx(state.secondaryContent, {})
		] });
	};

//#endregion
//#region node_modules/@fluentui/react-tag-picker/lib/components/TagPickerOption/useTagPickerOptionStyles.styles.js
	const tagPickerOptionClassNames = {
		root: "fui-TagPickerOption",
		media: "fui-TagPickerOption__media",
		secondaryContent: "fui-TagPickerOption__secondaryContent"
	};
	const useRootBaseStyle = /* @__PURE__ */ __resetStyles("r70qvj9", null, [".r70qvj9{display:flex;align-items:center;}"]);
	const useRootStyles$3 = /* @__PURE__ */ __styles({ secondaryContent: {
		mc9l5x: "f13qh94s",
		Budl1dq: "fjxzuw"
	} }, { d: [".f13qh94s{display:grid;}", ".fjxzuw{grid-template-columns:auto 1fr;}"] });
	const useSecondaryContentBaseStyle = /* @__PURE__ */ __resetStyles("r131qrbm", null, [".r131qrbm{grid-column-start:2;grid-row-start:2;font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase200);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase200);}"]);
	const useMediaBaseStyle = /* @__PURE__ */ __resetStyles("rrip69g", null, [".rrip69g{grid-row-start:span 2;}"]);
	/**
	* Apply styling to the TagPickerOption slots based on the state
	*/
	const useTagPickerOptionStyles_unstable = (state) => {
		"use no memo";
		const rootBaseStyle = useRootBaseStyle();
		const rootStyles = useRootStyles$3();
		const secondaryContentBaseStyle = useSecondaryContentBaseStyle();
		const mediaBaseStyle = useMediaBaseStyle();
		state.root.className = mergeClasses(tagPickerOptionClassNames.root, rootBaseStyle, state.secondaryContent && rootStyles.secondaryContent, state.root.className);
		useOptionStyles_unstable({
			...state,
			active: false,
			disabled: false,
			focusVisible: false,
			checkIcon: void 0,
			selected: false
		});
		if (state.media) state.media.className = mergeClasses(tagPickerOptionClassNames.media, mediaBaseStyle, state.media.className);
		if (state.secondaryContent) state.secondaryContent.className = mergeClasses(tagPickerOptionClassNames.secondaryContent, secondaryContentBaseStyle, state.secondaryContent.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-tag-picker/lib/components/TagPickerOption/TagPickerOption.js
/**
	* TagPickerOption component -
	* A TagPickerOption is a composite component that allows users to select tags.
	*/ const TagPickerOption = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useTagPickerOption_unstable(props, ref);
		useTagPickerOptionStyles_unstable(state);
		useCustomStyleHook("useTagPickerOptionStyles_unstable")(state);
		return renderTagPickerOption_unstable(state);
	});
	TagPickerOption.displayName = "TagPickerOption";

//#endregion
//#region node_modules/@fluentui/react-tag-picker/lib/utils/tagPicker2Tag.js
	function tagPickerSizeToTagSize(size$2) {
		switch (size$2) {
			case "medium": return "extra-small";
			case "large": return "small";
			case "extra-large": return "medium";
			default: return "extra-small";
		}
	}
	function tagSizeToTagPickerSize(size$2) {
		switch (size$2) {
			case "extra-small": return "medium";
			case "small": return "large";
			case "medium": return "extra-large";
			default: return "medium";
		}
	}
	function tagPickerAppearanceToTagAppearance(appearance) {
		switch (appearance) {
			case "filled-darker": return "outline";
			default: return "filled";
		}
	}

//#endregion
//#region node_modules/@fluentui/react-tag-picker/lib/components/TagPickerGroup/useTagPickerGroup.js
/**
	* Create the state required to render TagPickerGroup.
	*
	* The returned state can be modified with hooks such as usePickerTagGroupStyles_unstable,
	* before being passed to renderPickerTagGroup_unstable.
	*
	* @param props - props from this instance of TagPickerGroup
	* @param ref - reference to root HTMLDivElement of TagPickerGroup
	*/ const useTagPickerGroup_unstable = (props, ref) => {
		const hasSelectedOptions = useTagPickerContext_unstable((ctx) => ctx.selectedOptions.length > 0);
		const hasOneSelectedOption = useTagPickerContext_unstable((ctx) => ctx.selectedOptions.length === 1);
		const triggerRef = useTagPickerContext_unstable((ctx) => ctx.triggerRef);
		const tagPickerGroupRef = useTagPickerContext_unstable((ctx) => ctx.tagPickerGroupRef);
		const selectOption = useTagPickerContext_unstable((ctx) => ctx.selectOption);
		const size$2 = useTagPickerContext_unstable((ctx) => tagPickerSizeToTagSize(ctx.size));
		const appearance = useTagPickerContext_unstable((ctx) => ctx.appearance);
		const disabled = useTagPickerContext_unstable((ctx) => ctx.disabled);
		const arrowNavigationProps = useArrowNavigationGroup({
			circular: false,
			axis: "both",
			memorizeCurrent: true
		});
		return {
			...useTagGroup_unstable({
				role: "listbox",
				disabled,
				...props,
				...arrowNavigationProps,
				size: size$2,
				appearance: tagPickerAppearanceToTagAppearance(appearance),
				dismissible: true,
				onKeyDown: useEventCallback((event) => {
					var _props_onKeyDown;
					(_props_onKeyDown = props.onKeyDown) === null || _props_onKeyDown === void 0 || _props_onKeyDown.call(props, event);
					if (isHTMLElement(event.target) && event.key === ArrowRight) {
						var _triggerRef_current;
						(_triggerRef_current = triggerRef.current) === null || _triggerRef_current === void 0 || _triggerRef_current.focus();
					}
				}),
				onDismiss: useEventCallback((event, data) => {
					selectOption(event, {
						value: data.value,
						id: "ERROR_DO_NOT_USE",
						text: "ERROR_DO_NOT_USE"
					});
					if (hasOneSelectedOption && !event.isDefaultPrevented()) {
						var _triggerRef_current;
						(_triggerRef_current = triggerRef.current) === null || _triggerRef_current === void 0 || _triggerRef_current.focus();
					}
				})
			}, useMergedRefs(ref, tagPickerGroupRef)),
			hasSelectedOptions
		};
	};

//#endregion
//#region node_modules/@fluentui/react-tag-picker/lib/components/TagPickerGroup/renderTagPickerGroup.js
	function renderTagPickerGroup_unstable(state, contexts) {
		if (!state.hasSelectedOptions) return null;
		return renderTagGroup_unstable(state, contexts);
	}

//#endregion
//#region node_modules/@fluentui/react-tag-picker/lib/components/TagPickerGroup/useTagPickerGroupStyles.styles.js
	const tagPickerGroupClassNames = { root: "fui-TagPickerGroup" };
	/**
	* Styles for the root slot
	*/
	const useStyles$28 = /* @__PURE__ */ __styles({
		root: {
			Eh141a: "fni485r",
			B7ck84d: "f1ewtqcl",
			Bceei9c: "f113hnb5"
		},
		medium: {
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "fa2pw7h",
			i8kkvl: 0,
			Belr9w4: 0,
			rmohyg: "fkln5zr"
		},
		large: {
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "fc0zr7g",
			i8kkvl: 0,
			Belr9w4: 0,
			rmohyg: "f1eyhf9v"
		},
		"extra-large": {
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "fc0zr7g",
			i8kkvl: 0,
			Belr9w4: 0,
			rmohyg: "f1eyhf9v"
		}
	}, { d: [
		".fni485r{flex-wrap:wrap;}",
		".f1ewtqcl{box-sizing:border-box;}",
		".f113hnb5{cursor:text;}",
		[".fa2pw7h{padding:var(--spacingVerticalSNudge) 0 var(--spacingVerticalSNudge) 0;}", { p: -1 }],
		[".fkln5zr{gap:var(--spacingHorizontalXS);}", { p: -1 }],
		[".fc0zr7g{padding:var(--spacingVerticalS) 0 var(--spacingVerticalS) 0;}", { p: -1 }],
		[".f1eyhf9v{gap:var(--spacingHorizontalSNudge);}", { p: -1 }],
		[".fc0zr7g{padding:var(--spacingVerticalS) 0 var(--spacingVerticalS) 0;}", { p: -1 }],
		[".f1eyhf9v{gap:var(--spacingHorizontalSNudge);}", { p: -1 }]
	] });
	/**
	* Apply styling to the TagPickerGroup slots based on the state
	*/
	const useTagPickerGroupStyles_unstable = (state) => {
		"use no memo";
		useTagGroupStyles_unstable(state);
		const styles = useStyles$28();
		state.root.className = mergeClasses(tagPickerGroupClassNames.root, styles[tagSizeToTagPickerSize(state.size)], styles.root, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-tag-picker/lib/components/TagPickerGroup/TagPickerGroup.js
/**
	* TagPickerGroup component -
	* A TagPickerGroup is a composite component that allows users to group tags together.
	*/ const TagPickerGroup = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useTagPickerGroup_unstable(props, ref);
		useTagPickerGroupStyles_unstable(state);
		useCustomStyleHook("useTagPickerGroupStyles_unstable")(state);
		return renderTagPickerGroup_unstable(state, useTagGroupContextValues_unstable(state));
	});
	TagPickerGroup.displayName = "TagPickerGroup";

//#endregion
//#region node_modules/@fluentui/react-tag-picker/lib/components/TagPickerOptionGroup/useTagPickerOptionGroup.js
/**
	* Create the state required to render TagPickerOptionGroup.
	*
	* The returned state can be modified with hooks such as useTagPickerOptionGroupStyles_unstable,
	* before being passed to renderTagPickerOptionGroup_unstable.
	*
	* @param props - props from this instance of TagPickerOptionGroup
	* @param ref - reference to root HTMLDivElement of TagPickerOptionGroup
	*/ const useTagPickerOptionGroup = useOptionGroup_unstable;

//#endregion
//#region node_modules/@fluentui/react-tag-picker/lib/components/TagPickerOptionGroup/renderTagPickerOptionGroup.js
/**
	* Render the final JSX of TagPickerOptionGroup
	*/ const renderTagPickerOptionGroup = renderOptionGroup_unstable;

//#endregion
//#region node_modules/@fluentui/react-tag-picker/lib/components/TagPickerOptionGroup/useTagPickerOptionGroupStyles.styles.js
	const tagPickerOptionGroupClassNames = {
		root: "fui-TagPickerOptionGroup",
		label: "fui-TagPickerOptionGroup__label"
	};
	/**
	* Apply styling to the TagPickerOptionGroup slots based on the state
	*/
	const useTagPickerOptionGroupStyles = (state) => {
		"use no memo";
		useOptionGroupStyles_unstable(state);
		state.root.className = mergeClasses(tagPickerOptionGroupClassNames.root, state.root.className);
		if (state.label) state.label.className = mergeClasses(tagPickerOptionGroupClassNames.label, state.label.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-tag-picker/lib/components/TagPickerOptionGroup/TagPickerOptionGroup.js
/**
	* TagPickerOptionGroup component -
	* A TagPickerOptionGroup is a composite component that allows users to group TagPickerOptions.
	*/ const TagPickerOptionGroup = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useTagPickerOptionGroup(props, ref);
		useTagPickerOptionGroupStyles(state);
		useCustomStyleHook("useTagPickerOptionGroupStyles_unstable")(state);
		return renderTagPickerOptionGroup(state);
	});
	TagPickerOptionGroup.displayName = "TagPickerOptionGroup";

//#endregion
//#region node_modules/@fluentui/react-tag-picker/lib/utils/useTagPickerFilter.js
	function defaultRenderOption(option) {
		return /* @__PURE__ */ react.createElement(TagPickerOption, {
			value: option,
			key: option
		}, option);
	}
	function useTagPickerFilter({ filter: filterOverride, noOptionsElement, renderOption = defaultRenderOption, query, options }) {
		const defaultFilter$1 = react.useCallback((option) => {
			const trimmedQuery = query.trim();
			if (trimmedQuery === "") return true;
			return option.toLowerCase().includes(trimmedQuery.toLowerCase());
		}, [query]);
		const filter = filterOverride !== null && filterOverride !== void 0 ? filterOverride : defaultFilter$1;
		const filteredOptions = react.useMemo(() => options.reduce((accumulator, option, index) => {
			if (filter(option, index)) accumulator.push(renderOption(option));
			return accumulator;
		}, []), [
			options,
			renderOption,
			filter
		]);
		return filteredOptions.length === 0 ? [noOptionsElement.key ? noOptionsElement : /* @__PURE__ */ react.cloneElement(noOptionsElement, { key: "no-options" })] : filteredOptions;
	}

//#endregion
//#region node_modules/@fluentui/react-swatch-picker/lib/components/SwatchPicker/useSwatchPicker.js
/**
	* Create the state required to render SwatchPicker.
	*
	* The returned state can be modified with hooks such as useSwatchPickerStyles_unstable,
	* before being passed to renderSwatchPicker_unstable.
	*
	* @param props - props from this instance of SwatchPicker
	* @param ref - reference to root HTMLElement of SwatchPicker
	*/ const useSwatchPicker_unstable = (props, ref) => {
		props = useFieldControlProps_unstable(props);
		const { layout, onSelectionChange, size: size$2 = "medium", shape, spacing = "medium", style, ...rest } = props;
		const isGrid = layout === "grid";
		const focusAttributes = useArrowNavigationGroup({
			circular: true,
			axis: isGrid ? "grid-linear" : "both",
			memorizeCurrent: true
		});
		const role = isGrid ? "grid" : "radiogroup";
		const [selectedValue, setSelectedValue] = useControllableState({
			state: props.selectedValue,
			defaultState: props.defaultSelectedValue,
			initialState: ""
		});
		const requestSelectionChange = useEventCallback((event, data) => {
			onSelectionChange === null || onSelectionChange === void 0 || onSelectionChange(event, {
				type: "click",
				event,
				selectedValue: data.selectedValue,
				selectedSwatch: data.selectedSwatch
			});
			setSelectedValue(data.selectedValue);
		});
		return {
			components: { root: "div" },
			root: always(getIntrinsicElementProps("div", {
				ref,
				role,
				...focusAttributes,
				...rest
			}), { elementType: "div" }),
			isGrid,
			requestSelectionChange,
			selectedValue,
			size: size$2,
			shape,
			spacing
		};
	};

//#endregion
//#region node_modules/@fluentui/react-swatch-picker/lib/contexts/swatchPicker.js
	const useSwatchPickerContextValues = (state) => {
		const { isGrid, size: size$2, shape, spacing, requestSelectionChange, selectedValue } = state;
		return { swatchPicker: {
			isGrid,
			size: size$2,
			shape,
			spacing,
			selectedValue,
			requestSelectionChange
		} };
	};
	const swatchPickerContextDefaultValue = {
		requestSelectionChange: () => {},
		isGrid: false,
		size: "medium",
		shape: "square",
		spacing: "medium",
		selectedValue: void 0
	};
	const SwatchPickerContext = createContext(void 0);
	const SwatchPickerProvider = SwatchPickerContext.Provider;
	const useSwatchPickerContextValue_unstable = (selector) => useContextSelector(SwatchPickerContext, (ctx = swatchPickerContextDefaultValue) => selector(ctx));

//#endregion
//#region node_modules/@fluentui/react-swatch-picker/lib/components/SwatchPicker/renderSwatchPicker.js
/**
	* Render the final JSX of SwatchPicker
	*/ const renderSwatchPicker_unstable = (state, contextValues) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(SwatchPickerProvider, {
			value: contextValues.swatchPicker,
			children: /* @__PURE__ */ jsx(state.root, { children: state.root.children })
		});
	};

//#endregion
//#region node_modules/@fluentui/react-swatch-picker/lib/components/SwatchPicker/useSwatchPickerStyles.styles.js
	const swatchPickerClassNames = { root: "fui-SwatchPicker" };
	/**
	* Styles for the root slot
	*/
	const useStyles$27 = /* @__PURE__ */ __styles({
		root: {
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f14ufcw5",
			mc9l5x: "f22iagw"
		},
		row: { Beiy3e4: "f1063pyq" },
		grid: { Beiy3e4: "f1vx9l62" },
		spacingSmall: {
			i8kkvl: 0,
			Belr9w4: 0,
			rmohyg: "f1t6b6ee"
		},
		spacingMedium: {
			i8kkvl: 0,
			Belr9w4: 0,
			rmohyg: "f4xv25i"
		}
	}, { d: [
		[".f14ufcw5{padding:var(--spacingHorizontalNone) var(--spacingVerticalNone);}", { p: -1 }],
		".f22iagw{display:flex;}",
		".f1063pyq{flex-direction:row;}",
		".f1vx9l62{flex-direction:column;}",
		[".f1t6b6ee{gap:2px;}", { p: -1 }],
		[".f4xv25i{gap:4px;}", { p: -1 }]
	] });
	/**
	* Apply styling to the SwatchPicker slots based on the state
	*/
	const useSwatchPickerStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$27();
		const layoutStyle = state.isGrid ? styles.grid : styles.row;
		const spacingStyle = state.spacing === "small" ? styles.spacingSmall : styles.spacingMedium;
		state.root.className = mergeClasses(swatchPickerClassNames.root, styles.root, layoutStyle, spacingStyle, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-swatch-picker/lib/components/SwatchPicker/SwatchPicker.js
/**
	* SwatchPicker component - TODO: add more docs
	*/ const SwatchPicker = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useSwatchPicker_unstable(props, ref);
		const contextValues = useSwatchPickerContextValues(state);
		useSwatchPickerStyles_unstable(state);
		useCustomStyleHook("useSwatchPickerStyles_unstable")(state);
		return renderSwatchPicker_unstable(state, contextValues);
	});
	SwatchPicker.displayName = "SwatchPicker";

//#endregion
//#region node_modules/@fluentui/react-swatch-picker/lib/components/ColorSwatch/useColorSwatchStyles.styles.js
	const colorSwatchClassNames = {
		root: "fui-ColorSwatch",
		icon: "fui-ColorSwatch__icon",
		disabledIcon: "fui-ColorSwatch__disabledIcon"
	};
	const swatchCSSVars = {
		color: `--fui-SwatchPicker--color`,
		borderColor: `--fui-SwatchPicker--borderColor`
	};
	const { color, borderColor } = swatchCSSVars;
	/**
	* Styles for the root slot
	*/
	const useResetStyles$1 = /* @__PURE__ */ __resetStyles("ryw27oi", null, {
		r: [
			".ryw27oi{display:inline-flex;flex-shrink:0;align-items:center;justify-content:center;box-sizing:border-box;border:1px solid var(--fui-SwatchPicker--borderColor);background:var(--fui-SwatchPicker--color);overflow:hidden;padding:0;}",
			".ryw27oi:hover{cursor:pointer;border:none;box-shadow:inset 0 0 0 var(--strokeWidthThick) var(--colorBrandStroke1),inset 0 0 0 var(--strokeWidthThicker) var(--colorStrokeFocus1);}",
			".ryw27oi:hover:active{border:none;box-shadow:inset 0 0 0 var(--strokeWidthThicker) var(--colorCompoundBrandStrokePressed),inset 0 0 0 var(--strokeWidthThickest) var(--colorStrokeFocus1);}",
			".ryw27oi:focus{outline:none;}",
			".ryw27oi:focus-visible{outline:none;}",
			".ryw27oi[data-fui-focus-visible]{border:none;outline:none;box-shadow:inset 0 0 0 var(--strokeWidthThick) var(--colorStrokeFocus2),inset 0 0 0 var(--strokeWidthThicker) var(--colorStrokeFocus1);}"
		],
		s: ["@media (forced-colors: active){.ryw27oi{forced-color-adjust:none;}.ryw27oi:hover{box-shadow:inset 0 0 0 var(--strokeWidthThick) var(--colorBrandStroke2Hover),inset 0 0 0 var(--strokeWidthThicker) var(--colorStrokeFocus1);}.ryw27oi:hover:active{box-shadow:inset 0 0 0 var(--strokeWidthThicker) var(--colorBrandStroke2Pressed),inset 0 0 0 var(--strokeWidthThickest) var(--colorStrokeFocus1);}}"]
	});
	const useStyles$26 = /* @__PURE__ */ __styles({
		disabled: {
			eoavqd: "fphbwmw",
			Bvxd0ez: "f1q3txrk",
			Be968up: "f10pb1y8"
		},
		selected: {
			Bgfg5da: 0,
			B9xav0g: 0,
			oivjwe: 0,
			Bn0qgzm: 0,
			B4g9neb: 0,
			zhjwy3: 0,
			wvpqe5: 0,
			ibv6hh: 0,
			u1mtju: 0,
			h3c5rm: 0,
			vrafjx: 0,
			Bekrc4i: 0,
			i8vvqc: 0,
			g2u3we: 0,
			icvyot: 0,
			B4j52fo: 0,
			irswps: "f3bhgqh",
			E5pizo: "f8ps3yo",
			Bvxd0ez: "f106r15f",
			vajtyg: "ft0nc49",
			j6ew2k: "f16jq8vy",
			Bv9i2bc: "f1wdoq7e"
		},
		selectedSmall: {
			E5pizo: "fxflcoq",
			Bvxd0ez: "fha7ylp",
			vajtyg: "fb3iqi"
		}
	}, {
		h: [
			".fphbwmw:hover{cursor:not-allowed;}",
			".f1q3txrk:hover{box-shadow:none;}",
			".f106r15f:hover{box-shadow:inset 0 0 0 var(--strokeWidthThickest) var(--colorCompoundBrandStrokeHover),inset 0 0 0 6px var(--colorStrokeFocus1);}",
			".ft0nc49:hover:active{box-shadow:inset 0 0 0 var(--strokeWidthThickest) var(--colorCompoundBrandStrokePressed),inset 0 0 0 7px var(--colorStrokeFocus1);}",
			".fha7ylp:hover{box-shadow:inset 0 0 0 var(--strokeWidthThick) var(--colorCompoundBrandStrokeHover),inset 0 0 0 var(--strokeWidthThicker) var(--colorStrokeFocus1);}",
			".fb3iqi:hover:active{box-shadow:inset 0 0 0 var(--strokeWidthThicker) var(--colorCompoundBrandStrokePressed),inset 0 0 0 var(--strokeWidthThickest) var(--colorStrokeFocus1);}"
		],
		m: [["@media (forced-colors: active){.f10pb1y8:hover{box-shadow:none;}}", { m: "(forced-colors: active)" }], ["@media (forced-colors: active){.f1wdoq7e{box-shadow:inset 0 0 0 var(--strokeWidthThicker) var(--colorBrandStroke2Pressed),inset 0 0 0 5px var(--colorStrokeFocus1);}}", { m: "(forced-colors: active)" }]],
		d: [
			[".f3bhgqh{border:none;}", { p: -2 }],
			".f8ps3yo{box-shadow:inset 0 0 0 var(--strokeWidthThicker) var(--colorBrandStroke1),inset 0 0 0 5px var(--colorStrokeFocus1);}",
			".f16jq8vy[data-fui-focus-visible]{box-shadow:inset 0 0 0 var(--strokeWidthThicker) var(--colorStrokeFocus2),inset 0 0 0 5px var(--colorStrokeFocus1);}",
			".fxflcoq{box-shadow:inset 0 0 0 var(--strokeWidthThick) var(--colorBrandStroke1),inset 0 0 0 var(--strokeWidthThicker) var(--colorStrokeFocus1);}"
		]
	});
	const useSizeStyles$2 = /* @__PURE__ */ __styles({
		"extra-small": {
			a9b677: "f64fuq3",
			Bqenvij: "fjamq6b",
			Bvxd0ez: "fnzblak",
			Bfsrqk8: 0,
			B9zn80p: 0,
			libdba: 0,
			qi15n7: 0,
			G6mxvm: 0,
			Bpld233: 0,
			B2v0cj4: 0,
			qv9p00: 0,
			Bg6oviu: 0,
			Bk6r4ia: 0,
			Bckajt6: 0,
			Bone85h: 0,
			hkxzgu: 0,
			b661bw: 0,
			kpb45w: 0,
			uiygdg: 0,
			rljib7: "f18wa7jm",
			vajtyg: "faswyoo"
		},
		small: {
			a9b677: "fq4mcun",
			Bqenvij: "frvgh55",
			Bfsrqk8: 0,
			B9zn80p: 0,
			libdba: 0,
			qi15n7: 0,
			G6mxvm: 0,
			Bpld233: 0,
			B2v0cj4: 0,
			qv9p00: 0,
			Bg6oviu: 0,
			Bk6r4ia: 0,
			Bckajt6: 0,
			Bone85h: 0,
			hkxzgu: 0,
			b661bw: 0,
			kpb45w: 0,
			uiygdg: 0,
			rljib7: "f18wa7jm",
			vajtyg: "faswyoo"
		},
		medium: {
			a9b677: "f1w9dchk",
			Bqenvij: "fxldao9"
		},
		large: {
			a9b677: "f1szoe96",
			Bqenvij: "f1d2rq10"
		}
	}, {
		d: [
			".f64fuq3{width:20px;}",
			".fjamq6b{height:20px;}",
			".fq4mcun{width:24px;}",
			".frvgh55{height:24px;}",
			".f1w9dchk{width:28px;}",
			".fxldao9{height:28px;}",
			".f1szoe96{width:32px;}",
			".f1d2rq10{height:32px;}"
		],
		h: [
			".fnzblak:hover{box-shadow:inset 0 0 0 var(--strokeWidthThin) var(--colorBrandStroke1),inset 0 0 0 var(--strokeWidthThick) var(--colorStrokeFocus1);}",
			[".f18wa7jm:hover:active{border:none;}", { p: -2 }],
			".faswyoo:hover:active{box-shadow:inset 0 0 0 var(--strokeWidthThick) var(--colorCompoundBrandStrokePressed),inset 0 0 0 var(--strokeWidthThicker) var(--colorStrokeFocus1);}",
			[".f18wa7jm:hover:active{border:none;}", { p: -2 }]
		]
	});
	const useShapeStyles$4 = /* @__PURE__ */ __styles({
		rounded: {
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "ft85np5",
			Bw81rd7: 0,
			kdpuga: 0,
			dm238s: 0,
			B6xbmo0: 0,
			B3whbx2: "f2krc9w"
		},
		circular: {
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "f44lkw9",
			Bw81rd7: 0,
			kdpuga: 0,
			dm238s: 0,
			B6xbmo0: 0,
			B3whbx2: "f1062rbf"
		},
		square: {
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "f1fabniw",
			Bw81rd7: 0,
			kdpuga: 0,
			dm238s: 0,
			B6xbmo0: 0,
			B3whbx2: "fj0ryk1"
		}
	}, { d: [
		[".ft85np5{border-radius:var(--borderRadiusMedium);}", { p: -1 }],
		[".f2krc9w[data-fui-focus-visible]{border-radius:var(--borderRadiusMedium);}", { p: -1 }],
		[".f44lkw9{border-radius:var(--borderRadiusCircular);}", { p: -1 }],
		[".f1062rbf[data-fui-focus-visible]{border-radius:var(--borderRadiusCircular);}", { p: -1 }],
		[".f1fabniw{border-radius:var(--borderRadiusNone);}", { p: -1 }],
		[".fj0ryk1[data-fui-focus-visible]{border-radius:var(--borderRadiusNone);}", { p: -1 }]
	] });
	const useIconStyles$1 = /* @__PURE__ */ __styles({
		disabledIcon: {
			sj55zd: "fqpbvvt",
			Bhu2qc9: "f14y0k3d"
		},
		icon: {
			qhf8xq: "f1euv43f",
			mc9l5x: "f22iagw",
			qb2dma: "f7nlbp4"
		},
		"extra-small": { Be2twd7: "f4ybsrx" },
		small: { Be2twd7: "f4ybsrx" },
		medium: { Be2twd7: "fe5j1ua" },
		large: { Be2twd7: "f1rt2boy" }
	}, { d: [
		".fqpbvvt{color:var(--colorNeutralForegroundInverted);}",
		".f14y0k3d{filter:drop-shadow(0 1px 1px rgb(0 0 0 / 1));}",
		".f1euv43f{position:absolute;}",
		".f22iagw{display:flex;}",
		".f7nlbp4{align-self:center;}",
		".f4ybsrx{font-size:16px;}",
		".fe5j1ua{font-size:20px;}",
		".f1rt2boy{font-size:24px;}"
	] });
	/**
	* Apply styling to the ColorSwatch slots based on the state
	*/
	const useColorSwatchStyles_unstable = (state) => {
		"use no memo";
		const { size: size$2 = "medium", shape = "square" } = state;
		const resetStyles = useResetStyles$1();
		const styles = useStyles$26();
		const sizeStyles = useSizeStyles$2();
		const shapeStyles = useShapeStyles$4();
		const iconStyles = useIconStyles$1();
		const smallerSelectedStyles = size$2 === "small" || size$2 === "extra-small" ? styles.selectedSmall : "";
		state.root.className = mergeClasses(colorSwatchClassNames.root, resetStyles, sizeStyles[size$2], shapeStyles[shape], state.selected && styles.selected, state.selected && smallerSelectedStyles, state.disabled && styles.disabled, state.root.className);
		if (state.disabled && state.disabledIcon) state.disabledIcon.className = mergeClasses(iconStyles.icon, iconStyles[size$2], iconStyles.disabledIcon, state.disabledIcon.className);
		if (state.icon) state.icon.className = mergeClasses(iconStyles.icon, iconStyles[size$2], state.icon.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-swatch-picker/lib/components/ColorSwatch/useColorSwatch.js
/**
	* Create the state required to render ColorSwatch.
	*
	* The returned state can be modified with hooks such as useColorSwatchStyles_unstable,
	* before being passed to renderColorSwatch_unstable.
	*
	* @param props - props from this instance of ColorSwatch
	* @param ref - reference to root HTMLButtonElement of ColorSwatch
	*/ const useColorSwatch_unstable = (props, ref) => {
		const { borderColor: borderColor$2, color: color$1, disabled, disabledIcon, icon, value, onClick, size: size$2, shape, style, ...rest } = props;
		const _size = useSwatchPickerContextValue_unstable((ctx) => ctx.size);
		const _shape = useSwatchPickerContextValue_unstable((ctx) => ctx.shape);
		const isGrid = useSwatchPickerContextValue_unstable((ctx) => ctx.isGrid);
		const requestSelectionChange = useSwatchPickerContextValue_unstable((ctx) => ctx.requestSelectionChange);
		const selected = useSwatchPickerContextValue_unstable((ctx) => ctx.selectedValue === value);
		const onColorSwatchClick = useEventCallback(mergeCallbacks(onClick, (event) => requestSelectionChange(event, {
			selectedValue: value,
			selectedSwatch: color$1
		})));
		const rootVariables = {
			[swatchCSSVars.color]: color$1,
			[swatchCSSVars.borderColor]: borderColor$2 !== null && borderColor$2 !== void 0 ? borderColor$2 : tokens.colorTransparentStroke
		};
		const role = isGrid ? "gridcell" : "radio";
		const ariaSelected = isGrid ? { "aria-selected": selected } : { "aria-checked": selected };
		const iconShorthand = optional(icon, { elementType: "span" });
		const disabledIconShorthand = optional(disabledIcon, {
			defaultProps: { children: /* @__PURE__ */ react.createElement(ProhibitedFilled, null) },
			renderByDefault: true,
			elementType: "span"
		});
		return {
			components: {
				root: "button",
				icon: "span",
				disabledIcon: "span"
			},
			root: always(getIntrinsicElementProps("button", {
				ref,
				role,
				...ariaSelected,
				onClick: onColorSwatchClick,
				type: "button",
				disabled,
				...rest,
				style: {
					...rootVariables,
					...style
				}
			}), { elementType: "button" }),
			icon: iconShorthand,
			disabledIcon: disabledIconShorthand,
			disabled,
			size: size$2 !== null && size$2 !== void 0 ? size$2 : _size,
			shape: shape !== null && shape !== void 0 ? shape : _shape,
			selected,
			color: color$1,
			value
		};
	};

//#endregion
//#region node_modules/@fluentui/react-swatch-picker/lib/components/ColorSwatch/renderColorSwatch.js
/**
	* Render the final JSX of ColorSwatch
	*/ const renderColorSwatch_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(state.root, { children: [
			state.root.children,
			state.icon && /* @__PURE__ */ jsx(state.icon, {}),
			state.disabled && state.disabledIcon && /* @__PURE__ */ jsx(state.disabledIcon, {})
		] });
	};

//#endregion
//#region node_modules/@fluentui/react-swatch-picker/lib/components/ColorSwatch/ColorSwatch.js
/**
	* ColorSwatch component is used to render a colors, icons and gradients.
	*/ const ColorSwatch = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useColorSwatch_unstable(props, ref);
		useColorSwatchStyles_unstable(state);
		useCustomStyleHook("useColorSwatchStyles_unstable")(state);
		return renderColorSwatch_unstable(state);
	});
	ColorSwatch.displayName = "ColorSwatch";

//#endregion
//#region node_modules/@fluentui/react-swatch-picker/lib/components/ImageSwatch/useImageSwatch.js
/**
	* Create the state required to render ImageSwatch.
	*
	* The returned state can be modified with hooks such as useImageSwatchStyles_unstable,
	* before being passed to renderImageSwatch_unstable.
	*
	* @param props - props from this instance of ImageSwatch
	* @param ref - reference to root HTMLDivElement of ImageSwatch
	*/ const useImageSwatch_unstable = (props, ref) => {
		const { src, value, onClick, style, ...rest } = props;
		const size$2 = useSwatchPickerContextValue_unstable((ctx) => ctx.size);
		const shape = useSwatchPickerContextValue_unstable((ctx) => ctx.shape);
		const isGrid = useSwatchPickerContextValue_unstable((ctx) => ctx.isGrid);
		const requestSelectionChange = useSwatchPickerContextValue_unstable((ctx) => ctx.requestSelectionChange);
		const selected = useSwatchPickerContextValue_unstable((ctx) => ctx.selectedValue === value);
		const role = isGrid ? "gridcell" : "radio";
		const ariaSelected = isGrid ? { "aria-selected": selected } : { "aria-checked": selected };
		const onImageSwatchClick = useEventCallback(mergeCallbacks(onClick, (event) => requestSelectionChange(event, {
			selectedValue: value,
			selectedSwatch: src
		})));
		return {
			components: { root: "button" },
			root: always(getIntrinsicElementProps("button", {
				ref,
				role,
				...ariaSelected,
				onClick: onImageSwatchClick,
				...rest,
				style: {
					backgroundImage: `url(${src})`,
					...style
				}
			}), { elementType: "button" }),
			value,
			selected,
			size: size$2,
			shape
		};
	};

//#endregion
//#region node_modules/@fluentui/react-swatch-picker/lib/components/ImageSwatch/renderImageSwatch.js
/**
	* Render the final JSX of ImageSwatch
	*/ const renderImageSwatch_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, {});
	};

//#endregion
//#region node_modules/@fluentui/react-swatch-picker/lib/components/ImageSwatch/useImageSwatchStyles.styles.js
	const imageSwatchClassNames = { root: "fui-ImageSwatch" };
	/**
	* Styles for the root slot
	*/
	const useStyles$25 = /* @__PURE__ */ __resetStyles("r18b5q7m", null, {
		r: [
			".r18b5q7m{display:inline-flex;box-sizing:border-box;border:1px solid var(--colorTransparentStroke);background-size:cover;background-repeat:no-repeat;padding:0;}",
			".r18b5q7m:hover{cursor:pointer;border:none;box-shadow:inset 0 0 0 var(--strokeWidthThick) var(--colorBrandStroke1),inset 0 0 0 var(--strokeWidthThicker) var(--colorStrokeFocus1);}",
			".r18b5q7m:hover:active{border:none;box-shadow:inset 0 0 0 var(--strokeWidthThicker) var(--colorCompoundBrandStrokePressed),inset 0 0 0 var(--strokeWidthThickest) var(--colorStrokeFocus1);}",
			".r18b5q7m:focus{outline:none;}",
			".r18b5q7m:focus-visible{outline:none;}",
			".r18b5q7m[data-fui-focus-visible]{border:none;outline:none;box-shadow:inset 0 0 0 var(--strokeWidthThick) var(--colorStrokeFocus2),inset 0 0 0 var(--strokeWidthThicker) var(--colorStrokeFocus1);}"
		],
		s: ["@media (forced-colors: active){.r18b5q7m{forced-color-adjust:none;}.r18b5q7m:hover{box-shadow:inset 0 0 0 var(--strokeWidthThick) var(--colorBrandStroke2Hover),inset 0 0 0 var(--strokeWidthThicker) var(--colorStrokeFocus1);}.r18b5q7m:hover:active{box-shadow:inset 0 0 0 var(--strokeWidthThicker) var(--colorBrandStroke2Pressed),inset 0 0 0 var(--strokeWidthThickest) var(--colorStrokeFocus1);}}"]
	});
	const useStylesSelected = /* @__PURE__ */ __styles({ selected: {
		Bgfg5da: 0,
		B9xav0g: 0,
		oivjwe: 0,
		Bn0qgzm: 0,
		B4g9neb: 0,
		zhjwy3: 0,
		wvpqe5: 0,
		ibv6hh: 0,
		u1mtju: 0,
		h3c5rm: 0,
		vrafjx: 0,
		Bekrc4i: 0,
		i8vvqc: 0,
		g2u3we: 0,
		icvyot: 0,
		B4j52fo: 0,
		irswps: "f3bhgqh",
		E5pizo: "f8ps3yo",
		Bvxd0ez: "f106r15f",
		vajtyg: "ft0nc49",
		j6ew2k: "f16jq8vy",
		Bv9i2bc: "f1wdoq7e"
	} }, {
		d: [
			[".f3bhgqh{border:none;}", { p: -2 }],
			".f8ps3yo{box-shadow:inset 0 0 0 var(--strokeWidthThicker) var(--colorBrandStroke1),inset 0 0 0 5px var(--colorStrokeFocus1);}",
			".f16jq8vy[data-fui-focus-visible]{box-shadow:inset 0 0 0 var(--strokeWidthThicker) var(--colorStrokeFocus2),inset 0 0 0 5px var(--colorStrokeFocus1);}"
		],
		h: [".f106r15f:hover{box-shadow:inset 0 0 0 var(--strokeWidthThickest) var(--colorCompoundBrandStrokeHover),inset 0 0 0 6px var(--colorStrokeFocus1);}", ".ft0nc49:hover:active{box-shadow:inset 0 0 0 var(--strokeWidthThickest) var(--colorCompoundBrandStrokePressed),inset 0 0 0 7px var(--colorStrokeFocus1);}"],
		m: [["@media (forced-colors: active){.f1wdoq7e{box-shadow:inset 0 0 0 var(--strokeWidthThicker) var(--colorBrandStroke2Pressed),inset 0 0 0 5px var(--colorStrokeFocus1);}}", { m: "(forced-colors: active)" }]]
	});
	const useSizeStyles$1 = /* @__PURE__ */ __styles({
		"extra-small": {
			a9b677: "f64fuq3",
			Bqenvij: "fjamq6b"
		},
		small: {
			a9b677: "fq4mcun",
			Bqenvij: "frvgh55"
		},
		medium: {
			a9b677: "f1w9dchk",
			Bqenvij: "fxldao9"
		},
		large: {
			a9b677: "f1szoe96",
			Bqenvij: "f1d2rq10"
		}
	}, { d: [
		".f64fuq3{width:20px;}",
		".fjamq6b{height:20px;}",
		".fq4mcun{width:24px;}",
		".frvgh55{height:24px;}",
		".f1w9dchk{width:28px;}",
		".fxldao9{height:28px;}",
		".f1szoe96{width:32px;}",
		".f1d2rq10{height:32px;}"
	] });
	const useShapeStyles$3 = /* @__PURE__ */ __styles({
		rounded: {
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "ft85np5",
			Bw81rd7: 0,
			kdpuga: 0,
			dm238s: 0,
			B6xbmo0: 0,
			B3whbx2: "f2krc9w"
		},
		circular: {
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "f44lkw9",
			Bw81rd7: 0,
			kdpuga: 0,
			dm238s: 0,
			B6xbmo0: 0,
			B3whbx2: "f1062rbf"
		},
		square: {
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "f1fabniw",
			Bw81rd7: 0,
			kdpuga: 0,
			dm238s: 0,
			B6xbmo0: 0,
			B3whbx2: "fj0ryk1"
		}
	}, { d: [
		[".ft85np5{border-radius:var(--borderRadiusMedium);}", { p: -1 }],
		[".f2krc9w[data-fui-focus-visible]{border-radius:var(--borderRadiusMedium);}", { p: -1 }],
		[".f44lkw9{border-radius:var(--borderRadiusCircular);}", { p: -1 }],
		[".f1062rbf[data-fui-focus-visible]{border-radius:var(--borderRadiusCircular);}", { p: -1 }],
		[".f1fabniw{border-radius:var(--borderRadiusNone);}", { p: -1 }],
		[".fj0ryk1[data-fui-focus-visible]{border-radius:var(--borderRadiusNone);}", { p: -1 }]
	] });
	/**
	* Apply styling to the ImageSwatch slots based on the state
	*/
	const useImageSwatchStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$25();
		const selectedStyles = useStylesSelected();
		const sizeStyles = useSizeStyles$1();
		const shapeStyles = useShapeStyles$3();
		const { size: size$2 = "medium", shape = "square" } = state;
		state.root.className = mergeClasses(imageSwatchClassNames.root, styles, sizeStyles[size$2], shapeStyles[shape], state.selected && selectedStyles.selected, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-swatch-picker/lib/components/ImageSwatch/ImageSwatch.js
/**
	* ImageSwatch component is used to render an images, patterns and textures.
	*/ const ImageSwatch = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useImageSwatch_unstable(props, ref);
		useImageSwatchStyles_unstable(state);
		useCustomStyleHook("useImageSwatchStyles_unstable")(state);
		return renderImageSwatch_unstable(state);
	});
	ImageSwatch.displayName = "ImageSwatch";

//#endregion
//#region node_modules/@fluentui/react-swatch-picker/lib/components/SwatchPickerRow/useSwatchPickerRow.js
/**
	* Create the state required to render SwatchPickerRow.
	*
	* The returned state can be modified with hooks such as useSwatchPickerRowStyles_unstable,
	* before being passed to renderSwatchPickerRow_unstable.
	*
	* @param props - props from this instance of SwatchPickerRow
	* @param ref - reference to root HTMLDivElement of SwatchPickerRow
	*/ const useSwatchPickerRow_unstable = (props, ref) => {
		const { style, ...rest } = props;
		const spacing = useSwatchPickerContextValue_unstable((ctx) => ctx.spacing);
		return {
			components: { root: "div" },
			root: always(getIntrinsicElementProps("div", {
				ref,
				role: "row",
				...rest
			}), { elementType: "div" }),
			spacing
		};
	};

//#endregion
//#region node_modules/@fluentui/react-swatch-picker/lib/components/SwatchPickerRow/renderSwatchPickerRow.js
/**
	* Render the final JSX of SwatchPickerRow
	*/ const renderSwatchPickerRow_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, {});
	};

//#endregion
//#region node_modules/@fluentui/react-swatch-picker/lib/components/SwatchPickerRow/useSwatchPickerRowStyles.styles.js
	const swatchPickerRowClassNames = { root: "fui-SwatchPickerRow" };
	/**
	* Styles for the root slot
	*/
	const useResetStyles = /* @__PURE__ */ __resetStyles("r1xhj18k", null, [".r1xhj18k{display:flex;flex-direction:row;}"]);
	const useStyles$24 = /* @__PURE__ */ __styles({
		spacingSmall: { i8kkvl: "f16mnhsx" },
		spacingMedium: { i8kkvl: "f1q8lukm" }
	}, { d: [".f16mnhsx{column-gap:2px;}", ".f1q8lukm{column-gap:4px;}"] });
	/**
	* Apply styling to the SwatchPickerRow slots based on the state
	*/
	const useSwatchPickerRowStyles_unstable = (state) => {
		"use no memo";
		const resetStyles = useResetStyles();
		const styles = useStyles$24();
		const spacingStyle = state.spacing === "small" ? styles.spacingSmall : styles.spacingMedium;
		state.root.className = mergeClasses(swatchPickerRowClassNames.root, resetStyles, spacingStyle, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-swatch-picker/lib/components/SwatchPickerRow/SwatchPickerRow.js
/**
	* SwatchPickerRow component is used to render a row of swatches.
	*/ const SwatchPickerRow = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useSwatchPickerRow_unstable(props, ref);
		useSwatchPickerRowStyles_unstable(state);
		useCustomStyleHook("useSwatchPickerRowStyles_unstable")(state);
		return renderSwatchPickerRow_unstable(state);
	});
	SwatchPickerRow.displayName = "SwatchPickerRow";

//#endregion
//#region node_modules/@fluentui/react-swatch-picker/lib/utils/renderUtils.js
	const renderSwatchPickerGrid = (props) => {
		const { items, columnCount, renderRow, renderSwatch } = props;
		const _renderRow = renderRow || (({ children, rowId }) => /* @__PURE__ */ react.createElement(SwatchPickerRow, { key: rowId }, children));
		const _renderSwatch = renderSwatch || ((item) => {
			var _item_src;
			return item.src ? /* @__PURE__ */ react.createElement(ImageSwatch, {
				key: item.value,
				src: (_item_src = item.src) !== null && _item_src !== void 0 ? _item_src : "",
				...item
			}) : /* @__PURE__ */ react.createElement(ColorSwatch, {
				key: item.value,
				color: item.color || "",
				...item
			});
		});
		const rowCount = Math.ceil(items.length / columnCount);
		return Array.from({ length: rowCount }, (_, i) => {
			const start = i * columnCount;
			const end = start + columnCount;
			return items.slice(start, end);
		}).map((row, index) => _renderRow({
			children: row.map(_renderSwatch),
			rowId: index
		}));
	};

//#endregion
//#region node_modules/@fluentui/react-swatch-picker/lib/components/EmptySwatch/useEmptySwatch.js
/**
	* Create the state required to render EmptySwatch.
	*
	* The returned state can be modified with hooks such as useEmptySwatchStyles_unstable,
	* before being passed to renderEmptySwatch_unstable.
	*
	* @param props - props from this instance of EmptySwatch
	* @param ref - reference to root HTMLDivElement of EmptySwatch
	*/ const useEmptySwatch_unstable = (props, ref) => {
		const { size: size$2, shape, ...rest } = props;
		const _size = useSwatchPickerContextValue_unstable((ctx) => ctx.size);
		const _shape = useSwatchPickerContextValue_unstable((ctx) => ctx.shape);
		const isGrid = useSwatchPickerContextValue_unstable((ctx) => ctx.isGrid);
		const role = isGrid ? "gridcell" : "radio";
		const a11yProps = isGrid ? {} : { "aria-checked": false };
		return {
			components: { root: "button" },
			root: always(getIntrinsicElementProps("button", {
				ref,
				role,
				...a11yProps,
				...rest
			}), { elementType: "button" }),
			size: size$2 !== null && size$2 !== void 0 ? size$2 : _size,
			shape: shape !== null && shape !== void 0 ? shape : _shape
		};
	};

//#endregion
//#region node_modules/@fluentui/react-swatch-picker/lib/components/EmptySwatch/renderEmptySwatch.js
/**
	* Render the final JSX of EmptySwatch
	*/ const renderEmptySwatch_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, {});
	};

//#endregion
//#region node_modules/@fluentui/react-swatch-picker/lib/components/EmptySwatch/useEmptySwatchStyles.styles.js
	const emptySwatchClassNames = { root: "fui-EmptySwatch" };
	/**
	* Styles for the root slot
	*/
	const useStyles$23 = /* @__PURE__ */ __resetStyles("r1top892", null, [".r1top892{background-color:var(--colorTransparentBackground);border:1px dashed var(--colorNeutralForeground4);}"]);
	const useSizeStyles = /* @__PURE__ */ __styles({
		"extra-small": {
			a9b677: "f64fuq3",
			Bqenvij: "fjamq6b"
		},
		small: {
			a9b677: "fq4mcun",
			Bqenvij: "frvgh55"
		},
		medium: {
			a9b677: "f1w9dchk",
			Bqenvij: "fxldao9"
		},
		large: {
			a9b677: "f1szoe96",
			Bqenvij: "f1d2rq10"
		}
	}, { d: [
		".f64fuq3{width:20px;}",
		".fjamq6b{height:20px;}",
		".fq4mcun{width:24px;}",
		".frvgh55{height:24px;}",
		".f1w9dchk{width:28px;}",
		".fxldao9{height:28px;}",
		".f1szoe96{width:32px;}",
		".f1d2rq10{height:32px;}"
	] });
	const useShapeStyles$2 = /* @__PURE__ */ __styles({
		rounded: {
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "ft85np5",
			Bw81rd7: 0,
			kdpuga: 0,
			dm238s: 0,
			B6xbmo0: 0,
			B3whbx2: "f2krc9w"
		},
		circular: {
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "f44lkw9",
			Bw81rd7: 0,
			kdpuga: 0,
			dm238s: 0,
			B6xbmo0: 0,
			B3whbx2: "f1062rbf"
		},
		square: {
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "f1fabniw",
			Bw81rd7: 0,
			kdpuga: 0,
			dm238s: 0,
			B6xbmo0: 0,
			B3whbx2: "fj0ryk1"
		}
	}, { d: [
		[".ft85np5{border-radius:var(--borderRadiusMedium);}", { p: -1 }],
		[".f2krc9w[data-fui-focus-visible]{border-radius:var(--borderRadiusMedium);}", { p: -1 }],
		[".f44lkw9{border-radius:var(--borderRadiusCircular);}", { p: -1 }],
		[".f1062rbf[data-fui-focus-visible]{border-radius:var(--borderRadiusCircular);}", { p: -1 }],
		[".f1fabniw{border-radius:var(--borderRadiusNone);}", { p: -1 }],
		[".fj0ryk1[data-fui-focus-visible]{border-radius:var(--borderRadiusNone);}", { p: -1 }]
	] });
	/**
	* Apply styling to the EmptySwatch slots based on the state
	*/
	const useEmptySwatchStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$23();
		const sizeStyles = useSizeStyles();
		const shapeStyles = useShapeStyles$2();
		var _state_size;
		const size$2 = (_state_size = state.size) !== null && _state_size !== void 0 ? _state_size : "medium";
		var _state_shape;
		state.root.className = mergeClasses(emptySwatchClassNames.root, styles, sizeStyles[size$2], shapeStyles[(_state_shape = state.shape) !== null && _state_shape !== void 0 ? _state_shape : "square"], state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-swatch-picker/lib/components/EmptySwatch/EmptySwatch.js
/**
	* EmptySwatch component is used for adding new color swatches.
	*/ const EmptySwatch = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useEmptySwatch_unstable(props, ref);
		useEmptySwatchStyles_unstable(state);
		useCustomStyleHook("useEmptySwatchStyles_unstable")(state);
		return renderEmptySwatch_unstable(state);
	});
	EmptySwatch.displayName = "EmptySwatch";

//#endregion
//#region node_modules/@fluentui/react-carousel/lib/components/CarouselContext.js
	const carouselContextDefaultValue = {
		activeIndex: 0,
		appearance: "flat",
		selectPageByElement: () => {
			return 0;
		},
		selectPageByDirection: () => {
			return 0;
		},
		selectPageByIndex: () => {
			/** noop */		},
		subscribeForValues: () => () => {
			/** noop */		},
		enableAutoplay: () => {
			/** noop */		},
		resetAutoplay: () => {
			/** noop */		},
		circular: false,
		containerRef: void 0,
		viewportRef: void 0
	};
	const CarouselContext = createContext(void 0);
	const CarouselProvider = CarouselContext.Provider;
	const useCarouselContext_unstable = (selector) => useContextSelector(CarouselContext, (ctx = carouselContextDefaultValue) => selector(ctx));

//#endregion
//#region node_modules/@fluentui/react-carousel/lib/components/CarouselButton/useCarouselButtonStyles.styles.js
	const carouselButtonClassNames = {
		root: "fui-CarouselButton",
		icon: "fui-CarouselButton__icon"
	};
	/**
	* Styles for the root slot
	*/
	const useStyles$22 = /* @__PURE__ */ __styles({ root: {
		B6of3ja: "fgr6219",
		jrapky: "f10jk5vf",
		sj55zd: "fkfq4zb",
		De3pzq: "fkfdr9r",
		Bkecrkj: "fc5wo7j",
		eoavqd: "f8491dx"
	} }, {
		d: [
			".fgr6219{margin-top:auto;}",
			".f10jk5vf{margin-bottom:auto;}",
			".fkfq4zb{color:var(--colorNeutralForeground2);}",
			".fkfdr9r{background-color:var(--colorNeutralBackgroundAlpha);}",
			".fc5wo7j{pointer-events:all;}"
		],
		h: [".f8491dx:hover{cursor:pointer;}"]
	});
	/**
	* Apply styling to the CarouselButton slots based on the state
	*/
	const useCarouselButtonStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$22();
		state = {
			...state,
			...useButtonStyles_unstable(state)
		};
		state.root.className = mergeClasses(carouselButtonClassNames.root, styles.root, state.root.className);
		if (state.icon) state.icon.className = mergeClasses(carouselButtonClassNames.icon, state.icon.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-carousel/lib/components/CarouselButton/useCarouselButton.js
/**
	* Create the state required to render CarouselButton.
	*
	* The returned state can be modified with hooks such as useCarouselButtonStyles_unstable,
	* before being passed to renderCarouselButton_unstable.
	*
	* @param props - props from this instance of CarouselButton
	* @param ref - reference to root HTMLDivElement of CarouselButton
	*/ const useCarouselButton_unstable = (props, ref) => {
		const { navType = "next" } = props;
		const [totalSlides, setTotalSlides] = react.useState(0);
		const { dir } = useFluent();
		const buttonRef = react.useRef(void 0);
		const circular = useCarouselContext_unstable((ctx) => ctx.circular);
		const [canLoop, setCanLoop] = react.useState(circular);
		const containerRef = useCarouselContext_unstable((ctx) => ctx.containerRef);
		const selectPageByDirection = useCarouselContext_unstable((ctx) => ctx.selectPageByDirection);
		const subscribeForValues = useCarouselContext_unstable((ctx) => ctx.subscribeForValues);
		const resetAutoplay = useCarouselContext_unstable((ctx) => ctx.resetAutoplay);
		const isTrailing = useCarouselContext_unstable((ctx) => {
			if (circular && canLoop) return false;
			if (navType === "prev") return ctx.activeIndex === 0;
			return ctx.activeIndex === totalSlides - 1;
		});
		const handleClick = (event) => {
			if (event.isDefaultPrevented()) return;
			const nextIndex = selectPageByDirection(event, navType);
			let _trailing = false;
			if (navType === "prev") _trailing = nextIndex === 0;
			else _trailing = nextIndex === totalSlides - 1;
			if (!circular && _trailing && (containerRef === null || containerRef === void 0 ? void 0 : containerRef.current)) containerRef.current.querySelectorAll(`.${carouselButtonClassNames.root}`).forEach((_buttonRef) => {
				if (_buttonRef !== buttonRef.current) _buttonRef.focus();
			});
			resetAutoplay();
		};
		useIsomorphicLayoutEffect(() => {
			return subscribeForValues((data) => {
				if (data.canLoop !== void 0) setCanLoop(data.canLoop);
				setTotalSlides(data.navItemsCount);
			});
		}, [subscribeForValues]);
		const nextArrowIcon = dir === "ltr" ? /* @__PURE__ */ react.createElement(ChevronRightRegular, null) : /* @__PURE__ */ react.createElement(ChevronLeftRegular, null);
		const prevArrowIcon = dir === "ltr" ? /* @__PURE__ */ react.createElement(ChevronLeftRegular, null) : /* @__PURE__ */ react.createElement(ChevronRightRegular, null);
		return {
			navType,
			...useButton_unstable({
				icon: optional(props.icon, {
					defaultProps: { children: navType === "next" ? nextArrowIcon : prevArrowIcon },
					renderByDefault: true,
					elementType: "span"
				}),
				disabled: isTrailing,
				tabIndex: isTrailing ? -1 : 0,
				"aria-disabled": isTrailing,
				appearance: "subtle",
				...props,
				onClick: useEventCallback(mergeCallbacks(handleClick, props.onClick))
			}, useMergedRefs(ref, buttonRef))
		};
	};

//#endregion
//#region node_modules/@fluentui/react-carousel/lib/components/CarouselButton/renderCarouselButton.js
/**
	* Render the final JSX of CarouselButton
	*/ const renderCarouselButton_unstable = (state) => {
		assertSlots(state);
		return renderButton_unstable(state);
	};

//#endregion
//#region node_modules/@fluentui/react-carousel/lib/components/CarouselButton/CarouselButton.js
/**
	* A default navigation button that will set value to the next/previous page,
	* driven by it's type 'next' or 'previous'.
	*/ const CarouselButton = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useCarouselButton_unstable(props, ref);
		useCarouselButtonStyles_unstable(state);
		useCustomStyleHook("useCarouselButtonStyles_unstable")(state);
		return renderCarouselButton_unstable(state);
	});
	CarouselButton.displayName = "CarouselButton";

//#endregion
//#region node_modules/@fluentui/react-carousel/lib/components/CarouselNav/CarouselNavContext.js
	const carouselNavContext = react.createContext(void 0);
	const carouselNavContextDefaultValue = { appearance: void 0 };
	const useCarouselNavContext = () => {
		var _React_useContext;
		return (_React_useContext = react.useContext(carouselNavContext)) !== null && _React_useContext !== void 0 ? _React_useContext : carouselNavContextDefaultValue;
	};
	const CarouselNavContextProvider = carouselNavContext.Provider;
	function useCarouselNavContextValues_unstable(state) {
		const { appearance } = state;
		return { carouselNav: react.useMemo(() => ({ appearance }), [appearance]) };
	}

//#endregion
//#region node_modules/@fluentui/react-carousel/lib/components/CarouselNav/CarouselNavIndexContext.js
	const carouselNavIndexContext = react.createContext(void 0);
	const carouselNavIndexContextDefaultValue = 0;
	const useCarouselNavIndexContext = () => {
		var _React_useContext;
		return (_React_useContext = react.useContext(carouselNavIndexContext)) !== null && _React_useContext !== void 0 ? _React_useContext : carouselNavIndexContextDefaultValue;
	};
	const CarouselNavIndexContextProvider = carouselNavIndexContext.Provider;

//#endregion
//#region node_modules/@fluentui/react-carousel/lib/components/CarouselNav/renderCarouselNav.js
/**
	* Render the final JSX of CarouselNav
	*/ const renderCarouselNav_unstable = (state, contextValues) => {
		assertSlots(state);
		const { totalSlides, renderNavButton } = state;
		return /* @__PURE__ */ jsx(state.root, { children: /* @__PURE__ */ jsx(CarouselNavContextProvider, {
			value: contextValues.carouselNav,
			children: new Array(totalSlides).fill(null).map((_, index) => /* @__PURE__ */ jsx(CarouselNavIndexContextProvider, {
				value: index,
				children: renderNavButton(index)
			}, index))
		}) });
	};

//#endregion
//#region node_modules/@fluentui/react-carousel/lib/components/CarouselNav/useCarouselNav.js
/**
	* Create the state required to render CarouselNav.
	*
	* The returned state can be modified with hooks such as useCarouselNavStyles_unstable,
	* before being passed to renderCarouselNav_unstable.
	*
	* @param props - props from this instance of CarouselNav
	* @param ref - reference to root HTMLDivElement of CarouselNav
	*/ const useCarouselNav_unstable = (props, ref) => {
		const { appearance } = props;
		const focusableGroupAttr = useArrowNavigationGroup({
			circular: false,
			axis: "horizontal",
			memorizeCurrent: false,
			unstable_hasDefault: true
		});
		const [totalSlides, setTotalSlides] = useControllableState({
			state: props.totalSlides,
			initialState: 0
		});
		const subscribeForValues = useCarouselContext_unstable((ctx) => ctx.subscribeForValues);
		useIsomorphicLayoutEffect(() => {
			return subscribeForValues((data) => {
				setTotalSlides(data.navItemsCount);
			});
		}, [subscribeForValues, setTotalSlides]);
		return {
			totalSlides,
			appearance,
			renderNavButton: props.children,
			components: { root: "div" },
			root: always(getIntrinsicElementProps("div", {
				ref,
				role: "tablist",
				...props,
				...focusableGroupAttr,
				children: null
			}), { elementType: "div" })
		};
	};

//#endregion
//#region node_modules/@fluentui/react-carousel/lib/components/CarouselNav/useCarouselNavStyles.styles.js
	const carouselNavClassNames = { root: "fui-CarouselNav" };
	/**
	* Styles for the root slot
	*/
	const useStyles$21 = /* @__PURE__ */ __styles({ root: {
		mc9l5x: "f22iagw",
		Beiy3e4: "f1063pyq",
		Bt984gj: "f122n59",
		Brf1p80: "f4d9j23",
		Bkecrkj: "fc5wo7j",
		Bfpq7zp: 0,
		g9k6zt: 0,
		Bn4voq9: 0,
		giviqs: "f89hs3r",
		Bw81rd7: 0,
		kdpuga: 0,
		dm238s: 0,
		B6xbmo0: 0,
		B3whbx2: "f2krc9w",
		B8q5s1w: "f8hki3x",
		Bci5o5g: ["f1d2448m", "ffh67wi"],
		n8qw10: "f1bjia2o",
		Bdrgwmp: ["ffh67wi", "f1d2448m"],
		Beyfa6y: 0,
		Bbmb7ep: 0,
		Btl43ni: 0,
		B7oj6ja: 0,
		Dimara: "f1kijzfu",
		jrapky: 0,
		Frg6f3: 0,
		t21cq0: 0,
		B6of3ja: 0,
		B74szlk: "fkb7v5e",
		De3pzq: "fkfdr9r"
	} }, { d: [
		".f22iagw{display:flex;}",
		".f1063pyq{flex-direction:row;}",
		".f122n59{align-items:center;}",
		".f4d9j23{justify-content:center;}",
		".fc5wo7j{pointer-events:all;}",
		[".f89hs3r[data-fui-focus-visible]{outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}", { p: -1 }],
		[".f2krc9w[data-fui-focus-visible]{border-radius:var(--borderRadiusMedium);}", { p: -1 }],
		".f8hki3x[data-fui-focus-visible]{border-top-color:transparent;}",
		".f1d2448m[data-fui-focus-visible]{border-right-color:transparent;}",
		".ffh67wi[data-fui-focus-visible]{border-left-color:transparent;}",
		".f1bjia2o[data-fui-focus-visible]{border-bottom-color:transparent;}",
		[".f1kijzfu{border-radius:var(--borderRadiusXLarge);}", { p: -1 }],
		[".fkb7v5e{margin:auto var(--spacingHorizontalS);}", { p: -1 }],
		".fkfdr9r{background-color:var(--colorNeutralBackgroundAlpha);}"
	] });
	/**
	* Apply styling to the CarouselNav slots based on the state
	*/
	const useCarouselNavStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$21();
		state.root.className = mergeClasses(carouselNavClassNames.root, styles.root, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-carousel/lib/components/CarouselNav/CarouselNav.js
/**
	* Used to jump to a card based on index, using arrow navigation via Tabster.
	*
	* The children of this component will be wrapped in a context to
	* provide the appropriate value based on their index position.
	*/ const CarouselNav = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useCarouselNav_unstable(props, ref);
		const contextValues = useCarouselNavContextValues_unstable(state);
		useCarouselNavStyles_unstable(state);
		useCustomStyleHook("useCarouselNavStyles_unstable")(state);
		return renderCarouselNav_unstable(state, contextValues);
	});
	CarouselNav.displayName = "CarouselNav";

//#endregion
//#region node_modules/@fluentui/react-carousel/lib/components/CarouselNavButton/useCarouselNavButton.js
/**
	* Create the state required to render CarouselNavButton.
	*
	* The returned state can be modified with hooks such as useCarouselNavButtonStyles_unstable,
	* before being passed to renderCarouselNavButton_unstable.
	*
	* @param props - props from this instance of CarouselNavButton
	* @param ref - reference to root HTMLDivElement of CarouselNavButton
	*/ const useCarouselNavButton_unstable = (props, ref) => {
		const { onClick, as = "button" } = props;
		const { appearance } = useCarouselNavContext();
		const index = useCarouselNavIndexContext();
		const selectPageByIndex = useCarouselContext_unstable((ctx) => ctx.selectPageByIndex);
		const selected = useCarouselContext_unstable((ctx) => ctx.activeIndex === index);
		const subscribeForValues = useCarouselContext_unstable((ctx) => ctx.subscribeForValues);
		const resetAutoplay = useCarouselContext_unstable((ctx) => ctx.resetAutoplay);
		const handleClick = useEventCallback((event) => {
			onClick === null || onClick === void 0 || onClick(event);
			if (!event.defaultPrevented && isHTMLElement(event.target)) selectPageByIndex(event, index);
			resetAutoplay();
		});
		const defaultTabProps = useTabsterAttributes({ focusable: { isDefault: selected } });
		const buttonRef = react.useRef(void 0);
		const _carouselButton = always(getIntrinsicElementProps(as, useARIAButtonProps(props.as, props)), {
			elementType: "button",
			defaultProps: {
				ref: useMergedRefs(ref, buttonRef),
				role: "tab",
				type: "button",
				"aria-selected": selected,
				...defaultTabProps
			}
		});
		useIsomorphicLayoutEffect(() => {
			return subscribeForValues((data) => {
				var _data_groupIndexList;
				var _data_groupIndexList_index;
				const _controlledSlideIds = ((_data_groupIndexList_index = (_data_groupIndexList = data.groupIndexList) === null || _data_groupIndexList === void 0 ? void 0 : _data_groupIndexList[index]) !== null && _data_groupIndexList_index !== void 0 ? _data_groupIndexList_index : []).map((slideIndex) => {
					return data.slideNodes[slideIndex].id;
				}).join(" ");
				if (buttonRef.current) buttonRef.current.setAttribute("aria-controls", _controlledSlideIds);
			});
		}, [index, subscribeForValues]);
		_carouselButton.onClick = handleClick;
		return {
			selected,
			appearance,
			components: { root: "button" },
			root: _carouselButton
		};
	};

//#endregion
//#region node_modules/@fluentui/react-carousel/lib/components/CarouselNavButton/renderCarouselNavButton.js
/**
	* Render the final JSX of CarouselNavButton
	*/ const renderCarouselNavButton_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, {});
	};

//#endregion
//#region node_modules/@fluentui/react-carousel/lib/components/CarouselNavButton/useCarouselNavButtonStyles.styles.js
	const carouselNavButtonClassNames = { root: "fui-CarouselNavButton" };
	/**
	* Styles for the root slot
	*/
	const useStyles$20 = /* @__PURE__ */ __styles({
		root: {
			Bceei9c: "f1k6fduh",
			Bkecrkj: "fc5wo7j",
			a9b677: "f1van5z7",
			Bqenvij: "f1fkmctz",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f1f5q0n8",
			B7ck84d: "f1e4lqlz",
			De3pzq: "f1c21dwh",
			B4j52fo: "fre7gi1",
			Bekrc4i: ["f1358rze", "f1rvrf73"],
			Bn0qgzm: "fqdk4by",
			ibv6hh: ["f1rvrf73", "f1358rze"],
			Bsft5z2: "f13zj6fq",
			ap17g6: "f2gz7yw",
			li1rpt: "f1gw3sf2",
			d9w3h3: 0,
			B3778ie: 0,
			B4j8arr: 0,
			Bl18szs: 0,
			Blrzh8d: "f1x820d0",
			Bjuhk93: 0,
			B1q35kw: 0,
			Bw17bha: 0,
			Bcgy8vk: 0,
			Du69r6: 0,
			Gp14am: 0,
			vfts7: 0,
			Bhxzhr1: 0,
			G63luc: 0,
			s924m2: 0,
			Barhvk9: 0,
			Ihftqj: 0,
			wywymt: 0,
			B0n5ga8: 0,
			Bm2nyyq: 0,
			xrcqlc: 0,
			e1d83w: "fnwf5yv",
			Dlnsje: "foue38v",
			a2br6o: "fi4ui2s",
			Bjyk6c5: "f1w4p7kh",
			go7t6h: "fo5b2b9",
			xdqbwx: "f16vizm6",
			Hwb57: "fqolsir",
			umgawz: "fim7wbh"
		},
		rootUnselected: {
			Bw0xxkn: 0,
			oeaueh: 0,
			Bpd4iqm: 0,
			Befb4lg: "f71xx7",
			Byu6kyc: 0,
			n8qw10: 0,
			Bbjhlyh: 0,
			i2cumq: 0,
			Bunx835: 0,
			Bdrgwmp: 0,
			mqozju: 0,
			lbo84a: 0,
			Bksnhdo: 0,
			Bci5o5g: 0,
			u5e7qz: 0,
			Bn40d3w: 0,
			B7b6zxw: 0,
			B8q5s1w: 0,
			B5gfjzb: 0,
			Bbcte9g: 0,
			Bqz3imu: "f1j9b7x8",
			Bj9ihqo: 0,
			Bl51kww: 0,
			B3bvztg: 0,
			Btyt4dx: 0,
			Brhw1f9: "f1tdm9ui",
			Bw81rd7: 0,
			kdpuga: 0,
			dm238s: 0,
			B6xbmo0: 0,
			B3whbx2: "f2krc9w",
			Bp15pi3: "f7x02et",
			Bay5ve9: "f1ry2q4s",
			Bni0232: "f1e9f9ku"
		},
		rootSelected: {
			a9b677: "f1eh74fx",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "fwku66v",
			Bw0xxkn: 0,
			oeaueh: 0,
			Bpd4iqm: 0,
			Befb4lg: "f71xx7",
			Byu6kyc: 0,
			n8qw10: 0,
			Bbjhlyh: 0,
			i2cumq: 0,
			Bunx835: 0,
			Bdrgwmp: 0,
			mqozju: 0,
			lbo84a: 0,
			Bksnhdo: 0,
			Bci5o5g: 0,
			u5e7qz: 0,
			Bn40d3w: 0,
			B7b6zxw: 0,
			B8q5s1w: 0,
			B5gfjzb: 0,
			Bbcte9g: 0,
			Bqz3imu: "f1j9b7x8",
			Bj9ihqo: 0,
			Bl51kww: 0,
			B3bvztg: 0,
			Btyt4dx: 0,
			Brhw1f9: "f1tdm9ui",
			Bw81rd7: 0,
			kdpuga: 0,
			dm238s: 0,
			B6xbmo0: 0,
			B3whbx2: "f2krc9w",
			a2br6o: "f1v6lwa2",
			d9w3h3: 0,
			B3778ie: 0,
			B4j8arr: 0,
			Bl18szs: 0,
			Blrzh8d: "fgm6wgx",
			Bay5ve9: "f1ry2q4s",
			Bni0232: "f1gxfet"
		},
		brand: {
			Bjyk6c5: "fnrv5e1",
			Bp15pi3: "fjsqi2x",
			Glksuk: "frrwqtn",
			Bay5ve9: "f9atwx8",
			Blzl0y7: "fmmpig5",
			Bni0232: "f1e9f9ku"
		},
		unselectedBrand: {
			Bp15pi3: "f7x02et",
			Bjyk6c5: "f1w4p7kh",
			Bay5ve9: "f1ry2q4s",
			Bni0232: "f1e9f9ku"
		}
	}, {
		d: [
			".f1k6fduh{cursor:pointer;}",
			".fc5wo7j{pointer-events:all;}",
			".f1van5z7{width:var(--spacingHorizontalS);}",
			".f1fkmctz{height:var(--spacingVerticalS);}",
			[".f1f5q0n8{padding:var(--spacingVerticalS) var(--spacingHorizontalS);}", { p: -1 }],
			".f1e4lqlz{box-sizing:content-box;}",
			".f1c21dwh{background-color:var(--colorTransparentBackground);}",
			".fre7gi1{border-top-width:0;}",
			".f1358rze{border-right-width:0;}",
			".f1rvrf73{border-left-width:0;}",
			".fqdk4by{border-bottom-width:0;}",
			".f13zj6fq::after{content:\"\";}",
			".f2gz7yw::after{display:block;}",
			".f1gw3sf2::after{box-sizing:border-box;}",
			[".f1x820d0::after{border-radius:50%;}", { p: -1 }],
			[".fnwf5yv::after{border:none;}", { p: -2 }],
			".foue38v::after{height:var(--spacingVerticalS);}",
			".fi4ui2s::after{width:var(--spacingHorizontalS);}",
			".f1w4p7kh::after{background-color:var(--colorNeutralForeground1);}",
			".fo5b2b9::after{color:var(--colorNeutralForeground1);}",
			[".f71xx7{outline:var(--strokeWidthThin) solid transparent;}", { p: -1 }],
			[".f1j9b7x8[data-fui-focus-visible]{border:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}", { p: -2 }],
			[".f1tdm9ui[data-fui-focus-visible]{margin:calc(-1 * var(--strokeWidthThick));}", { p: -1 }],
			[".f2krc9w[data-fui-focus-visible]{border-radius:var(--borderRadiusMedium);}", { p: -1 }],
			".f7x02et::after{opacity:0.6;}",
			".f1eh74fx{width:var(--spacingHorizontalL);}",
			[".fwku66v{padding:var(--spacingVerticalS) var(--spacingHorizontalXS);}", { p: -1 }],
			[".f71xx7{outline:var(--strokeWidthThin) solid transparent;}", { p: -1 }],
			[".f1j9b7x8[data-fui-focus-visible]{border:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}", { p: -2 }],
			[".f1tdm9ui[data-fui-focus-visible]{margin:calc(-1 * var(--strokeWidthThick));}", { p: -1 }],
			[".f2krc9w[data-fui-focus-visible]{border-radius:var(--borderRadiusMedium);}", { p: -1 }],
			".f1v6lwa2::after{width:var(--spacingHorizontalL);}",
			[".fgm6wgx::after{border-radius:4px;}", { p: -1 }],
			".fnrv5e1::after{background-color:var(--colorCompoundBrandBackground);}",
			".fjsqi2x::after{opacity:1;}"
		],
		m: [
			["@media (forced-colors: active){.f16vizm6::after{forced-color-adjust:none;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fqolsir::after{background-color:white;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fim7wbh::after{mix-blend-mode:difference;}}", { m: "(forced-colors: active)" }]
		],
		h: [
			".f1ry2q4s:hover::after{opacity:0.75;}",
			".frrwqtn:hover::after{background-color:var(--colorCompoundBrandBackgroundHover);}",
			".f9atwx8:hover::after{opacity:1;}"
		],
		a: [
			".f1e9f9ku:active::after{opacity:1;}",
			".f1gxfet:active::after{opacity:0.65;}",
			".fmmpig5:active::after{background-color:var(--colorCompoundBrandBackgroundPressed);}"
		]
	});
	/**
	* Apply styling to the CarouselNavButton slots based on the state
	*/
	const useCarouselNavButtonStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$20();
		const { selected, appearance } = state;
		state.root.className = mergeClasses(carouselNavButtonClassNames.root, styles.root, selected ? styles.rootSelected : styles.rootUnselected, appearance === "brand" && styles.brand, !selected && appearance === "brand" && styles.unselectedBrand, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-carousel/lib/components/CarouselNavButton/CarouselNavButton.js
/**
	* The child element of CarouselNav, a singular button that will set the carousels active value on click.
	*/ const CarouselNavButton = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useCarouselNavButton_unstable(props, ref);
		useCarouselNavButtonStyles_unstable(state);
		useCustomStyleHook("useCarouselNavButtonStyles_unstable")(state);
		return renderCarouselNavButton_unstable(state);
	});
	CarouselNavButton.displayName = "CarouselNavButton";

//#endregion
//#region node_modules/embla-carousel/esm/embla-carousel.esm.js
	function isNumber$1(subject) {
		return typeof subject === "number";
	}
	function isString(subject) {
		return typeof subject === "string";
	}
	function isBoolean(subject) {
		return typeof subject === "boolean";
	}
	function isObject(subject) {
		return Object.prototype.toString.call(subject) === "[object Object]";
	}
	function mathAbs(n) {
		return Math.abs(n);
	}
	function mathSign(n) {
		return Math.sign(n);
	}
	function deltaAbs(valueB, valueA) {
		return mathAbs(valueB - valueA);
	}
	function factorAbs(valueB, valueA) {
		if (valueB === 0 || valueA === 0) return 0;
		if (mathAbs(valueB) <= mathAbs(valueA)) return 0;
		return mathAbs(deltaAbs(mathAbs(valueB), mathAbs(valueA)) / valueB);
	}
	function roundToTwoDecimals(num) {
		return Math.round(num * 100) / 100;
	}
	function arrayKeys(array) {
		return objectKeys(array).map(Number);
	}
	function arrayLast(array) {
		return array[arrayLastIndex(array)];
	}
	function arrayLastIndex(array) {
		return Math.max(0, array.length - 1);
	}
	function arrayIsLastIndex(array, index) {
		return index === arrayLastIndex(array);
	}
	function arrayFromNumber(n, startAt = 0) {
		return Array.from(Array(n), (_, i) => startAt + i);
	}
	function objectKeys(object) {
		return Object.keys(object);
	}
	function objectsMergeDeep(objectA, objectB) {
		return [objectA, objectB].reduce((mergedObjects, currentObject) => {
			objectKeys(currentObject).forEach((key) => {
				const valueA = mergedObjects[key];
				const valueB = currentObject[key];
				mergedObjects[key] = isObject(valueA) && isObject(valueB) ? objectsMergeDeep(valueA, valueB) : valueB;
			});
			return mergedObjects;
		}, {});
	}
	function isMouseEvent(evt, ownerWindow) {
		return typeof ownerWindow.MouseEvent !== "undefined" && evt instanceof ownerWindow.MouseEvent;
	}
	function Alignment(align, viewSize) {
		const predefined = {
			start,
			center,
			end
		};
		function start() {
			return 0;
		}
		function center(n) {
			return end(n) / 2;
		}
		function end(n) {
			return viewSize - n;
		}
		function measure(n, index) {
			if (isString(align)) return predefined[align](n);
			return align(viewSize, n, index);
		}
		return { measure };
	}
	function EventStore() {
		let listeners = [];
		function add(node$1, type, handler, options = { passive: true }) {
			let removeListener;
			if ("addEventListener" in node$1) {
				node$1.addEventListener(type, handler, options);
				removeListener = () => node$1.removeEventListener(type, handler, options);
			} else {
				const legacyMediaQueryList = node$1;
				legacyMediaQueryList.addListener(handler);
				removeListener = () => legacyMediaQueryList.removeListener(handler);
			}
			listeners.push(removeListener);
			return self;
		}
		function clear() {
			listeners = listeners.filter((remove) => remove());
		}
		const self = {
			add,
			clear
		};
		return self;
	}
	function Animations(ownerDocument, ownerWindow, update, render) {
		const documentVisibleHandler = EventStore();
		const fixedTimeStep = 1e3 / 60;
		let lastTimeStamp = null;
		let accumulatedTime = 0;
		let animationId = 0;
		function init() {
			documentVisibleHandler.add(ownerDocument, "visibilitychange", () => {
				if (ownerDocument.hidden) reset();
			});
		}
		function destroy() {
			stop();
			documentVisibleHandler.clear();
		}
		function animate(timeStamp) {
			if (!animationId) return;
			if (!lastTimeStamp) {
				lastTimeStamp = timeStamp;
				update();
				update();
			}
			const timeElapsed = timeStamp - lastTimeStamp;
			lastTimeStamp = timeStamp;
			accumulatedTime += timeElapsed;
			while (accumulatedTime >= fixedTimeStep) {
				update();
				accumulatedTime -= fixedTimeStep;
			}
			render(accumulatedTime / fixedTimeStep);
			if (animationId) animationId = ownerWindow.requestAnimationFrame(animate);
		}
		function start() {
			if (animationId) return;
			animationId = ownerWindow.requestAnimationFrame(animate);
		}
		function stop() {
			ownerWindow.cancelAnimationFrame(animationId);
			lastTimeStamp = null;
			accumulatedTime = 0;
			animationId = 0;
		}
		function reset() {
			lastTimeStamp = null;
			accumulatedTime = 0;
		}
		return {
			init,
			destroy,
			start,
			stop,
			update,
			render
		};
	}
	function Axis(axis, contentDirection) {
		const isRightToLeft = contentDirection === "rtl";
		const isVertical = axis === "y";
		const scroll = isVertical ? "y" : "x";
		const cross = isVertical ? "x" : "y";
		const sign = !isVertical && isRightToLeft ? -1 : 1;
		const startEdge = getStartEdge();
		const endEdge = getEndEdge();
		function measureSize(nodeRect) {
			const { height, width } = nodeRect;
			return isVertical ? height : width;
		}
		function getStartEdge() {
			if (isVertical) return "top";
			return isRightToLeft ? "right" : "left";
		}
		function getEndEdge() {
			if (isVertical) return "bottom";
			return isRightToLeft ? "left" : "right";
		}
		function direction(n) {
			return n * sign;
		}
		return {
			scroll,
			cross,
			startEdge,
			endEdge,
			measureSize,
			direction
		};
	}
	function Limit(min$1 = 0, max$1 = 0) {
		const length$1 = mathAbs(min$1 - max$1);
		function reachedMin(n) {
			return n < min$1;
		}
		function reachedMax(n) {
			return n > max$1;
		}
		function reachedAny(n) {
			return reachedMin(n) || reachedMax(n);
		}
		function constrain(n) {
			if (!reachedAny(n)) return n;
			return reachedMin(n) ? min$1 : max$1;
		}
		function removeOffset(n) {
			if (!length$1) return n;
			return n - length$1 * Math.ceil((n - max$1) / length$1);
		}
		return {
			length: length$1,
			max: max$1,
			min: min$1,
			constrain,
			reachedAny,
			reachedMax,
			reachedMin,
			removeOffset
		};
	}
	function Counter(max$1, start, loop) {
		const { constrain } = Limit(0, max$1);
		const loopEnd = max$1 + 1;
		let counter$3 = withinLimit(start);
		function withinLimit(n) {
			return !loop ? constrain(n) : mathAbs((loopEnd + n) % loopEnd);
		}
		function get() {
			return counter$3;
		}
		function set(n) {
			counter$3 = withinLimit(n);
			return self;
		}
		function add(n) {
			return clone().set(get() + n);
		}
		function clone() {
			return Counter(max$1, get(), loop);
		}
		const self = {
			get,
			set,
			add,
			clone
		};
		return self;
	}
	function DragHandler(axis, rootNode, ownerDocument, ownerWindow, target, dragTracker, location, animation, scrollTo, scrollBody, scrollTarget, index, eventHandler, percentOfView, dragFree, dragThreshold, skipSnaps, baseFriction, watchDrag) {
		const { cross: crossAxis, direction } = axis;
		const focusNodes = [
			"INPUT",
			"SELECT",
			"TEXTAREA"
		];
		const nonPassiveEvent = { passive: false };
		const initEvents = EventStore();
		const dragEvents = EventStore();
		const goToNextThreshold = Limit(50, 225).constrain(percentOfView.measure(20));
		const snapForceBoost = {
			mouse: 300,
			touch: 400
		};
		const freeForceBoost = {
			mouse: 500,
			touch: 600
		};
		const baseSpeed = dragFree ? 43 : 25;
		let isMoving = false;
		let startScroll = 0;
		let startCross = 0;
		let pointerIsDown = false;
		let preventScroll = false;
		let preventClick = false;
		let isMouse = false;
		function init(emblaApi) {
			if (!watchDrag) return;
			function downIfAllowed(evt) {
				if (isBoolean(watchDrag) || watchDrag(emblaApi, evt)) down(evt);
			}
			const node$1 = rootNode;
			initEvents.add(node$1, "dragstart", (evt) => evt.preventDefault(), nonPassiveEvent).add(node$1, "touchmove", () => void 0, nonPassiveEvent).add(node$1, "touchend", () => void 0).add(node$1, "touchstart", downIfAllowed).add(node$1, "mousedown", downIfAllowed).add(node$1, "touchcancel", up).add(node$1, "contextmenu", up).add(node$1, "click", click, true);
		}
		function destroy() {
			initEvents.clear();
			dragEvents.clear();
		}
		function addDragEvents() {
			const node$1 = isMouse ? ownerDocument : rootNode;
			dragEvents.add(node$1, "touchmove", move, nonPassiveEvent).add(node$1, "touchend", up).add(node$1, "mousemove", move, nonPassiveEvent).add(node$1, "mouseup", up);
		}
		function isFocusNode(node$1) {
			const nodeName = node$1.nodeName || "";
			return focusNodes.includes(nodeName);
		}
		function forceBoost() {
			return (dragFree ? freeForceBoost : snapForceBoost)[isMouse ? "mouse" : "touch"];
		}
		function allowedForce(force, targetChanged) {
			const next$1 = index.add(mathSign(force) * -1);
			const baseForce = scrollTarget.byDistance(force, !dragFree).distance;
			if (dragFree || mathAbs(force) < goToNextThreshold) return baseForce;
			if (skipSnaps && targetChanged) return baseForce * .5;
			return scrollTarget.byIndex(next$1.get(), 0).distance;
		}
		function down(evt) {
			const isMouseEvt = isMouseEvent(evt, ownerWindow);
			isMouse = isMouseEvt;
			preventClick = dragFree && isMouseEvt && !evt.buttons && isMoving;
			isMoving = deltaAbs(target.get(), location.get()) >= 2;
			if (isMouseEvt && evt.button !== 0) return;
			if (isFocusNode(evt.target)) return;
			pointerIsDown = true;
			dragTracker.pointerDown(evt);
			scrollBody.useFriction(0).useDuration(0);
			target.set(location);
			addDragEvents();
			startScroll = dragTracker.readPoint(evt);
			startCross = dragTracker.readPoint(evt, crossAxis);
			eventHandler.emit("pointerDown");
		}
		function move(evt) {
			if (!isMouseEvent(evt, ownerWindow) && evt.touches.length >= 2) return up(evt);
			const lastScroll = dragTracker.readPoint(evt);
			const lastCross = dragTracker.readPoint(evt, crossAxis);
			const diffScroll = deltaAbs(lastScroll, startScroll);
			const diffCross = deltaAbs(lastCross, startCross);
			if (!preventScroll && !isMouse) {
				if (!evt.cancelable) return up(evt);
				preventScroll = diffScroll > diffCross;
				if (!preventScroll) return up(evt);
			}
			const diff = dragTracker.pointerMove(evt);
			if (diffScroll > dragThreshold) preventClick = true;
			scrollBody.useFriction(.3).useDuration(.75);
			animation.start();
			target.add(direction(diff));
			evt.preventDefault();
		}
		function up(evt) {
			const targetChanged = scrollTarget.byDistance(0, false).index !== index.get();
			const rawForce = dragTracker.pointerUp(evt) * forceBoost();
			const force = allowedForce(direction(rawForce), targetChanged);
			const forceFactor = factorAbs(rawForce, force);
			const speed = baseSpeed - 10 * forceFactor;
			const friction = baseFriction + forceFactor / 50;
			preventScroll = false;
			pointerIsDown = false;
			dragEvents.clear();
			scrollBody.useDuration(speed).useFriction(friction);
			scrollTo.distance(force, !dragFree);
			isMouse = false;
			eventHandler.emit("pointerUp");
		}
		function click(evt) {
			if (preventClick) {
				evt.stopPropagation();
				evt.preventDefault();
				preventClick = false;
			}
		}
		function pointerDown() {
			return pointerIsDown;
		}
		return {
			init,
			destroy,
			pointerDown
		};
	}
	function DragTracker(axis, ownerWindow) {
		const logInterval = 170;
		let startEvent;
		let lastEvent;
		function readTime(evt) {
			return evt.timeStamp;
		}
		function readPoint(evt, evtAxis) {
			const coord = `client${(evtAxis || axis.scroll) === "x" ? "X" : "Y"}`;
			return (isMouseEvent(evt, ownerWindow) ? evt : evt.touches[0])[coord];
		}
		function pointerDown(evt) {
			startEvent = evt;
			lastEvent = evt;
			return readPoint(evt);
		}
		function pointerMove(evt) {
			const diff = readPoint(evt) - readPoint(lastEvent);
			const expired = readTime(evt) - readTime(startEvent) > logInterval;
			lastEvent = evt;
			if (expired) startEvent = evt;
			return diff;
		}
		function pointerUp(evt) {
			if (!startEvent || !lastEvent) return 0;
			const diffDrag = readPoint(lastEvent) - readPoint(startEvent);
			const diffTime = readTime(evt) - readTime(startEvent);
			const expired = readTime(evt) - readTime(lastEvent) > logInterval;
			const force = diffDrag / diffTime;
			return diffTime && !expired && mathAbs(force) > .1 ? force : 0;
		}
		return {
			pointerDown,
			pointerMove,
			pointerUp,
			readPoint
		};
	}
	function NodeRects() {
		function measure(node$1) {
			const { offsetTop, offsetLeft, offsetWidth, offsetHeight } = node$1;
			return {
				top: offsetTop,
				right: offsetLeft + offsetWidth,
				bottom: offsetTop + offsetHeight,
				left: offsetLeft,
				width: offsetWidth,
				height: offsetHeight
			};
		}
		return { measure };
	}
	function PercentOfView(viewSize) {
		function measure(n) {
			return viewSize * (n / 100);
		}
		return { measure };
	}
	function ResizeHandler(container, eventHandler, ownerWindow, slides, axis, watchResize, nodeRects) {
		const observeNodes = [container].concat(slides);
		let resizeObserver;
		let containerSize;
		let slideSizes = [];
		let destroyed = false;
		function readSize(node$1) {
			return axis.measureSize(nodeRects.measure(node$1));
		}
		function init(emblaApi) {
			if (!watchResize) return;
			containerSize = readSize(container);
			slideSizes = slides.map(readSize);
			function defaultCallback(entries) {
				for (const entry of entries) {
					if (destroyed) return;
					const isContainer = entry.target === container;
					const slideIndex = slides.indexOf(entry.target);
					const lastSize = isContainer ? containerSize : slideSizes[slideIndex];
					if (mathAbs(readSize(isContainer ? container : slides[slideIndex]) - lastSize) >= .5) {
						emblaApi.reInit();
						eventHandler.emit("resize");
						break;
					}
				}
			}
			resizeObserver = new ResizeObserver((entries) => {
				if (isBoolean(watchResize) || watchResize(emblaApi, entries)) defaultCallback(entries);
			});
			ownerWindow.requestAnimationFrame(() => {
				observeNodes.forEach((node$1) => resizeObserver.observe(node$1));
			});
		}
		function destroy() {
			destroyed = true;
			if (resizeObserver) resizeObserver.disconnect();
		}
		return {
			init,
			destroy
		};
	}
	function ScrollBody(location, offsetLocation, previousLocation, target, baseDuration, baseFriction) {
		let scrollVelocity = 0;
		let scrollDirection = 0;
		let scrollDuration = baseDuration;
		let scrollFriction = baseFriction;
		let rawLocation = location.get();
		let rawLocationPrevious = 0;
		function seek() {
			const displacement = target.get() - location.get();
			const isInstant = !scrollDuration;
			let scrollDistance = 0;
			if (isInstant) {
				scrollVelocity = 0;
				previousLocation.set(target);
				location.set(target);
				scrollDistance = displacement;
			} else {
				previousLocation.set(location);
				scrollVelocity += displacement / scrollDuration;
				scrollVelocity *= scrollFriction;
				rawLocation += scrollVelocity;
				location.add(scrollVelocity);
				scrollDistance = rawLocation - rawLocationPrevious;
			}
			scrollDirection = mathSign(scrollDistance);
			rawLocationPrevious = rawLocation;
			return self;
		}
		function settled() {
			return mathAbs(target.get() - offsetLocation.get()) < .001;
		}
		function duration() {
			return scrollDuration;
		}
		function direction() {
			return scrollDirection;
		}
		function velocity() {
			return scrollVelocity;
		}
		function useBaseDuration() {
			return useDuration(baseDuration);
		}
		function useBaseFriction() {
			return useFriction(baseFriction);
		}
		function useDuration(n) {
			scrollDuration = n;
			return self;
		}
		function useFriction(n) {
			scrollFriction = n;
			return self;
		}
		const self = {
			direction,
			duration,
			velocity,
			seek,
			settled,
			useBaseFriction,
			useBaseDuration,
			useFriction,
			useDuration
		};
		return self;
	}
	function ScrollBounds(limit, location, target, scrollBody, percentOfView) {
		const pullBackThreshold = percentOfView.measure(10);
		const edgeOffsetTolerance = percentOfView.measure(50);
		const frictionLimit = Limit(.1, .99);
		let disabled = false;
		function shouldConstrain() {
			if (disabled) return false;
			if (!limit.reachedAny(target.get())) return false;
			if (!limit.reachedAny(location.get())) return false;
			return true;
		}
		function constrain(pointerDown) {
			if (!shouldConstrain()) return;
			const diffToEdge = mathAbs(limit[limit.reachedMin(location.get()) ? "min" : "max"] - location.get());
			const diffToTarget = target.get() - location.get();
			const friction = frictionLimit.constrain(diffToEdge / edgeOffsetTolerance);
			target.subtract(diffToTarget * friction);
			if (!pointerDown && mathAbs(diffToTarget) < pullBackThreshold) {
				target.set(limit.constrain(target.get()));
				scrollBody.useDuration(25).useBaseFriction();
			}
		}
		function toggleActive(active) {
			disabled = !active;
		}
		return {
			shouldConstrain,
			constrain,
			toggleActive
		};
	}
	function ScrollContain(viewSize, contentSize, snapsAligned, containScroll, pixelTolerance) {
		const scrollBounds = Limit(-contentSize + viewSize, 0);
		const snapsBounded = measureBounded();
		const scrollContainLimit = findScrollContainLimit();
		const snapsContained = measureContained();
		function usePixelTolerance(bound, snap) {
			return deltaAbs(bound, snap) <= 1;
		}
		function findScrollContainLimit() {
			const startSnap = snapsBounded[0];
			const endSnap = arrayLast(snapsBounded);
			return Limit(snapsBounded.lastIndexOf(startSnap), snapsBounded.indexOf(endSnap) + 1);
		}
		function measureBounded() {
			return snapsAligned.map((snapAligned, index) => {
				const { min: min$1, max: max$1 } = scrollBounds;
				const snap = scrollBounds.constrain(snapAligned);
				const isFirst = !index;
				const isLast = arrayIsLastIndex(snapsAligned, index);
				if (isFirst) return max$1;
				if (isLast) return min$1;
				if (usePixelTolerance(min$1, snap)) return min$1;
				if (usePixelTolerance(max$1, snap)) return max$1;
				return snap;
			}).map((scrollBound) => parseFloat(scrollBound.toFixed(3)));
		}
		function measureContained() {
			if (contentSize <= viewSize + pixelTolerance) return [scrollBounds.max];
			if (containScroll === "keepSnaps") return snapsBounded;
			const { min: min$1, max: max$1 } = scrollContainLimit;
			return snapsBounded.slice(min$1, max$1);
		}
		return {
			snapsContained,
			scrollContainLimit
		};
	}
	function ScrollLimit(contentSize, scrollSnaps, loop) {
		const max$1 = scrollSnaps[0];
		return { limit: Limit(loop ? max$1 - contentSize : arrayLast(scrollSnaps), max$1) };
	}
	function ScrollLooper(contentSize, limit, location, vectors) {
		const jointSafety = .1;
		const { reachedMin, reachedMax } = Limit(limit.min + jointSafety, limit.max + jointSafety);
		function shouldLoop(direction) {
			if (direction === 1) return reachedMax(location.get());
			if (direction === -1) return reachedMin(location.get());
			return false;
		}
		function loop(direction) {
			if (!shouldLoop(direction)) return;
			const loopDistance = contentSize * (direction * -1);
			vectors.forEach((v) => v.add(loopDistance));
		}
		return { loop };
	}
	function ScrollProgress(limit) {
		const { max: max$1, length: length$1 } = limit;
		function get(n) {
			const currentLocation = n - max$1;
			return length$1 ? currentLocation / -length$1 : 0;
		}
		return { get };
	}
	function ScrollSnaps(axis, alignment, containerRect, slideRects, slidesToScroll) {
		const { startEdge, endEdge } = axis;
		const { groupSlides } = slidesToScroll;
		const alignments = measureSizes().map(alignment.measure);
		const snaps = measureUnaligned();
		const snapsAligned = measureAligned();
		function measureSizes() {
			return groupSlides(slideRects).map((rects) => arrayLast(rects)[endEdge] - rects[0][startEdge]).map(mathAbs);
		}
		function measureUnaligned() {
			return slideRects.map((rect) => containerRect[startEdge] - rect[startEdge]).map((snap) => -mathAbs(snap));
		}
		function measureAligned() {
			return groupSlides(snaps).map((g) => g[0]).map((snap, index) => snap + alignments[index]);
		}
		return {
			snaps,
			snapsAligned
		};
	}
	function SlideRegistry(containSnaps, containScroll, scrollSnaps, scrollContainLimit, slidesToScroll, slideIndexes) {
		const { groupSlides } = slidesToScroll;
		const { min: min$1, max: max$1 } = scrollContainLimit;
		const slideRegistry = createSlideRegistry();
		function createSlideRegistry() {
			const groupedSlideIndexes = groupSlides(slideIndexes);
			const doNotContain = !containSnaps || containScroll === "keepSnaps";
			if (scrollSnaps.length === 1) return [slideIndexes];
			if (doNotContain) return groupedSlideIndexes;
			return groupedSlideIndexes.slice(min$1, max$1).map((group, index, groups) => {
				const isFirst = !index;
				const isLast = arrayIsLastIndex(groups, index);
				if (isFirst) return arrayFromNumber(arrayLast(groups[0]) + 1);
				if (isLast) return arrayFromNumber(arrayLastIndex(slideIndexes) - arrayLast(groups)[0] + 1, arrayLast(groups)[0]);
				return group;
			});
		}
		return { slideRegistry };
	}
	function ScrollTarget(loop, scrollSnaps, contentSize, limit, targetVector) {
		const { reachedAny, removeOffset, constrain } = limit;
		function minDistance(distances) {
			return distances.concat().sort((a, b) => mathAbs(a) - mathAbs(b))[0];
		}
		function findTargetSnap(target) {
			const distance = loop ? removeOffset(target) : constrain(target);
			const { index } = scrollSnaps.map((snap, index$1) => ({
				diff: shortcut(snap - distance, 0),
				index: index$1
			})).sort((d1, d2) => mathAbs(d1.diff) - mathAbs(d2.diff))[0];
			return {
				index,
				distance
			};
		}
		function shortcut(target, direction) {
			const targets = [
				target,
				target + contentSize,
				target - contentSize
			];
			if (!loop) return target;
			if (!direction) return minDistance(targets);
			const matchingTargets = targets.filter((t) => mathSign(t) === direction);
			if (matchingTargets.length) return minDistance(matchingTargets);
			return arrayLast(targets) - contentSize;
		}
		function byIndex(index, direction) {
			return {
				index,
				distance: shortcut(scrollSnaps[index] - targetVector.get(), direction)
			};
		}
		function byDistance(distance, snap) {
			const target = targetVector.get() + distance;
			const { index, distance: targetSnapDistance } = findTargetSnap(target);
			const reachedBound = !loop && reachedAny(target);
			if (!snap || reachedBound) return {
				index,
				distance
			};
			return {
				index,
				distance: distance + shortcut(scrollSnaps[index] - targetSnapDistance, 0)
			};
		}
		return {
			byDistance,
			byIndex,
			shortcut
		};
	}
	function ScrollTo(animation, indexCurrent, indexPrevious, scrollBody, scrollTarget, targetVector, eventHandler) {
		function scrollTo(target) {
			const distanceDiff = target.distance;
			const indexDiff = target.index !== indexCurrent.get();
			targetVector.add(distanceDiff);
			if (distanceDiff) if (scrollBody.duration()) animation.start();
			else {
				animation.update();
				animation.render(1);
				animation.update();
			}
			if (indexDiff) {
				indexPrevious.set(indexCurrent.get());
				indexCurrent.set(target.index);
				eventHandler.emit("select");
			}
		}
		function distance(n, snap) {
			scrollTo(scrollTarget.byDistance(n, snap));
		}
		function index(n, direction) {
			const targetIndex = indexCurrent.clone().set(n);
			scrollTo(scrollTarget.byIndex(targetIndex.get(), direction));
		}
		return {
			distance,
			index
		};
	}
	function SlideFocus(root, slides, slideRegistry, scrollTo, scrollBody, eventStore, eventHandler, watchFocus) {
		const focusListenerOptions = {
			passive: true,
			capture: true
		};
		let lastTabPressTime = 0;
		function init(emblaApi) {
			if (!watchFocus) return;
			function defaultCallback(index) {
				if ((/* @__PURE__ */ new Date()).getTime() - lastTabPressTime > 10) return;
				eventHandler.emit("slideFocusStart");
				root.scrollLeft = 0;
				const group = slideRegistry.findIndex((group$1) => group$1.includes(index));
				if (!isNumber$1(group)) return;
				scrollBody.useDuration(0);
				scrollTo.index(group, 0);
				eventHandler.emit("slideFocus");
			}
			eventStore.add(document, "keydown", registerTabPress, false);
			slides.forEach((slide, slideIndex) => {
				eventStore.add(slide, "focus", (evt) => {
					if (isBoolean(watchFocus) || watchFocus(emblaApi, evt)) defaultCallback(slideIndex);
				}, focusListenerOptions);
			});
		}
		function registerTabPress(event) {
			if (event.code === "Tab") lastTabPressTime = (/* @__PURE__ */ new Date()).getTime();
		}
		return { init };
	}
	function Vector1D(initialValue) {
		let value = initialValue;
		function get() {
			return value;
		}
		function set(n) {
			value = normalizeInput(n);
		}
		function add(n) {
			value += normalizeInput(n);
		}
		function subtract(n) {
			value -= normalizeInput(n);
		}
		function normalizeInput(n) {
			return isNumber$1(n) ? n : n.get();
		}
		return {
			get,
			set,
			add,
			subtract
		};
	}
	function Translate(axis, container) {
		const translate = axis.scroll === "x" ? x : y;
		const containerStyle = container.style;
		let previousTarget = null;
		let disabled = false;
		function x(n) {
			return `translate3d(${n}px,0px,0px)`;
		}
		function y(n) {
			return `translate3d(0px,${n}px,0px)`;
		}
		function to(target) {
			if (disabled) return;
			const newTarget = roundToTwoDecimals(axis.direction(target));
			if (newTarget === previousTarget) return;
			containerStyle.transform = translate(newTarget);
			previousTarget = newTarget;
		}
		function toggleActive(active) {
			disabled = !active;
		}
		function clear() {
			if (disabled) return;
			containerStyle.transform = "";
			if (!container.getAttribute("style")) container.removeAttribute("style");
		}
		return {
			clear,
			to,
			toggleActive
		};
	}
	function SlideLooper(axis, viewSize, contentSize, slideSizes, slideSizesWithGaps, snaps, scrollSnaps, location, slides) {
		const roundingSafety = .5;
		const ascItems = arrayKeys(slideSizesWithGaps);
		const descItems = arrayKeys(slideSizesWithGaps).reverse();
		const loopPoints = startPoints().concat(endPoints());
		function removeSlideSizes(indexes, from$1) {
			return indexes.reduce((a, i) => {
				return a - slideSizesWithGaps[i];
			}, from$1);
		}
		function slidesInGap(indexes, gap$1) {
			return indexes.reduce((a, i) => {
				return removeSlideSizes(a, gap$1) > 0 ? a.concat([i]) : a;
			}, []);
		}
		function findSlideBounds(offset$3) {
			return snaps.map((snap, index) => ({
				start: snap - slideSizes[index] + roundingSafety + offset$3,
				end: snap + viewSize - roundingSafety + offset$3
			}));
		}
		function findLoopPoints(indexes, offset$3, isEndEdge) {
			const slideBounds = findSlideBounds(offset$3);
			return indexes.map((index) => {
				const initial = isEndEdge ? 0 : -contentSize;
				const altered = isEndEdge ? contentSize : 0;
				const boundEdge = isEndEdge ? "end" : "start";
				const loopPoint = slideBounds[index][boundEdge];
				return {
					index,
					loopPoint,
					slideLocation: Vector1D(-1),
					translate: Translate(axis, slides[index]),
					target: () => location.get() > loopPoint ? initial : altered
				};
			});
		}
		function startPoints() {
			const gap$1 = scrollSnaps[0];
			return findLoopPoints(slidesInGap(descItems, gap$1), contentSize, false);
		}
		function endPoints() {
			return findLoopPoints(slidesInGap(ascItems, viewSize - scrollSnaps[0] - 1), -contentSize, true);
		}
		function canLoop() {
			return loopPoints.every(({ index }) => {
				return removeSlideSizes(ascItems.filter((i) => i !== index), viewSize) <= .1;
			});
		}
		function loop() {
			loopPoints.forEach((loopPoint) => {
				const { target, translate, slideLocation } = loopPoint;
				const shiftLocation = target();
				if (shiftLocation === slideLocation.get()) return;
				translate.to(shiftLocation);
				slideLocation.set(shiftLocation);
			});
		}
		function clear() {
			loopPoints.forEach((loopPoint) => loopPoint.translate.clear());
		}
		return {
			canLoop,
			clear,
			loop,
			loopPoints
		};
	}
	function SlidesHandler(container, eventHandler, watchSlides) {
		let mutationObserver;
		let destroyed = false;
		function init(emblaApi) {
			if (!watchSlides) return;
			function defaultCallback(mutations) {
				for (const mutation of mutations) if (mutation.type === "childList") {
					emblaApi.reInit();
					eventHandler.emit("slidesChanged");
					break;
				}
			}
			mutationObserver = new MutationObserver((mutations) => {
				if (destroyed) return;
				if (isBoolean(watchSlides) || watchSlides(emblaApi, mutations)) defaultCallback(mutations);
			});
			mutationObserver.observe(container, { childList: true });
		}
		function destroy() {
			if (mutationObserver) mutationObserver.disconnect();
			destroyed = true;
		}
		return {
			init,
			destroy
		};
	}
	function SlidesInView(container, slides, eventHandler, threshold) {
		const intersectionEntryMap = {};
		let inViewCache = null;
		let notInViewCache = null;
		let intersectionObserver;
		let destroyed = false;
		function init() {
			intersectionObserver = new IntersectionObserver((entries) => {
				if (destroyed) return;
				entries.forEach((entry) => {
					const index = slides.indexOf(entry.target);
					intersectionEntryMap[index] = entry;
				});
				inViewCache = null;
				notInViewCache = null;
				eventHandler.emit("slidesInView");
			}, {
				root: container.parentElement,
				threshold
			});
			slides.forEach((slide) => intersectionObserver.observe(slide));
		}
		function destroy() {
			if (intersectionObserver) intersectionObserver.disconnect();
			destroyed = true;
		}
		function createInViewList(inView) {
			return objectKeys(intersectionEntryMap).reduce((list, slideIndex) => {
				const index = parseInt(slideIndex);
				const { isIntersecting } = intersectionEntryMap[index];
				if (inView && isIntersecting || !inView && !isIntersecting) list.push(index);
				return list;
			}, []);
		}
		function get(inView = true) {
			if (inView && inViewCache) return inViewCache;
			if (!inView && notInViewCache) return notInViewCache;
			const slideIndexes = createInViewList(inView);
			if (inView) inViewCache = slideIndexes;
			if (!inView) notInViewCache = slideIndexes;
			return slideIndexes;
		}
		return {
			init,
			destroy,
			get
		};
	}
	function SlideSizes(axis, containerRect, slideRects, slides, readEdgeGap, ownerWindow) {
		const { measureSize, startEdge, endEdge } = axis;
		const withEdgeGap = slideRects[0] && readEdgeGap;
		const startGap = measureStartGap();
		const endGap = measureEndGap();
		const slideSizes = slideRects.map(measureSize);
		const slideSizesWithGaps = measureWithGaps();
		function measureStartGap() {
			if (!withEdgeGap) return 0;
			const slideRect = slideRects[0];
			return mathAbs(containerRect[startEdge] - slideRect[startEdge]);
		}
		function measureEndGap() {
			if (!withEdgeGap) return 0;
			const style = ownerWindow.getComputedStyle(arrayLast(slides));
			return parseFloat(style.getPropertyValue(`margin-${endEdge}`));
		}
		function measureWithGaps() {
			return slideRects.map((rect, index, rects) => {
				const isFirst = !index;
				const isLast = arrayIsLastIndex(rects, index);
				if (isFirst) return slideSizes[index] + startGap;
				if (isLast) return slideSizes[index] + endGap;
				return rects[index + 1][startEdge] - rect[startEdge];
			}).map(mathAbs);
		}
		return {
			slideSizes,
			slideSizesWithGaps,
			startGap,
			endGap
		};
	}
	function SlidesToScroll(axis, viewSize, slidesToScroll, loop, containerRect, slideRects, startGap, endGap, pixelTolerance) {
		const { startEdge, endEdge, direction } = axis;
		const groupByNumber = isNumber$1(slidesToScroll);
		function byNumber(array, groupSize) {
			return arrayKeys(array).filter((i) => i % groupSize === 0).map((i) => array.slice(i, i + groupSize));
		}
		function bySize(array) {
			if (!array.length) return [];
			return arrayKeys(array).reduce((groups, rectB, index) => {
				const rectA = arrayLast(groups) || 0;
				const isFirst = rectA === 0;
				const isLast = rectB === arrayLastIndex(array);
				const edgeA = containerRect[startEdge] - slideRects[rectA][startEdge];
				const edgeB = containerRect[startEdge] - slideRects[rectB][endEdge];
				const gapA = !loop && isFirst ? direction(startGap) : 0;
				const chunkSize = mathAbs(edgeB - (!loop && isLast ? direction(endGap) : 0) - (edgeA + gapA));
				if (index && chunkSize > viewSize + pixelTolerance) groups.push(rectB);
				if (isLast) groups.push(array.length);
				return groups;
			}, []).map((currentSize, index, groups) => {
				const previousSize = Math.max(groups[index - 1] || 0);
				return array.slice(previousSize, currentSize);
			});
		}
		function groupSlides(array) {
			return groupByNumber ? byNumber(array, slidesToScroll) : bySize(array);
		}
		return { groupSlides };
	}
	function Engine(root, container, slides, ownerDocument, ownerWindow, options, eventHandler) {
		const { align, axis: scrollAxis, direction, startIndex, loop, duration, dragFree, dragThreshold, inViewThreshold, slidesToScroll: groupSlides, skipSnaps, containScroll, watchResize, watchSlides, watchDrag, watchFocus } = options;
		const pixelTolerance = 2;
		const nodeRects = NodeRects();
		const containerRect = nodeRects.measure(container);
		const slideRects = slides.map(nodeRects.measure);
		const axis = Axis(scrollAxis, direction);
		const viewSize = axis.measureSize(containerRect);
		const percentOfView = PercentOfView(viewSize);
		const alignment = Alignment(align, viewSize);
		const containSnaps = !loop && !!containScroll;
		const { slideSizes, slideSizesWithGaps, startGap, endGap } = SlideSizes(axis, containerRect, slideRects, slides, loop || !!containScroll, ownerWindow);
		const slidesToScroll = SlidesToScroll(axis, viewSize, groupSlides, loop, containerRect, slideRects, startGap, endGap, pixelTolerance);
		const { snaps, snapsAligned } = ScrollSnaps(axis, alignment, containerRect, slideRects, slidesToScroll);
		const contentSize = -arrayLast(snaps) + arrayLast(slideSizesWithGaps);
		const { snapsContained, scrollContainLimit } = ScrollContain(viewSize, contentSize, snapsAligned, containScroll, pixelTolerance);
		const scrollSnaps = containSnaps ? snapsContained : snapsAligned;
		const { limit } = ScrollLimit(contentSize, scrollSnaps, loop);
		const index = Counter(arrayLastIndex(scrollSnaps), startIndex, loop);
		const indexPrevious = index.clone();
		const slideIndexes = arrayKeys(slides);
		const update = ({ dragHandler, scrollBody: scrollBody$1, scrollBounds, options: { loop: loop$1 } }) => {
			if (!loop$1) scrollBounds.constrain(dragHandler.pointerDown());
			scrollBody$1.seek();
		};
		const render = ({ scrollBody: scrollBody$1, translate, location: location$1, offsetLocation: offsetLocation$1, previousLocation: previousLocation$1, scrollLooper, slideLooper, dragHandler, animation: animation$1, eventHandler: eventHandler$1, scrollBounds, options: { loop: loop$1 } }, alpha) => {
			const shouldSettle = scrollBody$1.settled();
			const withinBounds = !scrollBounds.shouldConstrain();
			const hasSettled = loop$1 ? shouldSettle : shouldSettle && withinBounds;
			const hasSettledAndIdle = hasSettled && !dragHandler.pointerDown();
			if (hasSettledAndIdle) animation$1.stop();
			const interpolatedLocation = location$1.get() * alpha + previousLocation$1.get() * (1 - alpha);
			offsetLocation$1.set(interpolatedLocation);
			if (loop$1) {
				scrollLooper.loop(scrollBody$1.direction());
				slideLooper.loop();
			}
			translate.to(offsetLocation$1.get());
			if (hasSettledAndIdle) eventHandler$1.emit("settle");
			if (!hasSettled) eventHandler$1.emit("scroll");
		};
		const animation = Animations(ownerDocument, ownerWindow, () => update(engine), (alpha) => render(engine, alpha));
		const friction = .68;
		const startLocation = scrollSnaps[index.get()];
		const location = Vector1D(startLocation);
		const previousLocation = Vector1D(startLocation);
		const offsetLocation = Vector1D(startLocation);
		const target = Vector1D(startLocation);
		const scrollBody = ScrollBody(location, offsetLocation, previousLocation, target, duration, friction);
		const scrollTarget = ScrollTarget(loop, scrollSnaps, contentSize, limit, target);
		const scrollTo = ScrollTo(animation, index, indexPrevious, scrollBody, scrollTarget, target, eventHandler);
		const scrollProgress = ScrollProgress(limit);
		const eventStore = EventStore();
		const slidesInView = SlidesInView(container, slides, eventHandler, inViewThreshold);
		const { slideRegistry } = SlideRegistry(containSnaps, containScroll, scrollSnaps, scrollContainLimit, slidesToScroll, slideIndexes);
		const slideFocus = SlideFocus(root, slides, slideRegistry, scrollTo, scrollBody, eventStore, eventHandler, watchFocus);
		const engine = {
			ownerDocument,
			ownerWindow,
			eventHandler,
			containerRect,
			slideRects,
			animation,
			axis,
			dragHandler: DragHandler(axis, root, ownerDocument, ownerWindow, target, DragTracker(axis, ownerWindow), location, animation, scrollTo, scrollBody, scrollTarget, index, eventHandler, percentOfView, dragFree, dragThreshold, skipSnaps, friction, watchDrag),
			eventStore,
			percentOfView,
			index,
			indexPrevious,
			limit,
			location,
			offsetLocation,
			previousLocation,
			options,
			resizeHandler: ResizeHandler(container, eventHandler, ownerWindow, slides, axis, watchResize, nodeRects),
			scrollBody,
			scrollBounds: ScrollBounds(limit, offsetLocation, target, scrollBody, percentOfView),
			scrollLooper: ScrollLooper(contentSize, limit, offsetLocation, [
				location,
				offsetLocation,
				previousLocation,
				target
			]),
			scrollProgress,
			scrollSnapList: scrollSnaps.map(scrollProgress.get),
			scrollSnaps,
			scrollTarget,
			scrollTo,
			slideLooper: SlideLooper(axis, viewSize, contentSize, slideSizes, slideSizesWithGaps, snaps, scrollSnaps, offsetLocation, slides),
			slideFocus,
			slidesHandler: SlidesHandler(container, eventHandler, watchSlides),
			slidesInView,
			slideIndexes,
			slideRegistry,
			slidesToScroll,
			target,
			translate: Translate(axis, container)
		};
		return engine;
	}
	function EventHandler() {
		let listeners = {};
		let api;
		function init(emblaApi) {
			api = emblaApi;
		}
		function getListeners(evt) {
			return listeners[evt] || [];
		}
		function emit(evt) {
			getListeners(evt).forEach((e) => e(api, evt));
			return self;
		}
		function on(evt, cb) {
			listeners[evt] = getListeners(evt).concat([cb]);
			return self;
		}
		function off(evt, cb) {
			listeners[evt] = getListeners(evt).filter((e) => e !== cb);
			return self;
		}
		function clear() {
			listeners = {};
		}
		const self = {
			init,
			emit,
			off,
			on,
			clear
		};
		return self;
	}
	const defaultOptions$1 = {
		align: "center",
		axis: "x",
		container: null,
		slides: null,
		containScroll: "trimSnaps",
		direction: "ltr",
		slidesToScroll: 1,
		inViewThreshold: 0,
		breakpoints: {},
		dragFree: false,
		dragThreshold: 10,
		loop: false,
		skipSnaps: false,
		duration: 25,
		startIndex: 0,
		active: true,
		watchDrag: true,
		watchResize: true,
		watchSlides: true,
		watchFocus: true
	};
	function OptionsHandler(ownerWindow) {
		function mergeOptions(optionsA, optionsB) {
			return objectsMergeDeep(optionsA, optionsB || {});
		}
		function optionsAtMedia(options) {
			const optionsAtMedia$1 = options.breakpoints || {};
			return mergeOptions(options, objectKeys(optionsAtMedia$1).filter((media) => ownerWindow.matchMedia(media).matches).map((media) => optionsAtMedia$1[media]).reduce((a, mediaOption) => mergeOptions(a, mediaOption), {}));
		}
		function optionsMediaQueries(optionsList) {
			return optionsList.map((options) => objectKeys(options.breakpoints || {})).reduce((acc, mediaQueries) => acc.concat(mediaQueries), []).map(ownerWindow.matchMedia);
		}
		return {
			mergeOptions,
			optionsAtMedia,
			optionsMediaQueries
		};
	}
	function PluginsHandler(optionsHandler) {
		let activePlugins = [];
		function init(emblaApi, plugins) {
			activePlugins = plugins.filter(({ options }) => optionsHandler.optionsAtMedia(options).active !== false);
			activePlugins.forEach((plugin) => plugin.init(emblaApi, optionsHandler));
			return plugins.reduce((map, plugin) => Object.assign(map, { [plugin.name]: plugin }), {});
		}
		function destroy() {
			activePlugins = activePlugins.filter((plugin) => plugin.destroy());
		}
		return {
			init,
			destroy
		};
	}
	function EmblaCarousel(root, userOptions, userPlugins) {
		const ownerDocument = root.ownerDocument;
		const ownerWindow = ownerDocument.defaultView;
		const optionsHandler = OptionsHandler(ownerWindow);
		const pluginsHandler = PluginsHandler(optionsHandler);
		const mediaHandlers = EventStore();
		const eventHandler = EventHandler();
		const { mergeOptions, optionsAtMedia, optionsMediaQueries } = optionsHandler;
		const { on, off, emit } = eventHandler;
		const reInit = reActivate;
		let destroyed = false;
		let engine;
		let optionsBase = mergeOptions(defaultOptions$1, EmblaCarousel.globalOptions);
		let options = mergeOptions(optionsBase);
		let pluginList = [];
		let pluginApis;
		let container;
		let slides;
		function storeElements() {
			const { container: userContainer, slides: userSlides } = options;
			container = (isString(userContainer) ? root.querySelector(userContainer) : userContainer) || root.children[0];
			const customSlides = isString(userSlides) ? container.querySelectorAll(userSlides) : userSlides;
			slides = [].slice.call(customSlides || container.children);
		}
		function createEngine(options$1) {
			const engine$1 = Engine(root, container, slides, ownerDocument, ownerWindow, options$1, eventHandler);
			if (options$1.loop && !engine$1.slideLooper.canLoop()) return createEngine(Object.assign({}, options$1, { loop: false }));
			return engine$1;
		}
		function activate(withOptions, withPlugins) {
			if (destroyed) return;
			optionsBase = mergeOptions(optionsBase, withOptions);
			options = optionsAtMedia(optionsBase);
			pluginList = withPlugins || pluginList;
			storeElements();
			engine = createEngine(options);
			optionsMediaQueries([optionsBase, ...pluginList.map(({ options: options$1 }) => options$1)]).forEach((query) => mediaHandlers.add(query, "change", reActivate));
			if (!options.active) return;
			engine.translate.to(engine.location.get());
			engine.animation.init();
			engine.slidesInView.init();
			engine.slideFocus.init(self);
			engine.eventHandler.init(self);
			engine.resizeHandler.init(self);
			engine.slidesHandler.init(self);
			if (engine.options.loop) engine.slideLooper.loop();
			if (container.offsetParent && slides.length) engine.dragHandler.init(self);
			pluginApis = pluginsHandler.init(self, pluginList);
		}
		function reActivate(withOptions, withPlugins) {
			const startIndex = selectedScrollSnap();
			deActivate();
			activate(mergeOptions({ startIndex }, withOptions), withPlugins);
			eventHandler.emit("reInit");
		}
		function deActivate() {
			engine.dragHandler.destroy();
			engine.eventStore.clear();
			engine.translate.clear();
			engine.slideLooper.clear();
			engine.resizeHandler.destroy();
			engine.slidesHandler.destroy();
			engine.slidesInView.destroy();
			engine.animation.destroy();
			pluginsHandler.destroy();
			mediaHandlers.clear();
		}
		function destroy() {
			if (destroyed) return;
			destroyed = true;
			mediaHandlers.clear();
			deActivate();
			eventHandler.emit("destroy");
			eventHandler.clear();
		}
		function scrollTo(index, jump, direction) {
			if (!options.active || destroyed) return;
			engine.scrollBody.useBaseFriction().useDuration(jump === true ? 0 : options.duration);
			engine.scrollTo.index(index, direction || 0);
		}
		function scrollNext(jump) {
			scrollTo(engine.index.add(1).get(), jump, -1);
		}
		function scrollPrev(jump) {
			scrollTo(engine.index.add(-1).get(), jump, 1);
		}
		function canScrollNext() {
			return engine.index.add(1).get() !== selectedScrollSnap();
		}
		function canScrollPrev() {
			return engine.index.add(-1).get() !== selectedScrollSnap();
		}
		function scrollSnapList() {
			return engine.scrollSnapList;
		}
		function scrollProgress() {
			return engine.scrollProgress.get(engine.offsetLocation.get());
		}
		function selectedScrollSnap() {
			return engine.index.get();
		}
		function previousScrollSnap() {
			return engine.indexPrevious.get();
		}
		function slidesInView() {
			return engine.slidesInView.get();
		}
		function slidesNotInView() {
			return engine.slidesInView.get(false);
		}
		function plugins() {
			return pluginApis;
		}
		function internalEngine() {
			return engine;
		}
		function rootNode() {
			return root;
		}
		function containerNode() {
			return container;
		}
		function slideNodes() {
			return slides;
		}
		const self = {
			canScrollNext,
			canScrollPrev,
			containerNode,
			internalEngine,
			destroy,
			off,
			on,
			emit,
			plugins,
			previousScrollSnap,
			reInit,
			rootNode,
			scrollNext,
			scrollPrev,
			scrollProgress,
			scrollSnapList,
			scrollTo,
			selectedScrollSnap,
			slideNodes,
			slidesInView,
			slidesNotInView
		};
		activate(userOptions, userPlugins);
		setTimeout(() => eventHandler.emit("init"), 0);
		return self;
	}
	EmblaCarousel.globalOptions = void 0;

//#endregion
//#region node_modules/@fluentui/react-carousel/lib/components/CarouselCard/useCarouselCardStyles.styles.js
	const carouselCardClassNames = { root: "fui-CarouselCard" };
	/**
	* Styles for the root slot
	*/
	const useStyles$19 = /* @__PURE__ */ __styles({
		root: {
			xawz: 0,
			Bh6795r: 0,
			Bnnss6s: 0,
			fkmc3a: "fg68ejw",
			B2u0y6b: "f6dzj5z"
		},
		autoSize: {
			xawz: 0,
			Bh6795r: 0,
			Bnnss6s: 0,
			fkmc3a: "fd9q35j",
			Bf4jedk: "fy77jfu",
			a9b677: "f14z66ap",
			B2u0y6b: "f6dzj5z"
		},
		elevated: {
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "f1kijzfu",
			E5pizo: "f1hg901r",
			B68tc82: 0,
			Bmxbyg5: 0,
			Bpg54ce: "f1a3p1vp"
		}
	}, { d: [
		[".fg68ejw{flex:0 0 100%;}", { p: -1 }],
		".f6dzj5z{max-width:100%;}",
		[".fd9q35j{flex:0 0 auto;}", { p: -1 }],
		".fy77jfu{min-width:0;}",
		".f14z66ap{width:auto;}",
		[".f1kijzfu{border-radius:var(--borderRadiusXLarge);}", { p: -1 }],
		".f1hg901r{box-shadow:var(--shadow16);}",
		[".f1a3p1vp{overflow:hidden;}", { p: -1 }]
	] });
	/**
	* Apply styling to the CarouselCard slots based on the state
	*/
	const useCarouselCardStyles_unstable = (state) => {
		"use no memo";
		const { autoSize } = state;
		const appearance = useCarouselContext_unstable((context) => context.appearance);
		const styles = useStyles$19();
		state.root.className = mergeClasses(carouselCardClassNames.root, styles.root, appearance === "elevated" && styles.elevated, autoSize && styles.autoSize, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-carousel/lib/components/CarouselSlider/useCarouselSliderStyles.styles.js
	const carouselSliderClassNames = { root: "fui-CarouselSlider" };
	/**
	* Styles for the root slot
	*/
	const useStyles$18 = /* @__PURE__ */ __styles({
		root: {
			mc9l5x: "f22iagw",
			Eiaeu8: "f1115ve7"
		},
		elevated: {
			i8kkvl: 0,
			Belr9w4: 0,
			rmohyg: "f1vkj2z1"
		}
	}, { d: [
		".f22iagw{display:flex;}",
		".f1115ve7{overflow-anchor:none;}",
		[".f1vkj2z1{gap:var(--spacingHorizontalXXL);}", { p: -1 }]
	] });
	/**
	* Apply styling to the CarouselSlider slots based on the state
	*/
	const useCarouselSliderStyles_unstable = (state) => {
		"use no memo";
		const appearance = useCarouselContext_unstable((context) => context.appearance);
		const styles = useStyles$18();
		state.root.className = mergeClasses(carouselSliderClassNames.root, styles.root, appearance === "elevated" && styles.elevated, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/embla-carousel-autoplay/esm/embla-carousel-autoplay.esm.js
	const defaultOptions = {
		active: true,
		breakpoints: {},
		delay: 4e3,
		jump: false,
		playOnInit: true,
		stopOnFocusIn: true,
		stopOnInteraction: true,
		stopOnMouseEnter: false,
		stopOnLastSnap: false,
		rootNode: null
	};
	function normalizeDelay(emblaApi, delay) {
		const scrollSnaps = emblaApi.scrollSnapList();
		if (typeof delay === "number") return scrollSnaps.map(() => delay);
		return delay(scrollSnaps, emblaApi);
	}
	function getAutoplayRootNode(emblaApi, rootNode) {
		const emblaRootNode = emblaApi.rootNode();
		return rootNode && rootNode(emblaRootNode) || emblaRootNode;
	}
	function Autoplay(userOptions = {}) {
		let options;
		let emblaApi;
		let destroyed;
		let delay;
		let timerStartTime = null;
		let timerId = 0;
		let autoplayActive = false;
		let mouseIsOver = false;
		let playOnDocumentVisible = false;
		let jump = false;
		function init(emblaApiInstance, optionsHandler) {
			emblaApi = emblaApiInstance;
			const { mergeOptions, optionsAtMedia } = optionsHandler;
			options = optionsAtMedia(mergeOptions(mergeOptions(defaultOptions, Autoplay.globalOptions), userOptions));
			if (emblaApi.scrollSnapList().length <= 1) return;
			jump = options.jump;
			destroyed = false;
			delay = normalizeDelay(emblaApi, options.delay);
			const { eventStore, ownerDocument } = emblaApi.internalEngine();
			const isDraggable = !!emblaApi.internalEngine().options.watchDrag;
			const root = getAutoplayRootNode(emblaApi, options.rootNode);
			eventStore.add(ownerDocument, "visibilitychange", visibilityChange);
			if (isDraggable) emblaApi.on("pointerDown", pointerDown);
			if (isDraggable && !options.stopOnInteraction) emblaApi.on("pointerUp", pointerUp);
			if (options.stopOnMouseEnter) eventStore.add(root, "mouseenter", mouseEnter);
			if (options.stopOnMouseEnter && !options.stopOnInteraction) eventStore.add(root, "mouseleave", mouseLeave);
			if (options.stopOnFocusIn) emblaApi.on("slideFocusStart", stopAutoplay);
			if (options.stopOnFocusIn && !options.stopOnInteraction) eventStore.add(emblaApi.containerNode(), "focusout", startAutoplay);
			if (options.playOnInit) startAutoplay();
		}
		function destroy() {
			emblaApi.off("pointerDown", pointerDown).off("pointerUp", pointerUp).off("slideFocusStart", stopAutoplay);
			stopAutoplay();
			destroyed = true;
			autoplayActive = false;
		}
		function setTimer() {
			const { ownerWindow } = emblaApi.internalEngine();
			ownerWindow.clearTimeout(timerId);
			timerId = ownerWindow.setTimeout(next$1, delay[emblaApi.selectedScrollSnap()]);
			timerStartTime = (/* @__PURE__ */ new Date()).getTime();
			emblaApi.emit("autoplay:timerset");
		}
		function clearTimer() {
			const { ownerWindow } = emblaApi.internalEngine();
			ownerWindow.clearTimeout(timerId);
			timerId = 0;
			timerStartTime = null;
			emblaApi.emit("autoplay:timerstopped");
		}
		function startAutoplay() {
			if (destroyed) return;
			if (documentIsHidden()) {
				playOnDocumentVisible = true;
				return;
			}
			if (!autoplayActive) emblaApi.emit("autoplay:play");
			setTimer();
			autoplayActive = true;
		}
		function stopAutoplay() {
			if (destroyed) return;
			if (autoplayActive) emblaApi.emit("autoplay:stop");
			clearTimer();
			autoplayActive = false;
		}
		function visibilityChange() {
			if (documentIsHidden()) {
				playOnDocumentVisible = autoplayActive;
				return stopAutoplay();
			}
			if (playOnDocumentVisible) startAutoplay();
		}
		function documentIsHidden() {
			const { ownerDocument } = emblaApi.internalEngine();
			return ownerDocument.visibilityState === "hidden";
		}
		function pointerDown() {
			if (!mouseIsOver) stopAutoplay();
		}
		function pointerUp() {
			if (!mouseIsOver) startAutoplay();
		}
		function mouseEnter() {
			mouseIsOver = true;
			stopAutoplay();
		}
		function mouseLeave() {
			mouseIsOver = false;
			startAutoplay();
		}
		function play(jumpOverride) {
			if (typeof jumpOverride !== "undefined") jump = jumpOverride;
			startAutoplay();
		}
		function stop() {
			if (autoplayActive) stopAutoplay();
		}
		function reset() {
			if (autoplayActive) startAutoplay();
		}
		function isPlaying() {
			return autoplayActive;
		}
		function next$1() {
			const { index } = emblaApi.internalEngine();
			const nextIndex = index.clone().add(1).get();
			const lastIndex$1 = emblaApi.scrollSnapList().length - 1;
			const kill = options.stopOnLastSnap && nextIndex === lastIndex$1;
			if (emblaApi.canScrollNext()) emblaApi.scrollNext(jump);
			else emblaApi.scrollTo(0, jump);
			emblaApi.emit("autoplay:select");
			if (kill) return stopAutoplay();
			startAutoplay();
		}
		function timeUntilNext() {
			if (!timerStartTime) return null;
			return delay[emblaApi.selectedScrollSnap()] - ((/* @__PURE__ */ new Date()).getTime() - timerStartTime);
		}
		return {
			name: "autoplay",
			options: userOptions,
			init,
			destroy,
			play,
			stop,
			reset,
			isPlaying,
			timeUntilNext
		};
	}
	Autoplay.globalOptions = void 0;

//#endregion
//#region node_modules/embla-carousel-fade/esm/embla-carousel-fade.esm.js
	function clampNumber(number, min$1, max$1) {
		return Math.min(Math.max(number, min$1), max$1);
	}
	function isNumber(value) {
		return typeof value === "number" && !isNaN(value);
	}
	function Fade(userOptions = {}) {
		const fullOpacity = 1;
		const noOpacity = 0;
		const fadeFriction = .68;
		let emblaApi;
		let opacities = [];
		let fadeToNextDistance;
		let distanceFromPointerDown = 0;
		let fadeVelocity = 0;
		let progress = 0;
		let shouldFadePair = false;
		let defaultSettledBehaviour;
		let defaultProgressBehaviour;
		function init(emblaApiInstance) {
			emblaApi = emblaApiInstance;
			const selectedSnap = emblaApi.selectedScrollSnap();
			const { scrollBody, containerRect, axis } = emblaApi.internalEngine();
			fadeToNextDistance = clampNumber(axis.measureSize(containerRect) * .75, 200, 500);
			shouldFadePair = false;
			opacities = emblaApi.scrollSnapList().map((_, index) => index === selectedSnap ? fullOpacity : noOpacity);
			defaultSettledBehaviour = scrollBody.settled;
			defaultProgressBehaviour = emblaApi.scrollProgress;
			scrollBody.settled = settled;
			emblaApi.scrollProgress = scrollProgress;
			emblaApi.on("select", select).on("slideFocus", fadeToSelectedSnapInstantly).on("pointerDown", pointerDown).on("pointerUp", pointerUp);
			disableScroll();
			fadeToSelectedSnapInstantly();
		}
		function destroy() {
			const { scrollBody } = emblaApi.internalEngine();
			scrollBody.settled = defaultSettledBehaviour;
			emblaApi.scrollProgress = defaultProgressBehaviour;
			emblaApi.off("select", select).off("slideFocus", fadeToSelectedSnapInstantly).off("pointerDown", pointerDown).off("pointerUp", pointerUp);
			emblaApi.slideNodes().forEach((slideNode) => {
				const slideStyle = slideNode.style;
				slideStyle.opacity = "";
				slideStyle.transform = "";
				slideStyle.pointerEvents = "";
				if (!slideNode.getAttribute("style")) slideNode.removeAttribute("style");
			});
		}
		function fadeToSelectedSnapInstantly() {
			setOpacities(emblaApi.selectedScrollSnap(), fullOpacity);
		}
		function pointerUp() {
			shouldFadePair = false;
		}
		function pointerDown() {
			shouldFadePair = false;
			distanceFromPointerDown = 0;
			fadeVelocity = 0;
		}
		function select() {
			const duration = emblaApi.internalEngine().scrollBody.duration();
			fadeVelocity = duration ? 0 : fullOpacity;
			shouldFadePair = true;
			if (!duration) fadeToSelectedSnapInstantly();
		}
		function getSlideTransform(position$1) {
			const { axis } = emblaApi.internalEngine();
			return `translate${axis.scroll.toUpperCase()}(${axis.direction(position$1)}px)`;
		}
		function disableScroll() {
			const { translate, slideLooper } = emblaApi.internalEngine();
			translate.clear();
			translate.toggleActive(false);
			slideLooper.loopPoints.forEach(({ translate: translate$1 }) => {
				translate$1.clear();
				translate$1.toggleActive(false);
			});
		}
		function lockExcessiveScroll(fadeIndex) {
			const { scrollSnaps, location, target } = emblaApi.internalEngine();
			if (!isNumber(fadeIndex) || opacities[fadeIndex] < .5) return;
			location.set(scrollSnaps[fadeIndex]);
			target.set(location);
		}
		function setOpacities(fadeIndex, velocity) {
			emblaApi.scrollSnapList().forEach((_, indexA) => {
				const absVelocity = Math.abs(velocity);
				const currentOpacity = opacities[indexA];
				const isFadeIndex = indexA === fadeIndex;
				const clampedOpacity = clampNumber(isFadeIndex ? currentOpacity + absVelocity : currentOpacity - absVelocity, noOpacity, fullOpacity);
				opacities[indexA] = clampedOpacity;
				const fadePair = isFadeIndex && shouldFadePair;
				const indexB = emblaApi.previousScrollSnap();
				if (fadePair) opacities[indexB] = 1 - clampedOpacity;
				if (isFadeIndex) setProgress(fadeIndex, clampedOpacity);
				setOpacity(indexA);
			});
		}
		function setOpacity(index) {
			const slidesInSnap = emblaApi.internalEngine().slideRegistry[index];
			const { scrollSnaps, containerRect } = emblaApi.internalEngine();
			const opacity = opacities[index];
			slidesInSnap.forEach((slideIndex) => {
				const slideStyle = emblaApi.slideNodes()[slideIndex].style;
				const roundedOpacity = parseFloat(opacity.toFixed(2));
				const hasOpacity = roundedOpacity > noOpacity;
				const transform = getSlideTransform(hasOpacity ? scrollSnaps[index] : containerRect.width + 2);
				if (hasOpacity) slideStyle.transform = transform;
				slideStyle.opacity = roundedOpacity.toString();
				slideStyle.pointerEvents = opacity > .5 ? "auto" : "none";
				if (!hasOpacity) slideStyle.transform = transform;
			});
		}
		function setProgress(fadeIndex, opacity) {
			const { index, dragHandler, scrollSnaps } = emblaApi.internalEngine();
			const pointerDown$1 = dragHandler.pointerDown();
			const snapFraction = 1 / (scrollSnaps.length - 1);
			let indexA = fadeIndex;
			let indexB = pointerDown$1 ? emblaApi.selectedScrollSnap() : emblaApi.previousScrollSnap();
			if (pointerDown$1 && indexA === indexB) {
				const reverseSign = Math.sign(distanceFromPointerDown) * -1;
				indexA = indexB;
				indexB = index.clone().set(indexB).add(reverseSign).get();
			}
			progress = indexB * snapFraction + (indexA - indexB) * snapFraction * opacity;
		}
		function getFadeIndex() {
			const { dragHandler, index, scrollBody } = emblaApi.internalEngine();
			const selectedSnap = emblaApi.selectedScrollSnap();
			if (!dragHandler.pointerDown()) return selectedSnap;
			const directionSign = Math.sign(scrollBody.velocity());
			const distanceSign = Math.sign(distanceFromPointerDown);
			const nextSnap = index.clone().set(selectedSnap).add(directionSign * -1).get();
			if (!directionSign || !distanceSign) return null;
			return distanceSign === directionSign ? nextSnap : selectedSnap;
		}
		function fade(emblaApi$1) {
			const { dragHandler, scrollBody } = emblaApi$1.internalEngine();
			const pointerDown$1 = dragHandler.pointerDown();
			const velocity = scrollBody.velocity();
			const duration = scrollBody.duration();
			const fadeIndex = getFadeIndex();
			const noFadeIndex = !isNumber(fadeIndex);
			if (pointerDown$1) {
				if (!velocity) return;
				distanceFromPointerDown += velocity;
				fadeVelocity = Math.abs(velocity / fadeToNextDistance);
				lockExcessiveScroll(fadeIndex);
			}
			if (!pointerDown$1) {
				if (!duration || noFadeIndex) return;
				fadeVelocity += (fullOpacity - opacities[fadeIndex]) / duration;
				fadeVelocity *= fadeFriction;
			}
			if (noFadeIndex) return;
			setOpacities(fadeIndex, fadeVelocity);
		}
		function settled() {
			const { target, location } = emblaApi.internalEngine();
			const diffToTarget = target.get() - location.get();
			const notReachedTarget = Math.abs(diffToTarget) >= 1;
			const fadeIndex = getFadeIndex();
			const noFadeIndex = !isNumber(fadeIndex);
			fade(emblaApi);
			if (noFadeIndex || notReachedTarget) return false;
			return opacities[fadeIndex] > .999;
		}
		function scrollProgress() {
			return progress;
		}
		return {
			name: "fade",
			options: userOptions,
			init,
			destroy
		};
	}
	Fade.globalOptions = void 0;

//#endregion
//#region node_modules/@fluentui/react-carousel/lib/components/pointerEvents.js
	function pointerEventPlugin(options) {
		let emblaApi;
		let pointerEvent;
		let carouselListenerTarget;
		/**
		* Heads up!
		*
		* We don't use `emblaApi.on('pointerDown', ...)` as the callback does not provide the event.
		*/ function documentDownListener(event) {
			if (event.target) {
				const targetNode = event.target;
				if (targetNode.classList.contains(carouselClassNames.root) || (carouselListenerTarget === null || carouselListenerTarget === void 0 ? void 0 : carouselListenerTarget.contains(targetNode))) pointerEvent = event;
			}
			if (carouselListenerTarget) {
				carouselListenerTarget.removeEventListener("mousedown", documentDownListener);
				carouselListenerTarget.removeEventListener("pointerdown", documentDownListener);
			}
		}
		function pointerUpListener() {
			if (carouselListenerTarget) {
				carouselListenerTarget.addEventListener("mousedown", documentDownListener);
				carouselListenerTarget.addEventListener("pointerdown", documentDownListener);
			}
		}
		function clearPointerEvent() {
			pointerEvent = void 0;
			pointerUpListener();
		}
		function selectListener() {
			if (pointerEvent) {
				var _emblaApi_selectedScrollSnap;
				const newIndex = (_emblaApi_selectedScrollSnap = emblaApi.selectedScrollSnap()) !== null && _emblaApi_selectedScrollSnap !== void 0 ? _emblaApi_selectedScrollSnap : 0;
				options.onSelectViaDrag(pointerEvent, newIndex);
			}
		}
		function init(emblaApiInstance, optionsHandler) {
			emblaApi = emblaApiInstance;
			carouselListenerTarget = emblaApi.containerNode();
			carouselListenerTarget.addEventListener("mousedown", documentDownListener);
			carouselListenerTarget.addEventListener("pointerdown", documentDownListener);
			emblaApi.on("pointerUp", pointerUpListener);
			emblaApi.on("select", selectListener);
			emblaApi.on("settle", clearPointerEvent);
		}
		function destroy() {
			if (carouselListenerTarget) {
				carouselListenerTarget.removeEventListener("mousedown", documentDownListener);
				carouselListenerTarget.removeEventListener("pointerdown", documentDownListener);
			}
			carouselListenerTarget = void 0;
			emblaApi.off("pointerUp", pointerUpListener);
			emblaApi.off("select", selectListener);
			emblaApi.off("settle", clearPointerEvent);
		}
		return {
			name: "pointerEvent",
			options,
			init,
			destroy
		};
	}

//#endregion
//#region node_modules/@fluentui/react-carousel/lib/components/useEmblaCarousel.js
	const DEFAULT_EMBLA_OPTIONS = {
		containScroll: "trimSnaps",
		inViewThreshold: .99,
		watchDrag: false,
		skipSnaps: true,
		container: `.${carouselSliderClassNames.root}`,
		slides: `.${carouselCardClassNames.root}`
	};
	const EMBLA_VISIBILITY_EVENT = "embla:visibilitychange";
	function setTabsterDefault(element, isDefault) {
		const tabsterAttr = element.getAttribute("data-tabster");
		if (tabsterAttr) {
			const tabsterAttributes = JSON.parse(tabsterAttr);
			if (tabsterAttributes.focusable) {
				tabsterAttributes.focusable.isDefault = isDefault;
				element.setAttribute("data-tabster", JSON.stringify(tabsterAttributes));
			}
		}
	}
	function useEmblaCarousel(options) {
		const { align, autoplayInterval, direction, loop, slidesToScroll, watchDrag, containScroll, motion, onDragIndexChange, onAutoplayIndexChange } = options;
		var _motion_kind;
		const motionType = typeof motion === "string" ? motion : (_motion_kind = motion === null || motion === void 0 ? void 0 : motion.kind) !== null && _motion_kind !== void 0 ? _motion_kind : "slide";
		var _motion_duration;
		const motionDuration = typeof motion === "string" ? 25 : (_motion_duration = motion === null || motion === void 0 ? void 0 : motion.duration) !== null && _motion_duration !== void 0 ? _motion_duration : 25;
		const [activeIndex, setActiveIndex] = useControllableState({
			defaultState: options.defaultActiveIndex,
			state: options.activeIndex,
			initialState: 0
		});
		const onDragEvent = useEventCallback((event, index) => {
			onDragIndexChange === null || onDragIndexChange === void 0 || onDragIndexChange(event, {
				event,
				type: "drag",
				index
			});
		});
		const emblaOptions = react.useRef({
			align,
			direction,
			loop,
			slidesToScroll,
			startIndex: activeIndex,
			watchDrag,
			containScroll,
			duration: motionDuration
		});
		const emblaApi = react.useRef(null);
		const autoplayRef = react.useRef(false);
		const resetAutoplay = react.useCallback(() => {
			var _emblaApi_current_plugins_autoplay, _emblaApi_current;
			(_emblaApi_current = emblaApi.current) === null || _emblaApi_current === void 0 || (_emblaApi_current_plugins_autoplay = _emblaApi_current.plugins().autoplay) == null || _emblaApi_current_plugins_autoplay.reset();
		}, []);
		const getPlugins = react.useCallback(() => {
			const plugins = [];
			plugins.push(Autoplay({
				playOnInit: autoplayRef.current,
				delay: autoplayInterval,
				stopOnInteraction: true,
				stopOnFocusIn: false,
				stopOnMouseEnter: false
			}));
			if (motionType === "fade") plugins.push(Fade());
			if (watchDrag) plugins.push(pointerEventPlugin({ onSelectViaDrag: onDragEvent }));
			return plugins;
		}, [
			motionType,
			onDragEvent,
			watchDrag,
			autoplayInterval
		]);
		const enableAutoplay = react.useCallback((autoplay, temporary) => {
			if (!temporary) autoplayRef.current = autoplay;
			if (autoplay && autoplayRef.current) {
				var _emblaApi_current_plugins_autoplay, _emblaApi_current;
				(_emblaApi_current = emblaApi.current) === null || _emblaApi_current === void 0 || (_emblaApi_current_plugins_autoplay = _emblaApi_current.plugins().autoplay) == null || _emblaApi_current_plugins_autoplay.play();
				resetAutoplay();
			} else if (!autoplay) {
				var _emblaApi_current_plugins_autoplay1, _emblaApi_current1;
				(_emblaApi_current1 = emblaApi.current) === null || _emblaApi_current1 === void 0 || (_emblaApi_current_plugins_autoplay1 = _emblaApi_current1.plugins().autoplay) == null || _emblaApi_current_plugins_autoplay1.stop();
			}
		}, [resetAutoplay]);
		const listeners = react.useRef(/* @__PURE__ */ new Set());
		const subscribeForValues = react.useCallback((listener) => {
			listeners.current.add(listener);
			return () => {
				listeners.current.delete(listener);
			};
		}, []);
		const updateIndex = () => {
			var _emblaApi_current, _emblaApi_current1, _emblaApi_current2, _slideRegistry_newIndex;
			var _emblaApi_current_selectedScrollSnap;
			const newIndex = (_emblaApi_current_selectedScrollSnap = (_emblaApi_current = emblaApi.current) === null || _emblaApi_current === void 0 ? void 0 : _emblaApi_current.selectedScrollSnap()) !== null && _emblaApi_current_selectedScrollSnap !== void 0 ? _emblaApi_current_selectedScrollSnap : 0;
			const slides = (_emblaApi_current1 = emblaApi.current) === null || _emblaApi_current1 === void 0 ? void 0 : _emblaApi_current1.slideNodes();
			const slideRegistry = (_emblaApi_current2 = emblaApi.current) === null || _emblaApi_current2 === void 0 ? void 0 : _emblaApi_current2.internalEngine().slideRegistry;
			var _slideRegistry_newIndex_;
			const actualIndex = (_slideRegistry_newIndex_ = slideRegistry === null || slideRegistry === void 0 ? void 0 : (_slideRegistry_newIndex = slideRegistry[newIndex]) === null || _slideRegistry_newIndex === void 0 ? void 0 : _slideRegistry_newIndex[0]) !== null && _slideRegistry_newIndex_ !== void 0 ? _slideRegistry_newIndex_ : 0;
			slides === null || slides === void 0 || slides.forEach((slide, slideIndex) => {
				setTabsterDefault(slide, slideIndex === actualIndex);
			});
			setActiveIndex(newIndex);
		};
		const handleReinit = useEventCallback(() => {
			var _emblaApi_current, _emblaApi_current1, _emblaApi_current2, _emblaApi_current3, _emblaApi_current4;
			var _emblaApi_current_slideNodes;
			const nodes = (_emblaApi_current_slideNodes = (_emblaApi_current = emblaApi.current) === null || _emblaApi_current === void 0 ? void 0 : _emblaApi_current.slideNodes()) !== null && _emblaApi_current_slideNodes !== void 0 ? _emblaApi_current_slideNodes : [];
			var _emblaApi_current_internalEngine_slideRegistry;
			const groupIndexList = (_emblaApi_current_internalEngine_slideRegistry = (_emblaApi_current1 = emblaApi.current) === null || _emblaApi_current1 === void 0 ? void 0 : _emblaApi_current1.internalEngine().slideRegistry) !== null && _emblaApi_current_internalEngine_slideRegistry !== void 0 ? _emblaApi_current_internalEngine_slideRegistry : [];
			const navItemsCount = groupIndexList.length > 0 ? groupIndexList.length : nodes.length;
			const canLoop = (_emblaApi_current2 = emblaApi.current) === null || _emblaApi_current2 === void 0 ? void 0 : _emblaApi_current2.internalEngine().slideLooper.canLoop();
			var _emblaApi_current_selectedScrollSnap;
			const data = {
				navItemsCount,
				activeIndex: (_emblaApi_current_selectedScrollSnap = (_emblaApi_current3 = emblaApi.current) === null || _emblaApi_current3 === void 0 ? void 0 : _emblaApi_current3.selectedScrollSnap()) !== null && _emblaApi_current_selectedScrollSnap !== void 0 ? _emblaApi_current_selectedScrollSnap : 0,
				groupIndexList,
				slideNodes: nodes,
				canLoop
			};
			updateIndex();
			(_emblaApi_current4 = emblaApi.current) === null || _emblaApi_current4 === void 0 || _emblaApi_current4.scrollTo(activeIndex, false);
			for (const listener of listeners.current) listener(data);
		});
		const handleIndexChange = useEventCallback((_, eventType) => {
			var _emblaApi_current;
			var _emblaApi_current_selectedScrollSnap;
			const newIndex = (_emblaApi_current_selectedScrollSnap = (_emblaApi_current = emblaApi.current) === null || _emblaApi_current === void 0 ? void 0 : _emblaApi_current.selectedScrollSnap()) !== null && _emblaApi_current_selectedScrollSnap !== void 0 ? _emblaApi_current_selectedScrollSnap : 0;
			updateIndex();
			if (eventType === "autoplay:select") {
				const noopEvent = new Event("autoplay");
				onAutoplayIndexChange === null || onAutoplayIndexChange === void 0 || onAutoplayIndexChange(noopEvent, {
					event: noopEvent,
					type: "autoplay",
					index: newIndex
				});
			}
		});
		const viewportRef = react.useRef(null);
		const containerRef = react.useMemo(() => {
			const handleVisibilityChange = () => {
				var _emblaApi_current, _emblaApi_current1;
				const cardElements = (_emblaApi_current = emblaApi.current) === null || _emblaApi_current === void 0 ? void 0 : _emblaApi_current.slideNodes();
				var _emblaApi_current_slidesInView;
				const visibleIndexes = (_emblaApi_current_slidesInView = (_emblaApi_current1 = emblaApi.current) === null || _emblaApi_current1 === void 0 ? void 0 : _emblaApi_current1.slidesInView()) !== null && _emblaApi_current_slidesInView !== void 0 ? _emblaApi_current_slidesInView : [];
				cardElements === null || cardElements === void 0 || cardElements.forEach((cardElement, index) => {
					cardElement.dispatchEvent(new CustomEvent(EMBLA_VISIBILITY_EVENT, {
						bubbles: false,
						detail: { isVisible: visibleIndexes.includes(index) }
					}));
				});
			};
			const plugins = getPlugins();
			return { set current(newElement) {
				if (emblaApi.current) {
					var _emblaApi_current_plugins_autoplay, _emblaApi_current_plugins, _emblaApi_current;
					(_emblaApi_current_plugins = (_emblaApi_current = emblaApi.current).plugins) === null || _emblaApi_current_plugins === void 0 || (_emblaApi_current_plugins_autoplay = _emblaApi_current_plugins.call(_emblaApi_current).autoplay) == null || _emblaApi_current_plugins_autoplay.stop();
					emblaApi.current.off("slidesInView", handleVisibilityChange);
					emblaApi.current.off("select", handleIndexChange);
					emblaApi.current.off("reInit", handleReinit);
					emblaApi.current.off("autoplay:select", handleIndexChange);
					emblaApi.current.destroy();
					emblaApi.current = null;
				}
				if (newElement) {
					var _viewportRef_current;
					const newEmblaApi = EmblaCarousel((_viewportRef_current = viewportRef.current) !== null && _viewportRef_current !== void 0 ? _viewportRef_current : newElement, {
						...DEFAULT_EMBLA_OPTIONS,
						...emblaOptions.current
					}, plugins);
					newEmblaApi.on("reInit", handleReinit);
					newEmblaApi.on("slidesInView", handleVisibilityChange);
					newEmblaApi.on("select", handleIndexChange);
					newEmblaApi.on("autoplay:select", handleIndexChange);
					emblaApi.current = newEmblaApi;
				}
			} };
		}, [
			getPlugins,
			handleIndexChange,
			handleReinit
		]);
		const carouselApi = react.useMemo(() => ({
			scrollToElement: (element, jump) => {
				var _emblaApi_current, _emblaApi_current1, _emblaApi_current2;
				const cardElements = (_emblaApi_current = emblaApi.current) === null || _emblaApi_current === void 0 ? void 0 : _emblaApi_current.slideNodes();
				var _emblaApi_current_internalEngine_slideRegistry;
				const groupIndexList = (_emblaApi_current_internalEngine_slideRegistry = (_emblaApi_current1 = emblaApi.current) === null || _emblaApi_current1 === void 0 ? void 0 : _emblaApi_current1.internalEngine().slideRegistry) !== null && _emblaApi_current_internalEngine_slideRegistry !== void 0 ? _emblaApi_current_internalEngine_slideRegistry : [];
				var _cardElements_indexOf;
				const cardIndex = (_cardElements_indexOf = cardElements === null || cardElements === void 0 ? void 0 : cardElements.indexOf(element)) !== null && _cardElements_indexOf !== void 0 ? _cardElements_indexOf : 0;
				const groupIndex = groupIndexList.findIndex((group) => {
					return group.includes(cardIndex);
				});
				const indexFocus = groupIndex !== null && groupIndex !== void 0 ? groupIndex : cardIndex;
				(_emblaApi_current2 = emblaApi.current) === null || _emblaApi_current2 === void 0 || _emblaApi_current2.scrollTo(indexFocus, jump);
				return indexFocus;
			},
			scrollToIndex: (index, jump) => {
				var _emblaApi_current;
				(_emblaApi_current = emblaApi.current) === null || _emblaApi_current === void 0 || _emblaApi_current.scrollTo(index, jump);
			},
			scrollInDirection: (dir) => {
				var _emblaApi_current;
				if (dir === "prev") {
					var _emblaApi_current1;
					(_emblaApi_current1 = emblaApi.current) === null || _emblaApi_current1 === void 0 || _emblaApi_current1.scrollPrev();
				} else {
					var _emblaApi_current2;
					(_emblaApi_current2 = emblaApi.current) === null || _emblaApi_current2 === void 0 || _emblaApi_current2.scrollNext();
				}
				var _emblaApi_current_selectedScrollSnap;
				return (_emblaApi_current_selectedScrollSnap = (_emblaApi_current = emblaApi.current) === null || _emblaApi_current === void 0 ? void 0 : _emblaApi_current.selectedScrollSnap()) !== null && _emblaApi_current_selectedScrollSnap !== void 0 ? _emblaApi_current_selectedScrollSnap : 0;
			}
		}), []);
		react.useEffect(() => {
			var _emblaApi_current_plugins_autoplay, _emblaApi_current_plugins, _emblaApi_current, _emblaApi_current1;
			const plugins = getPlugins();
			emblaOptions.current = {
				startIndex: emblaOptions.current.startIndex,
				align,
				direction,
				loop,
				slidesToScroll,
				watchDrag,
				containScroll,
				duration: motionDuration
			};
			(_emblaApi_current = emblaApi.current) === null || _emblaApi_current === void 0 || (_emblaApi_current_plugins = _emblaApi_current.plugins) == null || (_emblaApi_current_plugins_autoplay = _emblaApi_current_plugins.call(_emblaApi_current).autoplay) == null || _emblaApi_current_plugins_autoplay.stop();
			(_emblaApi_current1 = emblaApi.current) === null || _emblaApi_current1 === void 0 || _emblaApi_current1.reInit({
				...DEFAULT_EMBLA_OPTIONS,
				...emblaOptions.current
			}, plugins);
		}, [
			align,
			containScroll,
			direction,
			getPlugins,
			loop,
			slidesToScroll,
			watchDrag,
			motionDuration
		]);
		react.useEffect(() => {
			var _emblaApi_current, _emblaApi_current_slideNodes, _emblaApi_current1;
			var _emblaApi_current_selectedScrollSnap;
			const currentActiveIndex = (_emblaApi_current_selectedScrollSnap = (_emblaApi_current = emblaApi.current) === null || _emblaApi_current === void 0 ? void 0 : _emblaApi_current.selectedScrollSnap()) !== null && _emblaApi_current_selectedScrollSnap !== void 0 ? _emblaApi_current_selectedScrollSnap : 0;
			var _emblaApi_current_slideNodes_length;
			const slideLength = (_emblaApi_current_slideNodes_length = (_emblaApi_current1 = emblaApi.current) === null || _emblaApi_current1 === void 0 ? void 0 : (_emblaApi_current_slideNodes = _emblaApi_current1.slideNodes()) === null || _emblaApi_current_slideNodes === void 0 ? void 0 : _emblaApi_current_slideNodes.length) !== null && _emblaApi_current_slideNodes_length !== void 0 ? _emblaApi_current_slideNodes_length : 0;
			emblaOptions.current.startIndex = activeIndex;
			if (activeIndex < slideLength && activeIndex !== currentActiveIndex) {
				var _emblaApi_current2;
				(_emblaApi_current2 = emblaApi.current) === null || _emblaApi_current2 === void 0 || _emblaApi_current2.scrollTo(activeIndex);
			}
		}, [activeIndex]);
		return {
			activeIndex,
			carouselApi,
			viewportRef,
			containerRef,
			subscribeForValues,
			enableAutoplay,
			resetAutoplay
		};
	}

//#endregion
//#region node_modules/@fluentui/react-carousel/lib/components/Carousel/useCarousel.js
/**
	* Create the state required to render Carousel.
	*
	* The returned state can be modified with hooks such as useCarouselStyles_unstable,
	* before being passed to renderCarousel_unstable.
	*
	* @param props - props from this instance of Carousel
	* @param ref - reference to root HTMLDivElement of Carousel
	*/ function useCarousel_unstable(props, ref) {
		"use no memo";
		const { align = "center", circular = false, onActiveIndexChange, groupSize = "auto", draggable = false, whitespace: whitespace$1 = false, announcement, motion = "slide", autoplayInterval = 4e3, appearance = "flat" } = props;
		const { dir } = useFluent();
		const { activeIndex, carouselApi, containerRef, viewportRef, subscribeForValues, enableAutoplay, resetAutoplay } = useEmblaCarousel({
			align,
			direction: dir,
			loop: circular,
			slidesToScroll: groupSize,
			defaultActiveIndex: props.defaultActiveIndex,
			activeIndex: props.activeIndex,
			watchDrag: draggable,
			containScroll: whitespace$1 ? false : "keepSnaps",
			motion,
			onDragIndexChange: onActiveIndexChange,
			onAutoplayIndexChange: onActiveIndexChange,
			autoplayInterval
		});
		const selectPageByElement = useEventCallback((event, element, jump) => {
			const foundIndex = carouselApi.scrollToElement(element, jump);
			onActiveIndexChange === null || onActiveIndexChange === void 0 || onActiveIndexChange(event, {
				event,
				type: "focus",
				index: foundIndex
			});
			return foundIndex;
		});
		const selectPageByIndex = useEventCallback((event, index, jump) => {
			carouselApi.scrollToIndex(index, jump);
			onActiveIndexChange === null || onActiveIndexChange === void 0 || onActiveIndexChange(event, {
				event,
				type: "click",
				index
			});
		});
		const selectPageByDirection = useEventCallback((event, direction) => {
			const nextPageIndex = carouselApi.scrollInDirection(direction);
			onActiveIndexChange === null || onActiveIndexChange === void 0 || onActiveIndexChange(event, {
				event,
				type: "click",
				index: nextPageIndex
			});
			return nextPageIndex;
		});
		const mergedContainerRef = useMergedRefs(ref, containerRef);
		const announcementTextRef = react.useRef("");
		const totalNavLength = react.useRef(0);
		const navGroupRef = react.useRef([]);
		const { announce } = useAnnounce();
		const updateAnnouncement = useEventCallback(() => {
			if (totalNavLength.current <= 0 || !announcement) return;
			const announcementText = announcement(activeIndex, totalNavLength.current, navGroupRef.current);
			if (announcementText !== announcementTextRef.current) {
				announcementTextRef.current = announcementText;
				announce(announcementText, { polite: true });
			}
		});
		useIsomorphicLayoutEffect(() => {
			return subscribeForValues((data) => {
				if (totalNavLength.current <= 0 && data.navItemsCount > 0 && announcement) announcementTextRef.current = announcement(data.activeIndex, data.navItemsCount, data.groupIndexList);
				totalNavLength.current = data.navItemsCount;
				navGroupRef.current = data.groupIndexList;
				updateAnnouncement();
			});
		}, [
			subscribeForValues,
			updateAnnouncement,
			announcement
		]);
		useIsomorphicLayoutEffect(() => {
			updateAnnouncement();
		}, [activeIndex, updateAnnouncement]);
		return {
			components: { root: "div" },
			root: always(getIntrinsicElementProps("div", {
				ref: mergedContainerRef,
				role: "region",
				...props
			}), { elementType: "div" }),
			activeIndex,
			appearance,
			circular,
			containerRef: mergedContainerRef,
			viewportRef,
			selectPageByElement,
			selectPageByDirection,
			selectPageByIndex,
			subscribeForValues,
			enableAutoplay,
			resetAutoplay
		};
	}

//#endregion
//#region node_modules/@fluentui/react-carousel/lib/components/Carousel/renderCarousel.js
/**
	* Render the final JSX of Carousel
	*/ const renderCarousel_unstable = (state, contextValues) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(CarouselProvider, {
			value: contextValues.carousel,
			children: /* @__PURE__ */ jsx(state.root, {})
		});
	};

//#endregion
//#region node_modules/@fluentui/react-carousel/lib/components/Carousel/useCarouselStyles.styles.js
	const carouselClassNames = { root: "fui-Carousel" };
	/**
	* Styles for the root slot
	*/
	const useStyles$17 = /* @__PURE__ */ __styles({
		root: {
			B68tc82: "f1p9o1ba",
			Eiaeu8: "f1115ve7",
			qhf8xq: "f10pi13n"
		},
		elevated: {
			jrapky: 0,
			Frg6f3: 0,
			t21cq0: 0,
			B6of3ja: 0,
			B74szlk: "flfurxc",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f16dxoy8"
		}
	}, { d: [
		".f1p9o1ba{overflow-x:hidden;}",
		".f1115ve7{overflow-anchor:none;}",
		".f10pi13n{position:relative;}",
		[".flfurxc{margin:var(--spacingVerticalL);}", { p: -1 }],
		[".f16dxoy8{padding:var(--spacingVerticalL);}", { p: -1 }]
	] });
	/**
	* Apply styling to the Carousel slots based on the state
	*/
	const useCarouselStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$17();
		const { appearance } = state;
		state.root.className = mergeClasses(carouselClassNames.root, styles.root, appearance === "elevated" && styles.elevated, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-carousel/lib/components/Carousel/useCarouselContextValues.js
	function useCarouselContextValues_unstable(state) {
		const { activeIndex, appearance, selectPageByElement, selectPageByDirection, selectPageByIndex, subscribeForValues, enableAutoplay, resetAutoplay, circular, containerRef, viewportRef } = state;
		return { carousel: react.useMemo(() => ({
			activeIndex,
			appearance,
			selectPageByElement,
			selectPageByDirection,
			selectPageByIndex,
			subscribeForValues,
			enableAutoplay,
			resetAutoplay,
			circular,
			containerRef,
			viewportRef
		}), [
			activeIndex,
			appearance,
			selectPageByElement,
			selectPageByDirection,
			selectPageByIndex,
			subscribeForValues,
			enableAutoplay,
			resetAutoplay,
			circular,
			containerRef,
			viewportRef
		]) };
	}

//#endregion
//#region node_modules/@fluentui/react-carousel/lib/components/Carousel/Carousel.js
/**
	* Carousel is the context wrapper and container for all carousel content/controls,
	* it has no direct style or slot opinions.
	*
	* Carousel also provides API interfaces for callbacks that will occur on navigation events.
	*/ const Carousel = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useCarousel_unstable(props, ref);
		useCarouselStyles_unstable(state);
		useCustomStyleHook("useCarouselStyles_unstable")(state);
		return renderCarousel_unstable(state, useCarouselContextValues_unstable(state));
	});
	Carousel.displayName = "Carousel";

//#endregion
//#region node_modules/@fluentui/react-carousel/lib/components/CarouselSlider/CarouselSliderContext.js
	const carouselSliderContext = react.createContext(void 0);
	const carouselSliderContextDefaultValue = { cardFocus: false };
	const useCarouselSliderContext = () => {
		var _React_useContext;
		return (_React_useContext = react.useContext(carouselSliderContext)) !== null && _React_useContext !== void 0 ? _React_useContext : carouselSliderContextDefaultValue;
	};
	const CarouselSliderContextProvider = carouselSliderContext.Provider;
	function useCarouselSliderContextValues_unstable(state) {
		const { cardFocus } = state;
		return { carouselSlider: react.useMemo(() => ({ cardFocus }), [cardFocus]) };
	}

//#endregion
//#region node_modules/@fluentui/react-carousel/lib/components/CarouselCard/useCarouselCard.js
/**
	* Create the state required to render CarouselCard.
	*
	* The returned state can be modified with hooks such as useCarouselCardStyles_unstable,
	* before being passed to renderCarouselCard_unstable.
	*
	* @param props - props from this instance of CarouselCard
	* @param ref - reference to root HTMLDivElement of CarouselCard
	*/ const useCarouselCard_unstable = (props, ref) => {
		const { autoSize } = props;
		const elementRef = react.useRef(null);
		const isMouseEvent$2 = react.useRef(false);
		const selectPageByElement = useCarouselContext_unstable((ctx) => ctx.selectPageByElement);
		const containerRef = useCarouselContext_unstable((ctx) => ctx.containerRef);
		const { cardFocus } = useCarouselSliderContext();
		const focusAttr = useFocusableGroup({ tabBehavior: "limited" });
		const focusAttrProps = cardFocus ? {
			...focusAttr,
			tabIndex: 0
		} : {};
		const id = useId(carouselCardClassNames.root, props.id);
		react.useEffect(() => {
			const element = elementRef.current;
			if (element) {
				const listener = (_e) => {
					const event = _e;
					if (!cardFocus) {
						const hidden = !event.detail.isVisible;
						element.ariaHidden = hidden.toString();
						element.inert = hidden;
					}
				};
				element.addEventListener(EMBLA_VISIBILITY_EVENT, listener);
				return () => {
					element.removeEventListener(EMBLA_VISIBILITY_EVENT, listener);
				};
			}
		}, [cardFocus]);
		const handleFocus = react.useCallback((e) => {
			if (!e.defaultPrevented && isHTMLElement(e.currentTarget) && !isMouseEvent$2.current) {
				var _containerRef_current;
				containerRef === null || containerRef === void 0 || (_containerRef_current = containerRef.current) == null || _containerRef_current.scrollTo(0, 0);
				selectPageByElement(e, e.currentTarget, false);
			}
			isMouseEvent$2.current = false;
		}, [selectPageByElement, containerRef]);
		const handlePointerDown = (e) => {
			if (!e.defaultPrevented) isMouseEvent$2.current = true;
		};
		const handlePointerUp = (e) => {
			if (!e.defaultPrevented) isMouseEvent$2.current = false;
		};
		const onFocusCapture = mergeCallbacks(props.onFocusCapture, handleFocus);
		const onPointerUp = mergeCallbacks(props.onPointerUp, handlePointerUp);
		const onPointerDown = mergeCallbacks(props.onPointerDown, handlePointerDown);
		return {
			autoSize,
			components: { root: "div" },
			root: always(getIntrinsicElementProps("div", {
				ref: useMergedRefs(elementRef, ref),
				role: "tabpanel",
				tabIndex: cardFocus ? 0 : void 0,
				...props,
				id,
				onFocusCapture,
				onPointerUp,
				onPointerDown,
				...focusAttrProps
			}), { elementType: "div" })
		};
	};

//#endregion
//#region node_modules/@fluentui/react-carousel/lib/components/CarouselCard/renderCarouselCard.js
/**
	* Render the final JSX of CarouselCard
	*/ const renderCarouselCard_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, {});
	};

//#endregion
//#region node_modules/@fluentui/react-carousel/lib/components/CarouselCard/CarouselCard.js
/**
	* The defining wrapper of a carousel's indexed content, they will take up the full
	* viewport of CarouselSlider or div wrapper,
	* users may place multiple items within this Card if desired, with consideration of viewport width.
	*
	* Clickable actions within the content area are available via mouse and tab as expected,
	* non-active card content will be set to inert until moved to active card.
	*/ const CarouselCard = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useCarouselCard_unstable(props, ref);
		useCarouselCardStyles_unstable(state);
		useCustomStyleHook("useCarouselCardStyles_unstable")(state);
		return renderCarouselCard_unstable(state);
	});
	CarouselCard.displayName = "CarouselCard";

//#endregion
//#region node_modules/@fluentui/react-carousel/lib/components/CarouselAutoplayButton/useCarouselAutoplayButton.js
/**
	* Create the state required to render CarouselAutoplayButton.
	*
	* The returned state can be modified with hooks such as useCarouselAutoplayButtonStyles_unstable,
	* before being passed to renderCarouselAutoplayButton_unstable.
	*
	* @param props - props from this instance of CarouselAutoplayButton
	* @param ref - reference to root HTMLDivElement of CarouselAutoplayButton
	*/ const useCarouselAutoplayButton_unstable = (props, ref) => {
		const { onCheckedChange, checked, defaultChecked } = props;
		const [autoplay, setAutoplay] = useControllableState({
			state: checked,
			defaultState: defaultChecked,
			initialState: false
		});
		const enableAutoplay = useCarouselContext_unstable((ctx) => ctx.enableAutoplay);
		react.useEffect(() => {
			enableAutoplay(autoplay);
			return () => {
				enableAutoplay(false);
			};
		}, [autoplay, enableAutoplay]);
		const handleClick = (event) => {
			if (event.isDefaultPrevented()) return;
			const newValue = !autoplay;
			setAutoplay(newValue);
			onCheckedChange === null || onCheckedChange === void 0 || onCheckedChange(event, {
				event,
				type: "click",
				checked: newValue
			});
		};
		return { ...useToggleButton_unstable({
			icon: optional(props.icon, {
				defaultProps: { children: autoplay ? /* @__PURE__ */ react.createElement(PauseCircleRegular, null) : /* @__PURE__ */ react.createElement(PlayCircleRegular, null) },
				renderByDefault: true,
				elementType: "span"
			}),
			...props,
			checked: autoplay,
			onClick: useEventCallback(mergeCallbacks(handleClick, props.onClick))
		}, ref) };
	};

//#endregion
//#region node_modules/@fluentui/react-carousel/lib/components/CarouselAutoplayButton/renderCarouselAutoplayButton.js
/**
	* Render the final JSX of CarouselAutoplayButton
	*/ const renderCarouselAutoplayButton_unstable = (state) => {
		assertSlots(state);
		return renderButton_unstable(state);
	};

//#endregion
//#region node_modules/@fluentui/react-carousel/lib/components/CarouselAutoplayButton/useCarouselAutoplayButtonStyles.styles.js
	const carouselAutoplayButtonClassNames = {
		root: "fui-CarouselAutoplayButton",
		icon: "fui-CarouselAutoplayButton__icon"
	};
	/**
	* Styles for the root slot
	*/
	const useStyles$16 = /* @__PURE__ */ __styles({ root: {
		Bkecrkj: "fc5wo7j",
		B6of3ja: "fgr6219",
		jrapky: "f10jk5vf",
		g2u3we: "fghlq4f",
		h3c5rm: ["f1gn591s", "fjscplz"],
		B9xav0g: "fb073pr",
		zhjwy3: ["fjscplz", "f1gn591s"],
		sj55zd: "fkfq4zb",
		De3pzq: "fkfdr9r",
		eoavqd: "f8491dx"
	} }, {
		d: [
			".fc5wo7j{pointer-events:all;}",
			".fgr6219{margin-top:auto;}",
			".f10jk5vf{margin-bottom:auto;}",
			".fghlq4f{border-top-color:var(--colorTransparentStroke);}",
			".f1gn591s{border-right-color:var(--colorTransparentStroke);}",
			".fjscplz{border-left-color:var(--colorTransparentStroke);}",
			".fb073pr{border-bottom-color:var(--colorTransparentStroke);}",
			".fkfq4zb{color:var(--colorNeutralForeground2);}",
			".fkfdr9r{background-color:var(--colorNeutralBackgroundAlpha);}"
		],
		h: [".f8491dx:hover{cursor:pointer;}"]
	});
	/**
	* Apply styling to the CarouselAutoplayButton slots based on the state
	*/
	const useCarouselAutoplayButtonStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$16();
		useToggleButtonStyles_unstable(state);
		state.root.className = mergeClasses(carouselAutoplayButtonClassNames.root, styles.root, state.root.className);
		if (state.icon) state.icon.className = mergeClasses(carouselAutoplayButtonClassNames.icon, state.icon.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-carousel/lib/components/CarouselAutoplayButton/CarouselAutoplayButton.js
/**
	* If the Carousel is on auto-play, the user may opt into pausing the auto-play feature via the
	* CarouselAutoplayButton which must be present for auto-play to be enabled.
	*
	* If CarouselAutoplayButton is present, auto-play will default to true on mount.
	*/ const CarouselAutoplayButton = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useCarouselAutoplayButton_unstable(props, ref);
		useCarouselAutoplayButtonStyles_unstable(state);
		useCustomStyleHook("useCarouselAutoplayButtonStyles_unstable")(state);
		return renderCarouselAutoplayButton_unstable(state);
	});
	CarouselAutoplayButton.displayName = "CarouselAutoplayButton";

//#endregion
//#region node_modules/@fluentui/react-carousel/lib/components/CarouselNavImageButton/useCarouselNavImageButton.js
/**
	* Create the state required to render CarouselNavImageButton.
	*
	* The returned state can be modified with hooks such as useCarouselNavImageButtonStyles_unstable,
	* before being passed to renderCarouselNavImageButton_unstable.
	*
	* @param props - props from this instance of CarouselNavImageButton
	* @param ref - reference to root HTMLButtonElement | HTMLAnchorElement of CarouselNavImageButton
	*/ const useCarouselNavImageButton_unstable = (props, ref) => {
		const { onClick, as = "button" } = props;
		const index = useCarouselNavIndexContext();
		const selectPageByIndex = useCarouselContext_unstable((ctx) => ctx.selectPageByIndex);
		const selected = useCarouselContext_unstable((ctx) => ctx.activeIndex === index);
		const subscribeForValues = useCarouselContext_unstable((ctx) => ctx.subscribeForValues);
		const handleClick = useEventCallback((event) => {
			onClick === null || onClick === void 0 || onClick(event);
			if (!event.defaultPrevented && isHTMLElement(event.target)) selectPageByIndex(event, index);
		});
		const defaultTabProps = useTabsterAttributes({ focusable: { isDefault: selected } });
		const buttonRef = react.useRef(void 0);
		const _carouselButton = always(getIntrinsicElementProps(as, useARIAButtonProps(props.as, props)), {
			elementType: "button",
			defaultProps: {
				ref: useMergedRefs(ref, buttonRef),
				role: "tab",
				type: "button",
				"aria-selected": selected,
				...defaultTabProps
			}
		});
		useIsomorphicLayoutEffect(() => {
			return subscribeForValues((data) => {
				var _data_groupIndexList;
				var _data_groupIndexList_index;
				const _controlledSlideIds = ((_data_groupIndexList_index = (_data_groupIndexList = data.groupIndexList) === null || _data_groupIndexList === void 0 ? void 0 : _data_groupIndexList[index]) !== null && _data_groupIndexList_index !== void 0 ? _data_groupIndexList_index : []).map((slideIndex) => {
					return data.slideNodes[slideIndex].id;
				}).join(" ");
				if (buttonRef.current) buttonRef.current.setAttribute("aria-controls", _controlledSlideIds);
			});
		}, [subscribeForValues, index]);
		_carouselButton.onClick = handleClick;
		return {
			components: {
				root: "button",
				image: "img"
			},
			root: _carouselButton,
			image: always(getIntrinsicElementProps("img", {
				"aria-hidden": true,
				alt: "",
				role: "presentation",
				...props.image
			}), { elementType: "img" }),
			selected
		};
	};

//#endregion
//#region node_modules/@fluentui/react-carousel/lib/components/CarouselNavImageButton/renderCarouselNavImageButton.js
/**
	* Render the final JSX of CarouselNavImageButton
	*/ const renderCarouselNavImageButton_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, { children: /* @__PURE__ */ jsx(state.image, {}) });
	};

//#endregion
//#region node_modules/@fluentui/react-carousel/lib/components/CarouselNavImageButton/useCarouselNavImageButtonStyles.styles.js
	const carouselNavImageButtonClassNames = {
		root: "fui-CarouselNavImageButton",
		image: "fui-CarouselNavImageButton__image"
	};
	/**
	* Styles for the root slot
	*/
	const useStyles$15 = /* @__PURE__ */ __styles({
		root: {
			B7ck84d: "f1e4lqlz",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f1c5fvqg",
			jrapky: 0,
			Frg6f3: 0,
			t21cq0: 0,
			B6of3ja: 0,
			B74szlk: "f186qr3g",
			g2u3we: "fghlq4f",
			h3c5rm: ["f1gn591s", "fjscplz"],
			B9xav0g: "fb073pr",
			zhjwy3: ["fjscplz", "f1gn591s"],
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "fq9zq91",
			a9b677: "feqmc2u",
			Bqenvij: "fbhnoac",
			B68tc82: 0,
			Bmxbyg5: 0,
			Bpg54ce: "f1a3p1vp",
			eoavqd: "f8491dx"
		},
		image: {
			a9b677: "feqmc2u",
			Bqenvij: "fbhnoac",
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "fq9zq91"
		},
		selected: {
			a9b677: "f124akge",
			Bqenvij: "ff2sm71"
		}
	}, {
		d: [
			".f1e4lqlz{box-sizing:content-box;}",
			[".f1c5fvqg{padding:0px;}", { p: -1 }],
			[".f186qr3g{margin:0 var(--spacingHorizontalXS);}", { p: -1 }],
			".fghlq4f{border-top-color:var(--colorTransparentStroke);}",
			".f1gn591s{border-right-color:var(--colorTransparentStroke);}",
			".fjscplz{border-left-color:var(--colorTransparentStroke);}",
			".fb073pr{border-bottom-color:var(--colorTransparentStroke);}",
			[".fq9zq91{border-radius:var(--borderRadiusSmall);}", { p: -1 }],
			".feqmc2u{width:40px;}",
			".fbhnoac{height:40px;}",
			[".f1a3p1vp{overflow:hidden;}", { p: -1 }],
			[".fq9zq91{border-radius:var(--borderRadiusSmall);}", { p: -1 }],
			".f124akge{width:48px;}",
			".ff2sm71{height:48px;}"
		],
		h: [".f8491dx:hover{cursor:pointer;}"]
	});
	/**
	* Apply styling to the CarouselNavImageButton slots based on the state
	*/
	const useCarouselNavImageButtonStyles_unstable = (state) => {
		"use no memo";
		const { selected } = state;
		const styles = useStyles$15();
		state.root.className = mergeClasses(carouselNavImageButtonClassNames.root, styles.root, selected && styles.selected, state.root.className);
		if (state.image) {
			var _state_image;
			state.image.className = mergeClasses(carouselNavImageButtonClassNames.image, styles.image, selected && styles.selected, (_state_image = state.image) === null || _state_image === void 0 ? void 0 : _state_image.className);
		}
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-carousel/lib/components/CarouselNavImageButton/CarouselNavImageButton.js
/**
	* A variant child element of CarouselNav, a singular image button that displays a
	* preview of card content and will set the carousels active value on click.
	*/ const CarouselNavImageButton = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useCarouselNavImageButton_unstable(props, ref);
		useCarouselNavImageButtonStyles_unstable(state);
		useCustomStyleHook("useCarouselNavImageButtonStyles_unstable")(state);
		return renderCarouselNavImageButton_unstable(state);
	});
	CarouselNavImageButton.displayName = "CarouselNavImageButton";

//#endregion
//#region node_modules/@fluentui/react-carousel/lib/components/CarouselSlider/useCarouselSlider.js
/**
	* Create the state required to render CarouselSlider.
	*
	* The returned state can be modified with hooks such as useCarouselSliderStyles_unstable,
	* before being passed to renderCarouselSlider_unstable.
	*
	* @param props - props from this instance of CarouselSlider
	* @param ref - reference to root HTMLDivElement of CarouselSlider
	*/ const useCarouselSlider_unstable = (props, ref) => {
		const { cardFocus = false } = props;
		const focusableGroupAttr = useArrowNavigationGroup({
			circular: useCarouselContext_unstable((ctx) => ctx.circular),
			axis: "horizontal",
			memorizeCurrent: false,
			unstable_hasDefault: true
		});
		const focusProps = cardFocus ? focusableGroupAttr : {};
		return {
			cardFocus,
			components: { root: "div" },
			root: always(getIntrinsicElementProps("div", {
				ref,
				role: "group",
				...props,
				...focusProps
			}), { elementType: "div" })
		};
	};

//#endregion
//#region node_modules/@fluentui/react-carousel/lib/components/CarouselSlider/renderCarouselSlider.js
/**
	* Render the final JSX of CarouselSlider
	*/ const renderCarouselSlider_unstable = (state, contextValues) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(CarouselSliderContextProvider, {
			value: contextValues.carouselSlider,
			children: /* @__PURE__ */ jsx(state.root, {})
		});
	};

//#endregion
//#region node_modules/@fluentui/react-carousel/lib/components/CarouselSlider/CarouselSlider.js
/**
	* CarouselSlider component - The viewport window that CarouselCards are contained within.
	*/ const CarouselSlider = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useCarouselSlider_unstable(props, ref);
		useCarouselSliderStyles_unstable(state);
		useCustomStyleHook("useCarouselSliderStyles_unstable")(state);
		return renderCarouselSlider_unstable(state, useCarouselSliderContextValues_unstable(state));
	});
	CarouselSlider.displayName = "CarouselSlider";

//#endregion
//#region node_modules/@fluentui/react-carousel/lib/components/CarouselNavContainer/useCarouselNavContainer.js
/**
	* Create the state required to render CarouselNavContainer.
	*
	* The returned state can be modified with hooks such as useCarouselNavContainerStyles_unstable,
	* before being passed to renderCarouselNavContainer_unstable.
	*
	* @param props - props from this instance of CarouselNavContainer
	* @param ref - reference to root HTMLDivElement of CarouselNavContainer
	*/ const useCarouselNavContainer_unstable = (props, ref) => {
		const { layout } = props;
		const next$1 = optional(props.next, {
			defaultProps: { navType: "next" },
			elementType: CarouselButton,
			renderByDefault: true
		});
		const prev$1 = optional(props.prev, {
			defaultProps: { navType: "prev" },
			elementType: CarouselButton,
			renderByDefault: true
		});
		const autoplay = optional(props.autoplay, {
			elementType: CarouselAutoplayButton,
			renderByDefault: !!props.autoplay || !!props.autoplayTooltip
		});
		const nextTooltip = optional(props.nextTooltip, {
			defaultProps: {},
			elementType: Tooltip,
			renderByDefault: false
		});
		const prevTooltip = optional(props.prevTooltip, {
			defaultProps: {},
			elementType: Tooltip,
			renderByDefault: false
		});
		const autoplayTooltip = optional(props.autoplayTooltip, {
			defaultProps: {},
			elementType: Tooltip,
			renderByDefault: false
		});
		return {
			layout,
			components: {
				root: "div",
				next: CarouselButton,
				prev: CarouselButton,
				autoplay: CarouselAutoplayButton,
				nextTooltip: Tooltip,
				prevTooltip: Tooltip,
				autoplayTooltip: Tooltip
			},
			root: always(getIntrinsicElementProps("div", {
				ref,
				...props
			}), { elementType: "div" }),
			next: next$1,
			prev: prev$1,
			autoplay,
			nextTooltip,
			prevTooltip,
			autoplayTooltip
		};
	};

//#endregion
//#region node_modules/@fluentui/react-carousel/lib/components/CarouselNavContainer/renderCarouselNavContainer.js
/**
	* Render the final JSX of CarouselNavContainer
	*/ const renderCarouselNavContainer_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(state.root, { children: [
			!state.autoplayTooltip && state.autoplay && /* @__PURE__ */ jsx(state.autoplay, {}),
			state.autoplayTooltip && state.autoplay && /* @__PURE__ */ jsx(state.autoplayTooltip, { children: /* @__PURE__ */ jsx(state.autoplay, {}) }),
			!state.prevTooltip && state.prev && /* @__PURE__ */ jsx(state.prev, {}),
			state.prevTooltip && state.prev && /* @__PURE__ */ jsx(state.prevTooltip, { children: /* @__PURE__ */ jsx(state.prev, {}) }),
			state.root.children,
			!state.nextTooltip && state.next && /* @__PURE__ */ jsx(state.next, {}),
			state.nextTooltip && state.next && /* @__PURE__ */ jsx(state.nextTooltip, { children: /* @__PURE__ */ jsx(state.next, {}) })
		] });
	};

//#endregion
//#region node_modules/@fluentui/react-carousel/lib/components/CarouselNavContainer/useCarouselNavContainerStyles.styles.js
	const carouselNavContainerClassNames = {
		root: "fui-CarouselNavContainer",
		next: "fui-CarouselNavContainer__next",
		prev: "fui-CarouselNavContainer__prev",
		autoplay: "fui-CarouselNavContainer__autoplay",
		nextTooltip: "fui-CarouselNavContainer__nextTooltip",
		prevTooltip: "fui-CarouselNavContainer__prevTooltip",
		autoplayTooltip: "fui-CarouselNavContainer__autoplayTooltip"
	};
	/**
	* Styles for the root slot
	*/
	const useStyles$14 = /* @__PURE__ */ __styles({
		root: {
			mc9l5x: "f22iagw",
			Beiy3e4: "f1063pyq",
			Brf1p80: "f4d9j23",
			a9b677: "fly5x3f",
			Bkecrkj: "f1aehjj5"
		},
		next: {},
		prev: {},
		autoplay: {},
		inline: { B6of3ja: "f1mevb6" },
		overlay: {
			qhf8xq: "f1euv43f",
			B5kzvoi: "f1bu4tuc",
			B7ck84d: "f1ewtqcl"
		},
		overlayWide: { B5kzvoi: "f1bu4tuc" },
		nextWide: { Frg6f3: ["fcgxt0o", "f1ujusj6"] },
		prevWide: { t21cq0: ["f1ujusj6", "fcgxt0o"] },
		nextOverlayWide: { t21cq0: ["fkujibs", "f199hnxi"] },
		prevOverlayWide: { Frg6f3: ["f199hnxi", "fkujibs"] },
		autoplayOverlayWide: { Frg6f3: ["f199hnxi", "fkujibs"] },
		expanded: {
			a9b677: "fly5x3f",
			Bqenvij: "f1l02sjl",
			Bt984gj: "fgs5rwf",
			Brf1p80: "f4d9j23",
			B5kzvoi: "f1yab3r1",
			c7y7m3: "f1ok8cdc",
			yx0ijg: "fcq6x80",
			v4amzz: "f1gy9d85"
		},
		nextOverlayExpanded: {
			qhf8xq: "f1euv43f",
			j35jbq: ["f8b87gs", "fedtrts"],
			Bhzewxz: "f1i1t8d1",
			Bz10aip: "f188r07x"
		},
		prevOverlayExpanded: {
			qhf8xq: "f1euv43f",
			oyh7mz: ["fedtrts", "f8b87gs"],
			Bhzewxz: "f1i1t8d1",
			Bz10aip: "f188r07x"
		},
		autoplayExpanded: {
			qhf8xq: "f1euv43f",
			B5kzvoi: "f49tsn4",
			oyh7mz: ["fedtrts", "f8b87gs"],
			jrapky: "f18zxyen"
		}
	}, { d: [
		".f22iagw{display:flex;}",
		".f1063pyq{flex-direction:row;}",
		".f4d9j23{justify-content:center;}",
		".fly5x3f{width:100%;}",
		".f1aehjj5{pointer-events:none;}",
		".f1mevb6{margin-top:var(--spacingVerticalM);}",
		".f1euv43f{position:absolute;}",
		".f1bu4tuc{bottom:var(--spacingVerticalM);}",
		".f1ewtqcl{box-sizing:border-box;}",
		".fcgxt0o{margin-left:auto;}",
		".f1ujusj6{margin-right:auto;}",
		".fkujibs{margin-right:var(--spacingHorizontalM);}",
		".f199hnxi{margin-left:var(--spacingHorizontalM);}",
		".f1l02sjl{height:100%;}",
		".fgs5rwf{align-items:flex-end;}",
		".f1yab3r1{bottom:0;}",
		".f1ok8cdc>div{position:relative;}",
		".fcq6x80>div{bottom:var(--spacingVerticalL);}",
		".f1gy9d85>div{margin-bottom:0;}",
		".f8b87gs{right:var(--spacingHorizontalM);}",
		".fedtrts{left:var(--spacingHorizontalM);}",
		".f1i1t8d1{top:50%;}",
		".f188r07x{transform:translateY(-50%);}",
		".f49tsn4{bottom:-var(--spacingHorizontalXS);}",
		".f18zxyen{margin-bottom:var(--spacingVerticalM);}"
	] });
	/**
	* Apply styling to the CarouselNavContainer slots based on the state
	*/
	const useCarouselNavContainerStyles_unstable = (state) => {
		"use no memo";
		const { layout } = state;
		const isOverlay = layout === "overlay" || layout === "overlay-wide" || layout === "overlay-expanded";
		const isWide = layout === "inline-wide" || layout === "overlay-wide";
		const styles = useStyles$14();
		state.root.className = mergeClasses(carouselNavContainerClassNames.root, styles.root, isOverlay ? styles.overlay : styles.inline, isOverlay && isWide && styles.overlayWide, layout === "overlay-expanded" && styles.expanded, state.root.className);
		if (state.next) state.next.className = mergeClasses(carouselNavContainerClassNames.next, styles.next, isWide && styles.nextWide, isWide && isOverlay && styles.nextOverlayWide, layout === "overlay-expanded" && styles.nextOverlayExpanded, state.next.className);
		if (state.prev) state.prev.className = mergeClasses(carouselNavContainerClassNames.prev, styles.prev, isWide && styles.prevWide, !state.autoplay && isWide && isOverlay && styles.prevOverlayWide, layout === "overlay-expanded" && styles.prevOverlayExpanded, state.prev.className);
		if (state.autoplay) state.autoplay.className = mergeClasses(carouselNavContainerClassNames.autoplay, styles.autoplay, layout === "overlay-expanded" && styles.autoplayExpanded, isWide && isOverlay && styles.autoplayOverlayWide, state.autoplay.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-carousel/lib/components/CarouselNavContainer/CarouselNavContainer.js
/**
	* CarouselNavContainer component - This container will provide multiple valid layout options for the underlying carousel controls
	*/ const CarouselNavContainer = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useCarouselNavContainer_unstable(props, ref);
		useCarouselNavContainerStyles_unstable(state);
		useCustomStyleHook("useCarouselNavContainerStyles_unstable")(state);
		return renderCarouselNavContainer_unstable(state);
	});
	CarouselNavContainer.displayName = "CarouselNavContainer";

//#endregion
//#region node_modules/@fluentui/react-carousel/lib/components/CarouselViewport/useCarouselViewport.js
/**
	* Create the state required to render CarouselViewport.
	*
	* The returned state can be modified with hooks such as useCarouselViewportStyles_unstable,
	* before being passed to renderCarouselViewport_unstable.
	*
	* @param props - props from this instance of CarouselViewport
	* @param ref - reference to root HTMLDivElement of CarouselViewport
	*/ const useCarouselViewport_unstable = (props, ref) => {
		const hasFocus = react.useRef(false);
		const hasMouse = react.useRef(false);
		const viewportRef = useCarouselContext_unstable((ctx) => ctx.viewportRef);
		const enableAutoplay = useCarouselContext_unstable((ctx) => ctx.enableAutoplay);
		const handleFocusCapture = react.useCallback(() => {
			hasFocus.current = true;
			enableAutoplay(false, true);
		}, [enableAutoplay]);
		const handleBlurCapture = react.useCallback((e) => {
			if (!e.currentTarget.contains(e.relatedTarget)) {
				hasFocus.current = false;
				if (!hasMouse.current) enableAutoplay(true, true);
			}
		}, [enableAutoplay]);
		const handleMouseEnter = react.useCallback(() => {
			hasMouse.current = true;
			enableAutoplay(false, true);
		}, [enableAutoplay]);
		const handleMouseLeave = react.useCallback(() => {
			hasMouse.current = false;
			if (!hasFocus.current) enableAutoplay(true, true);
		}, [enableAutoplay]);
		const onFocusCapture = mergeCallbacks(props.onFocusCapture, handleFocusCapture);
		const onBlurCapture = mergeCallbacks(props.onBlurCapture, handleBlurCapture);
		const onMouseEnter = mergeCallbacks(props.onMouseEnter, handleMouseEnter);
		const onMouseLeave = mergeCallbacks(props.onMouseLeave, handleMouseLeave);
		return {
			components: { root: "div" },
			root: always(getIntrinsicElementProps("div", {
				ref: useMergedRefs(ref, viewportRef),
				role: "presentation",
				draggable: true,
				...props,
				onFocusCapture,
				onBlurCapture,
				onMouseEnter,
				onMouseLeave
			}), { elementType: "div" })
		};
	};

//#endregion
//#region node_modules/@fluentui/react-carousel/lib/components/CarouselViewport/renderCarouselViewport.js
/**
	* Render the final JSX of CarouselViewport
	*/ const renderCarouselViewport_unstable = (state, contextValues) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(CarouselSliderContextProvider, {
			value: contextValues.carouselSlider,
			children: /* @__PURE__ */ jsx(state.root, {})
		});
	};

//#endregion
//#region node_modules/@fluentui/react-carousel/lib/components/CarouselViewport/useCarouselViewportStyles.styles.js
	const carouselViewportClassNames = { root: "fui-CarouselViewport" };
	/**
	* Styles for the root slot
	*/
	const useStyles$13 = /* @__PURE__ */ __styles({ root: {
		B2u0y6b: "f6dzj5z",
		a9b677: "f14z66ap"
	} }, { d: [".f6dzj5z{max-width:100%;}", ".f14z66ap{width:auto;}"] });
	/**
	* Apply styling to the CarouselViewport slots based on the state
	*/
	const useCarouselViewportStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$13();
		state.root.className = mergeClasses(carouselViewportClassNames.root, styles.root, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-carousel/lib/components/CarouselViewport/CarouselViewport.js
/**
	* CarouselViewport component - TODO: add more docs
	*/ const CarouselViewport = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useCarouselViewport_unstable(props, ref);
		useCarouselViewportStyles_unstable(state);
		useCustomStyleHook("useCarouselViewportStyles_unstable")(state);
		return renderCarouselViewport_unstable(state, useCarouselSliderContextValues_unstable(state));
	});
	CarouselViewport.displayName = "CarouselViewport";

//#endregion
//#region node_modules/@fluentui/react-list/lib/hooks/useListSelection.js
	function useListSelection(options = { selectionMode: "multiselect" }) {
		const { selectionMode, defaultSelectedItems, onSelectionChange } = options;
		const [selectedItems, setSelectedItems] = useControllableState({
			state: options.selectedItems,
			defaultState: defaultSelectedItems,
			initialState: []
		});
		const [selected, selectionMethods] = useSelection({
			selectionMode,
			defaultSelectedItems,
			selectedItems,
			onSelectionChange: (e, data) => {
				setSelectedItems(data.selectedItems);
				onSelectionChange === null || onSelectionChange === void 0 || onSelectionChange(e, data);
			}
		});
		const toggleItem = useEventCallback((e, itemId) => selectionMethods.toggleItem(e, itemId));
		const toggleAllItems = useEventCallback((e, itemIds) => {
			selectionMethods.toggleAllItems(e, itemIds);
		});
		const deselectItem = useEventCallback((e, itemId) => selectionMethods.deselectItem(e, itemId));
		const selectItem = useEventCallback((e, itemId) => selectionMethods.selectItem(e, itemId));
		const clearSelection = useEventCallback((e) => selectionMethods.clearItems(e));
		return {
			selectedItems: react.useMemo(() => Array.from(selected), [selected]),
			toggleItem,
			toggleAllItems,
			deselectItem,
			selectItem,
			setSelectedItems,
			isSelected: (id) => selectionMethods.isSelected(id),
			clearSelection
		};
	}

//#endregion
//#region node_modules/@fluentui/react-list/lib/utils/calculateListRole.js
/**
	* Calculate the role for the list based on the navigation mode and selectable state
	* @param navigationMode - the navigation mode of the list
	* @param selectable - whether the list is selectable
	* @returns 'grid' if navigationMode is 'composite', otherwise 'listbox' if selectable or 'list' if not
	*/ const calculateListRole = (navigationMode, selectable) => {
		if (navigationMode === "composite") return "grid";
		else if (selectable) return "listbox";
		else return "list";
	};

//#endregion
//#region node_modules/@fluentui/react-list/lib/utils/validateProperElementTypes.js
/**
	* Validates that the List and ListItem elements are compatible
	* @param listRenderedAs - the type of the parent element
	* @param listItemRenderedAs - the type of the child element
	*/ function validateProperElementTypes(listRenderedAs, listItemRenderedAs) {
		if (listItemRenderedAs === "div" && listRenderedAs !== "div") throw new Error("ListItem cannot be rendered as a div when its parent is not a div.");
		if (listItemRenderedAs === "li" && listRenderedAs === "div") throw new Error("ListItem cannot be rendered as a li when its parent is a div.");
	}

//#endregion
//#region node_modules/@fluentui/react-list/lib/utils/validateProperRolesAreUsed.js
/**
	* Validate that the proper roles are used for the given combination of roles and states.
	* If the roles are invalid and we're not running in production mode, an warning will be logged to the console.
	*
	* @param role - the role of the list
	* @param listItemRole - the role of the list item
	* @param hasSelection - whether the list has selection enabled
	* @param hasFocusableChildren - whether the list has focusable children
	* @returns
	*/ const validateProperRolesAreUsed = (role, listItemRole, hasSelection, hasFocusableChildren) => {
		if (role === "list" && listItemRole !== "listitem") throw new Error("When the List role is \"list\", ListItem role must be \"listitem\".");
		if (role === "listbox" && listItemRole !== "option") throw new Error("When the List role is \"listbox\", ListItem role must be \"option\".");
		if (role === "grid" && listItemRole !== "row") throw new Error("When the List role is \"grid\", ListItem role must be \"row\".");
		const expectedRole = (() => {
			if (hasFocusableChildren) return "grid";
			else if (hasSelection) return "listbox";
			else return "list";
		})();
		if (role !== expectedRole) console.warn(`@fluentui/react-list [useList]:\nThe role "${role}" does not match the expected role "${expectedRole}".\nPlease use the "navigationMode" property for automatic role assignment and keyboard navigation.\nIf you are using this role intentionally, make sure to verify screen reader support.
    `);
	};

//#endregion
//#region node_modules/@fluentui/react-list/lib/utils/calculateListItemRoleForListRole.js
/**
	* Calculate the role for the list item based on the list role.
	* @param listRole - the role of the list
	* @returns proper role for the list item
	*/ const calculateListItemRoleForListRole = (listRole) => {
		switch (listRole) {
			case "list": return "listitem";
			case "listbox": return "option";
			case "grid": return "row";
			default: return "listitem";
		}
	};

//#endregion
//#region node_modules/@fluentui/react-list/lib/utils/validateGridCellsArePresent.js
/**
	* Validates that grid cells are present in a grid list item. This is necessary for proper screen reader support.
	* If grid cells are not present and we're not running in production mode, a warning will be logged to the console.
	* @param listRole - The role of the list
	* @param listItemEl - The list item element
	* @returns
	*/ const validateGridCellsArePresent = (listRole, listItemEl) => {
		if (listRole !== "grid") return;
		if (listItemEl.querySelectorAll(":scope > [role=\"gridcell\"]").length === 0) console.warn(`@fluentui/react-list [useList]:\nList items in List with "grid" role (which is automatically assigned when navigationMode is set to "composite") must contain at least one "gridcell" as direct child of <ListItem /> for proper screen reader support.`, `Ideally, each focus target should be in it's own "gridcell", which is a direct child of <ListItem />.\n`);
	};

//#endregion
//#region node_modules/@fluentui/react-list/lib/components/List/useList.js
	const DEFAULT_ROOT_EL_TYPE$1 = "ul";
	/**
	* Create the state required to render List.
	*
	* The returned state can be modified with hooks such as useListStyles_unstable,
	* before being passed to renderList_unstable.
	*
	* @param props - props from this instance of List
	* @param ref - reference to root HTMLElement of List
	*/ const useList_unstable = (props, ref) => {
		const { navigationMode, selectionMode, selectedItems, defaultSelectedItems, onSelectionChange } = props;
		const as = props.as || navigationMode === "composite" ? "div" : DEFAULT_ROOT_EL_TYPE$1;
		const arrowNavigationAttributes = useArrowNavigationGroup({
			axis: "vertical",
			memorizeCurrent: true
		});
		const [selectionState, setSelectionState] = useControllableState({
			state: selectedItems,
			defaultState: defaultSelectedItems,
			initialState: []
		});
		const selection = useListSelection({
			onSelectionChange: useEventCallback((e, data) => {
				const selectedItemsAsArray = Array.from(data.selectedItems);
				setSelectionState(selectedItemsAsArray);
				onSelectionChange === null || onSelectionChange === void 0 || onSelectionChange(e, {
					event: e,
					type: "change",
					selectedItems: selectedItemsAsArray
				});
			}),
			selectionMode: selectionMode || "multiselect",
			selectedItems: selectionState
		});
		const listRole = props.role || calculateListRole(navigationMode, !!selectionMode);
		const listItemRole = calculateListItemRoleForListRole(listRole);
		const { findAllFocusable } = useFocusFinders();
		const validateListItem = useEventCallback((listItemEl) => {
			const itemRole = listItemEl.getAttribute("role") || "";
			const focusable = findAllFocusable(listItemEl);
			validateProperElementTypes(as, listItemEl.tagName.toLocaleLowerCase());
			validateProperRolesAreUsed(listRole, itemRole, !!selectionMode, focusable.length > 0);
			validateGridCellsArePresent(listRole, listItemEl);
		});
		return {
			components: { root: as },
			root: always(getIntrinsicElementProps(as, {
				ref,
				role: listRole,
				...selectionMode && { "aria-multiselectable": selectionMode === "multiselect" ? true : void 0 },
				...arrowNavigationAttributes,
				...props
			}), { elementType: as }),
			listItemRole,
			validateListItem,
			navigationMode,
			selection: selectionMode ? selection : void 0
		};
	};

//#endregion
//#region node_modules/@fluentui/react-list/lib/components/List/listContext.js
	const listContextDefaultValue = {
		selection: void 0,
		validateListItem: () => {}
	};
	const listContext = createContext(void 0);
	const ListContextProvider = listContext.Provider;
	const useListContext_unstable = (selector) => useContextSelector(listContext, (ctx = listContextDefaultValue) => selector(ctx));
	const ListSynchronousContext = react.createContext(void 0);
	const ListSynchronousContextProvider = ListSynchronousContext.Provider;
	const useListSynchronousContext = () => react.useContext(ListSynchronousContext) || {
		navigationMode: void 0,
		listItemRole: "listitem"
	};

//#endregion
//#region node_modules/@fluentui/react-list/lib/components/List/renderList.js
/**
	* Render the final JSX of List
	*/ const renderList_unstable = (state, contextValues) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(ListContextProvider, {
			value: contextValues.listContext,
			children: /* @__PURE__ */ jsx(ListSynchronousContextProvider, {
				value: contextValues.synchronousContext,
				children: /* @__PURE__ */ jsx(state.root, {})
			})
		});
	};

//#endregion
//#region node_modules/@fluentui/react-list/lib/components/List/useListStyles.styles.js
	const listClassNames = { root: "fui-List" };
	const useRootBaseStyles$1 = /* @__PURE__ */ __resetStyles("r1m6yby2", null, [".r1m6yby2{padding:0;margin:0;text-indent:0;list-style-type:none;}"]);
	/**
	* Apply styling to the List slots based on the state
	*/
	const useListStyles_unstable = (state) => {
		"use no memo";
		const rootStyles = useRootBaseStyles$1();
		state.root.className = mergeClasses(listClassNames.root, rootStyles, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-list/lib/components/List/useListContextValues.js
	function useListContextValues_unstable(state) {
		const { selection, navigationMode, listItemRole, validateListItem } = state;
		return {
			listContext: {
				selection,
				navigationMode,
				validateListItem
			},
			synchronousContext: react.useMemo(() => ({
				listItemRole,
				navigationMode
			}), [listItemRole, navigationMode])
		};
	}

//#endregion
//#region node_modules/@fluentui/react-list/lib/components/List/List.js
	const List = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useList_unstable(props, ref);
		const contextValues = useListContextValues_unstable(state);
		useListStyles_unstable(state);
		useCustomStyleHook("useListStyles_unstable")(state);
		return renderList_unstable(state, contextValues);
	});
	List.displayName = "List";

//#endregion
//#region node_modules/@fluentui/react-list/lib/events/ListItemActionEvent.js
	const ListItemActionEventName = "ListItemAction";
	const createListItemActionEvent = (originalEvent) => new CustomEvent(ListItemActionEventName, {
		cancelable: true,
		bubbles: true,
		detail: { originalEvent }
	});

//#endregion
//#region node_modules/@fluentui/react-list/lib/components/ListItem/useListItem.js
	const DEFAULT_ROOT_EL_TYPE = "li";
	/**
	* Create the state required to render ListItem.
	*
	* The returned state can be modified with hooks such as useListItemStyles_unstable,
	* before being passed to renderListItem_unstable.
	*
	* @param props - props from this instance of ListItem
	* @param ref - reference to root HTMLLIElement | HTMLDivElementof ListItem
	*/ const useListItem_unstable = (props, ref) => {
		const id = useId("listItem");
		const { value = id, onKeyDown, onClick, tabIndex, role, onAction, disabledSelection } = props;
		const toggleItem = useListContext_unstable((ctx) => {
			var _ctx_selection;
			return (_ctx_selection = ctx.selection) === null || _ctx_selection === void 0 ? void 0 : _ctx_selection.toggleItem;
		});
		const { navigationMode, listItemRole } = useListSynchronousContext();
		const isSelectionModeEnabled = useListContext_unstable((ctx) => !!ctx.selection);
		var _useListContext_unstable;
		const isSelected = (_useListContext_unstable = useListContext_unstable((ctx) => {
			var _ctx_selection;
			return (_ctx_selection = ctx.selection) === null || _ctx_selection === void 0 ? void 0 : _ctx_selection.isSelected(value);
		})) !== null && _useListContext_unstable !== void 0 ? _useListContext_unstable : false;
		const validateListItem = useListContext_unstable((ctx) => ctx.validateListItem);
		const as = props.as || navigationMode === "composite" ? "div" : DEFAULT_ROOT_EL_TYPE;
		const finalListItemRole = role || listItemRole;
		const focusableItems = Boolean(isSelectionModeEnabled || navigationMode || tabIndex === 0);
		const rootRef = react.useRef(null);
		const checkmarkRef = react.useRef(null);
		const handleAction = useEventCallback((event) => {
			onAction === null || onAction === void 0 || onAction(event, {
				event,
				value,
				type: ListItemActionEventName
			});
			if (event.defaultPrevented) return;
			if (isSelectionModeEnabled && !disabledSelection) toggleItem === null || toggleItem === void 0 || toggleItem(event.detail.originalEvent, value);
		});
		react.useEffect(() => {
			if (rootRef.current) validateListItem(rootRef.current);
		}, [validateListItem]);
		const triggerAction = (e) => {
			const actionEvent = createListItemActionEvent(e);
			handleAction(actionEvent);
			e.target.dispatchEvent(actionEvent);
		};
		const focusableGroupAttrs = useFocusableGroup({
			ignoreDefaultKeydown: { Enter: true },
			tabBehavior: "limited-trap-focus"
		});
		const handleClick = useEventCallback((e) => {
			onClick === null || onClick === void 0 || onClick(e);
			if (e.defaultPrevented) return;
			if (elementContains(checkmarkRef.current, e.target)) return;
			triggerAction(e);
		});
		const handleKeyDown = useEventCallback((e) => {
			onKeyDown === null || onKeyDown === void 0 || onKeyDown(e);
			if (e.defaultPrevented) return;
			if (e.target !== e.currentTarget) {
				if (focusableItems) {
					switch (e.key) {
						case ArrowLeft:
							e.target.dispatchEvent(new GroupperMoveFocusEvent({ action: GroupperMoveFocusActions.Escape }));
							break;
						case ArrowDown:
						case ArrowUp:
							e.preventDefault();
							e.target.dispatchEvent(new GroupperMoveFocusEvent({ action: GroupperMoveFocusActions.Escape }));
							e.currentTarget.dispatchEvent(new MoverMoveFocusEvent({ key: MoverKeys[e.key] }));
					}
					return;
				}
				return;
			}
			switch (e.key) {
				case Space:
					e.preventDefault();
					if (isSelectionModeEnabled) {
						if (!disabledSelection) toggleItem === null || toggleItem === void 0 || toggleItem(e, value);
					} else triggerAction(e);
					break;
				case Enter:
					triggerAction(e);
					break;
				case ArrowRight:
					if (navigationMode === "composite") e.target.dispatchEvent(new GroupperMoveFocusEvent({ action: GroupperMoveFocusActions.Enter }));
					break;
			}
		});
		const onCheckboxChange = useEventCallback((e, data) => {
			if (!isSelectionModeEnabled || e.defaultPrevented) return;
			toggleItem === null || toggleItem === void 0 || toggleItem(e, value);
		});
		const arrowNavigationAttributes = useArrowNavigationGroup({ axis: "horizontal" });
		const tabsterAttributes = useMergedTabsterAttributes_unstable(focusableItems ? arrowNavigationAttributes : {}, focusableGroupAttrs, props);
		const root = always(getIntrinsicElementProps(as, {
			ref: useMergedRefs(rootRef, ref),
			tabIndex: focusableItems ? 0 : void 0,
			role: finalListItemRole,
			id: String(value),
			...isSelectionModeEnabled && {
				"aria-selected": isSelected,
				"aria-disabled": disabledSelection && !onAction || void 0
			},
			...props,
			...tabsterAttributes,
			onKeyDown: handleKeyDown,
			onClick: isSelectionModeEnabled || onClick || onAction ? handleClick : void 0
		}), { elementType: as });
		const checkmark = optional(props.checkmark, {
			defaultProps: {
				checked: isSelected,
				tabIndex: -1,
				disabled: disabledSelection
			},
			renderByDefault: isSelectionModeEnabled,
			elementType: Checkbox
		});
		const mergedCheckmarkRef = useMergedRefs(checkmark === null || checkmark === void 0 ? void 0 : checkmark.ref, checkmarkRef);
		if (checkmark) {
			checkmark.onChange = mergeCallbacks(checkmark.onChange, onCheckboxChange);
			checkmark.ref = mergedCheckmarkRef;
		}
		return {
			components: {
				root: as,
				checkmark: Checkbox
			},
			root,
			checkmark,
			disabled: disabledSelection && !onAction,
			selectable: isSelectionModeEnabled,
			navigable: focusableItems
		};
	};

//#endregion
//#region node_modules/@fluentui/react-list/lib/components/ListItem/renderListItem.js
/**
	* Render the final JSX of ListItem
	*/ const renderListItem_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(state.root, { children: [state.checkmark && /* @__PURE__ */ jsx(state.checkmark, {}), state.root.children] });
	};

//#endregion
//#region node_modules/@fluentui/react-list/lib/components/ListItem/useListItemStyles.styles.js
	const listItemClassNames = {
		root: "fui-ListItem",
		checkmark: "fui-ListItem__checkmark"
	};
	const useRootBaseStyles = /* @__PURE__ */ __resetStyles("rikgcmv", null, [".rikgcmv{padding:0;margin:0;text-indent:0;list-style-type:none;}", ".rikgcmv[data-fui-focus-visible]{outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);}"]);
	const useCheckmarkBaseStyles = /* @__PURE__ */ __styles({ root: {
		qb2dma: "f7nlbp4",
		Bpb5tq4: 0,
		Biccaaf: 0,
		Gaeyjg: 0,
		ldoezw: 0,
		B6gmeee: "f1bgo3o3"
	} }, { d: [".f7nlbp4{align-self:center;}", [".f1bgo3o3 .fui-Checkbox__indicator{margin:4px;}", { p: -1 }]] });
	/**
	* Styles for the root slot
	*/
	const useStyles$12 = /* @__PURE__ */ __styles({
		rootClickableOrSelectable: {
			mc9l5x: "f22iagw",
			Bceei9c: "f1k6fduh"
		},
		disabled: { Bceei9c: "f158kwzp" }
	}, { d: [
		".f22iagw{display:flex;}",
		".f1k6fduh{cursor:pointer;}",
		".f158kwzp{cursor:default;}"
	] });
	/**
	* Apply styling to the ListItem slots based on the state
	*/
	const useListItemStyles_unstable = (state) => {
		"use no memo";
		const rootBaseStyles = useRootBaseStyles();
		const checkmarkBaseStyles = useCheckmarkBaseStyles();
		const styles = useStyles$12();
		state.root.className = mergeClasses(listItemClassNames.root, rootBaseStyles, (state.selectable || state.navigable) && styles.rootClickableOrSelectable, state.disabled && styles.disabled, state.root.className);
		if (state.checkmark) state.checkmark.className = mergeClasses(listItemClassNames.checkmark, checkmarkBaseStyles.root, state.checkmark.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-list/lib/components/ListItem/ListItem.js
	const ListItem = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useListItem_unstable(props, ref);
		useListItemStyles_unstable(state);
		useCustomStyleHook("useListItemStyles_unstable")(state);
		return renderListItem_unstable(state);
	});
	ListItem.displayName = "ListItem";

//#endregion
//#region node_modules/@ctrl/tinycolor/dist/module/util.js
/**
	* Take input from [0, n] and return it as [0, 1]
	* @hidden
	*/
	function bound01(n, max$1) {
		if (isOnePointZero(n)) n = "100%";
		var isPercent = isPercentage(n);
		n = max$1 === 360 ? n : Math.min(max$1, Math.max(0, parseFloat(n)));
		if (isPercent) n = parseInt(String(n * max$1), 10) / 100;
		if (Math.abs(n - max$1) < 1e-6) return 1;
		if (max$1 === 360) n = (n < 0 ? n % max$1 + max$1 : n % max$1) / parseFloat(String(max$1));
		else n = n % max$1 / parseFloat(String(max$1));
		return n;
	}
	/**
	* Force a number between 0 and 1
	* @hidden
	*/
	function clamp01(val) {
		return Math.min(1, Math.max(0, val));
	}
	/**
	* Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
	* <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
	* @hidden
	*/
	function isOnePointZero(n) {
		return typeof n === "string" && n.indexOf(".") !== -1 && parseFloat(n) === 1;
	}
	/**
	* Check to see if string passed in is a percentage
	* @hidden
	*/
	function isPercentage(n) {
		return typeof n === "string" && n.indexOf("%") !== -1;
	}
	/**
	* Return a valid alpha value [0,1] with all invalid values being set to 1
	* @hidden
	*/
	function boundAlpha(a) {
		a = parseFloat(a);
		if (isNaN(a) || a < 0 || a > 1) a = 1;
		return a;
	}
	/**
	* Replace a decimal with it's percentage value
	* @hidden
	*/
	function convertToPercentage(n) {
		if (n <= 1) return "".concat(Number(n) * 100, "%");
		return n;
	}
	/**
	* Force a hex value to have 2 characters
	* @hidden
	*/
	function pad2(c) {
		return c.length === 1 ? "0" + c : String(c);
	}

//#endregion
//#region node_modules/@ctrl/tinycolor/dist/module/conversion.js
/**
	* Handle bounds / percentage checking to conform to CSS color spec
	* <http://www.w3.org/TR/css3-color/>
	* *Assumes:* r, g, b in [0, 255] or [0, 1]
	* *Returns:* { r, g, b } in [0, 255]
	*/
	function rgbToRgb(r, g, b) {
		return {
			r: bound01(r, 255) * 255,
			g: bound01(g, 255) * 255,
			b: bound01(b, 255) * 255
		};
	}
	/**
	* Converts an RGB color value to HSL.
	* *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]
	* *Returns:* { h, s, l } in [0,1]
	*/
	function rgbToHsl(r, g, b) {
		r = bound01(r, 255);
		g = bound01(g, 255);
		b = bound01(b, 255);
		var max$1 = Math.max(r, g, b);
		var min$1 = Math.min(r, g, b);
		var h = 0;
		var s = 0;
		var l = (max$1 + min$1) / 2;
		if (max$1 === min$1) {
			s = 0;
			h = 0;
		} else {
			var d = max$1 - min$1;
			s = l > .5 ? d / (2 - max$1 - min$1) : d / (max$1 + min$1);
			switch (max$1) {
				case r:
					h = (g - b) / d + (g < b ? 6 : 0);
					break;
				case g:
					h = (b - r) / d + 2;
					break;
				case b:
					h = (r - g) / d + 4;
					break;
				default: break;
			}
			h /= 6;
		}
		return {
			h,
			s,
			l
		};
	}
	function hue2rgb(p, q, t) {
		if (t < 0) t += 1;
		if (t > 1) t -= 1;
		if (t < 1 / 6) return p + (q - p) * (6 * t);
		if (t < 1 / 2) return q;
		if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
		return p;
	}
	/**
	* Converts an HSL color value to RGB.
	*
	* *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]
	* *Returns:* { r, g, b } in the set [0, 255]
	*/
	function hslToRgb(h, s, l) {
		var r;
		var g;
		var b;
		h = bound01(h, 360);
		s = bound01(s, 100);
		l = bound01(l, 100);
		if (s === 0) {
			g = l;
			b = l;
			r = l;
		} else {
			var q = l < .5 ? l * (1 + s) : l + s - l * s;
			var p = 2 * l - q;
			r = hue2rgb(p, q, h + 1 / 3);
			g = hue2rgb(p, q, h);
			b = hue2rgb(p, q, h - 1 / 3);
		}
		return {
			r: r * 255,
			g: g * 255,
			b: b * 255
		};
	}
	/**
	* Converts an RGB color value to HSV
	*
	* *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
	* *Returns:* { h, s, v } in [0,1]
	*/
	function rgbToHsv(r, g, b) {
		r = bound01(r, 255);
		g = bound01(g, 255);
		b = bound01(b, 255);
		var max$1 = Math.max(r, g, b);
		var min$1 = Math.min(r, g, b);
		var h = 0;
		var v = max$1;
		var d = max$1 - min$1;
		var s = max$1 === 0 ? 0 : d / max$1;
		if (max$1 === min$1) h = 0;
		else {
			switch (max$1) {
				case r:
					h = (g - b) / d + (g < b ? 6 : 0);
					break;
				case g:
					h = (b - r) / d + 2;
					break;
				case b:
					h = (r - g) / d + 4;
					break;
				default: break;
			}
			h /= 6;
		}
		return {
			h,
			s,
			v
		};
	}
	/**
	* Converts an HSV color value to RGB.
	*
	* *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
	* *Returns:* { r, g, b } in the set [0, 255]
	*/
	function hsvToRgb(h, s, v) {
		h = bound01(h, 360) * 6;
		s = bound01(s, 100);
		v = bound01(v, 100);
		var i = Math.floor(h);
		var f = h - i;
		var p = v * (1 - s);
		var q = v * (1 - f * s);
		var t = v * (1 - (1 - f) * s);
		var mod = i % 6;
		var r = [
			v,
			q,
			p,
			p,
			t,
			v
		][mod];
		var g = [
			t,
			v,
			v,
			q,
			p,
			p
		][mod];
		var b = [
			p,
			p,
			t,
			v,
			v,
			q
		][mod];
		return {
			r: r * 255,
			g: g * 255,
			b: b * 255
		};
	}
	/**
	* Converts an RGB color to hex
	*
	* Assumes r, g, and b are contained in the set [0, 255]
	* Returns a 3 or 6 character hex
	*/
	function rgbToHex(r, g, b, allow3Char) {
		var hex = [
			pad2(Math.round(r).toString(16)),
			pad2(Math.round(g).toString(16)),
			pad2(Math.round(b).toString(16))
		];
		if (allow3Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1))) return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
		return hex.join("");
	}
	/**
	* Converts an RGBA color plus alpha transparency to hex
	*
	* Assumes r, g, b are contained in the set [0, 255] and
	* a in [0, 1]. Returns a 4 or 8 character rgba hex
	*/
	function rgbaToHex(r, g, b, a, allow4Char) {
		var hex = [
			pad2(Math.round(r).toString(16)),
			pad2(Math.round(g).toString(16)),
			pad2(Math.round(b).toString(16)),
			pad2(convertDecimalToHex(a))
		];
		if (allow4Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1)) && hex[3].startsWith(hex[3].charAt(1))) return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
		return hex.join("");
	}
	/** Converts a decimal to a hex value */
	function convertDecimalToHex(d) {
		return Math.round(parseFloat(d) * 255).toString(16);
	}
	/** Converts a hex value to a decimal */
	function convertHexToDecimal(h) {
		return parseIntFromHex(h) / 255;
	}
	/** Parse a base-16 hex value into a base-10 integer */
	function parseIntFromHex(val) {
		return parseInt(val, 16);
	}
	function numberInputToObject(color$1) {
		return {
			r: color$1 >> 16,
			g: (color$1 & 65280) >> 8,
			b: color$1 & 255
		};
	}

//#endregion
//#region node_modules/@ctrl/tinycolor/dist/module/css-color-names.js
/**
	* @hidden
	*/
	var names = {
		aliceblue: "#f0f8ff",
		antiquewhite: "#faebd7",
		aqua: "#00ffff",
		aquamarine: "#7fffd4",
		azure: "#f0ffff",
		beige: "#f5f5dc",
		bisque: "#ffe4c4",
		black: "#000000",
		blanchedalmond: "#ffebcd",
		blue: "#0000ff",
		blueviolet: "#8a2be2",
		brown: "#a52a2a",
		burlywood: "#deb887",
		cadetblue: "#5f9ea0",
		chartreuse: "#7fff00",
		chocolate: "#d2691e",
		coral: "#ff7f50",
		cornflowerblue: "#6495ed",
		cornsilk: "#fff8dc",
		crimson: "#dc143c",
		cyan: "#00ffff",
		darkblue: "#00008b",
		darkcyan: "#008b8b",
		darkgoldenrod: "#b8860b",
		darkgray: "#a9a9a9",
		darkgreen: "#006400",
		darkgrey: "#a9a9a9",
		darkkhaki: "#bdb76b",
		darkmagenta: "#8b008b",
		darkolivegreen: "#556b2f",
		darkorange: "#ff8c00",
		darkorchid: "#9932cc",
		darkred: "#8b0000",
		darksalmon: "#e9967a",
		darkseagreen: "#8fbc8f",
		darkslateblue: "#483d8b",
		darkslategray: "#2f4f4f",
		darkslategrey: "#2f4f4f",
		darkturquoise: "#00ced1",
		darkviolet: "#9400d3",
		deeppink: "#ff1493",
		deepskyblue: "#00bfff",
		dimgray: "#696969",
		dimgrey: "#696969",
		dodgerblue: "#1e90ff",
		firebrick: "#b22222",
		floralwhite: "#fffaf0",
		forestgreen: "#228b22",
		fuchsia: "#ff00ff",
		gainsboro: "#dcdcdc",
		ghostwhite: "#f8f8ff",
		goldenrod: "#daa520",
		gold: "#ffd700",
		gray: "#808080",
		green: "#008000",
		greenyellow: "#adff2f",
		grey: "#808080",
		honeydew: "#f0fff0",
		hotpink: "#ff69b4",
		indianred: "#cd5c5c",
		indigo: "#4b0082",
		ivory: "#fffff0",
		khaki: "#f0e68c",
		lavenderblush: "#fff0f5",
		lavender: "#e6e6fa",
		lawngreen: "#7cfc00",
		lemonchiffon: "#fffacd",
		lightblue: "#add8e6",
		lightcoral: "#f08080",
		lightcyan: "#e0ffff",
		lightgoldenrodyellow: "#fafad2",
		lightgray: "#d3d3d3",
		lightgreen: "#90ee90",
		lightgrey: "#d3d3d3",
		lightpink: "#ffb6c1",
		lightsalmon: "#ffa07a",
		lightseagreen: "#20b2aa",
		lightskyblue: "#87cefa",
		lightslategray: "#778899",
		lightslategrey: "#778899",
		lightsteelblue: "#b0c4de",
		lightyellow: "#ffffe0",
		lime: "#00ff00",
		limegreen: "#32cd32",
		linen: "#faf0e6",
		magenta: "#ff00ff",
		maroon: "#800000",
		mediumaquamarine: "#66cdaa",
		mediumblue: "#0000cd",
		mediumorchid: "#ba55d3",
		mediumpurple: "#9370db",
		mediumseagreen: "#3cb371",
		mediumslateblue: "#7b68ee",
		mediumspringgreen: "#00fa9a",
		mediumturquoise: "#48d1cc",
		mediumvioletred: "#c71585",
		midnightblue: "#191970",
		mintcream: "#f5fffa",
		mistyrose: "#ffe4e1",
		moccasin: "#ffe4b5",
		navajowhite: "#ffdead",
		navy: "#000080",
		oldlace: "#fdf5e6",
		olive: "#808000",
		olivedrab: "#6b8e23",
		orange: "#ffa500",
		orangered: "#ff4500",
		orchid: "#da70d6",
		palegoldenrod: "#eee8aa",
		palegreen: "#98fb98",
		paleturquoise: "#afeeee",
		palevioletred: "#db7093",
		papayawhip: "#ffefd5",
		peachpuff: "#ffdab9",
		peru: "#cd853f",
		pink: "#ffc0cb",
		plum: "#dda0dd",
		powderblue: "#b0e0e6",
		purple: "#800080",
		rebeccapurple: "#663399",
		red: "#ff0000",
		rosybrown: "#bc8f8f",
		royalblue: "#4169e1",
		saddlebrown: "#8b4513",
		salmon: "#fa8072",
		sandybrown: "#f4a460",
		seagreen: "#2e8b57",
		seashell: "#fff5ee",
		sienna: "#a0522d",
		silver: "#c0c0c0",
		skyblue: "#87ceeb",
		slateblue: "#6a5acd",
		slategray: "#708090",
		slategrey: "#708090",
		snow: "#fffafa",
		springgreen: "#00ff7f",
		steelblue: "#4682b4",
		tan: "#d2b48c",
		teal: "#008080",
		thistle: "#d8bfd8",
		tomato: "#ff6347",
		turquoise: "#40e0d0",
		violet: "#ee82ee",
		wheat: "#f5deb3",
		white: "#ffffff",
		whitesmoke: "#f5f5f5",
		yellow: "#ffff00",
		yellowgreen: "#9acd32"
	};

//#endregion
//#region node_modules/@ctrl/tinycolor/dist/module/format-input.js
/**
	* Given a string or object, convert that input to RGB
	*
	* Possible string inputs:
	* ```
	* "red"
	* "#f00" or "f00"
	* "#ff0000" or "ff0000"
	* "#ff000000" or "ff000000"
	* "rgb 255 0 0" or "rgb (255, 0, 0)"
	* "rgb 1.0 0 0" or "rgb (1, 0, 0)"
	* "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
	* "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
	* "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
	* "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
	* "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
	* ```
	*/
	function inputToRGB(color$1) {
		var rgb = {
			r: 0,
			g: 0,
			b: 0
		};
		var a = 1;
		var s = null;
		var v = null;
		var l = null;
		var ok = false;
		var format = false;
		if (typeof color$1 === "string") color$1 = stringInputToObject(color$1);
		if (typeof color$1 === "object") {
			if (isValidCSSUnit(color$1.r) && isValidCSSUnit(color$1.g) && isValidCSSUnit(color$1.b)) {
				rgb = rgbToRgb(color$1.r, color$1.g, color$1.b);
				ok = true;
				format = String(color$1.r).substr(-1) === "%" ? "prgb" : "rgb";
			} else if (isValidCSSUnit(color$1.h) && isValidCSSUnit(color$1.s) && isValidCSSUnit(color$1.v)) {
				s = convertToPercentage(color$1.s);
				v = convertToPercentage(color$1.v);
				rgb = hsvToRgb(color$1.h, s, v);
				ok = true;
				format = "hsv";
			} else if (isValidCSSUnit(color$1.h) && isValidCSSUnit(color$1.s) && isValidCSSUnit(color$1.l)) {
				s = convertToPercentage(color$1.s);
				l = convertToPercentage(color$1.l);
				rgb = hslToRgb(color$1.h, s, l);
				ok = true;
				format = "hsl";
			}
			if (Object.prototype.hasOwnProperty.call(color$1, "a")) a = color$1.a;
		}
		a = boundAlpha(a);
		return {
			ok,
			format: color$1.format || format,
			r: Math.min(255, Math.max(rgb.r, 0)),
			g: Math.min(255, Math.max(rgb.g, 0)),
			b: Math.min(255, Math.max(rgb.b, 0)),
			a
		};
	}
	var CSS_UNIT = "(?:".concat("[-\\+]?\\d*\\.\\d+%?", ")|(?:").concat("[-\\+]?\\d+%?", ")");
	var PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
	var PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
	var matchers = {
		CSS_UNIT: new RegExp(CSS_UNIT),
		rgb: /* @__PURE__ */ new RegExp("rgb" + PERMISSIVE_MATCH3),
		rgba: /* @__PURE__ */ new RegExp("rgba" + PERMISSIVE_MATCH4),
		hsl: /* @__PURE__ */ new RegExp("hsl" + PERMISSIVE_MATCH3),
		hsla: /* @__PURE__ */ new RegExp("hsla" + PERMISSIVE_MATCH4),
		hsv: /* @__PURE__ */ new RegExp("hsv" + PERMISSIVE_MATCH3),
		hsva: /* @__PURE__ */ new RegExp("hsva" + PERMISSIVE_MATCH4),
		hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
		hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
		hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
		hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
	};
	/**
	* Permissive string parsing.  Take in a number of formats, and output an object
	* based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`
	*/
	function stringInputToObject(color$1) {
		color$1 = color$1.trim().toLowerCase();
		if (color$1.length === 0) return false;
		var named = false;
		if (names[color$1]) {
			color$1 = names[color$1];
			named = true;
		} else if (color$1 === "transparent") return {
			r: 0,
			g: 0,
			b: 0,
			a: 0,
			format: "name"
		};
		var match$1 = matchers.rgb.exec(color$1);
		if (match$1) return {
			r: match$1[1],
			g: match$1[2],
			b: match$1[3]
		};
		match$1 = matchers.rgba.exec(color$1);
		if (match$1) return {
			r: match$1[1],
			g: match$1[2],
			b: match$1[3],
			a: match$1[4]
		};
		match$1 = matchers.hsl.exec(color$1);
		if (match$1) return {
			h: match$1[1],
			s: match$1[2],
			l: match$1[3]
		};
		match$1 = matchers.hsla.exec(color$1);
		if (match$1) return {
			h: match$1[1],
			s: match$1[2],
			l: match$1[3],
			a: match$1[4]
		};
		match$1 = matchers.hsv.exec(color$1);
		if (match$1) return {
			h: match$1[1],
			s: match$1[2],
			v: match$1[3]
		};
		match$1 = matchers.hsva.exec(color$1);
		if (match$1) return {
			h: match$1[1],
			s: match$1[2],
			v: match$1[3],
			a: match$1[4]
		};
		match$1 = matchers.hex8.exec(color$1);
		if (match$1) return {
			r: parseIntFromHex(match$1[1]),
			g: parseIntFromHex(match$1[2]),
			b: parseIntFromHex(match$1[3]),
			a: convertHexToDecimal(match$1[4]),
			format: named ? "name" : "hex8"
		};
		match$1 = matchers.hex6.exec(color$1);
		if (match$1) return {
			r: parseIntFromHex(match$1[1]),
			g: parseIntFromHex(match$1[2]),
			b: parseIntFromHex(match$1[3]),
			format: named ? "name" : "hex"
		};
		match$1 = matchers.hex4.exec(color$1);
		if (match$1) return {
			r: parseIntFromHex(match$1[1] + match$1[1]),
			g: parseIntFromHex(match$1[2] + match$1[2]),
			b: parseIntFromHex(match$1[3] + match$1[3]),
			a: convertHexToDecimal(match$1[4] + match$1[4]),
			format: named ? "name" : "hex8"
		};
		match$1 = matchers.hex3.exec(color$1);
		if (match$1) return {
			r: parseIntFromHex(match$1[1] + match$1[1]),
			g: parseIntFromHex(match$1[2] + match$1[2]),
			b: parseIntFromHex(match$1[3] + match$1[3]),
			format: named ? "name" : "hex"
		};
		return false;
	}
	/**
	* Check to see if it looks like a CSS unit
	* (see `matchers` above for definition).
	*/
	function isValidCSSUnit(color$1) {
		return Boolean(matchers.CSS_UNIT.exec(String(color$1)));
	}

//#endregion
//#region node_modules/@ctrl/tinycolor/dist/module/index.js
	var TinyColor = function() {
		function TinyColor$1(color$1, opts) {
			if (color$1 === void 0) color$1 = "";
			if (opts === void 0) opts = {};
			var _a;
			if (color$1 instanceof TinyColor$1) return color$1;
			if (typeof color$1 === "number") color$1 = numberInputToObject(color$1);
			this.originalInput = color$1;
			var rgb = inputToRGB(color$1);
			this.originalInput = color$1;
			this.r = rgb.r;
			this.g = rgb.g;
			this.b = rgb.b;
			this.a = rgb.a;
			this.roundA = Math.round(100 * this.a) / 100;
			this.format = (_a = opts.format) !== null && _a !== void 0 ? _a : rgb.format;
			this.gradientType = opts.gradientType;
			if (this.r < 1) this.r = Math.round(this.r);
			if (this.g < 1) this.g = Math.round(this.g);
			if (this.b < 1) this.b = Math.round(this.b);
			this.isValid = rgb.ok;
		}
		TinyColor$1.prototype.isDark = function() {
			return this.getBrightness() < 128;
		};
		TinyColor$1.prototype.isLight = function() {
			return !this.isDark();
		};
		/**
		* Returns the perceived brightness of the color, from 0-255.
		*/
		TinyColor$1.prototype.getBrightness = function() {
			var rgb = this.toRgb();
			return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
		};
		/**
		* Returns the perceived luminance of a color, from 0-1.
		*/
		TinyColor$1.prototype.getLuminance = function() {
			var rgb = this.toRgb();
			var R;
			var G;
			var B;
			var RsRGB = rgb.r / 255;
			var GsRGB = rgb.g / 255;
			var BsRGB = rgb.b / 255;
			if (RsRGB <= .03928) R = RsRGB / 12.92;
			else R = Math.pow((RsRGB + .055) / 1.055, 2.4);
			if (GsRGB <= .03928) G = GsRGB / 12.92;
			else G = Math.pow((GsRGB + .055) / 1.055, 2.4);
			if (BsRGB <= .03928) B = BsRGB / 12.92;
			else B = Math.pow((BsRGB + .055) / 1.055, 2.4);
			return .2126 * R + .7152 * G + .0722 * B;
		};
		/**
		* Returns the alpha value of a color, from 0-1.
		*/
		TinyColor$1.prototype.getAlpha = function() {
			return this.a;
		};
		/**
		* Sets the alpha value on the current color.
		*
		* @param alpha - The new alpha value. The accepted range is 0-1.
		*/
		TinyColor$1.prototype.setAlpha = function(alpha) {
			this.a = boundAlpha(alpha);
			this.roundA = Math.round(100 * this.a) / 100;
			return this;
		};
		/**
		* Returns whether the color is monochrome.
		*/
		TinyColor$1.prototype.isMonochrome = function() {
			return this.toHsl().s === 0;
		};
		/**
		* Returns the object as a HSVA object.
		*/
		TinyColor$1.prototype.toHsv = function() {
			var hsv = rgbToHsv(this.r, this.g, this.b);
			return {
				h: hsv.h * 360,
				s: hsv.s,
				v: hsv.v,
				a: this.a
			};
		};
		/**
		* Returns the hsva values interpolated into a string with the following format:
		* "hsva(xxx, xxx, xxx, xx)".
		*/
		TinyColor$1.prototype.toHsvString = function() {
			var hsv = rgbToHsv(this.r, this.g, this.b);
			var h = Math.round(hsv.h * 360);
			var s = Math.round(hsv.s * 100);
			var v = Math.round(hsv.v * 100);
			return this.a === 1 ? "hsv(".concat(h, ", ").concat(s, "%, ").concat(v, "%)") : "hsva(".concat(h, ", ").concat(s, "%, ").concat(v, "%, ").concat(this.roundA, ")");
		};
		/**
		* Returns the object as a HSLA object.
		*/
		TinyColor$1.prototype.toHsl = function() {
			var hsl = rgbToHsl(this.r, this.g, this.b);
			return {
				h: hsl.h * 360,
				s: hsl.s,
				l: hsl.l,
				a: this.a
			};
		};
		/**
		* Returns the hsla values interpolated into a string with the following format:
		* "hsla(xxx, xxx, xxx, xx)".
		*/
		TinyColor$1.prototype.toHslString = function() {
			var hsl = rgbToHsl(this.r, this.g, this.b);
			var h = Math.round(hsl.h * 360);
			var s = Math.round(hsl.s * 100);
			var l = Math.round(hsl.l * 100);
			return this.a === 1 ? "hsl(".concat(h, ", ").concat(s, "%, ").concat(l, "%)") : "hsla(".concat(h, ", ").concat(s, "%, ").concat(l, "%, ").concat(this.roundA, ")");
		};
		/**
		* Returns the hex value of the color.
		* @param allow3Char will shorten hex value to 3 char if possible
		*/
		TinyColor$1.prototype.toHex = function(allow3Char) {
			if (allow3Char === void 0) allow3Char = false;
			return rgbToHex(this.r, this.g, this.b, allow3Char);
		};
		/**
		* Returns the hex value of the color -with a # prefixed.
		* @param allow3Char will shorten hex value to 3 char if possible
		*/
		TinyColor$1.prototype.toHexString = function(allow3Char) {
			if (allow3Char === void 0) allow3Char = false;
			return "#" + this.toHex(allow3Char);
		};
		/**
		* Returns the hex 8 value of the color.
		* @param allow4Char will shorten hex value to 4 char if possible
		*/
		TinyColor$1.prototype.toHex8 = function(allow4Char) {
			if (allow4Char === void 0) allow4Char = false;
			return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
		};
		/**
		* Returns the hex 8 value of the color -with a # prefixed.
		* @param allow4Char will shorten hex value to 4 char if possible
		*/
		TinyColor$1.prototype.toHex8String = function(allow4Char) {
			if (allow4Char === void 0) allow4Char = false;
			return "#" + this.toHex8(allow4Char);
		};
		/**
		* Returns the shorter hex value of the color depends on its alpha -with a # prefixed.
		* @param allowShortChar will shorten hex value to 3 or 4 char if possible
		*/
		TinyColor$1.prototype.toHexShortString = function(allowShortChar) {
			if (allowShortChar === void 0) allowShortChar = false;
			return this.a === 1 ? this.toHexString(allowShortChar) : this.toHex8String(allowShortChar);
		};
		/**
		* Returns the object as a RGBA object.
		*/
		TinyColor$1.prototype.toRgb = function() {
			return {
				r: Math.round(this.r),
				g: Math.round(this.g),
				b: Math.round(this.b),
				a: this.a
			};
		};
		/**
		* Returns the RGBA values interpolated into a string with the following format:
		* "RGBA(xxx, xxx, xxx, xx)".
		*/
		TinyColor$1.prototype.toRgbString = function() {
			var r = Math.round(this.r);
			var g = Math.round(this.g);
			var b = Math.round(this.b);
			return this.a === 1 ? "rgb(".concat(r, ", ").concat(g, ", ").concat(b, ")") : "rgba(".concat(r, ", ").concat(g, ", ").concat(b, ", ").concat(this.roundA, ")");
		};
		/**
		* Returns the object as a RGBA object.
		*/
		TinyColor$1.prototype.toPercentageRgb = function() {
			var fmt = function(x) {
				return "".concat(Math.round(bound01(x, 255) * 100), "%");
			};
			return {
				r: fmt(this.r),
				g: fmt(this.g),
				b: fmt(this.b),
				a: this.a
			};
		};
		/**
		* Returns the RGBA relative values interpolated into a string
		*/
		TinyColor$1.prototype.toPercentageRgbString = function() {
			var rnd = function(x) {
				return Math.round(bound01(x, 255) * 100);
			};
			return this.a === 1 ? "rgb(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%)") : "rgba(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%, ").concat(this.roundA, ")");
		};
		/**
		* The 'real' name of the color -if there is one.
		*/
		TinyColor$1.prototype.toName = function() {
			if (this.a === 0) return "transparent";
			if (this.a < 1) return false;
			var hex = "#" + rgbToHex(this.r, this.g, this.b, false);
			for (var _i = 0, _a = Object.entries(names); _i < _a.length; _i++) {
				var _b = _a[_i], key = _b[0];
				if (hex === _b[1]) return key;
			}
			return false;
		};
		TinyColor$1.prototype.toString = function(format) {
			var formatSet = Boolean(format);
			format = format !== null && format !== void 0 ? format : this.format;
			var formattedString = false;
			var hasAlpha = this.a < 1 && this.a >= 0;
			if (!formatSet && hasAlpha && (format.startsWith("hex") || format === "name")) {
				if (format === "name" && this.a === 0) return this.toName();
				return this.toRgbString();
			}
			if (format === "rgb") formattedString = this.toRgbString();
			if (format === "prgb") formattedString = this.toPercentageRgbString();
			if (format === "hex" || format === "hex6") formattedString = this.toHexString();
			if (format === "hex3") formattedString = this.toHexString(true);
			if (format === "hex4") formattedString = this.toHex8String(true);
			if (format === "hex8") formattedString = this.toHex8String();
			if (format === "name") formattedString = this.toName();
			if (format === "hsl") formattedString = this.toHslString();
			if (format === "hsv") formattedString = this.toHsvString();
			return formattedString || this.toHexString();
		};
		TinyColor$1.prototype.toNumber = function() {
			return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
		};
		TinyColor$1.prototype.clone = function() {
			return new TinyColor$1(this.toString());
		};
		/**
		* Lighten the color a given amount. Providing 100 will always return white.
		* @param amount - valid between 1-100
		*/
		TinyColor$1.prototype.lighten = function(amount) {
			if (amount === void 0) amount = 10;
			var hsl = this.toHsl();
			hsl.l += amount / 100;
			hsl.l = clamp01(hsl.l);
			return new TinyColor$1(hsl);
		};
		/**
		* Brighten the color a given amount, from 0 to 100.
		* @param amount - valid between 1-100
		*/
		TinyColor$1.prototype.brighten = function(amount) {
			if (amount === void 0) amount = 10;
			var rgb = this.toRgb();
			rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
			rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
			rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
			return new TinyColor$1(rgb);
		};
		/**
		* Darken the color a given amount, from 0 to 100.
		* Providing 100 will always return black.
		* @param amount - valid between 1-100
		*/
		TinyColor$1.prototype.darken = function(amount) {
			if (amount === void 0) amount = 10;
			var hsl = this.toHsl();
			hsl.l -= amount / 100;
			hsl.l = clamp01(hsl.l);
			return new TinyColor$1(hsl);
		};
		/**
		* Mix the color with pure white, from 0 to 100.
		* Providing 0 will do nothing, providing 100 will always return white.
		* @param amount - valid between 1-100
		*/
		TinyColor$1.prototype.tint = function(amount) {
			if (amount === void 0) amount = 10;
			return this.mix("white", amount);
		};
		/**
		* Mix the color with pure black, from 0 to 100.
		* Providing 0 will do nothing, providing 100 will always return black.
		* @param amount - valid between 1-100
		*/
		TinyColor$1.prototype.shade = function(amount) {
			if (amount === void 0) amount = 10;
			return this.mix("black", amount);
		};
		/**
		* Desaturate the color a given amount, from 0 to 100.
		* Providing 100 will is the same as calling greyscale
		* @param amount - valid between 1-100
		*/
		TinyColor$1.prototype.desaturate = function(amount) {
			if (amount === void 0) amount = 10;
			var hsl = this.toHsl();
			hsl.s -= amount / 100;
			hsl.s = clamp01(hsl.s);
			return new TinyColor$1(hsl);
		};
		/**
		* Saturate the color a given amount, from 0 to 100.
		* @param amount - valid between 1-100
		*/
		TinyColor$1.prototype.saturate = function(amount) {
			if (amount === void 0) amount = 10;
			var hsl = this.toHsl();
			hsl.s += amount / 100;
			hsl.s = clamp01(hsl.s);
			return new TinyColor$1(hsl);
		};
		/**
		* Completely desaturates a color into greyscale.
		* Same as calling `desaturate(100)`
		*/
		TinyColor$1.prototype.greyscale = function() {
			return this.desaturate(100);
		};
		/**
		* Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.
		* Values outside of this range will be wrapped into this range.
		*/
		TinyColor$1.prototype.spin = function(amount) {
			var hsl = this.toHsl();
			var hue = (hsl.h + amount) % 360;
			hsl.h = hue < 0 ? 360 + hue : hue;
			return new TinyColor$1(hsl);
		};
		/**
		* Mix the current color a given amount with another color, from 0 to 100.
		* 0 means no mixing (return current color).
		*/
		TinyColor$1.prototype.mix = function(color$1, amount) {
			if (amount === void 0) amount = 50;
			var rgb1 = this.toRgb();
			var rgb2 = new TinyColor$1(color$1).toRgb();
			var p = amount / 100;
			return new TinyColor$1({
				r: (rgb2.r - rgb1.r) * p + rgb1.r,
				g: (rgb2.g - rgb1.g) * p + rgb1.g,
				b: (rgb2.b - rgb1.b) * p + rgb1.b,
				a: (rgb2.a - rgb1.a) * p + rgb1.a
			});
		};
		TinyColor$1.prototype.analogous = function(results, slices) {
			if (results === void 0) results = 6;
			if (slices === void 0) slices = 30;
			var hsl = this.toHsl();
			var part = 360 / slices;
			var ret = [this];
			for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results;) {
				hsl.h = (hsl.h + part) % 360;
				ret.push(new TinyColor$1(hsl));
			}
			return ret;
		};
		/**
		* taken from https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js
		*/
		TinyColor$1.prototype.complement = function() {
			var hsl = this.toHsl();
			hsl.h = (hsl.h + 180) % 360;
			return new TinyColor$1(hsl);
		};
		TinyColor$1.prototype.monochromatic = function(results) {
			if (results === void 0) results = 6;
			var hsv = this.toHsv();
			var h = hsv.h;
			var s = hsv.s;
			var v = hsv.v;
			var res = [];
			var modification = 1 / results;
			while (results--) {
				res.push(new TinyColor$1({
					h,
					s,
					v
				}));
				v = (v + modification) % 1;
			}
			return res;
		};
		TinyColor$1.prototype.splitcomplement = function() {
			var hsl = this.toHsl();
			var h = hsl.h;
			return [
				this,
				new TinyColor$1({
					h: (h + 72) % 360,
					s: hsl.s,
					l: hsl.l
				}),
				new TinyColor$1({
					h: (h + 216) % 360,
					s: hsl.s,
					l: hsl.l
				})
			];
		};
		/**
		* Compute how the color would appear on a background
		*/
		TinyColor$1.prototype.onBackground = function(background) {
			var fg = this.toRgb();
			var bg = new TinyColor$1(background).toRgb();
			var alpha = fg.a + bg.a * (1 - fg.a);
			return new TinyColor$1({
				r: (fg.r * fg.a + bg.r * bg.a * (1 - fg.a)) / alpha,
				g: (fg.g * fg.a + bg.g * bg.a * (1 - fg.a)) / alpha,
				b: (fg.b * fg.a + bg.b * bg.a * (1 - fg.a)) / alpha,
				a: alpha
			});
		};
		/**
		* Alias for `polyad(3)`
		*/
		TinyColor$1.prototype.triad = function() {
			return this.polyad(3);
		};
		/**
		* Alias for `polyad(4)`
		*/
		TinyColor$1.prototype.tetrad = function() {
			return this.polyad(4);
		};
		/**
		* Get polyad colors, like (for 1, 2, 3, 4, 5, 6, 7, 8, etc...)
		* monad, dyad, triad, tetrad, pentad, hexad, heptad, octad, etc...
		*/
		TinyColor$1.prototype.polyad = function(n) {
			var hsl = this.toHsl();
			var h = hsl.h;
			var result = [this];
			var increment = 360 / n;
			for (var i = 1; i < n; i++) result.push(new TinyColor$1({
				h: (h + i * increment) % 360,
				s: hsl.s,
				l: hsl.l
			}));
			return result;
		};
		/**
		* compare color vs current color
		*/
		TinyColor$1.prototype.equals = function(color$1) {
			return this.toRgbString() === new TinyColor$1(color$1).toRgbString();
		};
		return TinyColor$1;
	}();
	function tinycolor(color$1, opts) {
		if (color$1 === void 0) color$1 = "";
		if (opts === void 0) opts = {};
		return new TinyColor(color$1, opts);
	}

//#endregion
//#region node_modules/@fluentui/react-color-picker/lib/components/ColorSlider/useColorSliderStyles.styles.js
	const colorSliderClassNames = {
		root: "fui-ColorSlider",
		rail: "fui-ColorSlider__rail",
		thumb: "fui-ColorSlider__thumb",
		input: "fui-ColorSlider__input"
	};
	const colorSliderCSSVars = {
		sliderDirectionVar: `--fui-Slider--direction`,
		sliderProgressVar: `--fui-Slider--progress`,
		thumbColorVar: `--fui-Slider__thumb--color`,
		railColorVar: `--fui-Slider__rail--color`,
		thumbSizeVar: `--fui-Slider__thumb--size`,
		railSizeVar: `--fui-Slider__rail--size`
	};
	`${/* @__PURE__ */ [
		`var(${colorSliderCSSVars.sliderDirectionVar})`,
		"red",
		"fuchsia",
		"blue",
		"aqua",
		"lime",
		"yellow",
		"red"
	].join(",")}`;
	/**
	* Styles for the root slot
	*/
	const useRootStyles$2 = /* @__PURE__ */ __resetStyles("r1j9hj9j", null, [".r1j9hj9j{position:relative;display:inline-grid;touch-action:none;align-items:center;justify-items:center;--fui-Slider__thumb--size:20px;--fui-Slider__rail--size:20px;min-height:32px;}"]);
	const useStyles$11 = /* @__PURE__ */ __styles({
		horizontal: {
			Bf4jedk: "f93ek0f",
			wkccdc: "fgfd48t",
			Budl1dq: "f11e9psi"
		},
		vertical: {
			sshi5w: "fwwq4i4",
			wkccdc: "fqcvrs3",
			Budl1dq: "fiadc6h"
		}
	}, { d: [
		".f93ek0f{min-width:200px;}",
		".fgfd48t{grid-template-rows:1fr var(--fui-Slider__thumb--size) 1fr;}",
		".f11e9psi{grid-template-columns:1fr 100% 1fr;}",
		".fwwq4i4{min-height:280px;}",
		".fqcvrs3{grid-template-rows:1fr 100% 1fr;}",
		".fiadc6h{grid-template-columns:1fr var(--fui-Slider__thumb--size) 1fr;}"
	] });
	const useChannelStyles = /* @__PURE__ */ __styles({
		hue: { Bcmaq0h: "f1curpo1" },
		saturation: { Bcmaq0h: ["fdhcg5e", "f1onqon0"] },
		value: { Bcmaq0h: ["f1r1ueul", "fbtriqu"] }
	}, { d: [
		".f1curpo1{background-image:linear-gradient(var(--fui-Slider--direction),red,fuchsia,blue,aqua,lime,yellow,red);}",
		".fdhcg5e{background-image:linear-gradient(to right, #808080, var(--fui-Slider__rail--color));}",
		".f1onqon0{background-image:linear-gradient(to left, #808080, var(--fui-Slider__rail--color));}",
		".f1r1ueul{background-image:linear-gradient(to right, #000, var(--fui-Slider__rail--color));}",
		".fbtriqu{background-image:linear-gradient(to left, #000, var(--fui-Slider__rail--color));}"
	] });
	/**
	* Styles for the rail slot
	*/
	const useRailStyles = /* @__PURE__ */ __styles({
		rail: {
			Bkecrkj: "f1aehjj5",
			Ijaq50: "faunodf",
			nk6f5a: "f88nxoq",
			Br312pm: "fd46tj4",
			Bw0ie65: "f1e2fz10",
			qhf8xq: "f10pi13n",
			Bvjb7m6: "fdgv6k0",
			Bpd4iqm: "fpvhumw",
			oeaueh: "f1yog68k",
			Bw0xxkn: "f13sgyd8",
			Ftih45: "fzhtfnv",
			Brfgrao: "f1j7ml58"
		},
		horizontal: {
			a9b677: "fly5x3f",
			Bqenvij: "f1cy86ho",
			Fbdkly: ["f1heqfse", "fkh49vu"],
			mdwyqc: ["fkh49vu", "f1heqfse"],
			Baz25je: "f16tdq4e"
		},
		vertical: {
			a9b677: "fqxfnkd",
			Bqenvij: "f1l02sjl",
			Ccq8qp: "f1rik0od",
			Bciustq: "f14xwovp",
			lawp4y: "febq2dz"
		}
	}, { d: [
		".f1aehjj5{pointer-events:none;}",
		".faunodf{grid-row-start:2;}",
		".f88nxoq{grid-row-end:2;}",
		".fd46tj4{grid-column-start:2;}",
		".f1e2fz10{grid-column-end:2;}",
		".f10pi13n{position:relative;}",
		".fdgv6k0{forced-color-adjust:none;}",
		".fpvhumw{outline-width:1px;}",
		".f1yog68k{outline-style:solid;}",
		".f13sgyd8{outline-color:var(--colorTransparentStroke);}",
		".fzhtfnv::before{content:'';}",
		".f1j7ml58::before{position:absolute;}",
		".fly5x3f{width:100%;}",
		".f1cy86ho{height:var(--fui-Slider__rail--size);}",
		".f1heqfse::before{left:-1px;}",
		".fkh49vu::before{right:-1px;}",
		".f16tdq4e::before{height:var(--fui-Slider__rail--size);}",
		".fqxfnkd{width:var(--fui-Slider__rail--size);}",
		".f1l02sjl{height:100%;}",
		".f1rik0od::before{width:var(--fui-Slider__rail--size);}",
		".f14xwovp::before{top:-1px;}",
		".febq2dz::before{bottom:1px;}"
	] });
	/**
	* Styles for the thumb slot
	*/
	const useThumbStyles$2 = /* @__PURE__ */ __styles({
		thumb: {
			Ijaq50: "faunodf",
			nk6f5a: "f88nxoq",
			Br312pm: "fd46tj4",
			Bw0ie65: "f1e2fz10",
			qhf8xq: "f1euv43f",
			a9b677: "f174ca62",
			Bqenvij: "f1yfdkfd",
			Bkecrkj: "f1aehjj5",
			oeaueh: "f1s6fcnf",
			Bvjb7m6: "fdgv6k0",
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "f44lkw9",
			Bgfg5da: 0,
			B9xav0g: 0,
			oivjwe: 0,
			Bn0qgzm: 0,
			B4g9neb: 0,
			zhjwy3: 0,
			wvpqe5: 0,
			ibv6hh: 0,
			u1mtju: 0,
			h3c5rm: 0,
			vrafjx: 0,
			Bekrc4i: 0,
			i8vvqc: 0,
			g2u3we: 0,
			icvyot: 0,
			B4j52fo: 0,
			irswps: "f1lvq45z",
			E5pizo: "f1whvlc6",
			De3pzq: "foksa45",
			Brfgrao: "f1j7ml58",
			lawp4y: 0,
			Fbdkly: 0,
			mdwyqc: 0,
			Bciustq: 0,
			gc50h5: "f1abv9ik",
			r59vdv: 0,
			Budzafs: 0,
			ck0cow: 0,
			n07z76: 0,
			Gng75u: "fielpny",
			Bcvre1j: "fyl8oag",
			Ftih45: "fzhtfnv",
			Bcgcnre: 0,
			Bqjgrrk: 0,
			qa3bma: 0,
			y0oebl: 0,
			Biqmznv: 0,
			Bm6vgfq: 0,
			Bbv0w2i: 0,
			uvfttm: 0,
			eqrjj: 0,
			Bk5zm6e: 0,
			m598lv: 0,
			B4f6apu: 0,
			ydt019: 0,
			Bq4z7u6: 0,
			Bdkvgpv: 0,
			B0qfbqy: 0,
			kj8mxx: "f3i7wkk"
		},
		horizontal: {
			Bz10aip: ["f13gfj74", "f1nfknbn"],
			oyh7mz: ["f1fj3zth", "fcf9u6w"]
		},
		vertical: {
			Bz10aip: "f5cv5a3",
			B5kzvoi: "feeniun"
		}
	}, { d: [
		".faunodf{grid-row-start:2;}",
		".f88nxoq{grid-row-end:2;}",
		".fd46tj4{grid-column-start:2;}",
		".f1e2fz10{grid-column-end:2;}",
		".f1euv43f{position:absolute;}",
		".f174ca62{width:var(--fui-Slider__thumb--size);}",
		".f1yfdkfd{height:var(--fui-Slider__thumb--size);}",
		".f1aehjj5{pointer-events:none;}",
		".f1s6fcnf{outline-style:none;}",
		".fdgv6k0{forced-color-adjust:none;}",
		[".f44lkw9{border-radius:var(--borderRadiusCircular);}", { p: -1 }],
		[".f1lvq45z{border:var(--strokeWidthThin) solid var(--colorNeutralForeground4);}", { p: -2 }],
		".f1whvlc6{box-shadow:var(--shadow4);}",
		".foksa45{background-color:var(--fui-Slider__thumb--color);}",
		".f1j7ml58::before{position:absolute;}",
		[".f1abv9ik::before{inset:0px;}", { p: -1 }],
		[".fielpny::before{border-radius:var(--borderRadiusCircular);}", { p: -1 }],
		".fyl8oag::before{box-sizing:border-box;}",
		".fzhtfnv::before{content:'';}",
		[".f3i7wkk::before{border:var(--strokeWidthThick) solid var(--colorNeutralBackground1);}", { p: -2 }],
		".f13gfj74{transform:translateX(-50%);}",
		".f1nfknbn{transform:translateX(50%);}",
		".f1fj3zth{left:var(--fui-Slider--progress);}",
		".fcf9u6w{right:var(--fui-Slider--progress);}",
		".f5cv5a3{transform:translateY(50%);}",
		".feeniun{bottom:var(--fui-Slider--progress);}"
	] });
	const useShapeStyles$1 = /* @__PURE__ */ __styles({
		rounded: {
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "ft85np5"
		},
		square: {
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "f1fabniw"
		}
	}, { d: [[".ft85np5{border-radius:var(--borderRadiusMedium);}", { p: -1 }], [".f1fabniw{border-radius:var(--borderRadiusNone);}", { p: -1 }]] });
	/**
	* Styles for the Input slot
	*/
	const useInputStyles$1 = /* @__PURE__ */ __styles({
		input: {
			Bceei9c: "f1k6fduh",
			abs64n: "fk73vx1",
			Ijaq50: "f16hsg94",
			nk6f5a: "f1nzqi2z",
			Br312pm: "fwpfdsa",
			Bw0ie65: "fuur7zz",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f1mk8lai",
			jrapky: 0,
			Frg6f3: 0,
			t21cq0: 0,
			B6of3ja: 0,
			B74szlk: "f1s184ao",
			jo39rj: 0,
			C5zqim: 0,
			Bdlbwnu: 0,
			B8rk77i: 0,
			Bbzx7hc: 0,
			Hwkvcz: 0,
			B0nnt1c: 0,
			Brwsv5j: 0,
			B2b7vog: 0,
			B4hmq5e: 0,
			B8jxwem: 0,
			B18nadz: 0,
			Ddg5ig: 0,
			Byj09el: 0,
			Dac2s3: 0,
			Dd2y6r: 0,
			Bk0t58e: "f1nq8t98",
			Ewenww: 0,
			Brqi8qb: 0,
			zz3kca: 0,
			low6xx: "fjt56wq",
			d0s10n: 0,
			wea7l5: 0,
			olu5tv: 0,
			g5nsvh: 0,
			Bqvnfwh: "f1n9m442"
		},
		horizontal: {
			Bqenvij: "f1yfdkfd",
			a9b677: "fly5x3f"
		},
		vertical: {
			Bqenvij: "f1l02sjl",
			a9b677: "f174ca62",
			Biqzhck: "f1r7j8g6",
			kgocjf: ["f1va4sj6", "f1r2v9sp"]
		}
	}, {
		d: [
			".f1k6fduh{cursor:pointer;}",
			".fk73vx1{opacity:0;}",
			".f16hsg94{grid-row-start:1;}",
			".f1nzqi2z{grid-row-end:-1;}",
			".fwpfdsa{grid-column-start:1;}",
			".fuur7zz{grid-column-end:-1;}",
			[".f1mk8lai{padding:0;}", { p: -1 }],
			[".f1s184ao{margin:0;}", { p: -1 }],
			".f1yfdkfd{height:var(--fui-Slider__thumb--size);}",
			".fly5x3f{width:100%;}",
			".f1l02sjl{height:100%;}",
			".f174ca62{width:var(--fui-Slider__thumb--size);}",
			".f1r7j8g6{writing-mode:vertical-lr;}",
			".f1va4sj6{direction:rtl;}",
			".f1r2v9sp{direction:ltr;}"
		],
		i: [
			[".f1nq8t98:focus-visible~.fui-ColorSlider__thumb{border:2px solid var(--colorStrokeFocus2);}", { p: -2 }],
			[".fjt56wq:focus-visible~.fui-ColorSlider__thumb{outline:var(--strokeWidthThick) solid var(--colorTransparentStroke);}", { p: -1 }],
			[".f1n9m442:focus-visible~.fui-ColorSlider__thumb{border-radius:var(--borderRadiusCircular);}", { p: -1 }]
		]
	});
	/**
	* Apply styling to the ColorSlider slots based on the state
	*/
	const useColorSliderStyles_unstable = (state) => {
		"use no memo";
		const rootStyles = useRootStyles$2();
		const styles = useStyles$11();
		const railStyles = useRailStyles();
		const thumbStyles = useThumbStyles$2();
		const inputStyles = useInputStyles$1();
		const shapeStyles = useShapeStyles$1();
		const channelStyles = useChannelStyles();
		const isVertical = state.vertical;
		state.root.className = mergeClasses(colorSliderClassNames.root, rootStyles, isVertical ? styles.vertical : styles.horizontal, state.root.className);
		state.rail.className = mergeClasses(colorSliderClassNames.rail, railStyles.rail, channelStyles[state.channel || "hue"], shapeStyles[state.shape || "rounded"], isVertical ? railStyles.vertical : railStyles.horizontal, state.rail.className);
		state.thumb.className = mergeClasses(colorSliderClassNames.thumb, thumbStyles.thumb, isVertical ? thumbStyles.vertical : thumbStyles.horizontal, state.thumb.className);
		state.input.className = mergeClasses(colorSliderClassNames.input, inputStyles.input, isVertical ? inputStyles.vertical : inputStyles.horizontal, state.input.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-color-picker/lib/contexts/colorPicker.js
	const useColorPickerContextValues = (state) => {
		const { color: color$1, shape, requestChange } = state;
		return { colorPicker: {
			requestChange,
			color: color$1,
			shape
		} };
	};
	const colorPickerContextDefaultValue = {
		requestChange: () => {},
		color: void 0,
		shape: "rounded"
	};
	const colorPickerContext = createContext(void 0);
	const ColorPickerProvider = colorPickerContext.Provider;
	const useColorPickerContextValue_unstable = (selector) => useContextSelector(colorPickerContext, (ctx = colorPickerContextDefaultValue) => selector(ctx));

//#endregion
//#region node_modules/@fluentui/react-color-picker/lib/utils/constants.js
	const MIN = 0;
	const MAX = 100;
	const HUE_MAX = 360;
	const INITIAL_COLOR = "#FFF";
	const INITIAL_COLOR_HSV = tinycolor(INITIAL_COLOR).toHsv();

//#endregion
//#region node_modules/@fluentui/react-color-picker/lib/utils/getPercent.js
/**
	* Calculates the percentage of a value within a given range.
	*
	* @param value - The value to be converted to a percentage.
	* @param min - The minimum value of the range.
	* @param max - The maximum value of the range.
	* @returns The percentage representation of the value within the range [min, max].
	*          Returns 0 if `min` is equal to `max`.
	*/ const getPercent = (value, min$1, max$1) => {
		return max$1 === min$1 ? 0 : (value - min$1) / (max$1 - min$1) * 100;
	};

//#endregion
//#region node_modules/@fluentui/react-color-picker/lib/utils/createHsvColor.js
/**
	* Creates an HSV color object with optional hue, saturation, value, and alpha components.
	*
	* @param {Partial<HsvColor>} param0 - An object containing optional HSV color components:
	*  - `h` (number): The hue component, default is 0.
	*  - `s` (number): The saturation component, default is 0.
	*  - `v` (number): The value component, default is 0.
	*  - `a` (number): The alpha component, default is 1.
	* @returns {HsvColor} The resulting HSV color object.
	*/ function createHsvColor({ h = 0, s = 0, v = 0, a = 1 }) {
		return {
			h,
			s,
			v,
			a
		};
	}

//#endregion
//#region node_modules/@fluentui/react-color-picker/lib/utils/adjustChannel.js
/**
	* Clamps a given value to the valid range for a specified color channel.
	*
	* @param value - The numeric value to be clamped.
	* @param channel - The color channel to use for clamping. Defaults to 'hue'.
	* @returns The clamped value within the range defined by the color channel.
	*/ function clampValue(value, channel = "hue") {
		return clamp$2(value, MIN, channel === "hue" ? HUE_MAX : MAX);
	}
	/**
	* Adjusts the specified color channel using the provided actions.
	*
	* @template T - The type of the result returned by the actions.
	* @param {ColorChannel} channel - The color channel to adjust.
	* @param {ChannelActions<T>} actions - An object containing actions for each color channel.
	* @returns {T} - The result of the action corresponding to the specified channel, or the hue action if the channel is not found.
	*/ function adjustChannel(channel, actions) {
		return actions[channel] || actions.hue;
	}

//#endregion
//#region node_modules/@fluentui/react-color-picker/lib/components/ColorSlider/useColorSlider.js
/**
	* Create the state required to render ColorSlider.
	*
	* The returned state can be modified with hooks such as useColorSliderStyles_unstable,
	* before being passed to renderColorSlider_unstable.
	*
	* @param props - props from this instance of ColorSlider
	* @param ref - reference to root HTMLInputElement of ColorSlider
	*/ const useColorSlider_unstable = (props, ref) => {
		"use no memo";
		const { dir } = useFluent();
		const onChangeFromContext = useColorPickerContextValue_unstable((ctx) => ctx.requestChange);
		const colorFromContext = useColorPickerContextValue_unstable((ctx) => ctx.color);
		const shapeFromContext = useColorPickerContextValue_unstable((ctx) => ctx.shape);
		const nativeProps = getPartitionedNativeProps({
			props,
			primarySlotTagName: "input",
			excludedPropNames: ["onChange", "color"]
		});
		const { color: color$1, channel = "hue", onChange = onChangeFromContext, shape = shapeFromContext, vertical, root, input, rail, thumb } = props;
		const hsvColor = color$1 || colorFromContext;
		const hslColor = tinycolor(hsvColor).toHsl();
		const [currentColor, setCurrentColor] = useControllableState({
			defaultState: props.defaultColor,
			state: hsvColor,
			initialState: INITIAL_COLOR_HSV
		});
		const MAX$1 = channel === "hue" ? HUE_MAX : MAX;
		const clampedValue = adjustChannel(channel, {
			hue: clampValue(currentColor.h),
			saturation: clampValue(currentColor.s * 100),
			value: clampValue(currentColor.v * 100)
		});
		const valuePercent = getPercent(clampedValue, MIN, MAX$1);
		const inputOnChange = input === null || input === void 0 ? void 0 : input.onChange;
		const _onChange = useEventCallback((event) => {
			const newValue = Number(event.target.value);
			const newColor = adjustChannel(channel, {
				hue: () => createHsvColor({
					...hsvColor,
					h: newValue
				}),
				saturation: () => createHsvColor({
					...hsvColor,
					s: newValue / 100
				}),
				value: () => createHsvColor({
					...hsvColor,
					v: newValue / 100
				})
			})();
			setCurrentColor(newColor);
			inputOnChange === null || inputOnChange === void 0 || inputOnChange(event);
			onChange === null || onChange === void 0 || onChange(event, {
				type: "change",
				event,
				color: newColor
			});
		});
		const rootVariables = {
			[colorSliderCSSVars.sliderDirectionVar]: vertical ? "180deg" : dir === "ltr" ? "-90deg" : "90deg",
			[colorSliderCSSVars.sliderProgressVar]: `${valuePercent}%`,
			[colorSliderCSSVars.thumbColorVar]: channel === "hue" ? `hsl(${clampedValue}, 100%, 50%)` : tinycolor(hsvColor).toRgbString(),
			[colorSliderCSSVars.railColorVar]: channel === "hue" ? `hsl(${hslColor.h} ${hslColor.s * 100}%, ${hslColor.l * 100}%)` : `hsl(${hslColor.h} 100%, 50%)`
		};
		const state = {
			shape,
			vertical,
			channel,
			components: {
				input: "input",
				rail: "div",
				root: "div",
				thumb: "div"
			},
			root: always(root, {
				defaultProps: {
					role: "group",
					...nativeProps.root
				},
				elementType: "div"
			}),
			input: always(input, {
				defaultProps: {
					id: useId("slider-", props.id),
					ref,
					min: MIN,
					max: MAX$1,
					tabIndex: 0,
					["aria-orientation"]: vertical ? "vertical" : "horizontal",
					...nativeProps.primary,
					type: "range"
				},
				elementType: "input"
			}),
			rail: always(rail, { elementType: "div" }),
			thumb: always(thumb, { elementType: "div" })
		};
		state.root.style = {
			...rootVariables,
			...state.root.style
		};
		state.input.value = clampedValue;
		state.input.onChange = _onChange;
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-color-picker/lib/components/ColorSlider/renderColorSlider.js
/**
	* Render the final JSX of ColorSlider
	*/ const renderColorSlider_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(state.root, { children: [
			/* @__PURE__ */ jsx(state.input, {}),
			/* @__PURE__ */ jsx(state.rail, {}),
			/* @__PURE__ */ jsx(state.thumb, {})
		] });
	};

//#endregion
//#region node_modules/@fluentui/react-color-picker/lib/components/ColorSlider/ColorSlider.js
/**
	* ColorSlider component
	*/ const ColorSlider = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useColorSlider_unstable(props, ref);
		useColorSliderStyles_unstable(state);
		useCustomStyleHook("useColorSliderStyles_unstable")(state);
		return renderColorSlider_unstable(state);
	});
	ColorSlider.displayName = "ColorSlider";

//#endregion
//#region node_modules/@fluentui/react-color-picker/lib/components/ColorPicker/useColorPicker.js
/**
	* Create the state required to render ColorPicker.
	*
	* The returned state can be modified with hooks such as useColorPickerStyles_unstable,
	* before being passed to renderColorPicker_unstable.
	*
	* @param props - props from this instance of ColorPicker
	* @param ref - reference to root HTMLDivElement of ColorPicker
	*/ const useColorPicker_unstable = (props, ref) => {
		const { color: color$1, onColorChange, shape, ...rest } = props;
		const requestChange = useEventCallback((event, data) => {
			onColorChange === null || onColorChange === void 0 || onColorChange(event, {
				type: "change",
				event,
				color: data.color
			});
		});
		return {
			components: { root: "div" },
			root: always(getIntrinsicElementProps("div", {
				ref,
				...rest
			}), { elementType: "div" }),
			color: color$1,
			requestChange,
			shape
		};
	};

//#endregion
//#region node_modules/@fluentui/react-color-picker/lib/components/ColorPicker/renderColorPicker.js
/**
	* Render the final JSX of ColorPicker
	*/ const renderColorPicker_unstable = (state, contextValues) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(ColorPickerProvider, {
			value: contextValues.colorPicker,
			children: /* @__PURE__ */ jsx(state.root, { children: state.root.children })
		});
	};

//#endregion
//#region node_modules/@fluentui/react-color-picker/lib/components/ColorPicker/useColorPickerStyles.styles.js
	const colorPickerClassNames = { root: "fui-ColorPicker" };
	/**
	* Styles for the root slot
	*/
	const useStyles$10 = /* @__PURE__ */ __styles({ root: {
		mc9l5x: "f22iagw",
		Beiy3e4: "f1vx9l62",
		i8kkvl: 0,
		Belr9w4: 0,
		rmohyg: "f7e3wsx"
	} }, { d: [
		".f22iagw{display:flex;}",
		".f1vx9l62{flex-direction:column;}",
		[".f7e3wsx{gap:var(--spacingVerticalXS);}", { p: -1 }]
	] });
	/**
	* Apply styling to the ColorPicker slots based on the state
	*/
	const useColorPickerStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$10();
		state.root.className = mergeClasses(colorPickerClassNames.root, styles.root, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-color-picker/lib/components/ColorPicker/ColorPicker.js
/**
	* ColorPicker component
	*/ const ColorPicker = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useColorPicker_unstable(props, ref);
		const contextValues = useColorPickerContextValues(state);
		useColorPickerStyles_unstable(state);
		useCustomStyleHook("useColorPickerStyles_unstable")(state);
		return renderColorPicker_unstable(state, contextValues);
	});
	ColorPicker.displayName = "ColorPicker";

//#endregion
//#region node_modules/@fluentui/react-color-picker/lib/components/ColorArea/useColorAreaStyles.styles.js
	const colorAreaClassNames = {
		root: "fui-ColorArea",
		thumb: "fui-ColorArea__thumb",
		inputX: "fui-ColorArea__inputX",
		inputY: "fui-ColorArea__inputY"
	};
	const colorAreaCSSVars = {
		areaXProgressVar: `--fui-AreaX--progress`,
		areaYProgressVar: `--fui-AreaY--progress`,
		thumbColorVar: `--fui-Area__thumb--color`,
		mainColorVar: `--fui-Area--main-color`
	};
	/**
	* Styles for the root slot
	*/
	const useRootStyles$1 = /* @__PURE__ */ __resetStyles("r77w3t7", "r9og4es", [".r77w3t7{position:relative;border:1px solid var(--colorNeutralStroke1);background:linear-gradient(to bottom, transparent, #000),linear-gradient(to right, #fff, transparent),var(--fui-Area--main-color);forced-color-adjust:none;display:inline-grid;touch-action:none;align-items:start;justify-items:start;--fui-Slider__thumb--size:20px;min-width:300px;min-height:300px;box-sizing:border-box;margin-bottom:var(--spacingVerticalSNudge);}", ".r9og4es{position:relative;border:1px solid var(--colorNeutralStroke1);background:linear-gradient(to bottom, transparent, #000),linear-gradient(to left, #fff, transparent),var(--fui-Area--main-color);forced-color-adjust:none;display:inline-grid;touch-action:none;align-items:start;justify-items:start;--fui-Slider__thumb--size:20px;min-width:300px;min-height:300px;box-sizing:border-box;margin-bottom:var(--spacingVerticalSNudge);}"]);
	/**
	* Styles for the thumb slot
	*/
	const useThumbStyles$1 = /* @__PURE__ */ __styles({
		thumb: {
			qhf8xq: "f1euv43f",
			a9b677: "f174ca62",
			Bqenvij: "f1yfdkfd",
			Bkecrkj: "f1aehjj5",
			oeaueh: "f1s6fcnf",
			Bvjb7m6: "fdgv6k0",
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "f44lkw9",
			Bgfg5da: 0,
			B9xav0g: 0,
			oivjwe: 0,
			Bn0qgzm: 0,
			B4g9neb: 0,
			zhjwy3: 0,
			wvpqe5: 0,
			ibv6hh: 0,
			u1mtju: 0,
			h3c5rm: 0,
			vrafjx: 0,
			Bekrc4i: 0,
			i8vvqc: 0,
			g2u3we: 0,
			icvyot: 0,
			B4j52fo: 0,
			irswps: "f1lvq45z",
			E5pizo: "f1whvlc6",
			De3pzq: "fqogvx2",
			Bz10aip: ["f1g1iug4", "f11okln6"],
			oyh7mz: ["f1r4bsg1", "fwsk87b"],
			B5kzvoi: "f1rtkqdg",
			Brfgrao: "f1j7ml58",
			lawp4y: 0,
			Fbdkly: 0,
			mdwyqc: 0,
			Bciustq: 0,
			gc50h5: "f1abv9ik",
			r59vdv: 0,
			Budzafs: 0,
			ck0cow: 0,
			n07z76: 0,
			Gng75u: "fielpny",
			Bcvre1j: "fyl8oag",
			Ftih45: "fzhtfnv",
			Bcgcnre: 0,
			Bqjgrrk: 0,
			qa3bma: 0,
			y0oebl: 0,
			Biqmznv: 0,
			Bm6vgfq: 0,
			Bbv0w2i: 0,
			uvfttm: 0,
			eqrjj: 0,
			Bk5zm6e: 0,
			m598lv: 0,
			B4f6apu: 0,
			ydt019: 0,
			Bq4z7u6: 0,
			Bdkvgpv: 0,
			B0qfbqy: 0,
			kj8mxx: "f3i7wkk"
		},
		focusIndicator: {
			Brovlpu: "ftqa4ok",
			B486eqv: "f2hkw1w",
			Bssx7fj: "f1b1k54r",
			uh7if5: ["f4ne723", "fqqcjud"],
			clntm0: "fh7aioi",
			Dlk2r6: ["fqqcjud", "f4ne723"],
			h6p2u: "f1ufm4qn",
			I6qiy5: ["f1qnwcb4", "fgrk5zm"],
			yzno9d: "fi52z01",
			By0wis0: ["fgrk5zm", "f1qnwcb4"],
			B2j2mmj: "ffht0p2",
			wigs8: "f1p0ul1q",
			pbfy6t: "f1c901ms",
			B0v4ure: "f1alokd7",
			Byrf0fs: 0,
			Bsiemmq: 0,
			Bwckmig: 0,
			skfxo0: 0,
			Iidy0u: 0,
			B98u21t: 0,
			Bvwlmkc: 0,
			jo1ztg: 0,
			Ba1iezr: 0,
			Blmvk6g: 0,
			B24cy0v: 0,
			Bil7v7r: 0,
			Br3gin4: 0,
			nr063g: 0,
			ghq09: 0,
			Bbgo44z: 0,
			Bseh09z: "f1i978nd",
			az1dzo: 0,
			Ba3ybja: 0,
			B6352mv: 0,
			vppk2z: 0,
			Biaj6j7: "f16hcqkr",
			B2pnrqr: "f1tye2sp",
			B29w5g4: ["flw7qy0", "f1t01kh7"],
			Bhhzhcn: "frujvlw",
			Bec0n69: ["f1t01kh7", "flw7qy0"]
		}
	}, {
		d: [
			".f1euv43f{position:absolute;}",
			".f174ca62{width:var(--fui-Slider__thumb--size);}",
			".f1yfdkfd{height:var(--fui-Slider__thumb--size);}",
			".f1aehjj5{pointer-events:none;}",
			".f1s6fcnf{outline-style:none;}",
			".fdgv6k0{forced-color-adjust:none;}",
			[".f44lkw9{border-radius:var(--borderRadiusCircular);}", { p: -1 }],
			[".f1lvq45z{border:var(--strokeWidthThin) solid var(--colorNeutralForeground4);}", { p: -2 }],
			".f1whvlc6{box-shadow:var(--shadow4);}",
			".fqogvx2{background-color:var(--fui-Area__thumb--color);}",
			".f1g1iug4{transform:translate(-50%, 50%);}",
			".f11okln6{transform:translate(50%, 50%);}",
			".f1r4bsg1{left:var(--fui-AreaX--progress);}",
			".fwsk87b{right:var(--fui-AreaX--progress);}",
			".f1rtkqdg{bottom:var(--fui-AreaY--progress);}",
			".f1j7ml58::before{position:absolute;}",
			[".f1abv9ik::before{inset:0px;}", { p: -1 }],
			[".fielpny::before{border-radius:var(--borderRadiusCircular);}", { p: -1 }],
			".fyl8oag::before{box-sizing:border-box;}",
			".fzhtfnv::before{content:'';}",
			[".f3i7wkk::before{border:var(--strokeWidthThick) solid var(--colorNeutralBackground1);}", { p: -2 }],
			".f1b1k54r[data-fui-focus-within]:focus-within{border-top-color:transparent;}",
			".f4ne723[data-fui-focus-within]:focus-within{border-right-color:transparent;}",
			".fqqcjud[data-fui-focus-within]:focus-within{border-left-color:transparent;}",
			".fh7aioi[data-fui-focus-within]:focus-within{border-bottom-color:transparent;}",
			".ffht0p2[data-fui-focus-within]:focus-within::after{content:\"\";}",
			".f1p0ul1q[data-fui-focus-within]:focus-within::after{position:absolute;}",
			".f1c901ms[data-fui-focus-within]:focus-within::after{pointer-events:none;}",
			".f1alokd7[data-fui-focus-within]:focus-within::after{z-index:1;}",
			[".f1i978nd[data-fui-focus-within]:focus-within::after{border:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}", { p: -2 }],
			[".f16hcqkr[data-fui-focus-within]:focus-within::after{border-radius:var(--borderRadiusCircular);}", { p: -1 }],
			".f1tye2sp[data-fui-focus-within]:focus-within::after{top:calc(var(--strokeWidthThick) * -1);}",
			".flw7qy0[data-fui-focus-within]:focus-within::after{right:calc(var(--strokeWidthThick) * -1);}",
			".f1t01kh7[data-fui-focus-within]:focus-within::after{left:calc(var(--strokeWidthThick) * -1);}",
			".frujvlw[data-fui-focus-within]:focus-within::after{bottom:calc(var(--strokeWidthThick) * -1);}"
		],
		f: [".ftqa4ok:focus{outline-style:none;}"],
		i: [".f2hkw1w:focus-visible{outline-style:none;}"],
		m: [
			["@media (forced-colors: active){.f1ufm4qn[data-fui-focus-within]:focus-within::after{border-top-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.f1qnwcb4[data-fui-focus-within]:focus-within::after{border-right-color:Highlight;}.fgrk5zm[data-fui-focus-within]:focus-within::after{border-left-color:Highlight;}}", { m: "(forced-colors: active)" }],
			["@media (forced-colors: active){.fi52z01[data-fui-focus-within]:focus-within::after{border-bottom-color:Highlight;}}", { m: "(forced-colors: active)" }]
		]
	});
	/**
	* Styles for the Input slot
	*/
	const useInputStyles = /* @__PURE__ */ __styles({ input: {
		B68tc82: 0,
		Bmxbyg5: 0,
		Bpg54ce: "f1a3p1vp",
		qhf8xq: "f1euv43f",
		Bkecrkj: "f1aehjj5",
		Bhzewxz: "f15twtuk",
		oyh7mz: ["f1vgc2s3", "f1e31b4d"],
		abs64n: "fk73vx1",
		Byoj8tv: 0,
		uwmqm3: 0,
		z189sj: 0,
		z8tnut: 0,
		B0ocmuz: "f1mk8lai",
		jrapky: 0,
		Frg6f3: 0,
		t21cq0: 0,
		B6of3ja: 0,
		B74szlk: "f1s184ao",
		a9b677: "fly5x3f",
		Bqenvij: "f1l02sjl"
	} }, { d: [
		[".f1a3p1vp{overflow:hidden;}", { p: -1 }],
		".f1euv43f{position:absolute;}",
		".f1aehjj5{pointer-events:none;}",
		".f15twtuk{top:0;}",
		".f1vgc2s3{left:0;}",
		".f1e31b4d{right:0;}",
		".fk73vx1{opacity:0;}",
		[".f1mk8lai{padding:0;}", { p: -1 }],
		[".f1s184ao{margin:0;}", { p: -1 }],
		".fly5x3f{width:100%;}",
		".f1l02sjl{height:100%;}"
	] });
	const useShapeStyles = /* @__PURE__ */ __styles({
		rounded: {
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "ft85np5"
		},
		square: {
			Beyfa6y: 0,
			Bbmb7ep: 0,
			Btl43ni: 0,
			B7oj6ja: 0,
			Dimara: "f1fabniw"
		}
	}, { d: [[".ft85np5{border-radius:var(--borderRadiusMedium);}", { p: -1 }], [".f1fabniw{border-radius:var(--borderRadiusNone);}", { p: -1 }]] });
	/**
	* Apply styling to the ColorArea slots based on the state
	*/
	const useColorAreaStyles_unstable = (state) => {
		"use no memo";
		const rootStyles = useRootStyles$1();
		const thumbStyles = useThumbStyles$1();
		const inputStyles = useInputStyles();
		const shapeStyles = useShapeStyles();
		state.root.className = mergeClasses(colorAreaClassNames.root, rootStyles, shapeStyles[state.shape || "rounded"], state.root.className);
		state.thumb.className = mergeClasses(colorAreaClassNames.thumb, thumbStyles.thumb, thumbStyles.focusIndicator, state.thumb.className);
		state.inputX.className = mergeClasses(colorAreaClassNames.inputX, inputStyles.input, state.inputX.className);
		state.inputY.className = mergeClasses(colorAreaClassNames.inputY, inputStyles.input, state.inputY.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-color-picker/lib/utils/getCoordinates.js
/**
	* Calculates the normalized coordinates of a mouse event relative to a given HTML element.
	*
	* @param element - The HTML element to calculate the coordinates relative to.
	* @param event - The mouse event containing the clientX and clientY properties.
	* @returns An object containing the normalized x and y coordinates, clamped between 0 and 1.
	*/ function getCoordinates(element, event) {
		const rect = element.getBoundingClientRect();
		const newX = roundTwoDecimal((event.clientX - rect.left) / rect.width);
		const newY = roundTwoDecimal(1 - (event.clientY - rect.top) / rect.height);
		return {
			x: clamp$2(newX, 0, 1),
			y: clamp$2(newY, 0, 1)
		};
	}
	/**
	* Rounds a given number to two decimal places.
	*
	* @param num - The number to be rounded.
	* @returns The number rounded to two decimal places.
	*/ function roundTwoDecimal(num) {
		return Math.round(num * 100) / 100;
	}

//#endregion
//#region node_modules/@fluentui/react-color-picker/lib/components/ColorArea/useColorArea.js
/**
	* Create the state required to render ColorArea.
	*
	* The returned state can be modified with hooks such as useColorAreaStyles_unstable,
	* before being passed to renderColorArea_unstable.
	*
	* @param props - props from this instance of ColorArea
	* @param ref - reference to root HTMLDivElement of ColorArea
	*/ const useColorArea_unstable = (props, ref) => {
		const { targetDocument } = useFluent();
		const rootRef = react.useRef(null);
		const xRef = react.useRef(null);
		const yRef = react.useRef(null);
		const focusWithinRef = useFocusWithin();
		const onChangeFromContext = useColorPickerContextValue_unstable((ctx) => ctx.requestChange);
		const colorFromContext = useColorPickerContextValue_unstable((ctx) => ctx.color);
		const shapeFromContext = useColorPickerContextValue_unstable((ctx) => ctx.shape);
		const { onChange = onChangeFromContext, shape = shapeFromContext, inputX, inputY, thumb, color: color$1, ...rest } = props;
		const [hsvColor, setColor] = useControllableState({
			defaultState: props.defaultColor,
			state: color$1 || colorFromContext,
			initialState: INITIAL_COLOR_HSV
		});
		const saturation = Math.round(hsvColor.s * 100);
		const value = Math.round(hsvColor.v * 100);
		const [activeAxis, setActiveAxis] = react.useState(null);
		const requestColorChange = useEventCallback((event) => {
			if (!rootRef.current) return;
			const coordinates = getCoordinates(rootRef.current, event);
			const newColor = {
				...hsvColor,
				s: coordinates.x,
				v: coordinates.y
			};
			setColor(newColor);
			onChange === null || onChange === void 0 || onChange(event, {
				type: "change",
				event,
				color: newColor
			});
		});
		const handleDocumentPointerMove = react.useCallback((event) => {
			requestColorChange(event);
		}, [requestColorChange]);
		const handleDocumentPointerUp = useEventCallback(() => {
			targetDocument === null || targetDocument === void 0 || targetDocument.removeEventListener("pointermove", handleDocumentPointerMove);
		});
		const handleRootOnPointerDown = useEventCallback((event) => {
			event.stopPropagation();
			event.preventDefault();
			requestColorChange(event.nativeEvent);
			targetDocument === null || targetDocument === void 0 || targetDocument.addEventListener("pointermove", handleDocumentPointerMove);
			targetDocument === null || targetDocument === void 0 || targetDocument.addEventListener("pointerup", handleDocumentPointerUp, { once: true });
		});
		const handleInputOnChange = useEventCallback((event) => {
			const targetValue = Number(event.target.value) / 100;
			const newColor = {
				...hsvColor,
				...event.target === xRef.current && { s: targetValue },
				...event.target === yRef.current && { v: targetValue }
			};
			setColor(newColor);
			onChange === null || onChange === void 0 || onChange(event, {
				type: "change",
				event,
				color: newColor
			});
		});
		const handleRootOnKeyDown = useEventCallback((event) => {
			let deltaX = 0;
			let deltaY = 0;
			let axis = "x";
			switch (event.key) {
				case "ArrowUp":
					event.preventDefault();
					axis = "y";
					deltaY = 1;
					break;
				case "ArrowDown":
					event.preventDefault();
					axis = "y";
					deltaY = -1;
					break;
				case "ArrowLeft":
					event.preventDefault();
					axis = "x";
					deltaX = -1;
					break;
				case "ArrowRight":
					event.preventDefault();
					axis = "x";
					deltaX = 1;
					break;
			}
			if (deltaX === 0 && deltaY === 0) return;
			const newColor = {
				...hsvColor,
				s: Math.min(Math.max(hsvColor.s + deltaX / 100, 0), 1),
				v: Math.min(Math.max(hsvColor.v + deltaY / 100, 0), 1)
			};
			setColor(newColor);
			setActiveAxis(axis);
			onChange === null || onChange === void 0 || onChange(event, {
				type: "change",
				event,
				color: newColor
			});
		});
		const rootVariables = {
			[colorAreaCSSVars.areaXProgressVar]: `${saturation}%`,
			[colorAreaCSSVars.areaYProgressVar]: `${value}%`,
			[colorAreaCSSVars.thumbColorVar]: tinycolor(hsvColor).toRgbString(),
			[colorAreaCSSVars.mainColorVar]: `hsl(${hsvColor.h}, 100%, 50%)`
		};
		const state = {
			shape,
			components: {
				inputX: "input",
				inputY: "input",
				root: "div",
				thumb: "div"
			},
			root: always(getIntrinsicElementProps("div", {
				ref,
				...rest
			}), { elementType: "div" }),
			inputX: always(inputX, {
				defaultProps: {
					id: useId("sliderX-"),
					type: "range",
					...activeAxis && { tabIndex: activeAxis === "x" ? 0 : -1 }
				},
				elementType: "input"
			}),
			inputY: always(inputY, {
				defaultProps: {
					id: useId("sliderY-"),
					type: "range",
					tabIndex: activeAxis && activeAxis === "y" ? 0 : -1
				},
				elementType: "input"
			}),
			thumb: always(thumb, { elementType: "div" })
		};
		state.root.ref = useMergedRefs(state.root.ref, rootRef);
		state.thumb.ref = useMergedRefs(state.thumb.ref, focusWithinRef);
		state.inputX.ref = useMergedRefs(state.inputX.ref, xRef);
		state.inputY.ref = useMergedRefs(state.inputY.ref, yRef);
		state.root.style = {
			...state.root.style,
			...rootVariables
		};
		state.root.onPointerDown = useEventCallback(mergeCallbacks(state.root.onPointerDown, handleRootOnPointerDown));
		state.root.onKeyDown = useEventCallback(mergeCallbacks(state.root.onKeyDown, handleRootOnKeyDown));
		state.inputX.onChange = useEventCallback(mergeCallbacks(state.inputX.onChange, handleInputOnChange));
		state.inputY.onChange = useEventCallback(mergeCallbacks(state.inputY.onChange, handleInputOnChange));
		state.inputX.value = saturation;
		state.inputY.value = value;
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-color-picker/lib/components/ColorArea/renderColorArea.js
/**
	* Render the final JSX of ColorArea
	*/ const renderColorArea_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, { children: /* @__PURE__ */ jsxs(state.thumb, { children: [/* @__PURE__ */ jsx(state.inputX, {}), /* @__PURE__ */ jsx(state.inputY, {})] }) });
	};

//#endregion
//#region node_modules/@fluentui/react-color-picker/lib/components/ColorArea/ColorArea.js
/**
	* ColorArea component
	*/ const ColorArea = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useColorArea_unstable(props, ref);
		useColorAreaStyles_unstable(state);
		useCustomStyleHook("useColorAreaStyles_unstable")(state);
		return renderColorArea_unstable(state);
	});
	ColorArea.displayName = "ColorArea";

//#endregion
//#region node_modules/@fluentui/react-color-picker/lib/components/AlphaSlider/useAlphaSliderStyles.styles.js
	const alphaSliderClassNames = {
		root: "fui-AlphaSlider",
		rail: "fui-AlphaSlider__rail",
		thumb: "fui-AlphaSlider__thumb",
		input: "fui-AlphaSlider__input"
	};
	const alphaSliderCSSVars = {
		sliderDirectionVar: `--fui-AlphaSlider--direction`,
		sliderProgressVar: `--fui-AlphaSlider--progress`,
		thumbColorVar: `--fui-AlphaSlider__thumb--color`,
		railColorVar: `--fui-AlphaSlider__rail--color`
	};
	/**
	* Styles for the root slot
	*/
	const useStyles$9 = /* @__PURE__ */ __styles({ rail: {
		Bgfg5da: 0,
		B9xav0g: 0,
		oivjwe: 0,
		Bn0qgzm: 0,
		B4g9neb: 0,
		zhjwy3: 0,
		wvpqe5: 0,
		ibv6hh: 0,
		u1mtju: 0,
		h3c5rm: 0,
		vrafjx: 0,
		Bekrc4i: 0,
		i8vvqc: 0,
		g2u3we: 0,
		icvyot: 0,
		B4j52fo: 0,
		irswps: "fm9niy",
		Bcmaq0h: "f183gti0"
	} }, { d: [[".fm9niy{border:1px solid var(--colorNeutralStroke1);}", { p: -2 }], `.f183gti0{background-image:linear-gradient(var(--fui-AlphaSlider--direction), transparent, var(--fui-AlphaSlider__rail--color)),url(https://fabricweb.azureedge.net/fabric-website/assets/images/transparent-pattern.png);}`] });
	/**
	* Styles for the thumb slot
	*/
	const useThumbStyles = /* @__PURE__ */ __styles({
		thumb: {
			De3pzq: "fxugw4r",
			cmx5o7: "f5vbyc6"
		},
		horizontal: {
			Bz10aip: ["f13gfj74", "f1nfknbn"],
			oyh7mz: ["fsmxtey", "fh8h8tc"]
		},
		vertical: {
			Bz10aip: "f5cv5a3",
			B5kzvoi: "falo4kr"
		}
	}, { d: [
		".fxugw4r{background-color:var(--colorNeutralBackground1);}",
		".f5vbyc6::before{background-color:var(--fui-AlphaSlider__thumb--color);}",
		".f13gfj74{transform:translateX(-50%);}",
		".f1nfknbn{transform:translateX(50%);}",
		".fsmxtey{left:var(--fui-AlphaSlider--progress);}",
		".fh8h8tc{right:var(--fui-AlphaSlider--progress);}",
		".f5cv5a3{transform:translateY(50%);}",
		".falo4kr{bottom:var(--fui-AlphaSlider--progress);}"
	] });
	/**
	* Apply styling to the AlphaSlider slots based on the state
	*/
	const useAlphaSliderStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$9();
		const thumbStyles = useThumbStyles();
		state.root.className = mergeClasses(alphaSliderClassNames.root, state.root.className);
		state.input.className = mergeClasses(alphaSliderClassNames.input, state.input.className);
		state.rail.className = mergeClasses(alphaSliderClassNames.rail, styles.rail, state.rail.className);
		state.thumb.className = mergeClasses(alphaSliderClassNames.thumb, thumbStyles.thumb, state.vertical ? thumbStyles.vertical : thumbStyles.horizontal, state.thumb.className);
		state.thumb.className = mergeClasses(alphaSliderClassNames.thumb, thumbStyles.thumb, state.vertical ? thumbStyles.vertical : thumbStyles.horizontal, state.thumb.className);
		useColorSliderStyles_unstable(state);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-color-picker/lib/components/AlphaSlider/alphaSliderUtils.js
/**
	* Adjusts the given value based on the transparency flag.
	*
	* @param value - The numeric value to adjust.
	* @param transparency - A boolean flag indicating whether to adjust for transparency.
	* @returns The adjusted value.
	*/ function adjustToTransparency(value, transparency) {
		return transparency ? 100 - value : value;
	}
	/**
	* Calculates the transparency value based on the given parameters.
	*
	* @param transparency - A boolean flag indicating whether to adjust for transparency.
	* @param value - An optional numeric value to adjust.
	* @returns The calculated transparency value or undefined if the value is not provided.
	*/ function calculateTransparencyValue(transparency, value) {
		return value !== void 0 ? adjustToTransparency(value * 100, transparency) : void 0;
	}
	/**
	* Determines the direction of the slider based on the given parameters.
	*
	* @param dir - The text direction, either 'ltr' (left-to-right) or 'rtl' (right-to-left).
	* @param vertical - A boolean indicating if the slider is vertical.
	* @param transparency - A boolean indicating if the slider is for transparency.
	* @returns The direction of the slider as a string representing degrees (e.g., '90deg').
	*/ function getSliderDirection(dir, vertical, transparency) {
		if (vertical) return transparency ? "180deg" : "0deg";
		return dir === "ltr" && !transparency ? "90deg" : "-90deg";
	}

//#endregion
//#region node_modules/@fluentui/react-color-picker/lib/components/AlphaSlider/useAlphaSliderState.js
	const useAlphaSliderState_unstable = (state, props) => {
		"use no memo";
		var _props_defaultColor;
		const { dir } = useFluent();
		const onChangeFromContext = useColorPickerContextValue_unstable((ctx) => ctx.requestChange);
		const colorFromContext = useColorPickerContextValue_unstable((ctx) => ctx.color);
		const { color: color$1, onChange = onChangeFromContext, transparency = false, vertical = false } = props;
		const hsvColor = color$1 || colorFromContext;
		const hslColor = tinycolor(hsvColor).toHsl();
		const [currentValue, setCurrentValue] = useControllableState({
			defaultState: calculateTransparencyValue(transparency, (_props_defaultColor = props.defaultColor) === null || _props_defaultColor === void 0 ? void 0 : _props_defaultColor.a),
			state: calculateTransparencyValue(transparency, hsvColor === null || hsvColor === void 0 ? void 0 : hsvColor.a),
			initialState: adjustToTransparency(100, transparency)
		});
		const clampedValue = clamp$2(currentValue, MIN, MAX);
		const valuePercent = getPercent(clampedValue, MIN, MAX);
		const inputOnChange = state.input.onChange;
		const _onChange = useEventCallback((event) => {
			const newValue = adjustToTransparency(Number(event.target.value), transparency);
			const newColor = createHsvColor({
				...hsvColor,
				a: newValue / 100
			});
			setCurrentValue(newValue);
			inputOnChange === null || inputOnChange === void 0 || inputOnChange(event);
			onChange === null || onChange === void 0 || onChange(event, {
				type: "change",
				event,
				color: newColor
			});
		});
		const sliderDirection = getSliderDirection(dir, vertical, transparency);
		const rootVariables = {
			[alphaSliderCSSVars.sliderDirectionVar]: sliderDirection,
			[alphaSliderCSSVars.sliderProgressVar]: `${valuePercent}%`,
			[alphaSliderCSSVars.thumbColorVar]: `hsla(${hslColor.h} ${hslColor.s * 100}%, ${hslColor.l * 100}%, ${hslColor.a})`,
			[alphaSliderCSSVars.railColorVar]: `hsl(${hslColor.h} ${hslColor.s * 100}%, ${hslColor.l * 100}%)`
		};
		state.root.style = {
			...rootVariables,
			...state.root.style
		};
		state.input.value = clampedValue;
		state.input.onChange = _onChange;
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-color-picker/lib/components/AlphaSlider/useAlphaSlider.js
/**
	* Create the state required to render AlphaSlider.
	*
	* The returned state can be modified with hooks such as useAlphaSliderStyles_unstable,
	* before being passed to renderAlphaSlider_unstable.
	*
	* @param props - props from this instance of AlphaSlider
	* @param ref - reference to root HTMLInputElement of AlphaSlider
	*/ const useAlphaSlider_unstable = (props, ref) => {
		const shapeFromContext = useColorPickerContextValue_unstable((ctx) => ctx.shape);
		const nativeProps = getPartitionedNativeProps({
			props,
			primarySlotTagName: "input",
			excludedPropNames: ["onChange", "color"]
		});
		const { shape = shapeFromContext, vertical, root, input, rail, thumb } = props;
		const state = {
			shape,
			vertical,
			components: {
				input: "input",
				rail: "div",
				root: "div",
				thumb: "div"
			},
			root: always(root, {
				defaultProps: nativeProps.root,
				elementType: "div"
			}),
			input: always(input, {
				defaultProps: {
					id: useId("slider-", props.id),
					ref,
					...nativeProps.primary,
					type: "range"
				},
				elementType: "input"
			}),
			rail: always(rail, { elementType: "div" }),
			thumb: always(thumb, { elementType: "div" })
		};
		useAlphaSliderState_unstable(state, props);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-color-picker/lib/components/AlphaSlider/renderAlphaSlider.js
/**
	* Render the final JSX of AlphaSlider
	*/ const renderAlphaSlider_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(state.root, { children: [
			/* @__PURE__ */ jsx(state.input, {}),
			/* @__PURE__ */ jsx(state.rail, {}),
			/* @__PURE__ */ jsx(state.thumb, {})
		] });
	};

//#endregion
//#region node_modules/@fluentui/react-color-picker/lib/components/AlphaSlider/AlphaSlider.js
/**
	* AlphaSlider component
	*/ const AlphaSlider = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useAlphaSlider_unstable(props, ref);
		useAlphaSliderStyles_unstable(state);
		useCustomStyleHook("useAlphaSliderStyles_unstable")(state);
		return renderAlphaSlider_unstable(state);
	});
	AlphaSlider.displayName = "AlphaSlider";

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/Nav/useNav.js
/**
	* Initial value for the uncontrolled case of the list of open indexes
	*/ function initializeUncontrolledOpenCategories({ defaultOpenCategories, multiple }) {
		if (defaultOpenCategories !== void 0) {
			if (Array.isArray(defaultOpenCategories)) return multiple ? defaultOpenCategories : [defaultOpenCategories[0]];
			return [defaultOpenCategories];
		}
	}
	/**
	* Updates the list of open indexes based on an index that changes
	* @param value - the index that will change
	* @param previousOpenItems - list of current open indexes
	* @param multiple - if Nav supports open categories at the same time
	*/ const updateOpenCategories = (value, previousOpenItems, multiple) => {
		if (multiple) if (previousOpenItems.includes(value)) return previousOpenItems.filter((i) => i !== value);
		else return [...previousOpenItems, value];
		return previousOpenItems[0] === value ? [] : [value];
	};
	/**
	* Create the state required to render Nav.
	*
	* The returned state can be modified with hooks such as useNavStyles,
	* before being passed to renderNav.
	*
	* @param props - props from this instance of Nav
	* @param ref - reference to root HTMLDivElement of Nav
	*/ const useNav_unstable = (props, ref) => {
		const { onNavItemSelect, onNavCategoryItemToggle, multiple = true, density = "medium", openCategories: controlledOpenCategoryItems, selectedCategoryValue: controlledSelectedCategoryValue, selectedValue: controlledSelectedValue, defaultOpenCategories, defaultSelectedValue, defaultSelectedCategoryValue } = props;
		const innerRef = react.useRef(null);
		const [openCategories, setOpenCategories] = useControllableState({
			state: controlledOpenCategoryItems,
			defaultState: initializeUncontrolledOpenCategories({
				defaultOpenCategories,
				multiple
			}),
			initialState: []
		});
		const [selectedCategoryValue, setSelectedCategoryValue] = useControllableState({
			state: controlledSelectedCategoryValue,
			defaultState: defaultSelectedCategoryValue,
			initialState: void 0
		});
		const [selectedValue, setSelectedValue] = useControllableState({
			state: controlledSelectedValue,
			defaultState: defaultSelectedValue,
			initialState: void 0
		});
		const currentSelectedValue = react.useRef(void 0);
		const previousSelectedValue = react.useRef(void 0);
		const currentSelectedCategoryValue = react.useRef(void 0);
		const previousSelectedCategoryValue = react.useRef(void 0);
		if (currentSelectedValue.current !== selectedValue) {
			previousSelectedValue.current = currentSelectedValue.current;
			currentSelectedValue.current = selectedValue;
		}
		if (currentSelectedCategoryValue.current !== selectedCategoryValue) {
			previousSelectedCategoryValue.current = currentSelectedCategoryValue.current;
			currentSelectedCategoryValue.current = selectedCategoryValue;
		}
		const onSelect = useEventCallback((event, data) => {
			setSelectedValue(data.value);
			setSelectedCategoryValue(data.categoryValue ? data.categoryValue : "");
			onNavItemSelect === null || onNavItemSelect === void 0 || onNavItemSelect(event, data);
		});
		const onRequestNavCategoryItemToggle = useEventCallback((event, data) => {
			if (data.categoryValue !== void 0) {
				const nextOpenCategories = updateOpenCategories(data.categoryValue, openCategories !== null && openCategories !== void 0 ? openCategories : [], multiple);
				onNavCategoryItemToggle === null || onNavCategoryItemToggle === void 0 || onNavCategoryItemToggle(event, data);
				setOpenCategories(nextOpenCategories);
			}
		});
		const registeredNavItems = react.useRef({});
		const onRegister = react.useCallback((data) => {
			registeredNavItems.current[JSON.stringify(data.value)] = data;
		}, []);
		const onUnregister = react.useCallback((data) => {
			delete registeredNavItems.current[JSON.stringify(data.value)];
		}, []);
		const getRegisteredNavItems = react.useCallback(() => {
			return {
				selectedValue: currentSelectedValue.current,
				previousSelectedValue: previousSelectedValue.current,
				selectedCategoryValue: currentSelectedCategoryValue.current,
				previousSelectedCategoryValue: previousSelectedCategoryValue.current,
				registeredNavItems: registeredNavItems.current
			};
		}, []);
		return {
			components: { root: "div" },
			root: always(getIntrinsicElementProps("div", {
				ref: useMergedRefs(ref, innerRef),
				...props
			}), { elementType: "div" }),
			openCategories,
			selectedValue,
			selectedCategoryValue,
			onRegister,
			onUnregister,
			onSelect,
			getRegisteredNavItems,
			onRequestNavCategoryItemToggle,
			multiple,
			density,
			tabbable: false
		};
	};

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/NavContext.js
	const navContextDefaultValue = {
		selectedValue: void 0,
		selectedCategoryValue: void 0,
		onRegister: () => {},
		onUnregister: () => {},
		onSelect: () => {},
		getRegisteredNavItems: () => {
			return { registeredNavItems: {} };
		},
		onRequestNavCategoryItemToggle() {},
		openCategories: [],
		multiple: true,
		density: "medium",
		tabbable: false
	};
	const NavContext = react.createContext(void 0);
	const NavProvider = NavContext.Provider;
	const useNavContext_unstable = () => react.useContext(NavContext) || navContextDefaultValue;

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/Nav/renderNav.js
	const renderNav_unstable = (state, contextValues) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(NavProvider, {
			value: contextValues.nav,
			children: /* @__PURE__ */ jsx(state.root, {})
		});
	};

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/Nav/useNavStyles.styles.js
	const navClassNames = { root: "fui-Nav" };
	/**
	* Styles for the root slot
	*/
	const useStyles$8 = /* @__PURE__ */ __styles({ root: {
		mc9l5x: "f22iagw",
		Beiy3e4: "f1vx9l62"
	} }, { d: [".f22iagw{display:flex;}", ".f1vx9l62{flex-direction:column;}"] });
	/**
	* Apply styling to the Nav slots based on the state
	*/
	const useNavStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$8();
		state.root.className = mergeClasses(navClassNames.root, styles.root, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/useNavContextValues.js
	function useNavContextValues_unstable(state) {
		const { selectedValue, selectedCategoryValue, onRegister, onUnregister, onSelect, getRegisteredNavItems, onRequestNavCategoryItemToggle, openCategories, multiple, density, onNavItemSelect, tabbable } = state;
		return { nav: react.useMemo(() => ({
			selectedValue,
			selectedCategoryValue,
			onSelect,
			onRegister,
			onUnregister,
			getRegisteredNavItems,
			onRequestNavCategoryItemToggle,
			openCategories,
			multiple,
			density,
			onNavItemSelect,
			tabbable
		}), [
			selectedValue,
			selectedCategoryValue,
			onSelect,
			onRegister,
			onUnregister,
			getRegisteredNavItems,
			onRequestNavCategoryItemToggle,
			openCategories,
			multiple,
			density,
			onNavItemSelect,
			tabbable
		]) };
	}

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/Nav/Nav.js
/**
	* Nav - A component that provides up to two levels of nesting for navigation.
	*/ const Nav = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useNav_unstable(props, ref);
		const contextValues = useNavContextValues_unstable(state);
		useNavStyles_unstable(state);
		useCustomStyleHook("useHamburgerStyles_unstable")(state);
		return renderNav_unstable(state, contextValues);
	});
	Nav.displayName = "Nav";

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/NavCategory/useNavCategory.js
/**
	* Create the state required to render NavCategory.
	*
	* The returned state can be modified with hooks such as useNavCategoryStyles_unstable,
	* before being passed to renderNavCategory_unstable.
	*
	* @param props - props from this instance of NavCategory
	* @param ref - reference to root HTMLDivElement of NavCategory
	*/ const useNavCategory_unstable = (props, ref) => {
		const { value, children } = props;
		const { openCategories } = useNavContext_unstable();
		return {
			open: openCategories === null || openCategories === void 0 ? void 0 : openCategories.includes(value),
			value,
			children: children !== null && children !== void 0 ? children : null
		};
	};

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/NavCategoryContext.js
	const NavCategoryContext = react.createContext(void 0);
	const navCategoryContextDefaultValue = {
		open: false,
		value: ""
	};
	const { Provider: NavCategoryProvider } = NavCategoryContext;
	const useNavCategoryContext_unstable = () => {
		var _React_useContext;
		return (_React_useContext = react.useContext(NavCategoryContext)) !== null && _React_useContext !== void 0 ? _React_useContext : navCategoryContextDefaultValue;
	};

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/NavCategory/renderNavCategory.js
/**
	* Render the final JSX of NavCategory
	*/ const renderNavCategory_unstable = (state, contextValues) => {
		return /* @__PURE__ */ react.createElement(NavCategoryProvider, { value: contextValues.categoryValue }, state.children);
	};

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/useNavCategoryContextValues_unstable.js
	function useNavCategoryContextValues_unstable(state) {
		const { open, value } = state;
		return { categoryValue: react.useMemo(() => ({
			open,
			value
		}), [open, value]) };
	}

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/NavCategory/NavCategory.js
/**
	* NavCategory component - a category in the navigation menu that can contain multiple items.
	*/ const NavCategory = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useNavCategory_unstable(props, ref);
		return renderNavCategory_unstable(state, useNavCategoryContextValues_unstable(state));
	});
	NavCategory.displayName = "NavCategory";

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/NavCategoryItem/useNavCategoryItem.js
	const ExpandIconMotion = createPresenceComponentVariant(Rotate, {
		duration: motionTokens.durationFast,
		easing: motionTokens.curveEasyEase,
		animateOpacity: false,
		fromAngle: 0,
		toAngle: 180
	});
	/**
	* Create the state required to render NavCategoryItem.
	*
	* The returned state can be modified with hooks such as useNavCategoryItemStyles,
	* before being passed to renderNavCategoryItem.
	*
	* @param props - props from this instance of NavCategoryItem
	* @param ref - reference to root HTMLButtonElement of NavCategoryItem
	*/ const useNavCategoryItem_unstable = (props, ref) => {
		const { onClick, expandIcon, icon } = props;
		const { open, value } = useNavCategoryContext_unstable();
		const { onRequestNavCategoryItemToggle, selectedCategoryValue, density = "medium" } = useNavContext_unstable();
		const onNavCategoryItemClick = useEventCallback(mergeCallbacks(onClick, (event) => onRequestNavCategoryItemToggle(event, {
			type: "click",
			event,
			value: "",
			categoryValue: value
		})));
		const selected = selectedCategoryValue === value && !open;
		const validAriaCurrent = selected && !open ? "page" : "false";
		return {
			open,
			value,
			selected,
			components: {
				root: "button",
				icon: "span",
				expandIcon: "span",
				expandIconMotion: ExpandIconMotion
			},
			root: always(getIntrinsicElementProps("button", {
				ref,
				"aria-current": validAriaCurrent,
				"aria-expanded": open,
				...props,
				onClick: onNavCategoryItemClick
			}), { elementType: "button" }),
			expandIcon: always(expandIcon, {
				defaultProps: {
					children: /* @__PURE__ */ react.createElement(ChevronDown20Regular, null),
					"aria-hidden": true
				},
				elementType: "span"
			}),
			expandIconMotion: presenceMotionSlot(props.expandIconMotion, {
				elementType: ExpandIconMotion,
				defaultProps: { visible: open }
			}),
			icon: optional(icon, { elementType: "span" }),
			density
		};
	};

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/NavCategoryItemContext.js
	const NavCategoryItemContext = react.createContext(void 0);
	const NavCategoryItemContextDefaultValues = { open: false };
	const { Provider: NavCategoryItemProvider } = NavCategoryItemContext;
	const useNavCategoryItemContext_unstable = () => {
		var _React_useContext;
		return (_React_useContext = react.useContext(NavCategoryItemContext)) !== null && _React_useContext !== void 0 ? _React_useContext : NavCategoryItemContextDefaultValues;
	};

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/NavCategoryItem/renderNavCategoryItem.js
	const getExpandIcon = (state) => {
		assertSlots(state);
		if (!state.expandIcon) return null;
		if (!state.expandIconMotion) return /* @__PURE__ */ jsx(state.expandIcon, {});
		return /* @__PURE__ */ jsx(state.expandIconMotion, { children: /* @__PURE__ */ jsx(state.expandIcon, {}) });
	};
	/**
	* Render the final JSX of NavCategoryItem
	*/ const renderNavCategoryItem_unstable = (state, contextValues) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(NavCategoryItemProvider, {
			value: contextValues.navCategoryItem,
			children: /* @__PURE__ */ jsxs(state.root, { children: [
				state.icon && /* @__PURE__ */ jsx(state.icon, {}),
				state.root.children,
				getExpandIcon(state)
			] })
		});
	};

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/sharedNavStyles.styles.js
	const navItemTokens = {
		defaultDrawerWidth: 260,
		indicatorOffset: 16,
		indicatorWidth: 4,
		indicatorHeight: 20,
		backgroundColor: tokens.colorNeutralBackground4,
		backgroundColorHover: tokens.colorNeutralBackground4Hover,
		backgroundColorPressed: tokens.colorNeutralBackground4Pressed,
		animationTokens: {
			animationDuration: tokens.durationFaster,
			animationFillMode: "both",
			animationTimingFunction: tokens.curveLinear
		},
		transitionTokens: {
			transitionDuration: tokens.durationFaster,
			transitionTimingFunction: tokens.curveLinear,
			transitionProperty: "background"
		}
	};
	/**
	* Styles for the root slot
	* Shared across NavItem, NavCategoryItem, NavSubItem, and AppItem
	*/
	const useRootDefaultClassName = /* @__PURE__ */ __resetStyles("rdi7s9k", "r94071", [
		".rdi7s9k{display:flex;text-transform:none;position:relative;justify-content:start;align-items:flex-start;text-align:left;gap:var(--spacingVerticalL);padding:var(--spacingVerticalMNudge) var(--spacingHorizontalS) var(--spacingVerticalMNudge) var(--spacingHorizontalMNudge);background-color:var(--colorNeutralBackground4);border-radius:var(--borderRadiusMedium);color:var(--colorNeutralForeground2);text-decoration-line:none;border:none;box-sizing:border-box;cursor:pointer;transition-duration:var(--durationFaster);transition-timing-function:var(--curveLinear);transition-property:background;width:100%;font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase300);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase300);}",
		".rdi7s9k:hover{background-color:var(--colorNeutralBackground4Hover);}",
		".rdi7s9k:focus-visible{outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);outline-offset:calc(var(--strokeWidthThick) * -1);}",
		".r94071{display:flex;text-transform:none;position:relative;justify-content:start;align-items:flex-start;text-align:right;gap:var(--spacingVerticalL);padding:var(--spacingVerticalMNudge) var(--spacingHorizontalMNudge) var(--spacingVerticalMNudge) var(--spacingHorizontalS);background-color:var(--colorNeutralBackground4);border-radius:var(--borderRadiusMedium);color:var(--colorNeutralForeground2);text-decoration-line:none;border:none;box-sizing:border-box;cursor:pointer;transition-duration:var(--durationFaster);transition-timing-function:var(--curveLinear);transition-property:background;width:100%;font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase300);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase300);}",
		".r94071:hover{background-color:var(--colorNeutralBackground4Hover);}",
		".r94071:focus-visible{outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);outline-offset:calc(var(--strokeWidthThick) * -1);}"
	]);
	const useSmallStyles = /* @__PURE__ */ __styles({ root: {
		Byoj8tv: 0,
		uwmqm3: 0,
		z189sj: 0,
		z8tnut: 0,
		B0ocmuz: ["f1434i56", "f1jkyjtc"]
	} }, { d: [[".f1434i56{padding:var(--spacingVerticalXS) var(--spacingHorizontalS) var(--spacingVerticalXS) var(--spacingHorizontalMNudge);}", { p: -1 }], [".f1jkyjtc{padding:var(--spacingVerticalXS) var(--spacingHorizontalMNudge) var(--spacingVerticalXS) var(--spacingHorizontalS);}", { p: -1 }]] });
	/**
	* Styles for the content slot (children)
	* Shared across NavItem, NavCategoryItem, NavSubItem, and AppItem
	*/
	const useContentStyles = /* @__PURE__ */ __styles({ selected: {
		Bahqtrf: "fk6fouc",
		Be2twd7: "fkhj508",
		Bhrd7zp: "fl43uef",
		Bg96gwp: "f1i3iumi"
	} }, { d: [
		".fk6fouc{font-family:var(--fontFamilyBase);}",
		".fkhj508{font-size:var(--fontSizeBase300);}",
		".fl43uef{font-weight:var(--fontWeightSemibold);}",
		".f1i3iumi{line-height:var(--lineHeightBase300);}"
	] });
	/**
	* French fry styles
	* Shared across NavItem, NavCategoryItem, and NavSubItem
	*/
	const useIndicatorStyles = /* @__PURE__ */ __styles({ base: {
		E3zdtr: "f1mdlcz9",
		xr36ep: "fpil94b",
		B67388b: "f90z1up",
		Bitv4sc: "f2ic3ny",
		Br128sd: "f1xz7mvd",
		rjyhj6: "f3i5gj0",
		Bjyk6c5: "fi4v1pz",
		Dlnsje: "f1tvrmnx",
		a2br6o: "f1p1ggug",
		d9w3h3: 0,
		B3778ie: 0,
		B4j8arr: 0,
		Bl18szs: 0,
		Blrzh8d: "f3b9emi",
		Bsft5z2: "f13zj6fq",
		vikyaa: 0,
		Brlscjf: 0,
		vvp1qr: 0,
		t65l24: "f1ak99p5",
		rc3c53: "fmnu42u"
	} }, {
		d: [
			".f1mdlcz9::after{position:absolute;}",
			".fpil94b::after{animation-duration:var(--durationFaster);}",
			".f90z1up::after{animation-fill-mode:both;}",
			".f2ic3ny::after{animation-timing-function:var(--curveLinear);}",
			".f1xz7mvd::after{animation-name:f1ayorr4;}",
			".f3i5gj0::after{-webkit-margin-start:-16px;margin-inline-start:-16px;}",
			".fi4v1pz::after{background-color:var(--colorCompoundBrandForeground1);}",
			".f1tvrmnx::after{height:20px;}",
			".f1p1ggug::after{width:4px;}",
			[".f3b9emi::after{border-radius:var(--borderRadiusCircular);}", { p: -1 }],
			".f13zj6fq::after{content:\"\";}"
		],
		k: ["@keyframes f1ayorr4{0%{background:transparent;}100%{background:var(--colorCompoundBrandForeground1);}}"],
		m: [["@media (forced-colors: active){.f1ak99p5::after{outline:solid 2px var(--colorTransparentStroke);}}", {
			p: -1,
			m: "(forced-colors: active)"
		}], ["@media (forced-colors: active){.fmnu42u::after{outline-offset:-2px;}}", { m: "(forced-colors: active)" }]]
	});
	/**
	* Styles for the icon slot
	* Shared across NavItem, NavCategoryItem, and NavSubItem
	* We use the grid trick to stack the filled and regular icons on top of each other
	*/
	const useIconStyles = /* @__PURE__ */ __styles({
		base: {
			mc9l5x: "f13qh94s",
			zoa1oz: "fngvled",
			sshi5w: "f16gbxbe",
			Bf4jedk: "f11u7vat",
			Bt984gj: "f1w4ww9t",
			Brf1p80: "f4d9j23",
			B68tc82: 0,
			Bmxbyg5: 0,
			Bpg54ce: "f1a3p1vp",
			B9gejnh: 0,
			yr4pdu: 0,
			Bvkmzld: 0,
			mqdk8l: 0,
			Gbjhqp: "f1uiug86",
			obb2bi: "fwrh02z",
			D0sxk3: "f16u1re",
			Esdz9e: 0,
			Bqil8sh: 0,
			Bbom3er: 0,
			djjtid: 0,
			mz70lj: "f1jsjwoh",
			t6yez3: "f8bsbmo"
		},
		selected: {
			C9vb3z: "f5rs5gh",
			ux3ctl: "f1ioc1t6",
			Ba906uv: "fey0lwf",
			D0sxk3: "fxoiby5",
			hndn0g: "fnh0dvc",
			cw2nnk: "fp7jrvw",
			Bkztwl0: "fdt4y6x",
			H8nmoi: "fvl64og",
			ipgedg: "ffh1t26"
		}
	}, {
		d: [
			".f13qh94s{display:grid;}",
			".fngvled{grid-template-areas:overlay-area;}",
			".f16gbxbe{min-height:20px;}",
			".f11u7vat{min-width:20px;}",
			".f1w4ww9t{align-items:top;}",
			".f4d9j23{justify-content:center;}",
			[".f1a3p1vp{overflow:hidden;}", { p: -1 }],
			[".f1uiug86 .fui-Icon-filled{grid-area:overlay-area;}", { p: -1 }],
			".fwrh02z .fui-Icon-filled{color:transparent;}",
			".f16u1re .fui-Icon-filled{display:none;}",
			[".f1jsjwoh .fui-Icon-regular{grid-area:overlay-area;}", { p: -1 }],
			".f8bsbmo .fui-Icon-regular{display:inline;}",
			".f5rs5gh .fui-Icon-filled{animation-duration:var(--durationFaster);}",
			".f1ioc1t6 .fui-Icon-filled{animation-fill-mode:both;}",
			".fey0lwf .fui-Icon-filled{animation-timing-function:var(--curveLinear);}",
			".fxoiby5 .fui-Icon-filled{display:inline;}",
			".fnh0dvc .fui-Icon-filled{animation-name:f9t3kp0;}",
			".fp7jrvw .fui-Icon-regular{animation-duration:var(--durationFaster);}",
			".fdt4y6x .fui-Icon-regular{animation-fill-mode:both;}",
			".fvl64og .fui-Icon-regular{animation-timing-function:var(--curveLinear);}",
			".ffh1t26 .fui-Icon-regular{animation-name:fvunsy5;}"
		],
		k: ["@keyframes f9t3kp0{0%{opacity:0;color:transparent;}100%{opacity:1;color:var(--colorNeutralForeground2BrandSelected);}}", "@keyframes fvunsy5{0%{opacity:1;color:var(--colorNeutralForeground2);}100%{opacity:0;color:transparent;}}"]
	});

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/NavCategoryItem/useNavCategoryItem.styles.js
	const navCategoryItemClassNames = {
		root: "fui-NavCategoryItem",
		icon: "fui-NavCategoryItem__icon",
		expandIcon: "fui-NavCategoryItem__expandIcon",
		expandIconMotion: "fui-NavCategoryItem__expandIconMotion"
	};
	const useExpandIconStyles = /* @__PURE__ */ __styles({
		base: {
			Jyy4pa: "f1lfeew",
			Bqenvij: "fjamq6b"
		},
		selected: {
			Bahqtrf: "fk6fouc",
			Be2twd7: "fkhj508",
			Bhrd7zp: "fl43uef",
			Bg96gwp: "f1i3iumi"
		}
	}, { d: [
		".f1lfeew{-webkit-margin-start:auto;margin-inline-start:auto;}",
		".fjamq6b{height:20px;}",
		".fk6fouc{font-family:var(--fontFamilyBase);}",
		".fkhj508{font-size:var(--fontSizeBase300);}",
		".fl43uef{font-weight:var(--fontWeightSemibold);}",
		".f1i3iumi{line-height:var(--lineHeightBase300);}"
	] });
	/**
	* Styles for the root slot
	*/
	const useRootStyles = /* @__PURE__ */ __styles({ base: { a9b677: "fly5x3f" } }, { d: [".fly5x3f{width:100%;}"] });
	/**
	* Apply styling to the NavCategoryItem slots based on the state
	*/
	const useNavCategoryItemStyles_unstable = (state) => {
		"use no memo";
		const rootStyles = useRootStyles();
		const smallStyles = useSmallStyles();
		const defaultRootClassName = useRootDefaultClassName();
		const contentStyles = useContentStyles();
		const indicatorStyles = useIndicatorStyles();
		const iconStyles = useIconStyles();
		const expandIconStyles = useExpandIconStyles();
		const { selected, open, density } = state;
		state.root.className = mergeClasses(navCategoryItemClassNames.root, defaultRootClassName, rootStyles.base, density === "small" && smallStyles.root, selected && open === false && indicatorStyles.base, selected && open === false && contentStyles.selected, state.root.className);
		state.expandIcon.className = mergeClasses(navCategoryItemClassNames.expandIcon, expandIconStyles.base, state.expandIcon.className);
		if (state.icon) state.icon.className = mergeClasses(navCategoryItemClassNames.icon, iconStyles.base, selected && iconStyles.selected, state.icon.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/useNavCategoryItemContextValues_unstable.js
	function useNavCategoryItemContextValues_unstable(state) {
		const { open, value } = state;
		return { navCategoryItem: react.useMemo(() => ({
			open,
			value
		}), [open, value]) };
	}

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/NavCategoryItem/NavCategoryItem.js
/**
	* A Nav Category Item provides provides a clickable accordion like header that exposes
	* a list of NavSubItems to take users to a new destination.
	*/ const NavCategoryItem = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useNavCategoryItem_unstable(props, ref);
		const contextValues = useNavCategoryItemContextValues_unstable(state);
		useNavCategoryItemStyles_unstable(state);
		useCustomStyleHook("useNavCategoryItemStyles")(state);
		return renderNavCategoryItem_unstable(state, contextValues);
	});
	NavCategoryItem.displayName = "NavCategoryItem";

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/NavItem/useNavItem.js
/**
	* Create the state required to render NavItem.
	*
	* The returned state can be modified with hooks such as useNavItemStyles_unstable,
	* before being passed to renderNavItem_unstable.
	*
	* @param props - props from this instance of NavItem
	* @param ref - reference to root HTMLAnchorElement of NavItem
	*/ const useNavItem_unstable = (props, ref) => {
		const { onClick, value, icon, as, href } = props;
		const { selectedValue, onRegister, onUnregister, onSelect, density = "medium" } = useNavContext_unstable();
		const rootElementType = as || (href ? "a" : "button");
		const selected = selectedValue === value;
		const innerRef = react.useRef(null);
		const onNavItemClick = useEventCallback((event) => {
			onClick === null || onClick === void 0 || onClick(event);
			if (!event.defaultPrevented && isHTMLElement(event.target)) onSelect(event, {
				type: "click",
				event,
				value
			});
		});
		const root = always(getIntrinsicElementProps(rootElementType, useARIAButtonProps(rootElementType, {
			"aria-current": selected ? "page" : "false",
			...props
		})), {
			elementType: rootElementType,
			defaultProps: {
				ref,
				type: rootElementType
			}
		});
		root.onClick = onNavItemClick;
		react.useEffect(() => {
			onRegister({
				value,
				ref: innerRef
			});
			return () => {
				onUnregister({
					value,
					ref: innerRef
				});
			};
		}, [
			onRegister,
			onUnregister,
			innerRef,
			value
		]);
		return {
			components: {
				root: rootElementType,
				icon: "span"
			},
			root,
			icon: optional(icon, { elementType: "span" }),
			selected,
			value,
			density
		};
	};

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/NavItem/renderNavItem.js
/**
	* Render the final JSX of NavItem
	*/ const renderNavItem_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(state.root, { children: [state.icon && /* @__PURE__ */ jsx(state.icon, {}), state.root.children] });
	};

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/NavItem/useNavItemStyles.styles.js
	const navItemClassNames = {
		root: "fui-NavItem",
		icon: "fui-NavItem__icon"
	};
	/**
	* Apply styling to the NavItem slots based on the state
	*/
	const useNavItemStyles_unstable = (state) => {
		"use no memo";
		const rootDefaultClassName = useRootDefaultClassName();
		const smallStyles = useSmallStyles();
		const contentStyles = useContentStyles();
		const indicatorStyles = useIndicatorStyles();
		const iconStyles = useIconStyles();
		const { selected, density } = state;
		state.root.className = mergeClasses(navItemClassNames.root, rootDefaultClassName, density === "small" && smallStyles.root, selected && indicatorStyles.base, selected && contentStyles.selected, state.root.className);
		if (state.icon) state.icon.className = mergeClasses(navItemClassNames.icon, iconStyles.base, selected && iconStyles.selected, state.icon.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/NavItem/NavItem.js
/**
	* NavItem component - a single item in the navigation menu.
	*/ const NavItem = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useNavItem_unstable(props, ref);
		useNavItemStyles_unstable(state);
		useCustomStyleHook("useNavItemStyles_unstable")(state);
		return renderNavItem_unstable(state);
	});
	NavItem.displayName = "NavItem";

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/NavSubItem/useNavSubItem.js
/**
	* Create the state required to render NavSubItem.
	*
	* The returned state can be modified with hooks such as useNavSubItemStyles_unstable,
	* before being passed to renderNavSubItem_unstable.
	*
	* @param props - props from this instance of NavSubItem
	* @param ref - reference to root HTMLButtonElement of NavSubItem
	*/ const useNavSubItem_unstable = (props, ref) => {
		const { onClick, value: subItemValue, as, href } = props;
		const { selectedValue, onRegister, onUnregister, onSelect, density = "medium" } = useNavContext_unstable();
		const { value: parentCategoryValue } = useNavCategoryContext_unstable();
		const rootElementType = as || (href ? "a" : "button");
		const selected = selectedValue === subItemValue;
		const innerRef = react.useRef(null);
		const onNavSubItemClick = useEventCallback((event) => {
			onClick === null || onClick === void 0 || onClick(event);
			if (!event.defaultPrevented && isHTMLElement(event.target)) onSelect(event, {
				type: "click",
				event,
				value: subItemValue,
				categoryValue: parentCategoryValue
			});
		});
		const root = always(getIntrinsicElementProps(rootElementType, useARIAButtonProps(rootElementType, {
			"aria-current": selected ? "page" : "false",
			...props
		})), {
			elementType: rootElementType,
			defaultProps: {
				ref,
				type: rootElementType
			}
		});
		root.onClick = onNavSubItemClick;
		react.useEffect(() => {
			onRegister({
				value: subItemValue,
				ref: innerRef
			});
			return () => {
				onUnregister({
					value: subItemValue,
					ref: innerRef
				});
			};
		}, [
			onRegister,
			onUnregister,
			innerRef,
			subItemValue
		]);
		return {
			components: { root: rootElementType },
			root,
			selected,
			value: subItemValue,
			density
		};
	};

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/NavSubItem/renderNavSubItem.js
/**
	* Render the final JSX of NavSubItem
	*/ const renderNavSubItem_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, {});
	};

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/NavSubItem/useNavSubItemStyles.styles.js
	const navSubItemClassNames = { root: "fui-NavSubItem" };
	/**
	* Styles for the content slot (children)
	*/
	const useNavSubItemSpecificStyles = /* @__PURE__ */ __styles({
		base: { B1hrpyx: "fqo71ku" },
		smallBase: { B1hrpyx: "f17f9sv1" },
		selectedIndicator: { rjyhj6: "f1f74g36" }
	}, { d: [
		".fqo71ku{-webkit-padding-start:46px;padding-inline-start:46px;}",
		".f17f9sv1{-webkit-padding-start:40px;padding-inline-start:40px;}",
		".f1f74g36::after{-webkit-margin-start:-52px;margin-inline-start:-52px;}"
	] });
	/**
	* Apply styling to the NavSubItem slots based on the state
	*/
	const useNavSubItemStyles_unstable = (state) => {
		"use no memo";
		const rootDefaultClassName = useRootDefaultClassName();
		const smallStyles = useSmallStyles();
		const contentStyles = useContentStyles();
		const indicatorStyles = useIndicatorStyles();
		const navSubItemSpecificStyles = useNavSubItemSpecificStyles();
		const { selected, density } = state;
		const isSmallDensity = density === "small";
		state.root.className = mergeClasses(navSubItemClassNames.root, rootDefaultClassName, isSmallDensity && smallStyles.root, isSmallDensity && navSubItemSpecificStyles.smallBase, navSubItemSpecificStyles.base, selected && indicatorStyles.base, selected && contentStyles.selected, selected && navSubItemSpecificStyles.selectedIndicator, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/NavSubItem/NavSubItem.js
/**
	* NavSubItem component - a sub-item within a navigation structure.
	*/ const NavSubItem = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useNavSubItem_unstable(props, ref);
		useNavSubItemStyles_unstable(state);
		useCustomStyleHook("useNavSubItemStyles_unstable")(state);
		return renderNavSubItem_unstable(state);
	});
	NavSubItem.displayName = "NavSubItem";

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/NavSubItemGroup/useNavSubItemGroup.js
	const smallSize = 28;
	const largeSize = 40;
	const NavGroupMotion = createPresenceComponent(({ items, density }) => {
		const isSmallDensity = density === "small";
		const height = items ? isSmallDensity ? items * smallSize : items * largeSize : 0;
		const durationPerItem = isSmallDensity ? 15 : 25;
		const keyframes = [{
			opacity: 0,
			minHeight: 0,
			height: 0
		}, {
			opacity: 1,
			minHeight: `${height}px`,
			height: `${height}px`
		}];
		const baseDuration = motionTokens.durationFast + (items || 0) * durationPerItem;
		const maxDuration = motionTokens.durationUltraSlow;
		const duration = baseDuration > maxDuration ? maxDuration : baseDuration;
		return {
			enter: {
				keyframes,
				duration,
				easing: motionTokens.curveDecelerateMid
			},
			exit: {
				keyframes: [...keyframes].reverse(),
				duration,
				easing: motionTokens.curveAccelerateMin
			}
		};
	});
	/**
	* Create the state required to render NavSubItemGroup.
	*
	* The returned state can be modified with hooks such as useNavSubItemGroupStyles_unstable,
	* before being passed to renderNavSubItemGroup_unstable.
	*
	* @param props - props from this instance of NavSubItemGroup
	* @param ref - reference to root HTMLDivElement of NavSubItemGroup
	*/ const useNavSubItemGroup_unstable = (props, ref) => {
		const { open } = useNavCategoryContext_unstable();
		const { density } = useNavContext_unstable();
		return {
			open,
			components: {
				root: "div",
				collapseMotion: NavGroupMotion
			},
			root: always(getIntrinsicElementProps("div", {
				...props,
				ref
			}), { elementType: "div" }),
			collapseMotion: presenceMotionSlot(props.collapseMotion, {
				elementType: NavGroupMotion,
				defaultProps: {
					visible: open,
					unmountOnExit: true,
					items: react.Children.count(props.children),
					density
				}
			})
		};
	};

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/NavSubItemGroup/renderNavSubItemGroup.js
/**
	* Render the final JSX of NavSubItemGroup
	*/ const renderNavSubItemGroup_unstable = (state) => {
		assertSlots(state);
		return state.collapseMotion ? /* @__PURE__ */ jsx(state.collapseMotion, { children: /* @__PURE__ */ jsx(state.root, {}) }) : /* @__PURE__ */ jsx(state.root, {});
	};

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/NavSubItemGroup/useNavSubItemGroupStyles.styles.js
	const navSubItemGroupClassNames = { root: "fui-NavSubItemGroup" };
	/**
	* Styles for the root slot
	*/
	const useStyles$7 = /* @__PURE__ */ __styles({ root: {
		Bz10aip: "f1yj8dow",
		B68tc82: 0,
		Bmxbyg5: 0,
		Bpg54ce: "f1a3p1vp"
	} }, { d: [".f1yj8dow{transform:translateZ(0);}", [".f1a3p1vp{overflow:hidden;}", { p: -1 }]] });
	/**
	* Apply styling to the NavSubItemGroup slots based on the state
	*/
	const useNavSubItemGroupStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$7();
		state.root.className = mergeClasses(navSubItemGroupClassNames.root, styles.root, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/NavSubItemGroup/NavSubItemGroup.js
/**
	* NavSubItemGroup component - a group of sub-items within a navigation structure.
	*/ const NavSubItemGroup = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useNavSubItemGroup_unstable(props, ref);
		useNavSubItemGroupStyles_unstable(state);
		useCustomStyleHook("useNavSubItemGroupStyles_unstable")(state);
		return renderNavSubItemGroup_unstable(state);
	});
	NavSubItemGroup.displayName = "NavSubItemGroup";

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/NavDrawer/useNavDrawer.js
/**
	* Create the state required to render NavDrawer.
	*
	* The returned state can be modified with hooks such as useNavDrawerStyles_unstable,
	* before being passed to renderNavDrawer_unstable.
	*
	* @param props - props from this instance of NavDrawer
	* @param ref - reference to root HTMLDivElement of NavDrawer
	*/ const useNavDrawer_unstable = (props, ref) => {
		const { size: size$2 = void 0, tabbable = false } = props;
		return {
			...useNav_unstable(props, ref),
			size: size$2,
			tabbable,
			components: { root: Drawer },
			root: always({
				ref,
				role: "navigation",
				...props
			}, { elementType: Drawer })
		};
	};

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/NavDrawer/renderNavDrawer.js
	const renderNavDrawer_unstable = (state, contextValues) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(NavProvider, {
			value: contextValues.nav,
			children: /* @__PURE__ */ jsx(state.root, {})
		});
	};

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/NavDrawer/useNavDrawerStyles.styles.js
	const navDrawerClassNames = { root: "fui-NavDrawer" };
	/**
	* Styles for the root slot
	*/
	const useStyles$6 = /* @__PURE__ */ __styles({
		root: {
			De3pzq: "f1ctqxl6",
			Bt984gj: "f3gca8"
		},
		defaultWidth: { a9b677: "f12j6lm0" }
	}, { d: [
		".f1ctqxl6{background-color:var(--colorNeutralBackground4);}",
		".f3gca8{align-items:unset;}",
		".f12j6lm0{width:260px;}"
	] });
	/**
	* Apply styling to the NavDrawer slots based on the state
	*/
	const useNavDrawerStyles_unstable = (state) => {
		"use no memo";
		const { size: size$2 } = state;
		const styles = useStyles$6();
		state.root.className = mergeClasses(navDrawerClassNames.root, styles.root, !size$2 && styles.defaultWidth, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/NavDrawer/NavDrawer.js
/**
	* NavDrawer component - a component that provides a drawer for navigation items.
	*/ const NavDrawer = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useNavDrawer_unstable(props, ref);
		const contextValues = useNavContextValues_unstable(state);
		useNavDrawerStyles_unstable(state);
		useCustomStyleHook("useNavDrawerStyles_unstable")(state);
		return renderNavDrawer_unstable(state, contextValues);
	});
	NavDrawer.displayName = "NavDrawer";

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/NavDrawerFooter/useNavDrawerFooter.js
/**
	* Create the state required to render NavDrawerFooter.
	*
	* The returned state can be modified with hooks such as useNavDrawerFooterStyles_unstable,
	* before being passed to renderNavDrawerFooter_unstable.
	*
	* @param props - props from this instance of NavDrawerFooter
	* @param ref - reference to root HTMLDivElement of NavDrawerFooter
	*/ const useNavDrawerFooter_unstable = (props, ref) => {
		return useDrawerFooter_unstable(props, ref);
	};

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/NavDrawerFooter/useNavDrawerFooterStyles.styles.js
	const navDrawerFooterClassNames = { root: "fui-NavDrawerFooter" };
	/**
	* Styles for the root slot
	*/
	const useStyles$5 = /* @__PURE__ */ __styles({ root: {
		Byoj8tv: 0,
		uwmqm3: 0,
		z189sj: 0,
		z8tnut: 0,
		B0ocmuz: "f1j1cbdv",
		mc9l5x: "f22iagw",
		Beiy3e4: "f1vx9l62",
		Belr9w4: "f1j0q4x9"
	} }, { d: [
		[".f1j1cbdv{padding:var(--spacingVerticalXXS) var(--spacingHorizontalXS) var(--spacingVerticalXXS) var(--spacingVerticalXS) var(--spacingHorizontalMNudge);}", { p: -1 }],
		".f22iagw{display:flex;}",
		".f1vx9l62{flex-direction:column;}",
		".f1j0q4x9{row-gap:var(--spacingVerticalXXS);}"
	] });
	/**
	* Apply styling to the NavDrawerFooter slots based on the state
	*/
	const useNavDrawerFooterStyles_unstable = (state) => {
		"use no memo";
		useDrawerFooterStyles_unstable(state);
		const styles = useStyles$5();
		state.root.className = mergeClasses(navDrawerFooterClassNames.root, styles.root, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/NavDrawerFooter/NavDrawerFooter.js
/**
	* NavDrawerFooter component
	*/ const NavDrawerFooter = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useNavDrawerFooter_unstable(props, ref);
		useNavDrawerFooterStyles_unstable(state);
		useCustomStyleHook("useNavDrawerFooterStyles_unstable")(state);
		return renderDrawerFooter_unstable(state);
	});
	NavDrawerFooter.displayName = "NavDrawerFooter";

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/NavDrawerHeader/useNavDrawerHeaderStyles.styles.js
	const navDrawerHeaderClassNames = { root: "fui-NavDrawerHeader" };
	/**
	* Styles for the root slot
	*/
	const useStyles$4 = /* @__PURE__ */ __styles({ root: {
		jrapky: 0,
		Frg6f3: 0,
		t21cq0: 0,
		B6of3ja: 0,
		B74szlk: "f1r2n0t9",
		B1hrpyx: "f80d8h0",
		Dbcxam: 0,
		rjzwhg: 0,
		Bblux5w: "fesrmp8"
	} }, { d: [
		[".f1r2n0t9{margin:unset;}", { p: -1 }],
		".f80d8h0{-webkit-padding-start:14px;padding-inline-start:14px;}",
		[".fesrmp8{padding-block:5px;}", { p: -1 }]
	] });
	/**
	* Apply styling to the NavDrawerHeader slots based on the state
	*/
	const useNavDrawerHeaderStyles_unstable = (state) => {
		"use no memo";
		useDrawerHeaderStyles_unstable(state);
		const styles = useStyles$4();
		state.root.className = mergeClasses(navDrawerHeaderClassNames.root, styles.root, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/NavDrawerHeader/useNavDrawerHeader.js
/**
	* Create the state required to render NavDrawerHeader.
	*
	* The returned state can be modified with hooks such as useNavDrawerHeaderStyles_unstable,
	* before being passed to renderNavDrawerHeader_unstable.
	*
	* @param props - props from this instance of NavDrawerHeader
	* @param ref - reference to root HTMLDivElement of NavDrawerHeader
	*/ const useNavDrawerHeader_unstable = (props, ref) => {
		return useDrawerHeader_unstable(props, ref);
	};

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/NavDrawerHeader/NavDrawerHeader.js
/**
	* NavDrawerHeader component
	*/ const NavDrawerHeader = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useNavDrawerHeader_unstable(props, ref);
		useNavDrawerHeaderStyles_unstable(state);
		useCustomStyleHook("useNavDrawerHeaderStyles_unstable")(state);
		return renderDrawerHeader_unstable(state);
	});
	NavDrawerHeader.displayName = "NavDrawerHeader";

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/NavDrawerBody/useNavDrawerBody.js
/**
	* Create the state required to render NavDrawerBody.
	*
	* The returned state can be modified with hooks such as useNavDrawerBodyStyles_unstable,
	* before being passed to renderNavDrawerBody_unstable.
	*
	* @param props - props from this instance of NavDrawerBody
	* @param ref - reference to root HTMLDivElement of NavDrawerBody
	*/ const useNavDrawerBody_unstable = (props, ref) => {
		const { tabbable } = useNavContext_unstable();
		return useDrawerBody_unstable({
			...useArrowNavigationGroup({
				axis: "vertical",
				circular: true,
				tabbable
			}),
			...props
		}, ref);
	};

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/NavDrawerBody/useNavDrawerBodyStyles.styles.js
	const navDrawerBodyClassNames = { root: "fui-NavDrawerBody" };
	/**
	* Styles for the root slot
	*/
	const useStyles$3 = /* @__PURE__ */ __styles({ root: {
		Byoj8tv: 0,
		uwmqm3: 0,
		z189sj: 0,
		z8tnut: 0,
		B0ocmuz: ["fif7vu7", "f1htewbf"],
		Bt984gj: "f3gca8",
		mc9l5x: "f22iagw",
		Beiy3e4: "f1vx9l62",
		Belr9w4: "f1j0q4x9"
	} }, { d: [
		[".fif7vu7{padding:0 var(--spacingHorizontalXS) 0 var(--spacingHorizontalMNudge);}", { p: -1 }],
		[".f1htewbf{padding:0 var(--spacingHorizontalMNudge) 0 var(--spacingHorizontalXS);}", { p: -1 }],
		".f3gca8{align-items:unset;}",
		".f22iagw{display:flex;}",
		".f1vx9l62{flex-direction:column;}",
		".f1j0q4x9{row-gap:var(--spacingVerticalXXS);}"
	] });
	/**
	* Apply styling to the NavDrawerBody slots based on the state
	*/
	const useNavDrawerBodyStyles_unstable = (state) => {
		"use no memo";
		useDrawerBodyStyles_unstable(state);
		const styles = useStyles$3();
		state.root.className = mergeClasses(navDrawerBodyClassNames.root, styles.root, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/NavDrawerBody/NavDrawerBody.js
/**
	* NavDrawerBody component
	*/ const NavDrawerBody = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useNavDrawerBody_unstable(props, ref);
		useNavDrawerBodyStyles_unstable(state);
		useCustomStyleHook("useNavDrawerBodyStyles_unstable")(state);
		return renderDrawerBody_unstable(state);
	});
	NavDrawerBody.displayName = "NavDrawerBody";

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/Hamburger/useHamburger.js
/**
	* Given user props, defines default props for the Button, calls useButtonState and useChecked, and returns
	* processed state.
	* @param props - User provided props to the Button component.
	* @param ref - User provided ref to be passed to the Button component.
	*/ const useHamburger_unstable = (props, ref) => {
		return useButton_unstable({
			icon: /* @__PURE__ */ react.createElement(Navigation20Filled, null),
			appearance: "transparent",
			...props
		}, ref);
	};

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/Hamburger/useHamburgerStyles.styles.js
	const hamburgerClassNames = {
		root: "fui-Hamburger",
		icon: "fui-Hamburger__icon"
	};
	/**
	* Styles for the root slot
	*/
	const useStyles$2 = /* @__PURE__ */ __styles({ root: {
		w71qe1: "f1iuv45f",
		De3pzq: "f1ctqxl6",
		Bgfg5da: 0,
		B9xav0g: 0,
		oivjwe: 0,
		Bn0qgzm: 0,
		B4g9neb: 0,
		zhjwy3: 0,
		wvpqe5: 0,
		ibv6hh: 0,
		u1mtju: 0,
		h3c5rm: 0,
		vrafjx: 0,
		Bekrc4i: 0,
		i8vvqc: 0,
		g2u3we: 0,
		icvyot: 0,
		B4j52fo: 0,
		irswps: "f3bhgqh",
		Jwef8y: "f11oyicx",
		ecr2s2: "f9fof1w"
	} }, {
		d: [
			".f1iuv45f{text-decoration-line:none;}",
			".f1ctqxl6{background-color:var(--colorNeutralBackground4);}",
			[".f3bhgqh{border:none;}", { p: -2 }]
		],
		h: [".f11oyicx:hover{background-color:var(--colorNeutralBackground4Hover);}"],
		a: [".f9fof1w:active{background-color:var(--colorNeutralBackground4Pressed);}"]
	});
	/**
	* Apply styling to the Hamburger slots based on the state
	*/
	const useHamburgerStyles_unstable = (state) => {
		"use no memo";
		useButtonStyles_unstable(state);
		const styles = useStyles$2();
		state.root.className = mergeClasses(hamburgerClassNames.root, styles.root, state.root.className);
		if (state.icon) state.icon.className = mergeClasses(hamburgerClassNames.icon, state.icon.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/Hamburger/Hamburger.js
/**
	* Hamburger component - a button that toggles a menu or navigation drawer.
	*/ const Hamburger = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useHamburger_unstable(props, ref);
		useHamburgerStyles_unstable(state);
		useCustomStyleHook("useHamburgerStyles_unstable")(state);
		return renderButton_unstable(state);
	});
	Hamburger.displayName = "Hamburger";

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/NavSectionHeader/useNavSectionHeader.js
/**
	* Create the state required to render NavSectionHeader.
	*
	* The returned state can be modified with hooks such as useNavSectionHeaderStyles_unstable,
	* before being passed to renderNavSectionHeader_unstable.
	*
	* @param props - props from this instance of NavSectionHeader
	* @param ref - reference to root HTMLDivElement of NavSectionHeader
	*/ const useNavSectionHeader_unstable = (props, ref) => {
		return {
			components: { root: "h3" },
			root: always(getIntrinsicElementProps("h3", {
				ref,
				...props
			}), { elementType: "h3" })
		};
	};

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/NavSectionHeader/renderNavSectionHeader.js
/**
	* Render the final JSX of NavSectionHeader
	*/ const renderNavSectionHeader_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsx(state.root, {});
	};

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/NavSectionHeader/useNavSectionHeaderStyles.styles.js
	const navSectionHeaderClassNames = { root: "fui-NavSectionHeader" };
	/**
	* Styles for the root slot
	*/
	const useStyles$1 = /* @__PURE__ */ __styles({ root: {
		Jyy4pa: "f1gr6hdk",
		Bo78w4l: 0,
		Cgygva: 0,
		yil37a: "f1ulrxyd",
		Bahqtrf: "fk6fouc",
		Be2twd7: "fy9rknc",
		Bhrd7zp: "fl43uef",
		Bg96gwp: "fwrc4pm"
	} }, { d: [
		".f1gr6hdk{-webkit-margin-start:10px;margin-inline-start:10px;}",
		[".f1ulrxyd{margin-block:8px;}", { p: -1 }],
		".fk6fouc{font-family:var(--fontFamilyBase);}",
		".fy9rknc{font-size:var(--fontSizeBase200);}",
		".fl43uef{font-weight:var(--fontWeightSemibold);}",
		".fwrc4pm{line-height:var(--lineHeightBase200);}"
	] });
	/**
	* Apply styling to the NavSectionHeader slots based on the state
	*/
	const useNavSectionHeaderStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles$1();
		state.root.className = mergeClasses(navSectionHeaderClassNames.root, styles.root, state.root.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/NavSectionHeader/NavSectionHeader.js
/**
	* NavSectionHeader component
	*/ const NavSectionHeader = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useNavSectionHeader_unstable(props, ref);
		useNavSectionHeaderStyles_unstable(state);
		useCustomStyleHook("useNavSectionHeaderStyles_unstable")(state);
		return renderNavSectionHeader_unstable(state);
	});
	NavSectionHeader.displayName = "NavSectionHeader";

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/NavDivider/useNavDivider.js
/**
	* Create the state required to render NavDivider.
	*
	* The returned state can be modified with hooks such as useNavDividerStyles_unstable,
	* before being passed to renderNavDivider_unstable.
	*
	* @param props - props from this instance of NavDivider
	* @param ref - reference to root HTMLDivElement of NavDivider
	*/ const useNavDivider_unstable = (props, ref) => {
		return useDivider_unstable({
			appearance: "strong",
			...props
		}, ref);
	};

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/NavDivider/useNavDividerStyles.styles.js
	const navDividerClassNames = {
		root: "fui-NavDivider",
		wrapper: "fui-NavDivider__wrapper"
	};
	const useStyles = /* @__PURE__ */ __styles({ root: {
		Bh6795r: "f1jhi6b8",
		B6of3ja: "fvjh0tl",
		jrapky: "fd1gkq"
	} }, { d: [
		".f1jhi6b8{flex-grow:0;}",
		".fvjh0tl{margin-top:4px;}",
		".fd1gkq{margin-bottom:4px;}"
	] });
	/**
	* Apply styling to the NavDivider slots based on the state
	*/
	const useNavDividerStyles_unstable = (state) => {
		"use no memo";
		const styles = useStyles();
		state.root.className = mergeClasses(navDividerClassNames.root, styles.root, state.root.className);
		state.wrapper.className = mergeClasses(navDividerClassNames.wrapper, state.wrapper.className);
		useDividerStyles_unstable(state);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/NavDivider/NavDivider.js
/**
	* NavDivider component - a divider used within navigation components to separate items.
	*/ const NavDivider = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useNavDivider_unstable(props, ref);
		useNavDividerStyles_unstable(state);
		useCustomStyleHook("useNavDividerStyles_unstable")(state);
		return renderDivider_unstable(state);
	});
	NavDivider.displayName = "NavDivider";

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/AppItem/useAppItem.js
/**
	* Create the state required to render AppItem.
	*
	* The returned state can be modified with hooks such as useAppItemStyles_unstable,
	* before being passed to renderAppItem_unstable.
	*
	* @param props - props from this instance of AppItem
	* @param ref - reference to root HTMLDivElement of AppItem
	*/ const useAppItem_unstable = (props, ref) => {
		const { icon, as, href } = props;
		const rootElementType = as || (href ? "a" : "button");
		const { density = "medium" } = useNavContext_unstable();
		const root = always(getIntrinsicElementProps(rootElementType, useARIAButtonProps(rootElementType, { ...props })), {
			elementType: rootElementType,
			defaultProps: {
				ref,
				type: rootElementType
			}
		});
		return {
			components: {
				root: rootElementType,
				icon: "span"
			},
			root,
			icon: optional(icon, { elementType: "span" }),
			density
		};
	};

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/AppItem/renderAppItem.js
/**
	* Render the final JSX of AppItem
	*/ const renderAppItem_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(state.root, { children: [state.icon && /* @__PURE__ */ jsx(state.icon, {}), state.root.children] });
	};

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/AppItem/useAppItemStyles.styles.js
	const appItemClassNames = {
		root: "fui-AppItem",
		icon: "fui-AppItem__icon"
	};
	/**
	* Styles for the root slot
	*/
	const useAppItemStyles = /* @__PURE__ */ __styles({
		root: {
			Bokbzmb: "f1x6gvzo",
			Jyy4pa: "f1djyvue",
			B1u1w3b: "feysv1g",
			a9b677: "f1jd6clc",
			Bt984gj: "f122n59",
			i8kkvl: 0,
			Belr9w4: 0,
			rmohyg: "f1ga9sj3",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: ["f1fdqhks", "fnlwq4f"],
			Bahqtrf: "fk6fouc",
			Be2twd7: "fod5ikn",
			Bhrd7zp: "fl43uef",
			Bg96gwp: "faaz57k"
		},
		small: {
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: ["f1m1l4b8", "f1yxbtnt"],
			i8kkvl: 0,
			Belr9w4: 0,
			rmohyg: "f1let0xu"
		},
		absentIconRootAdjustment: { B1hrpyx: "ft8721j" }
	}, { d: [
		[".feysv1g{margin-inline:4px;}", { p: -1 }],
		".f1jd6clc{width:revert;}",
		".f122n59{align-items:center;}",
		[".f1ga9sj3{gap:10px;}", { p: -1 }],
		".f1djyvue{-webkit-margin-start:-6px;margin-inline-start:-6px;}",
		".f1x6gvzo{-webkit-margin-end:0px;margin-inline-end:0px;}",
		[".f1fdqhks{padding:var(--spacingVerticalS) var(--spacingHorizontalS) var(--spacingVerticalS) var(--spacingHorizontalMNudge);}", { p: -1 }],
		[".fnlwq4f{padding:var(--spacingVerticalS) var(--spacingHorizontalMNudge) var(--spacingVerticalS) var(--spacingHorizontalS);}", { p: -1 }],
		".fk6fouc{font-family:var(--fontFamilyBase);}",
		".fod5ikn{font-size:var(--fontSizeBase400);}",
		".fl43uef{font-weight:var(--fontWeightSemibold);}",
		".faaz57k{line-height:var(--lineHeightBase400);}",
		[".f1m1l4b8{padding:var(--spacingVerticalS) var(--spacingHorizontalS) var(--spacingVerticalS) 14px;}", { p: -1 }],
		[".f1yxbtnt{padding:var(--spacingVerticalS) 14px var(--spacingVerticalS) var(--spacingHorizontalS);}", { p: -1 }],
		[".f1let0xu{gap:14px;}", { p: -1 }],
		".ft8721j{-webkit-padding-start:16px;padding-inline-start:16px;}"
	] });
	/**
	* Apply styling to the AppItem slots based on the state
	*/
	const useAppItemStyles_unstable = (state) => {
		"use no memo";
		const rootDefaultClassName = useRootDefaultClassName();
		const iconStyles = useIconStyles();
		const appItemSpecificStyles = useAppItemStyles();
		const { density, icon } = state;
		state.root.className = mergeClasses(rootDefaultClassName, appItemClassNames.root, appItemSpecificStyles.root, density === "small" && appItemSpecificStyles.small, !icon && appItemSpecificStyles.absentIconRootAdjustment, state.root.className);
		if (state.icon) state.icon.className = mergeClasses(appItemClassNames.icon, iconStyles.base, state.icon.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/AppItem/AppItem.js
/**
	* AppItem component - Application item in the navigation menu.
	*/ const AppItem = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useAppItem_unstable(props, ref);
		useAppItemStyles_unstable(state);
		useCustomStyleHook("useAppItemStyles_unstable")(state);
		return renderAppItem_unstable(state);
	});
	AppItem.displayName = "AppItem";

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/AppItemStatic/useAppItemStatic.js
/**
	* Create the state required to render AppItemStatic.
	*
	* The returned state can be modified with hooks such as useAppItemStaticStyles_unstable,
	* before being passed to renderAppItemStatic_unstable.
	*
	* @param props - props from this instance of AppItemStatic
	* @param ref - reference to root HTMLDivElement of AppItemStatic
	*/ const useAppItemStatic_unstable = (props, ref) => {
		const { icon } = props;
		const { density = "medium" } = useNavContext_unstable();
		return {
			components: {
				root: "div",
				icon: "span"
			},
			root: always(getIntrinsicElementProps("div", {
				ref,
				...props
			}), { elementType: "div" }),
			icon: optional(icon, { elementType: "span" }),
			density
		};
	};

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/AppItemStatic/renderAppItemStatic.js
/**
	* Render the final JSX of AppItemStatic
	*/ const renderAppItemStatic_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(state.root, { children: [state.icon && /* @__PURE__ */ jsx(state.icon, {}), state.root.children] });
	};

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/AppItemStatic/useAppItemStaticStyles.styles.js
	const appItemStaticClassNames = {
		root: "fui-AppItemStatic",
		icon: "fui-AppItemStatic__icon"
	};
	const useAppItemStaticStyles = /* @__PURE__ */ __styles({ root: {
		Bceei9c: "f158kwzp",
		Jwef8y: "fmaajru",
		ecr2s2: "f11z5bqc"
	} }, {
		d: [".f158kwzp{cursor:default;}"],
		h: [".fmaajru:hover{background-color:unset;}"],
		a: [".f11z5bqc:active{background-color:unset;}"]
	});
	/**
	* Apply styling to the AppItemStatic slots based on the state
	*/
	const useAppItemStaticStyles_unstable = (state) => {
		"use no memo";
		const rootDefaultClassName = useRootDefaultClassName();
		const iconStyles = useIconStyles();
		const appItemSpecificStyles = useAppItemStyles();
		const appItemStaticStyles = useAppItemStaticStyles();
		const { density, icon } = state;
		state.root.className = mergeClasses(rootDefaultClassName, appItemStaticClassNames.root, appItemSpecificStyles.root, appItemStaticStyles.root, density === "small" && appItemSpecificStyles.small, !icon && appItemSpecificStyles.absentIconRootAdjustment, state.root.className);
		if (state.icon) state.icon.className = mergeClasses(appItemStaticClassNames.icon, iconStyles.base, state.icon.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/AppItemStatic/AppItemStatic.js
/**
	* AppItemStatic component - Static application item in the navigation menu.
	*/ const AppItemStatic = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useAppItemStatic_unstable(props, ref);
		useAppItemStaticStyles_unstable(state);
		useCustomStyleHook("useAppItemStaticStyles_unstable")(state);
		return renderAppItemStatic_unstable(state);
	});
	AppItemStatic.displayName = "AppItemStatic";

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/SplitNavItem/useSplitNavItem.js
/**
	* Create the state required to render SplitNavItem.
	*
	* The returned state can be modified with hooks such as useSplitNavItemStyles_unstable,
	* before being passed to renderSplitNavItem_unstable.
	*
	* @param props - props from this instance of SplitNavItem
	* @param ref - reference to root HTMLDivElement of SplitNavItem
	*/ const useSplitNavItem_unstable = (props, ref) => {
		const { navItem, actionButton: actionButton$1, toggleButton: toggleButton$1, menuButton: menuButton$1, actionButtonTooltip, toggleButtonTooltip, menuButtonTooltip, children } = props;
		const { density = "medium" } = useNavContext_unstable();
		const { value: potentialParenValue } = useNavCategoryContext_unstable();
		const isSubNav = potentialParenValue.length > 0 ? true : false;
		const navItemShorthand = always(navItem, {
			defaultProps: { children },
			elementType: isSubNav ? NavSubItem : NavItem
		});
		const actionButtonShorthand = optional(actionButton$1, {
			defaultProps: {
				icon: /* @__PURE__ */ react.createElement(Pin20Regular, null),
				size: "small",
				appearance: "transparent"
			},
			elementType: Button
		});
		const toggleButtonShorthand = optional(toggleButton$1, {
			defaultProps: {
				icon: /* @__PURE__ */ react.createElement(Pin20Regular, null),
				size: "small",
				appearance: "transparent"
			},
			elementType: ToggleButton
		});
		const menuButtonShorthand = optional(menuButton$1, {
			defaultProps: {
				icon: /* @__PURE__ */ react.createElement(MoreHorizontalFilled, null),
				size: "small",
				appearance: "transparent"
			},
			elementType: MenuButton
		});
		const actionButtonTooltipShorthand = optional(actionButtonTooltip, {
			defaultProps: { relationship: "label" },
			elementType: Tooltip
		});
		const toggleButtonTooltipShorthand = optional(toggleButtonTooltip, {
			defaultProps: { relationship: "label" },
			elementType: Tooltip
		});
		const menuButtonTooltipShorthand = optional(menuButtonTooltip, {
			defaultProps: { relationship: "label" },
			elementType: Tooltip
		});
		return {
			components: {
				root: "div",
				navItem: isSubNav ? NavSubItem : NavItem,
				actionButton: Button,
				toggleButton: ToggleButton,
				menuButton: MenuButton,
				actionButtonTooltip: Tooltip,
				toggleButtonTooltip: Tooltip,
				menuButtonTooltip: Tooltip
			},
			root: always(getIntrinsicElementProps("div", {
				ref,
				...props,
				children: null
			}), { elementType: "div" }),
			navItem: navItemShorthand,
			actionButton: actionButtonShorthand,
			toggleButton: toggleButtonShorthand,
			menuButton: menuButtonShorthand,
			actionButtonTooltip: actionButtonTooltipShorthand,
			toggleButtonTooltip: toggleButtonTooltipShorthand,
			menuButtonTooltip: menuButtonTooltipShorthand,
			density,
			isSubNav
		};
	};

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/SplitNavItem/renderSplitNavItem.js
/**
	* @internal
	*
	* Helper function to render button slots
	*/ const renderButtonSlot = (Button$1, ButtonTooltip) => {
		if (!Button$1) return null;
		if (ButtonTooltip) return /* @__PURE__ */ jsx(ButtonTooltip, { children: /* @__PURE__ */ jsx(Button$1, {}) });
		return /* @__PURE__ */ jsx(Button$1, {});
	};
	/**
	* Render the final JSX of SplitNavItem
	*/ const renderSplitNavItem_unstable = (state) => {
		assertSlots(state);
		return /* @__PURE__ */ jsxs(state.root, { children: [
			state.navItem && /* @__PURE__ */ jsx(state.navItem, {}),
			renderButtonSlot(state.actionButton, state.actionButtonTooltip),
			renderButtonSlot(state.menuButton, state.menuButtonTooltip),
			renderButtonSlot(state.toggleButton, state.toggleButtonTooltip)
		] });
	};

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/SplitNavItem/useSplitNavItemStyles.styles.js
	const splitNavItemClassNames = {
		root: "fui-SplitNavItem",
		navItem: "fui-SplitNavItem__navItem",
		actionButton: "fui-SplitNavItem__actionButton",
		toggleButton: "fui-SplitNavItem__toggleButton",
		menuButton: "fui-SplitNavItem__menuButton",
		actionButtonTooltip: "fui-SplitNavItem__actionButtonTooltip",
		toggleButtonTooltip: "fui-SplitNavItem__toggleButtonTooltip",
		menuButtonTooltip: "fui-SplitNavItem__menuButtonTooltip"
	};
	const { actionButton, toggleButton, menuButton } = splitNavItemClassNames;
	`${actionButton}${toggleButton}${menuButton}`;
	/**
	* Styles for the root slot
	*/
	const useSplitNaveItemStyles = /* @__PURE__ */ __styles({
		baseRoot: {
			mc9l5x: "f22iagw",
			i8kkvl: 0,
			Belr9w4: 0,
			rmohyg: "fx80lhs",
			Bt984gj: "f1q9h2pe",
			Byoj8tv: 0,
			uwmqm3: 0,
			z189sj: 0,
			z8tnut: 0,
			B0ocmuz: "f19jm9xf",
			fsow6f: "fgusgyc",
			De3pzq: "f1ctqxl6",
			B3o57yi: "fnsygzv",
			Bkqvd7p: "f1e9ux7i",
			Bmy1vo4: "f1xfaukr",
			Jwef8y: "f11oyicx",
			xwko9w: "f8z0t4e",
			mcc9px: "f9ueil3",
			B02v5zz: "f1g2hb8n",
			i4x37a: "fpq6je",
			ecr2s2: "f9fof1w"
		},
		baseNavItem: {
			mc9l5x: "f22iagw",
			B9bfxx9: "f1cxpek8",
			qb2dma: "f1ub7u0d",
			fsow6f: ["f1o700av", "fes3tcz"],
			qhf8xq: "f10pi13n",
			Brf1p80: "f1s9ku6b",
			i8kkvl: 0,
			Belr9w4: 0,
			rmohyg: "f1u2hskj",
			De3pzq: "f3rmtva"
		},
		baseSecondary: {
			Bf4jedk: "f107v6xj",
			Bnt446c: "f1y335lp",
			B1hrpyx: "f12pses1",
			rjzwhg: "fibmr9j",
			Bt984gj: "f1s2louj"
		},
		baseMedium: { rjzwhg: "fjtod8q" },
		baseLarge: { rjzwhg: "f16gijt3" },
		hoverAction: {
			abs64n: "fk73vx1",
			Bkecrkj: "f1aehjj5",
			Bn62ygk: 0,
			Cwk7ip: 0,
			B3o57yi: 0,
			Bmy1vo4: 0,
			Bkqvd7p: 0,
			Bi2q7bf: ["fr12795", "fcl876f"],
			Es3by: "f1gqqdtu"
		}
	}, {
		d: [
			".f22iagw{display:flex;}",
			[".fx80lhs{gap:unset;}", { p: -1 }],
			".f1q9h2pe{align-items:stretch;}",
			[".f19jm9xf{padding:unset;}", { p: -1 }],
			".fgusgyc{text-align:unset;}",
			".f1ctqxl6{background-color:var(--colorNeutralBackground4);}",
			".fnsygzv{transition-duration:var(--durationFaster);}",
			".f1e9ux7i{transition-timing-function:var(--curveLinear);}",
			".f1xfaukr{transition-property:background;}",
			".f1cxpek8{text-transform:none;}",
			".f1ub7u0d{align-self:stretch;}",
			".f1o700av{text-align:left;}",
			".fes3tcz{text-align:right;}",
			".f10pi13n{position:relative;}",
			".f1s9ku6b{justify-content:start;}",
			[".f1u2hskj{gap:var(--spacingVerticalL);}", { p: -1 }],
			".f3rmtva{background-color:transparent;}",
			".f107v6xj{min-width:28px;}",
			".f1y335lp{-webkit-padding-end:12px;padding-inline-end:12px;}",
			".f12pses1{-webkit-padding-start:5px;padding-inline-start:5px;}",
			".fibmr9j{padding-block-start:5px;}",
			".f1s2louj{align-items:start;}",
			".fjtod8q{padding-block-start:9px;}",
			".f16gijt3{padding-block-start:12px;}",
			".fk73vx1{opacity:0;}",
			".f1aehjj5{pointer-events:none;}",
			[".fr12795{transition:opacity 150ms cubic-bezier(0.33,0,0.67,1);}", { p: -1 }],
			[".fcl876f{transition:opacity 150ms cubic-bezier(0.33, 0, 0.67, 1);}", { p: -1 }],
			".f1gqqdtu{will-change:opacity;}"
		],
		h: [
			".f11oyicx:hover{background-color:var(--colorNeutralBackground4Hover);}",
			".f8z0t4e:hover .fui-SplitNavItem__actionButton,.f8z0t4e:hover .fui-SplitNavItem__toggleButton,.f8z0t4e:hover .fui-SplitNavItem__menuButton{opacity:1;}",
			".f9ueil3:hover .fui-SplitNavItem__actionButton,.f9ueil3:hover .fui-SplitNavItem__toggleButton,.f9ueil3:hover .fui-SplitNavItem__menuButton{pointer-events:auto;}"
		],
		w: [".f1g2hb8n:focus-within .fui-SplitNavItem__actionButton,.f1g2hb8n:focus-within .fui-SplitNavItem__toggleButton,.f1g2hb8n:focus-within .fui-SplitNavItem__menuButton{opacity:1;}", ".fpq6je:focus-within .fui-SplitNavItem__actionButton,.fpq6je:focus-within .fui-SplitNavItem__toggleButton,.fpq6je:focus-within .fui-SplitNavItem__menuButton{pointer-events:auto;}"],
		a: [".f9fof1w:active{background-color:var(--colorNeutralBackground4Pressed);}"]
	});
	/**
	* Apply styling to the SplitNavItem slots based on the state
	*/
	const useSplitNavItemStyles_unstable = (state) => {
		"use no memo";
		const splitNavItemStyles = useSplitNaveItemStyles();
		const sharedRootClassNames = useRootDefaultClassName();
		state.root.className = mergeClasses(splitNavItemClassNames.root, sharedRootClassNames, splitNavItemStyles.baseRoot, state.root.className);
		if (state.navItem) state.navItem.className = mergeClasses(splitNavItemClassNames.navItem, splitNavItemStyles.baseNavItem, state.navItem.className);
		if (state.actionButton) state.actionButton.className = mergeClasses(splitNavItemClassNames.actionButton, splitNavItemStyles.baseSecondary, splitNavItemStyles.hoverAction, state.density === "medium" && splitNavItemStyles.baseMedium, state.actionButton.className);
		if (state.toggleButton) state.toggleButton.className = mergeClasses(splitNavItemClassNames.toggleButton, splitNavItemStyles.baseSecondary, splitNavItemStyles.hoverAction, state.density === "medium" && splitNavItemStyles.baseMedium, state.toggleButton.className);
		if (state.menuButton) state.menuButton.className = mergeClasses(splitNavItemClassNames.menuButton, splitNavItemStyles.baseSecondary, splitNavItemStyles.hoverAction, state.density === "medium" && splitNavItemStyles.baseMedium, state.menuButton.className);
		return state;
	};

//#endregion
//#region node_modules/@fluentui/react-nav/lib/components/SplitNavItem/SplitNavItem.js
/**
	* SplitNavItem component - TODO: add more docs
	*/ const SplitNavItem = /* @__PURE__ */ react.forwardRef((props, ref) => {
		const state = useSplitNavItem_unstable(props, ref);
		useSplitNavItemStyles_unstable(state);
		useCustomStyleHook("useSplitNavItemStyles_unstable")(state);
		return renderSplitNavItem_unstable(state);
	});
	SplitNavItem.displayName = "SplitNavItem";

//#endregion
exports.Accordion = Accordion;
exports.AccordionHeader = AccordionHeader;
exports.AccordionItem = AccordionItem;
exports.AccordionItemProvider = AccordionItemProvider;
exports.AccordionPanel = AccordionPanel;
exports.AccordionProvider = AccordionProvider;
exports.AlphaSlider = AlphaSlider;
exports.AnnounceProvider = AnnounceProvider;
exports.AppItem = AppItem;
exports.AppItemStatic = AppItemStatic;
exports.AriaLiveAnnouncer = AriaLiveAnnouncer;
exports.Avatar = Avatar;
exports.AvatarGroup = AvatarGroup;
exports.AvatarGroupItem = AvatarGroupItem;
exports.AvatarGroupPopover = AvatarGroupPopover;
exports.AvatarGroupProvider = AvatarGroupProvider;
exports.Badge = Badge;
exports.Body1 = Body1;
exports.Body1Strong = Body1Strong;
exports.Body1Stronger = Body1Stronger;
exports.Body2 = Body2;
exports.Breadcrumb = Breadcrumb;
exports.BreadcrumbButton = BreadcrumbButton;
exports.BreadcrumbDivider = BreadcrumbDivider;
exports.BreadcrumbItem = BreadcrumbItem;
exports.BreadcrumbProvider = BreadcrumbProvider;
exports.Button = Button;
exports.Caption1 = Caption1;
exports.Caption1Strong = Caption1Strong;
exports.Caption1Stronger = Caption1Stronger;
exports.Caption2 = Caption2;
exports.Caption2Strong = Caption2Strong;
exports.Card = Card;
exports.CardFooter = CardFooter;
exports.CardHeader = CardHeader;
exports.CardPreview = CardPreview;
exports.Carousel = Carousel;
exports.CarouselAutoplayButton = CarouselAutoplayButton;
exports.CarouselButton = CarouselButton;
exports.CarouselCard = CarouselCard;
exports.CarouselNav = CarouselNav;
exports.CarouselNavButton = CarouselNavButton;
exports.CarouselNavContainer = CarouselNavContainer;
exports.CarouselNavImageButton = CarouselNavImageButton;
exports.CarouselProvider = CarouselProvider;
exports.CarouselSlider = CarouselSlider;
exports.CarouselViewport = CarouselViewport;
exports.Checkbox = Checkbox;
exports.ColorArea = ColorArea;
exports.ColorPicker = ColorPicker;
exports.ColorSlider = ColorSlider;
exports.ColorSwatch = ColorSwatch;
exports.ColumnIdContextProvider = ColumnIdContextProvider;
exports.Combobox = Combobox;
exports.ComboboxProvider = ComboboxProvider;
exports.CompoundButton = CompoundButton;
exports.CounterBadge = CounterBadge;
exports.DATA_OVERFLOWING = DATA_OVERFLOWING;
exports.DATA_OVERFLOW_DIVIDER = DATA_OVERFLOW_DIVIDER;
exports.DATA_OVERFLOW_ITEM = DATA_OVERFLOW_ITEM;
exports.DATA_OVERFLOW_MENU = DATA_OVERFLOW_MENU;
exports.DataGrid = DataGrid;
exports.DataGridBody = DataGridBody;
exports.DataGridCell = DataGridCell;
exports.DataGridContextProvider = DataGridContextProvider;
exports.DataGridHeader = DataGridHeader;
exports.DataGridHeaderCell = DataGridHeaderCell;
exports.DataGridRow = DataGridRow;
exports.DataGridSelectionCell = DataGridSelectionCell;
exports.Dialog = Dialog;
exports.DialogActions = DialogActions;
exports.DialogBody = DialogBody;
exports.DialogContent = DialogContent;
exports.DialogProvider = DialogProvider;
exports.DialogSurface = DialogSurface;
exports.DialogTitle = DialogTitle;
exports.DialogTrigger = DialogTrigger;
exports.Display = Display;
exports.Divider = Divider;
exports.Drawer = Drawer;
exports.DrawerBody = DrawerBody;
exports.DrawerFooter = DrawerFooter;
exports.DrawerHeader = DrawerHeader;
exports.DrawerHeaderNavigation = DrawerHeaderNavigation;
exports.DrawerHeaderTitle = DrawerHeaderTitle;
exports.DrawerProvider = DrawerProvider;
exports.Dropdown = Dropdown;
exports.EmptySwatch = EmptySwatch;
exports.Field = Field;
exports.FieldContextProvider = FieldContextProvider;
exports.FlatTree = FlatTree;
exports.FlatTreeItem = FlatTreeItem;
exports.FluentProvider = FluentProvider;
exports.Hamburger = Hamburger;
exports.IdPrefixProvider = IdPrefixProvider;
exports.Image = Image;
exports.ImageSwatch = ImageSwatch;
exports.InfoButton = InfoButton;
exports.InfoLabel = InfoLabel;
exports.InlineDrawer = InlineDrawer;
exports.Input = Input;
exports.InteractionTag = InteractionTag;
exports.InteractionTagPrimary = InteractionTagPrimary;
exports.InteractionTagSecondary = InteractionTagSecondary;
exports.Label = Label;
exports.LargeTitle = LargeTitle;
exports.Link = Link;
exports.List = List;
exports.ListItem = ListItem;
exports.Listbox = Listbox;
exports.ListboxProvider = ListboxProvider;
exports.Menu = Menu;
exports.MenuButton = MenuButton;
exports.MenuDivider = MenuDivider;
exports.MenuGroup = MenuGroup;
exports.MenuGroupContextProvider = MenuGroupContextProvider;
exports.MenuGroupHeader = MenuGroupHeader;
exports.MenuItem = MenuItem;
exports.MenuItemCheckbox = MenuItemCheckbox;
exports.MenuItemLink = MenuItemLink;
exports.MenuItemRadio = MenuItemRadio;
exports.MenuItemSwitch = MenuItemSwitch;
exports.MenuList = MenuList;
exports.MenuListProvider = MenuListProvider;
exports.MenuPopover = MenuPopover;
exports.MenuProvider = MenuProvider;
exports.MenuSplitGroup = MenuSplitGroup;
exports.MenuTrigger = MenuTrigger;
exports.MenuTriggerContextProvider = MenuTriggerContextProvider;
exports.MessageBar = MessageBar;
exports.MessageBarActions = MessageBarActions;
exports.MessageBarBody = MessageBarBody;
exports.MessageBarContextProvider = MessageBarContextProvider;
exports.MessageBarGroup = MessageBarGroup;
exports.MessageBarTitle = MessageBarTitle;
exports.Nav = Nav;
exports.NavCategory = NavCategory;
exports.NavCategoryItem = NavCategoryItem;
exports.NavCategoryItemProvider = NavCategoryItemProvider;
exports.NavCategoryProvider = NavCategoryProvider;
exports.NavDivider = NavDivider;
exports.NavDrawer = NavDrawer;
exports.NavDrawerBody = NavDrawerBody;
exports.NavDrawerFooter = NavDrawerFooter;
exports.NavDrawerHeader = NavDrawerHeader;
exports.NavItem = NavItem;
exports.NavProvider = NavProvider;
exports.NavSectionHeader = NavSectionHeader;
exports.NavSubItem = NavSubItem;
exports.NavSubItemGroup = NavSubItemGroup;
exports.Option = Option;
exports.OptionGroup = OptionGroup;
exports.Overflow = Overflow;
exports.OverflowDivider = OverflowDivider;
exports.OverflowItem = OverflowItem;
exports.OverlayDrawer = OverlayDrawer;
exports.Persona = Persona;
exports.Popover = Popover;
exports.PopoverProvider = PopoverProvider;
exports.PopoverSurface = PopoverSurface;
exports.PopoverTrigger = PopoverTrigger;
exports.Portal = Portal;
exports.PortalMountNodeProvider = PortalMountNodeProvider;
exports.PositioningConfigurationProvider = PositioningConfigurationProvider;
exports.PresenceBadge = PresenceBadge;
exports.PresenceGroup = PresenceGroup;
exports.ProgressBar = ProgressBar;
exports.Radio = Radio;
exports.RadioGroup = RadioGroup;
exports.RadioGroupProvider = RadioGroupProvider;
exports.Rating = Rating;
exports.RatingDisplay = RatingDisplay;
exports.RatingItem = RatingItem;
exports.RatingItemProvider = RatingItemProvider;
exports.RendererProvider = RendererProvider;
exports.SSRProvider = SSRProvider;
exports.SearchBox = SearchBox;
exports.Select = Select;
exports.Skeleton = Skeleton;
exports.SkeletonContextProvider = SkeletonContextProvider;
exports.SkeletonItem = SkeletonItem;
exports.Slider = Slider;
exports.SpinButton = SpinButton;
exports.Spinner = Spinner;
exports.SplitButton = SplitButton;
exports.SplitNavItem = SplitNavItem;
exports.Subtitle1 = Subtitle1;
exports.Subtitle2 = Subtitle2;
exports.Subtitle2Stronger = Subtitle2Stronger;
exports.SwatchPicker = SwatchPicker;
exports.SwatchPickerProvider = SwatchPickerProvider;
exports.SwatchPickerRow = SwatchPickerRow;
exports.Switch = Switch;
exports.Tab = Tab;
exports.TabList = TabList;
exports.TabListProvider = TabListProvider;
exports.Table = Table;
exports.TableBody = TableBody;
exports.TableCell = TableCell;
exports.TableCellActions = TableCellActions;
exports.TableCellLayout = TableCellLayout;
exports.TableContextProvider = TableContextProvider;
exports.TableHeader = TableHeader;
exports.TableHeaderCell = TableHeaderCell;
exports.TableHeaderContextProvider = TableHeaderContextProvider;
exports.TableResizeHandle = TableResizeHandle;
exports.TableRow = TableRow;
exports.TableRowIdContextProvider = TableRowIdContextProvider;
exports.TableSelectionCell = TableSelectionCell;
exports.Tag = Tag;
exports.TagGroup = TagGroup;
exports.TagPicker = TagPicker;
exports.TagPickerButton = TagPickerButton;
exports.TagPickerControl = TagPickerControl;
exports.TagPickerGroup = TagPickerGroup;
exports.TagPickerInput = TagPickerInput;
exports.TagPickerList = TagPickerList;
exports.TagPickerOption = TagPickerOption;
exports.TagPickerOptionGroup = TagPickerOptionGroup;
exports.TeachingPopover = TeachingPopover;
exports.TeachingPopoverBody = TeachingPopoverBody;
exports.TeachingPopoverCarousel = TeachingPopoverCarousel;
exports.TeachingPopoverCarouselCard = TeachingPopoverCarouselCard;
exports.TeachingPopoverCarouselFooter = TeachingPopoverCarouselFooter;
exports.TeachingPopoverCarouselNav = TeachingPopoverCarouselNav;
exports.TeachingPopoverCarouselNavButton = TeachingPopoverCarouselNavButton;
exports.TeachingPopoverCarouselPageCount = TeachingPopoverCarouselPageCount;
exports.TeachingPopoverFooter = TeachingPopoverFooter;
exports.TeachingPopoverHeader = TeachingPopoverHeader;
exports.TeachingPopoverSurface = TeachingPopoverSurface;
exports.TeachingPopoverTitle = TeachingPopoverTitle;
exports.TeachingPopoverTrigger = TeachingPopoverTrigger;
exports.Text = Text;
exports.Textarea = Textarea;
exports.Title1 = Title1;
exports.Title2 = Title2;
exports.Title3 = Title3;
exports.Toast = Toast;
exports.ToastBody = ToastBody;
exports.ToastFooter = ToastFooter;
exports.ToastTitle = ToastTitle;
exports.ToastTrigger = ToastTrigger;
exports.Toaster = Toaster;
exports.ToggleButton = ToggleButton;
exports.Toolbar = Toolbar;
exports.ToolbarButton = ToolbarButton;
exports.ToolbarDivider = ToolbarDivider;
exports.ToolbarGroup = ToolbarGroup;
exports.ToolbarRadioButton = ToolbarRadioButton;
exports.ToolbarRadioGroup = ToolbarRadioGroup;
exports.ToolbarToggleButton = ToolbarToggleButton;
exports.Tooltip = Tooltip;
exports.Tree = Tree;
exports.TreeItem = TreeItem;
exports.TreeItemLayout = TreeItemLayout;
exports.TreeItemPersonaLayout = TreeItemPersonaLayout;
exports.TreeItemProvider = TreeItemProvider;
exports.TreeProvider = TreeProvider;
exports.TreeRootReset = TreeRootReset;
exports.__css = __css;
exports.__resetCSS = __resetCSS;
exports.__resetStyles = __resetStyles;
exports.__styles = __styles;
exports.accordionClassNames = accordionClassNames;
exports.accordionHeaderClassNames = accordionHeaderClassNames;
exports.accordionItemClassNames = accordionItemClassNames;
exports.accordionPanelClassNames = accordionPanelClassNames;
exports.alphaSliderClassNames = alphaSliderClassNames;
exports.appItemClassNames = appItemClassNames;
exports.appItemStaticClassNames = appItemStaticClassNames;
exports.arrowHeights = arrowHeights;
exports.assertSlots = assertSlots;
exports.avatarClassNames = avatarClassNames;
exports.avatarGroupClassNames = avatarGroupClassNames;
exports.avatarGroupItemClassNames = avatarGroupItemClassNames;
exports.avatarGroupPopoverClassNames = avatarGroupPopoverClassNames;
exports.badgeClassNames = badgeClassNames;
exports.body1ClassNames = body1ClassNames;
exports.body1StrongClassNames = body1StrongClassNames;
exports.body1StrongerClassNames = body1StrongerClassNames;
exports.body2ClassNames = body2ClassNames;
exports.breadcrumbButtonClassNames = breadcrumbButtonClassNames;
exports.breadcrumbClassNames = breadcrumbClassNames;
exports.breadcrumbDividerClassNames = breadcrumbDividerClassNames;
exports.breadcrumbItemClassNames = breadcrumbItemClassNames;
exports.buttonClassNames = buttonClassNames;
exports.caption1ClassNames = caption1ClassNames;
exports.caption1StrongClassNames = caption1StrongClassNames;
exports.caption1StrongerClassNames = caption1StrongerClassNames;
exports.caption2ClassNames = caption2ClassNames;
exports.caption2StrongClassNames = caption2StrongClassNames;
exports.cardCSSVars = cardCSSVars;
exports.cardClassNames = cardClassNames;
exports.cardFooterClassNames = cardFooterClassNames;
exports.cardHeaderCSSVars = cardHeaderCSSVars;
exports.cardHeaderClassNames = cardHeaderClassNames;
exports.cardPreviewClassNames = cardPreviewClassNames;
exports.carouselAutoplayButtonClassNames = carouselAutoplayButtonClassNames;
exports.carouselButtonClassNames = carouselButtonClassNames;
exports.carouselCardClassNames = carouselCardClassNames;
exports.carouselClassNames = carouselClassNames;
exports.carouselContextDefaultValue = carouselContextDefaultValue;
exports.carouselNavButtonClassNames = carouselNavButtonClassNames;
exports.carouselNavClassNames = carouselNavClassNames;
exports.carouselNavContainerClassNames = carouselNavContainerClassNames;
exports.carouselNavImageButtonClassNames = carouselNavImageButtonClassNames;
exports.carouselSliderClassNames = carouselSliderClassNames;
exports.carouselViewportClassNames = carouselViewportClassNames;
exports.checkboxClassNames = checkboxClassNames;
exports.colorAreaClassNames = colorAreaClassNames;
exports.colorPickerClassNames = colorPickerClassNames;
exports.colorSliderClassNames = colorSliderClassNames;
exports.colorSwatchClassNames = colorSwatchClassNames;
exports.comboboxClassNames = comboboxClassNames;
exports.compoundButtonClassNames = compoundButtonClassNames;
exports.counterBadgeClassNames = counterBadgeClassNames;
exports.createCSSRuleFromTheme = createCSSRuleFromTheme;
exports.createCustomFocusIndicatorStyle = createCustomFocusIndicatorStyle;
exports.createDOMRenderer = createDOMRenderer;
exports.createDarkTheme = createDarkTheme;
exports.createFocusOutlineStyle = createFocusOutlineStyle;
exports.createHighContrastTheme = createHighContrastTheme;
exports.createLightTheme = createLightTheme;
exports.createMotionComponent = createMotionComponent;
exports.createMotionComponentVariant = createMotionComponentVariant;
exports.createPresenceComponent = createPresenceComponent;
exports.createPresenceComponentVariant = createPresenceComponentVariant;
exports.createTableColumn = createTableColumn;
exports.createTeamsDarkTheme = createTeamsDarkTheme;
exports.dataGridBodyClassNames = dataGridBodyClassNames;
exports.dataGridCellClassNames = dataGridCellClassNames;
exports.dataGridClassNames = dataGridClassNames;
exports.dataGridHeaderCellClassNames = dataGridHeaderCellClassNames;
exports.dataGridHeaderClassNames = dataGridHeaderClassNames;
exports.dataGridRowClassNames = dataGridRowClassNames;
exports.dataGridSelectionCellClassNames = dataGridSelectionCellClassNames;
exports.dialogActionsClassNames = dialogActionsClassNames;
exports.dialogBodyClassNames = dialogBodyClassNames;
exports.dialogContentClassNames = dialogContentClassNames;
exports.dialogSurfaceClassNames = dialogSurfaceClassNames;
exports.dialogTitleClassNames = dialogTitleClassNames;
exports.displayClassNames = displayClassNames;
exports.dividerClassNames = dividerClassNames;
exports.drawerBodyClassNames = drawerBodyClassNames;
exports.drawerFooterClassNames = drawerFooterClassNames;
exports.drawerHeaderClassNames = drawerHeaderClassNames;
exports.drawerHeaderNavigationClassNames = drawerHeaderNavigationClassNames;
exports.drawerHeaderTitleClassNames = drawerHeaderTitleClassNames;
exports.dropdownClassNames = dropdownClassNames;
exports.emptySwatchClassNames = emptySwatchClassNames;
exports.fieldClassNames = fieldClassNames;
exports.flatTreeClassNames = flatTreeClassNames;
exports.flattenTree_unstable = flattenTree_unstable;
exports.fluentProviderClassNames = fluentProviderClassNames;
exports.getIntrinsicElementProps = getIntrinsicElementProps;
exports.getNativeElementProps = getNativeElementProps;
exports.getPartitionedNativeProps = getPartitionedNativeProps;
exports.getSlotClassNameProp_unstable = getSlotClassNameProp;
exports.getSlots = getSlots;
exports.hamburgerClassNames = hamburgerClassNames;
exports.imageClassNames = imageClassNames;
exports.imageSwatchClassNames = imageSwatchClassNames;
exports.infoButtonClassNames = infoButtonClassNames;
exports.infoLabelClassNames = infoLabelClassNames;
exports.inlineDrawerClassNames = inlineDrawerClassNames;
exports.inputClassNames = inputClassNames;
exports.interactionTagClassNames = interactionTagClassNames;
exports.interactionTagPrimaryClassNames = interactionTagPrimaryClassNames;
exports.interactionTagSecondaryClassNames = interactionTagSecondaryClassNames;
exports.isHTMLElement = isHTMLElement;
exports.isTruncatableBreadcrumbContent = isTruncatableBreadcrumbContent;
exports.labelClassNames = labelClassNames;
exports.largeTitleClassNames = largeTitleClassNames;
exports.linkClassNames = linkClassNames;
exports.listClassNames = listClassNames;
exports.listItemClassNames = listItemClassNames;
exports.listboxClassNames = listboxClassNames;
exports.makeResetStyles = makeResetStyles;
exports.makeStaticStyles = makeStaticStyles;
exports.makeStyles = makeStyles;
exports.menuButtonClassNames = menuButtonClassNames;
exports.menuDividerClassNames = menuDividerClassNames;
exports.menuGroupClassNames = menuGroupClassNames;
exports.menuGroupHeaderClassNames = menuGroupHeaderClassNames;
exports.menuItemCheckboxClassNames = menuItemCheckboxClassNames;
exports.menuItemClassNames = menuItemClassNames;
exports.menuItemLinkClassNames = menuItemLinkClassNames;
exports.menuItemRadioClassNames = menuItemRadioClassNames;
exports.menuItemSwitchClassNames = menuItemSwitchClassNames;
exports.menuListClassNames = menuListClassNames;
exports.menuPopoverClassNames = menuPopoverClassNames;
exports.menuSplitGroupClassNames = menuSplitGroupClassNames;
exports.mergeCallbacks = mergeCallbacks;
exports.mergeClasses = mergeClasses;
exports.messageBarActionsClassNames = messageBarActionsClassNames;
exports.messageBarBodyClassNames = messageBarBodyClassNames;
exports.messageBarClassNames = messageBarClassNames;
exports.messageBarGroupClassNames = messageBarGroupClassNames;
exports.messageBarTitleClassNames = messageBarTitleClassNames;
exports.motionTokens = motionTokens;
exports.navCategoryItemClassNames = navCategoryItemClassNames;
exports.navClassNames = navClassNames;
exports.navDividerClassNames = navDividerClassNames;
exports.navDrawerBodyClassNames = navDrawerBodyClassNames;
exports.navDrawerClassNames = navDrawerClassNames;
exports.navDrawerFooterClassNames = navDrawerFooterClassNames;
exports.navDrawerHeaderClassNames = navDrawerHeaderClassNames;
exports.navItemClassNames = navItemClassNames;
exports.navSectionHeaderClassNames = navSectionHeaderClassNames;
exports.navSubItemClassNames = navSubItemClassNames;
exports.navSubItemGroupClassNames = navSubItemGroupClassNames;
exports.optionClassNames = optionClassNames;
exports.optionGroupClassNames = optionGroupClassNames;
exports.overlayDrawerClassNames = overlayDrawerClassNames;
exports.partitionAvatarGroupItems = partitionAvatarGroupItems;
exports.partitionBreadcrumbItems = partitionBreadcrumbItems;
exports.personaClassNames = personaClassNames;
exports.popoverSurfaceClassNames = popoverSurfaceClassNames;
exports.presenceAvailableFilled = presenceAvailableFilled;
exports.presenceAvailableRegular = presenceAvailableRegular;
exports.presenceAwayFilled = presenceAwayFilled;
exports.presenceAwayRegular = presenceAwayRegular;
exports.presenceBadgeClassNames = presenceBadgeClassNames;
exports.presenceBlockedRegular = presenceBlockedRegular;
exports.presenceBusyFilled = presenceBusyFilled;
exports.presenceDndFilled = presenceDndFilled;
exports.presenceDndRegular = presenceDndRegular;
exports.presenceOfflineRegular = presenceOfflineRegular;
exports.presenceOofRegular = presenceOofRegular;
exports.presenceUnknownRegular = presenceUnknownRegular;
exports.progressBarClassNames = progressBarClassNames;
exports.radioClassNames = radioClassNames;
exports.radioGroupClassNames = radioGroupClassNames;
exports.ratingClassNames = ratingClassNames;
exports.ratingDisplayClassNames = ratingDisplayClassNames;
exports.ratingItemClassNames = ratingItemClassNames;
exports.renderAccordionHeader_unstable = renderAccordionHeader_unstable;
exports.renderAccordionItem_unstable = renderAccordionItem_unstable;
exports.renderAccordionPanel_unstable = renderAccordionPanel_unstable;
exports.renderAccordion_unstable = renderAccordion_unstable;
exports.renderAlphaSlider_unstable = renderAlphaSlider_unstable;
exports.renderAppItemStatic_unstable = renderAppItemStatic_unstable;
exports.renderAppItem_unstable = renderAppItem_unstable;
exports.renderAriaLiveAnnouncer_unstable = renderAriaLiveAnnouncer_unstable;
exports.renderAvatarGroupItem_unstable = renderAvatarGroupItem_unstable;
exports.renderAvatarGroupPopover_unstable = renderAvatarGroupPopover_unstable;
exports.renderAvatarGroup_unstable = renderAvatarGroup_unstable;
exports.renderAvatar_unstable = renderAvatar_unstable;
exports.renderBadge_unstable = renderBadge_unstable;
exports.renderBreadcrumbButton_unstable = renderBreadcrumbButton_unstable;
exports.renderBreadcrumbDivider_unstable = renderBreadcrumbDivider_unstable;
exports.renderBreadcrumbItem_unstable = renderBreadcrumbItem_unstable;
exports.renderBreadcrumb_unstable = renderBreadcrumb_unstable;
exports.renderButton_unstable = renderButton_unstable;
exports.renderCardFooter_unstable = renderCardFooter_unstable;
exports.renderCardHeader_unstable = renderCardHeader_unstable;
exports.renderCardPreview_unstable = renderCardPreview_unstable;
exports.renderCard_unstable = renderCard_unstable;
exports.renderCarouselAutoplayButton_unstable = renderCarouselAutoplayButton_unstable;
exports.renderCarouselButton_unstable = renderCarouselButton_unstable;
exports.renderCarouselCard_unstable = renderCarouselCard_unstable;
exports.renderCarouselNavButton_unstable = renderCarouselNavButton_unstable;
exports.renderCarouselNavContainer_unstable = renderCarouselNavContainer_unstable;
exports.renderCarouselNavImageButton_unstable = renderCarouselNavImageButton_unstable;
exports.renderCarouselNav_unstable = renderCarouselNav_unstable;
exports.renderCarouselSlider_unstable = renderCarouselSlider_unstable;
exports.renderCarouselViewport_unstable = renderCarouselViewport_unstable;
exports.renderCarousel_unstable = renderCarousel_unstable;
exports.renderCheckbox_unstable = renderCheckbox_unstable;
exports.renderColorArea_unstable = renderColorArea_unstable;
exports.renderColorPicker_unstable = renderColorPicker_unstable;
exports.renderColorSlider_unstable = renderColorSlider_unstable;
exports.renderColorSwatch_unstable = renderColorSwatch_unstable;
exports.renderCombobox_unstable = renderCombobox_unstable;
exports.renderCompoundButton_unstable = renderCompoundButton_unstable;
exports.renderDataGridBody_unstable = renderDataGridBody_unstable;
exports.renderDataGridCell_unstable = renderDataGridCell_unstable;
exports.renderDataGridHeaderCell_unstable = renderDataGridHeaderCell_unstable;
exports.renderDataGridHeader_unstable = renderDataGridHeader_unstable;
exports.renderDataGridRow_unstable = renderDataGridRow_unstable;
exports.renderDataGridSelectionCell_unstable = renderDataGridSelectionCell_unstable;
exports.renderDataGrid_unstable = renderDataGrid_unstable;
exports.renderDialogActions_unstable = renderDialogActions_unstable;
exports.renderDialogBody_unstable = renderDialogBody_unstable;
exports.renderDialogContent_unstable = renderDialogContent_unstable;
exports.renderDialogSurface_unstable = renderDialogSurface_unstable;
exports.renderDialogTitle_unstable = renderDialogTitle_unstable;
exports.renderDialogTrigger_unstable = renderDialogTrigger_unstable;
exports.renderDialog_unstable = renderDialog_unstable;
exports.renderDivider_unstable = renderDivider_unstable;
exports.renderDrawerBody_unstable = renderDrawerBody_unstable;
exports.renderDrawerFooter_unstable = renderDrawerFooter_unstable;
exports.renderDrawerHeaderNavigation_unstable = renderDrawerHeaderNavigation_unstable;
exports.renderDrawerHeaderTitle_unstable = renderDrawerHeaderTitle_unstable;
exports.renderDrawerHeader_unstable = renderDrawerHeader_unstable;
exports.renderDrawer_unstable = renderDrawer_unstable;
exports.renderDropdown_unstable = renderDropdown_unstable;
exports.renderEmptySwatch_unstable = renderEmptySwatch_unstable;
exports.renderField_unstable = renderField_unstable;
exports.renderFlatTree_unstable = renderFlatTree_unstable;
exports.renderFluentProvider_unstable = renderFluentProvider_unstable;
exports.renderImageSwatch_unstable = renderImageSwatch_unstable;
exports.renderImage_unstable = renderImage_unstable;
exports.renderInfoButton_unstable = renderInfoButton_unstable;
exports.renderInfoLabel_unstable = renderInfoLabel_unstable;
exports.renderInlineDrawer_unstable = renderInlineDrawer_unstable;
exports.renderInput_unstable = renderInput_unstable;
exports.renderInteractionTagPrimary_unstable = renderInteractionTagPrimary_unstable;
exports.renderInteractionTagSecondary_unstable = renderInteractionTagSecondary_unstable;
exports.renderInteractionTag_unstable = renderInteractionTag_unstable;
exports.renderLabel_unstable = renderLabel_unstable;
exports.renderLink_unstable = renderLink_unstable;
exports.renderListItem_unstable = renderListItem_unstable;
exports.renderList_unstable = renderList_unstable;
exports.renderListbox_unstable = renderListbox_unstable;
exports.renderMenuButton_unstable = renderMenuButton_unstable;
exports.renderMenuDivider_unstable = renderMenuDivider_unstable;
exports.renderMenuGroupHeader_unstable = renderMenuGroupHeader_unstable;
exports.renderMenuGroup_unstable = renderMenuGroup_unstable;
exports.renderMenuItemCheckbox_unstable = renderMenuItemCheckbox_unstable;
exports.renderMenuItemLink_unstable = renderMenuItemLink_unstable;
exports.renderMenuItemRadio_unstable = renderMenuItemRadio_unstable;
exports.renderMenuItemSwitch_unstable = renderMenuItemSwitch_unstable;
exports.renderMenuItem_unstable = renderMenuItem_unstable;
exports.renderMenuList_unstable = renderMenuList_unstable;
exports.renderMenuPopover_unstable = renderMenuPopover_unstable;
exports.renderMenuSplitGroup_unstable = renderMenuSplitGroup_unstable;
exports.renderMenuTrigger_unstable = renderMenuTrigger_unstable;
exports.renderMenu_unstable = renderMenu_unstable;
exports.renderMessageBarActions_unstable = renderMessageBarActions_unstable;
exports.renderMessageBarBody_unstable = renderMessageBarBody_unstable;
exports.renderMessageBarGroup_unstable = renderMessageBarGroup_unstable;
exports.renderMessageBarTitle_unstable = renderMessageBarTitle_unstable;
exports.renderMessageBar_unstable = renderMessageBar_unstable;
exports.renderNavCategoryItem_unstable = renderNavCategoryItem_unstable;
exports.renderNavCategory_unstable = renderNavCategory_unstable;
exports.renderNavDrawer_unstable = renderNavDrawer_unstable;
exports.renderNavItem_unstable = renderNavItem_unstable;
exports.renderNavSectionHeader_unstable = renderNavSectionHeader_unstable;
exports.renderNavSubItemGroup_unstable = renderNavSubItemGroup_unstable;
exports.renderNavSubItem_unstable = renderNavSubItem_unstable;
exports.renderNav_unstable = renderNav_unstable;
exports.renderOptionGroup_unstable = renderOptionGroup_unstable;
exports.renderOption_unstable = renderOption_unstable;
exports.renderOverlayDrawer_unstable = renderOverlayDrawer_unstable;
exports.renderPersona_unstable = renderPersona_unstable;
exports.renderPopoverSurface_unstable = renderPopoverSurface_unstable;
exports.renderPopoverTrigger_unstable = renderPopoverTrigger_unstable;
exports.renderPopover_unstable = renderPopover_unstable;
exports.renderPortal_unstable = renderPortal_unstable;
exports.renderProgressBar_unstable = renderProgressBar_unstable;
exports.renderRadioGroup_unstable = renderRadioGroup_unstable;
exports.renderRadio_unstable = renderRadio_unstable;
exports.renderRatingDisplay_unstable = renderRatingDisplay_unstable;
exports.renderRatingItem_unstable = renderRatingItem_unstable;
exports.renderRating_unstable = renderRating_unstable;
exports.renderSearchBox_unstable = renderSearchBox_unstable;
exports.renderSelect_unstable = renderSelect_unstable;
exports.renderSkeletonItem_unstable = renderSkeletonItem_unstable;
exports.renderSkeleton_unstable = renderSkeleton_unstable;
exports.renderSlider_unstable = renderSlider_unstable;
exports.renderSpinButton_unstable = renderSpinButton_unstable;
exports.renderSpinner_unstable = renderSpinner_unstable;
exports.renderSplitButton_unstable = renderSplitButton_unstable;
exports.renderSplitNavItem_unstable = renderSplitNavItem_unstable;
exports.renderSwatchPickerGrid = renderSwatchPickerGrid;
exports.renderSwatchPickerRow_unstable = renderSwatchPickerRow_unstable;
exports.renderSwatchPicker_unstable = renderSwatchPicker_unstable;
exports.renderSwitch_unstable = renderSwitch_unstable;
exports.renderTabList_unstable = renderTabList_unstable;
exports.renderTab_unstable = renderTab_unstable;
exports.renderTableBody_unstable = renderTableBody_unstable;
exports.renderTableCellActions_unstable = renderTableCellActions_unstable;
exports.renderTableCellLayout_unstable = renderTableCellLayout_unstable;
exports.renderTableCell_unstable = renderTableCell_unstable;
exports.renderTableHeaderCell_unstable = renderTableHeaderCell_unstable;
exports.renderTableHeader_unstable = renderTableHeader_unstable;
exports.renderTableResizeHandle_unstable = renderTableResizeHandle_unstable;
exports.renderTableRow_unstable = renderTableRow_unstable;
exports.renderTableSelectionCell_unstable = renderTableSelectionCell_unstable;
exports.renderTable_unstable = renderTable_unstable;
exports.renderTagGroup_unstable = renderTagGroup_unstable;
exports.renderTagPickerButton_unstable = renderTagPickerButton_unstable;
exports.renderTagPickerControl_unstable = renderTagPickerControl_unstable;
exports.renderTagPickerGroup_unstable = renderTagPickerGroup_unstable;
exports.renderTagPickerInput_unstable = renderTagPickerInput_unstable;
exports.renderTagPickerList_unstable = renderTagPickerList_unstable;
exports.renderTagPickerOptionGroup = renderTagPickerOptionGroup;
exports.renderTagPickerOption_unstable = renderTagPickerOption_unstable;
exports.renderTagPicker_unstable = renderTagPicker_unstable;
exports.renderTag_unstable = renderTag_unstable;
exports.renderTeachingPopoverBody_unstable = renderTeachingPopoverBody_unstable;
exports.renderTeachingPopoverCarouselCard_unstable = renderTeachingPopoverCarouselCard_unstable;
exports.renderTeachingPopoverCarouselFooter_unstable = renderTeachingPopoverCarouselFooter_unstable;
exports.renderTeachingPopoverCarouselNavButton_unstable = renderTeachingPopoverCarouselNavButton_unstable;
exports.renderTeachingPopoverCarouselNav_unstable = renderTeachingPopoverCarouselNav_unstable;
exports.renderTeachingPopoverCarouselPageCount_unstable = renderTeachingPopoverCarouselPageCount_unstable;
exports.renderTeachingPopoverCarousel_unstable = renderTeachingPopoverCarousel_unstable;
exports.renderTeachingPopoverFooter_unstable = renderTeachingPopoverFooter_unstable;
exports.renderTeachingPopoverHeader_unstable = renderTeachingPopoverHeader_unstable;
exports.renderTeachingPopoverSurface_unstable = renderTeachingPopoverSurface_unstable;
exports.renderTeachingPopoverTitle_unstable = renderTeachingPopoverTitle_unstable;
exports.renderTeachingPopoverTrigger_unstable = renderTeachingPopoverTrigger_unstable;
exports.renderTeachingPopover_unstable = renderTeachingPopover_unstable;
exports.renderText_unstable = renderText_unstable;
exports.renderTextarea_unstable = renderTextarea_unstable;
exports.renderToStyleElements = renderToStyleElements;
exports.renderToastBody_unstable = renderToastBody_unstable;
exports.renderToastFooter_unstable = renderToastFooter_unstable;
exports.renderToastTitle_unstable = renderToastTitle_unstable;
exports.renderToastTrigger_unstable = renderToastTrigger_unstable;
exports.renderToast_unstable = renderToast_unstable;
exports.renderToaster_unstable = renderToaster_unstable;
exports.renderToggleButton_unstable = renderButton_unstable;
exports.renderToolbarGroup_unstable = renderToolbarGroup_unstable;
exports.renderToolbar_unstable = renderToolbar_unstable;
exports.renderTooltip_unstable = renderTooltip_unstable;
exports.renderTreeItemLayout_unstable = renderTreeItemLayout_unstable;
exports.renderTreeItemPersonaLayout_unstable = renderTreeItemPersonaLayout_unstable;
exports.renderTreeItem_unstable = renderTreeItem_unstable;
exports.renderTree_unstable = renderTree_unstable;
exports.resetIdsForTests = resetIdsForTests;
exports.resolvePositioningShorthand = resolvePositioningShorthand;
exports.resolveShorthand = resolveShorthand;
exports.searchBoxClassNames = searchBoxClassNames;
exports.selectClassNames = selectClassNames;
exports.shorthands = shorthands;
exports.skeletonClassNames = skeletonClassNames;
exports.skeletonItemClassNames = skeletonItemClassNames;
exports.sliderCSSVars = sliderCSSVars;
exports.sliderClassNames = sliderClassNames;
Object.defineProperty(exports, 'slot', {
  enumerable: true,
  get: function () {
    return slot_exports;
  }
});
exports.spinButtonClassNames = spinButtonClassNames;
exports.spinnerClassNames = spinnerClassNames;
exports.splitButtonClassNames = splitButtonClassNames;
exports.splitNavItemClassNames = splitNavItemClassNames;
exports.subtitle1ClassNames = subtitle1ClassNames;
exports.subtitle2ClassNames = subtitle2ClassNames;
exports.subtitle2StrongerClassNames = subtitle2StrongerClassNames;
exports.swatchCSSVars = swatchCSSVars;
exports.swatchPickerClassNames = swatchPickerClassNames;
exports.swatchPickerContextDefaultValue = swatchPickerContextDefaultValue;
exports.swatchPickerRowClassNames = swatchPickerRowClassNames;
exports.switchClassNames = switchClassNames;
exports.tabClassNames = tabClassNames;
exports.tabListClassNames = tabListClassNames;
exports.tableBodyClassName = tableBodyClassName;
exports.tableBodyClassNames = tableBodyClassNames;
exports.tableCellActionsClassNames = tableCellActionsClassNames;
exports.tableCellClassName = tableCellClassName;
exports.tableCellClassNames = tableCellClassNames;
exports.tableCellLayoutClassNames = tableCellLayoutClassNames;
exports.tableClassName = tableClassName;
exports.tableClassNames = tableClassNames;
exports.tableHeaderCellClassName = tableHeaderCellClassName;
exports.tableHeaderCellClassNames = tableHeaderCellClassNames;
exports.tableHeaderClassName = tableHeaderClassName;
exports.tableHeaderClassNames = tableHeaderClassNames;
exports.tableResizeHandleClassNames = tableResizeHandleClassNames;
exports.tableRowClassName = tableRowClassName;
exports.tableRowClassNames = tableRowClassNames;
exports.tableSelectionCellClassNames = tableSelectionCellClassNames;
exports.tagClassNames = tagClassNames;
exports.tagGroupClassNames = tagGroupClassNames;
exports.tagPickerButtonClassNames = tagPickerButtonClassNames;
exports.tagPickerControlClassNames = tagPickerControlClassNames;
exports.tagPickerGroupClassNames = tagPickerGroupClassNames;
exports.tagPickerInputClassNames = tagPickerInputClassNames;
exports.tagPickerListClassNames = tagPickerListClassNames;
exports.tagPickerOptionClassNames = tagPickerOptionClassNames;
exports.tagPickerOptionGroupClassNames = tagPickerOptionGroupClassNames;
exports.teachingPopoverBodyClassNames = teachingPopoverBodyClassNames;
exports.teachingPopoverCarouselCardClassNames = teachingPopoverCarouselCardClassNames;
exports.teachingPopoverCarouselClassNames = teachingPopoverCarouselClassNames;
exports.teachingPopoverCarouselFooterClassNames = teachingPopoverCarouselFooterClassNames;
exports.teachingPopoverCarouselNavButtonClassNames = teachingPopoverCarouselNavButtonClassNames;
exports.teachingPopoverCarouselNavClassNames = teachingPopoverCarouselNavClassNames;
exports.teachingPopoverCarouselPageCountClassNames = teachingPopoverCarouselPageCountClassNames;
exports.teachingPopoverFooterClassNames = teachingPopoverFooterClassNames;
exports.teachingPopoverHeaderClassNames = teachingPopoverHeaderClassNames;
exports.teachingPopoverSurfaceClassNames = teachingPopoverSurfaceClassNames;
exports.teachingPopoverTitleClassNames = teachingPopoverTitleClassNames;
exports.teamsDarkTheme = teamsDarkTheme;
exports.teamsDarkV21Theme = teamsDarkV21Theme;
exports.teamsHighContrastTheme = teamsHighContrastTheme;
exports.teamsLightTheme = teamsLightTheme;
exports.teamsLightV21Theme = teamsLightV21Theme;
exports.textClassNames = textClassNames;
exports.textareaClassNames = textareaClassNames;
exports.themeToTokensObject = themeToTokensObject;
exports.title1ClassNames = title1ClassNames;
exports.title2ClassNames = title2ClassNames;
exports.title3ClassNames = title3ClassNames;
exports.toMountNodeProps = toMountNodeProps;
exports.toastBodyClassNames = toastBodyClassNames;
exports.toastFooterClassNames = toastFooterClassNames;
exports.toastTitleClassNames = toastTitleClassNames;
exports.toasterClassNames = toasterClassNames;
exports.toggleButtonClassNames = toggleButtonClassNames;
exports.tokens = tokens;
exports.toolbarClassNames = toolbarClassNames;
exports.toolbarGroupClassNames = toolbarGroupClassNames;
exports.tooltipClassNames = tooltipClassNames;
exports.treeClassNames = treeClassNames;
exports.treeItemClassNames = treeItemClassNames;
exports.treeItemLayoutClassNames = treeItemLayoutClassNames;
exports.treeItemLevelToken = treeItemLevelToken;
exports.treeItemPersonaLayoutClassNames = treeItemPersonaLayoutClassNames;
exports.truncateBreadcrumLongTooltip = truncateBreadcrumLongTooltip;
exports.truncateBreadcrumbLongName = truncateBreadcrumbLongName;
exports.typographyStyles = typographyStyles;
exports.useAccordionContextValues_unstable = useAccordionContextValues_unstable;
exports.useAccordionContext_unstable = useAccordionContext_unstable;
exports.useAccordionHeaderContextValues_unstable = useAccordionHeaderContextValues_unstable;
exports.useAccordionHeaderStyles_unstable = useAccordionHeaderStyles_unstable;
exports.useAccordionHeader_unstable = useAccordionHeader_unstable;
exports.useAccordionItemContextValues_unstable = useAccordionItemContextValues_unstable;
exports.useAccordionItemContext_unstable = useAccordionItemContext_unstable;
exports.useAccordionItemStyles_unstable = useAccordionItemStyles_unstable;
exports.useAccordionItem_unstable = useAccordionItem_unstable;
exports.useAccordionPanelStyles_unstable = useAccordionPanelStyles_unstable;
exports.useAccordionPanel_unstable = useAccordionPanel_unstable;
exports.useAccordionStyles_unstable = useAccordionStyles_unstable;
exports.useAccordion_unstable = useAccordion_unstable;
exports.useAlphaSliderStyles_unstable = useAlphaSliderStyles_unstable;
exports.useAlphaSlider_unstable = useAlphaSlider_unstable;
exports.useAnimationFrame = useAnimationFrame;
exports.useAnnounce = useAnnounce;
exports.useAppItemStaticStyles_unstable = useAppItemStaticStyles_unstable;
exports.useAppItemStatic_unstable = useAppItemStatic_unstable;
exports.useAppItemStyles_unstable = useAppItemStyles_unstable;
exports.useAppItem_unstable = useAppItem_unstable;
exports.useApplyScrollbarWidth = useApplyScrollbarWidth;
exports.useAriaLiveAnnouncerContextValues_unstable = useAriaLiveAnnouncerContextValues_unstable;
exports.useAriaLiveAnnouncer_unstable = useAriaLiveAnnouncer_unstable;
exports.useArrowNavigationGroup = useArrowNavigationGroup;
exports.useAvatarGroupContextValues = useAvatarGroupContextValues;
exports.useAvatarGroupContext_unstable = useAvatarGroupContext_unstable;
exports.useAvatarGroupItemStyles_unstable = useAvatarGroupItemStyles_unstable;
exports.useAvatarGroupItem_unstable = useAvatarGroupItem_unstable;
exports.useAvatarGroupPopoverContextValues_unstable = useAvatarGroupPopoverContextValues_unstable;
exports.useAvatarGroupPopoverStyles_unstable = useAvatarGroupPopoverStyles_unstable;
exports.useAvatarGroupPopover_unstable = useAvatarGroupPopover_unstable;
exports.useAvatarGroupStyles_unstable = useAvatarGroupStyles_unstable;
exports.useAvatarGroup_unstable = useAvatarGroup_unstable;
exports.useAvatarStyles_unstable = useAvatarStyles_unstable;
exports.useAvatar_unstable = useAvatar_unstable;
exports.useBadgeStyles_unstable = useBadgeStyles_unstable;
exports.useBadge_unstable = useBadge_unstable;
exports.useBreadcrumbButtonStyles_unstable = useBreadcrumbButtonStyles_unstable;
exports.useBreadcrumbButton_unstable = useBreadcrumbButton_unstable;
exports.useBreadcrumbContext_unstable = useBreadcrumbContext_unstable;
exports.useBreadcrumbDividerStyles_unstable = useBreadcrumbDividerStyles_unstable;
exports.useBreadcrumbDivider_unstable = useBreadcrumbDivider_unstable;
exports.useBreadcrumbItemStyles_unstable = useBreadcrumbItemStyles_unstable;
exports.useBreadcrumbItem_unstable = useBreadcrumbItem_unstable;
exports.useBreadcrumbStyles_unstable = useBreadcrumbStyles_unstable;
exports.useBreadcrumb_unstable = useBreadcrumb_unstable;
exports.useButtonStyles_unstable = useButtonStyles_unstable;
exports.useButton_unstable = useButton_unstable;
exports.useCardFooterStyles_unstable = useCardFooterStyles_unstable;
exports.useCardFooter_unstable = useCardFooter_unstable;
exports.useCardHeaderStyles_unstable = useCardHeaderStyles_unstable;
exports.useCardHeader_unstable = useCardHeader_unstable;
exports.useCardPreviewStyles_unstable = useCardPreviewStyles_unstable;
exports.useCardPreview_unstable = useCardPreview_unstable;
exports.useCardStyles_unstable = useCardStyles_unstable;
exports.useCard_unstable = useCard_unstable;
exports.useCarouselAutoplayButtonStyles_unstable = useCarouselAutoplayButtonStyles_unstable;
exports.useCarouselAutoplayButton_unstable = useCarouselAutoplayButton_unstable;
exports.useCarouselButtonStyles_unstable = useCarouselButtonStyles_unstable;
exports.useCarouselButton_unstable = useCarouselButton_unstable;
exports.useCarouselCardStyles_unstable = useCarouselCardStyles_unstable;
exports.useCarouselCard_unstable = useCarouselCard_unstable;
exports.useCarouselContext_unstable = useCarouselContext_unstable;
exports.useCarouselNavButtonStyles_unstable = useCarouselNavButtonStyles_unstable;
exports.useCarouselNavButton_unstable = useCarouselNavButton_unstable;
exports.useCarouselNavContainerStyles_unstable = useCarouselNavContainerStyles_unstable;
exports.useCarouselNavContainer_unstable = useCarouselNavContainer_unstable;
exports.useCarouselNavImageButtonStyles_unstable = useCarouselNavImageButtonStyles_unstable;
exports.useCarouselNavImageButton_unstable = useCarouselNavImageButton_unstable;
exports.useCarouselNavStyles_unstable = useCarouselNavStyles_unstable;
exports.useCarouselNav_unstable = useCarouselNav_unstable;
exports.useCarouselSliderStyles_unstable = useCarouselSliderStyles_unstable;
exports.useCarouselSlider_unstable = useCarouselSlider_unstable;
exports.useCarouselStyles_unstable = useCarouselStyles_unstable;
exports.useCarouselViewportStyles_unstable = useCarouselViewportStyles_unstable;
exports.useCarouselViewport_unstable = useCarouselViewport_unstable;
exports.useCarousel_unstable = useCarousel_unstable;
exports.useCheckboxStyles_unstable = useCheckboxStyles_unstable;
exports.useCheckbox_unstable = useCheckbox_unstable;
exports.useCheckmarkStyles_unstable = useCheckmarkStyles_unstable;
exports.useColorAreaStyles_unstable = useColorAreaStyles_unstable;
exports.useColorArea_unstable = useColorArea_unstable;
exports.useColorPickerStyles_unstable = useColorPickerStyles_unstable;
exports.useColorPicker_unstable = useColorPicker_unstable;
exports.useColorSliderStyles_unstable = useColorSliderStyles_unstable;
exports.useColorSlider_unstable = useColorSlider_unstable;
exports.useColorSwatchStyles_unstable = useColorSwatchStyles_unstable;
exports.useColorSwatch_unstable = useColorSwatch_unstable;
exports.useColumnIdContext = useColumnIdContext;
exports.useComboboxContextValues = useComboboxContextValues;
exports.useComboboxFilter = useComboboxFilter;
exports.useComboboxStyles_unstable = useComboboxStyles_unstable;
exports.useCombobox_unstable = useCombobox_unstable;
exports.useCompoundButtonStyles_unstable = useCompoundButtonStyles_unstable;
exports.useCompoundButton_unstable = useCompoundButton_unstable;
exports.useCounterBadgeStyles_unstable = useCounterBadgeStyles_unstable;
exports.useCounterBadge_unstable = useCounterBadge_unstable;
exports.useDataGridBodyStyles_unstable = useDataGridBodyStyles_unstable;
exports.useDataGridBody_unstable = useDataGridBody_unstable;
exports.useDataGridCellStyles_unstable = useDataGridCellStyles_unstable;
exports.useDataGridCell_unstable = useDataGridCell_unstable;
exports.useDataGridContextValues_unstable = useDataGridContextValues_unstable;
exports.useDataGridContext_unstable = useDataGridContext_unstable;
exports.useDataGridHeaderCellStyles_unstable = useDataGridHeaderCellStyles_unstable;
exports.useDataGridHeaderCell_unstable = useDataGridHeaderCell_unstable;
exports.useDataGridHeaderStyles_unstable = useDataGridHeaderStyles_unstable;
exports.useDataGridHeader_unstable = useDataGridHeader_unstable;
exports.useDataGridRowStyles_unstable = useDataGridRowStyles_unstable;
exports.useDataGridRow_unstable = useDataGridRow_unstable;
exports.useDataGridSelectionCellStyles_unstable = useDataGridSelectionCellStyles_unstable;
exports.useDataGridSelectionCell_unstable = useDataGridSelectionCell_unstable;
exports.useDataGridStyles_unstable = useDataGridStyles_unstable;
exports.useDataGrid_unstable = useDataGrid_unstable;
exports.useDialogActionsStyles_unstable = useDialogActionsStyles_unstable;
exports.useDialogActions_unstable = useDialogActions_unstable;
exports.useDialogBodyStyles_unstable = useDialogBodyStyles_unstable;
exports.useDialogBody_unstable = useDialogBody_unstable;
exports.useDialogContentStyles_unstable = useDialogContentStyles_unstable;
exports.useDialogContent_unstable = useDialogContent_unstable;
exports.useDialogContext_unstable = useDialogContext_unstable;
exports.useDialogSurfaceContextValues_unstable = useDialogSurfaceContextValues_unstable;
exports.useDialogSurfaceContext_unstable = useDialogSurfaceContext_unstable;
exports.useDialogSurfaceStyles_unstable = useDialogSurfaceStyles_unstable;
exports.useDialogSurface_unstable = useDialogSurface_unstable;
exports.useDialogTitleStyles_unstable = useDialogTitleStyles_unstable;
exports.useDialogTitle_unstable = useDialogTitle_unstable;
exports.useDialogTrigger_unstable = useDialogTrigger_unstable;
exports.useDialog_unstable = useDialog_unstable;
exports.useDividerStyles_unstable = useDividerStyles_unstable;
exports.useDivider_unstable = useDivider_unstable;
exports.useDrawerBodyStyles_unstable = useDrawerBodyStyles_unstable;
exports.useDrawerBody_unstable = useDrawerBody_unstable;
exports.useDrawerContextValue = useDrawerContextValue;
exports.useDrawerContext_unstable = useDrawerContext_unstable;
exports.useDrawerFooterStyles_unstable = useDrawerFooterStyles_unstable;
exports.useDrawerFooter_unstable = useDrawerFooter_unstable;
exports.useDrawerHeaderNavigationStyles_unstable = useDrawerHeaderNavigationStyles_unstable;
exports.useDrawerHeaderNavigation_unstable = useDrawerHeaderNavigation_unstable;
exports.useDrawerHeaderStyles_unstable = useDrawerHeaderStyles_unstable;
exports.useDrawerHeaderTitleStyles_unstable = useDrawerHeaderTitleStyles_unstable;
exports.useDrawerHeaderTitle_unstable = useDrawerHeaderTitle_unstable;
exports.useDrawerHeader_unstable = useDrawerHeader_unstable;
exports.useDrawerStyles_unstable = useDrawerStyles_unstable;
exports.useDrawer_unstable = useDrawer_unstable;
exports.useDropdownStyles_unstable = useDropdownStyles_unstable;
exports.useDropdown_unstable = useDropdown_unstable;
exports.useEmptySwatchStyles_unstable = useEmptySwatchStyles_unstable;
exports.useEmptySwatch_unstable = useEmptySwatch_unstable;
exports.useEventCallback = useEventCallback;
exports.useFieldContextValues_unstable = useFieldContextValues_unstable;
exports.useFieldContext_unstable = useFieldContext_unstable;
exports.useFieldControlProps_unstable = useFieldControlProps_unstable;
exports.useFieldStyles_unstable = useFieldStyles_unstable;
exports.useField_unstable = useField_unstable;
exports.useFlatTreeContextValues_unstable = useFlatTreeContextValues_unstable;
exports.useFlatTreeStyles_unstable = useFlatTreeStyles_unstable;
exports.useFlatTree_unstable = useFlatTree_unstable;
exports.useFluent = useFluent;
exports.useFluentProviderContextValues_unstable = useFluentProviderContextValues_unstable;
exports.useFluentProviderStyles_unstable = useFluentProviderStyles_unstable;
exports.useFluentProviderThemeStyleTag = useFluentProviderThemeStyleTag;
exports.useFluentProvider_unstable = useFluentProvider_unstable;
exports.useFocusFinders = useFocusFinders;
exports.useFocusObserved = useFocusObserved;
exports.useFocusVisible = useFocusVisible;
exports.useFocusWithin = useFocusWithin;
exports.useFocusableGroup = useFocusableGroup;
exports.useHamburgerStyles_unstable = useHamburgerStyles_unstable;
exports.useHamburger_unstable = useHamburger_unstable;
exports.useHeadlessFlatTree_unstable = useHeadlessFlatTree_unstable;
exports.useId = useId;
exports.useImageStyles_unstable = useImageStyles_unstable;
exports.useImageSwatchStyles_unstable = useImageSwatchStyles_unstable;
exports.useImageSwatch_unstable = useImageSwatch_unstable;
exports.useImage_unstable = useImage_unstable;
exports.useInfoButtonStyles_unstable = useInfoButtonStyles_unstable;
exports.useInfoButton_unstable = useInfoButton_unstable;
exports.useInfoLabelStyles_unstable = useInfoLabelStyles_unstable;
exports.useInfoLabel_unstable = useInfoLabel_unstable;
exports.useInlineDrawerStyles_unstable = useInlineDrawerStyles_unstable;
exports.useInlineDrawer_unstable = useInlineDrawer_unstable;
exports.useInputStyles_unstable = useInputStyles_unstable;
exports.useInput_unstable = useInput_unstable;
exports.useInteractionTagContextValues_unstable = useInteractionTagContextValues_unstable;
exports.useInteractionTagPrimaryStyles_unstable = useInteractionTagPrimaryStyles_unstable;
exports.useInteractionTagPrimary_unstable = useInteractionTagPrimary_unstable;
exports.useInteractionTagSecondaryStyles_unstable = useInteractionTagSecondaryStyles_unstable;
exports.useInteractionTagSecondary_unstable = useInteractionTagSecondary_unstable;
exports.useInteractionTagStyles_unstable = useInteractionTagStyles_unstable;
exports.useInteractionTag_unstable = useInteractionTag_unstable;
exports.useIsInTableHeader = useIsInTableHeader;
exports.useIsOverflowGroupVisible = useIsOverflowGroupVisible;
exports.useIsOverflowItemVisible = useIsOverflowItemVisible;
exports.useIsSSR = useIsSSR;
exports.useIsomorphicLayoutEffect = useIsomorphicLayoutEffect;
exports.useKeyboardNavAttribute = useKeyboardNavAttribute;
exports.useLabelStyles_unstable = useLabelStyles_unstable;
exports.useLabel_unstable = useLabel_unstable;
exports.useLinkState_unstable = useLinkState_unstable;
exports.useLinkStyles_unstable = useLinkStyles_unstable;
exports.useLink_unstable = useLink_unstable;
exports.useListItemStyles_unstable = useListItemStyles_unstable;
exports.useListItem_unstable = useListItem_unstable;
exports.useListStyles_unstable = useListStyles_unstable;
exports.useList_unstable = useList_unstable;
exports.useListboxContextValues = useListboxContextValues;
exports.useListboxContext_unstable = useListboxContext_unstable;
exports.useListboxStyles_unstable = useListboxStyles_unstable;
exports.useListbox_unstable = useListbox_unstable;
exports.useMenuButtonStyles_unstable = useMenuButtonStyles_unstable;
exports.useMenuButton_unstable = useMenuButton_unstable;
exports.useMenuContextValues_unstable = useMenuContextValues_unstable;
exports.useMenuContext_unstable = useMenuContext_unstable;
exports.useMenuDividerStyles_unstable = useMenuDividerStyles_unstable;
exports.useMenuDivider_unstable = useMenuDivider_unstable;
exports.useMenuGroupContextValues_unstable = useMenuGroupContextValues_unstable;
exports.useMenuGroupContext_unstable = useMenuGroupContext_unstable;
exports.useMenuGroupHeaderStyles_unstable = useMenuGroupHeaderStyles_unstable;
exports.useMenuGroupHeader_unstable = useMenuGroupHeader_unstable;
exports.useMenuGroupStyles_unstable = useMenuGroupStyles_unstable;
exports.useMenuGroup_unstable = useMenuGroup_unstable;
exports.useMenuItemCheckboxStyles_unstable = useMenuItemCheckboxStyles_unstable;
exports.useMenuItemCheckbox_unstable = useMenuItemCheckbox_unstable;
exports.useMenuItemLinkStyles_unstable = useMenuItemLinkStyles_unstable;
exports.useMenuItemLink_unstable = useMenuItemLink_unstable;
exports.useMenuItemRadioStyles_unstable = useMenuItemRadioStyles_unstable;
exports.useMenuItemRadio_unstable = useMenuItemRadio_unstable;
exports.useMenuItemStyles_unstable = useMenuItemStyles_unstable;
exports.useMenuItemSwitchStyles_unstable = useMenuItemSwitchStyles_unstable;
exports.useMenuItemSwitch_unstable = useMenuItemSwitch_unstable;
exports.useMenuItem_unstable = useMenuItem_unstable;
exports.useMenuListContextValues_unstable = useMenuListContextValues_unstable;
exports.useMenuListContext_unstable = useMenuListContext_unstable;
exports.useMenuListStyles_unstable = useMenuListStyles_unstable;
exports.useMenuList_unstable = useMenuList_unstable;
exports.useMenuPopoverStyles_unstable = useMenuPopoverStyles_unstable;
exports.useMenuPopover_unstable = useMenuPopover_unstable;
exports.useMenuSplitGroupStyles_unstable = useMenuSplitGroupStyles_unstable;
exports.useMenuSplitGroup_unstable = useMenuSplitGroup_unstable;
exports.useMenuTriggerContext_unstable = useMenuTriggerContext_unstable;
exports.useMenuTrigger_unstable = useMenuTrigger_unstable;
exports.useMenu_unstable = useMenu_unstable;
exports.useMergedRefs = useMergedRefs;
exports.useMessageBarActionsContextValue_unstable = useMessageBarActionsContextValue_unstable;
exports.useMessageBarActionsStyles_unstable = useMessageBarActionsStyles_unstable;
exports.useMessageBarActions_unstable = useMessageBarActions_unstable;
exports.useMessageBarBodyStyles_unstable = useMessageBarBodyStyles_unstable;
exports.useMessageBarBody_unstable = useMessageBarBody_unstable;
exports.useMessageBarContext = useMessageBarContext;
exports.useMessageBarContextValue_unstable = useMessageBarContextValue_unstable;
exports.useMessageBarGroupStyles_unstable = useMessageBarGroupStyles_unstable;
exports.useMessageBarGroup_unstable = useMessageBarGroup_unstable;
exports.useMessageBarStyles_unstable = useMessageBarStyles_unstable;
exports.useMessageBarTitleStyles_unstable = useMessageBarTitleStyles_unstable;
exports.useMessageBarTitle_unstable = useMessageBarTitle_unstable;
exports.useMessageBar_unstable = useMessageBar_unstable;
exports.useModalAttributes = useModalAttributes;
exports.useNavCategoryContextValues_unstable = useNavCategoryContextValues_unstable;
exports.useNavCategoryContext_unstable = useNavCategoryContext_unstable;
exports.useNavCategoryItemContextValues_unstable = useNavCategoryItemContextValues_unstable;
exports.useNavCategoryItemContext_unstable = useNavCategoryItemContext_unstable;
exports.useNavCategoryItemStyles_unstable = useNavCategoryItemStyles_unstable;
exports.useNavCategoryItem_unstable = useNavCategoryItem_unstable;
exports.useNavCategory_unstable = useNavCategory_unstable;
exports.useNavContextValues_unstable = useNavContextValues_unstable;
exports.useNavContext_unstable = useNavContext_unstable;
exports.useNavDividerStyles_unstable = useNavDividerStyles_unstable;
exports.useNavDivider_unstable = useNavDivider_unstable;
exports.useNavDrawerBodyStyles_unstable = useNavDrawerBodyStyles_unstable;
exports.useNavDrawerBody_unstable = useNavDrawerBody_unstable;
exports.useNavDrawerFooterStyles_unstable = useNavDrawerFooterStyles_unstable;
exports.useNavDrawerFooter_unstable = useNavDrawerFooter_unstable;
exports.useNavDrawerHeaderStyles_unstable = useNavDrawerHeaderStyles_unstable;
exports.useNavDrawerHeader_unstable = useNavDrawerHeader_unstable;
exports.useNavDrawerStyles_unstable = useNavDrawerStyles_unstable;
exports.useNavDrawer_unstable = useNavDrawer_unstable;
exports.useNavItemStyles_unstable = useNavItemStyles_unstable;
exports.useNavItem_unstable = useNavItem_unstable;
exports.useNavSectionHeaderStyles_unstable = useNavSectionHeaderStyles_unstable;
exports.useNavSectionHeader_unstable = useNavSectionHeader_unstable;
exports.useNavStyles_unstable = useNavStyles_unstable;
exports.useNavSubItemGroupStyles_unstable = useNavSubItemGroupStyles_unstable;
exports.useNavSubItemGroup_unstable = useNavSubItemGroup_unstable;
exports.useNavSubItemStyles_unstable = useNavSubItemStyles_unstable;
exports.useNavSubItem_unstable = useNavSubItem_unstable;
exports.useNav_unstable = useNav_unstable;
exports.useObservedElement = useObservedElement;
exports.useOptionGroupStyles_unstable = useOptionGroupStyles_unstable;
exports.useOptionGroup_unstable = useOptionGroup_unstable;
exports.useOptionStyles_unstable = useOptionStyles_unstable;
exports.useOption_unstable = useOption_unstable;
exports.useOverflowCount = useOverflowCount;
exports.useOverflowMenu = useOverflowMenu;
exports.useOverflowVisibility = useOverflowVisibility;
exports.useOverlayDrawerStyles_unstable = useOverlayDrawerStyles_unstable;
exports.useOverlayDrawer_unstable = useOverlayDrawer_unstable;
exports.usePersonaStyles_unstable = usePersonaStyles_unstable;
exports.usePersona_unstable = usePersona_unstable;
exports.usePopoverContext_unstable = usePopoverContext_unstable;
exports.usePopoverSurfaceStyles_unstable = usePopoverSurfaceStyles_unstable;
exports.usePopoverSurface_unstable = usePopoverSurface_unstable;
exports.usePopoverTrigger_unstable = usePopoverTrigger_unstable;
exports.usePopover_unstable = usePopover_unstable;
exports.usePortalMountNode = usePortalMountNode;
exports.usePortal_unstable = usePortal_unstable;
exports.usePositioning = usePositioning;
exports.usePresenceBadgeStyles_unstable = usePresenceBadgeStyles_unstable;
exports.usePresenceBadge_unstable = usePresenceBadge_unstable;
exports.useProgressBarStyles_unstable = useProgressBarStyles_unstable;
exports.useProgressBar_unstable = useProgressBar_unstable;
exports.useRadioGroupContextValue_unstable = useRadioGroupContextValue_unstable;
exports.useRadioGroupContextValues = useRadioGroupContextValues;
exports.useRadioGroupContext_unstable = useRadioGroupContext_unstable;
exports.useRadioGroupStyles_unstable = useRadioGroupStyles_unstable;
exports.useRadioGroup_unstable = useRadioGroup_unstable;
exports.useRadioStyles_unstable = useRadioStyles_unstable;
exports.useRadio_unstable = useRadio_unstable;
exports.useRatingContextValues = useRatingContextValues;
exports.useRatingDisplayContextValues = useRatingDisplayContextValues;
exports.useRatingDisplayStyles_unstable = useRatingDisplayStyles_unstable;
exports.useRatingDisplay_unstable = useRatingDisplay_unstable;
exports.useRatingItemContextValue_unstable = useRatingItemContextValue_unstable;
exports.useRatingItemStyles_unstable = useRatingItemStyles_unstable;
exports.useRatingItem_unstable = useRatingItem_unstable;
exports.useRatingStyles_unstable = useRatingStyles_unstable;
exports.useRating_unstable = useRating_unstable;
exports.useRestoreFocusSource = useRestoreFocusSource;
exports.useRestoreFocusTarget = useRestoreFocusTarget;
exports.useSafeZoneArea = useSafeZoneArea;
exports.useScrollbarWidth = useScrollbarWidth;
exports.useSearchBoxStyles_unstable = useSearchBoxStyles_unstable;
exports.useSearchBox_unstable = useSearchBox_unstable;
exports.useSelectStyles_unstable = useSelectStyles_unstable;
exports.useSelect_unstable = useSelect_unstable;
exports.useSelection = useSelection;
exports.useSkeletonContext = useSkeletonContext;
exports.useSkeletonItemStyles_unstable = useSkeletonItemStyles_unstable;
exports.useSkeletonItem_unstable = useSkeletonItem_unstable;
exports.useSkeletonStyles_unstable = useSkeletonStyles_unstable;
exports.useSkeleton_unstable = useSkeleton_unstable;
exports.useSliderState_unstable = useSliderState_unstable;
exports.useSliderStyles_unstable = useSliderStyles_unstable;
exports.useSlider_unstable = useSlider_unstable;
exports.useSpinButtonStyles_unstable = useSpinButtonStyles_unstable;
exports.useSpinButton_unstable = useSpinButton_unstable;
exports.useSpinnerStyles_unstable = useSpinnerStyles_unstable;
exports.useSpinner_unstable = useSpinner_unstable;
exports.useSplitButtonStyles_unstable = useSplitButtonStyles_unstable;
exports.useSplitButton_unstable = useSplitButton_unstable;
exports.useSplitNavItemStyles_unstable = useSplitNavItemStyles_unstable;
exports.useSplitNavItem_unstable = useSplitNavItem_unstable;
exports.useSubtreeContext_unstable = useSubtreeContext_unstable;
exports.useSwatchPickerContextValue_unstable = useSwatchPickerContextValue_unstable;
exports.useSwatchPickerContextValues = useSwatchPickerContextValues;
exports.useSwatchPickerRowStyles_unstable = useSwatchPickerRowStyles_unstable;
exports.useSwatchPickerRow_unstable = useSwatchPickerRow_unstable;
exports.useSwatchPickerStyles_unstable = useSwatchPickerStyles_unstable;
exports.useSwatchPicker_unstable = useSwatchPicker_unstable;
exports.useSwitchStyles_unstable = useSwitchStyles_unstable;
exports.useSwitch_unstable = useSwitch_unstable;
exports.useTabListContextValues_unstable = useTabListContextValues_unstable;
exports.useTabListContext_unstable = useTabListContext_unstable;
exports.useTabListStyles_unstable = useTabListStyles_unstable;
exports.useTabList_unstable = useTabList_unstable;
exports.useTabStyles_unstable = useTabStyles_unstable;
exports.useTab_unstable = useTab_unstable;
exports.useTableBodyStyles_unstable = useTableBodyStyles_unstable;
exports.useTableBody_unstable = useTableBody_unstable;
exports.useTableCellActionsStyles_unstable = useTableCellActionsStyles_unstable;
exports.useTableCellActions_unstable = useTableCellActions_unstable;
exports.useTableCellLayoutStyles_unstable = useTableCellLayoutStyles_unstable;
exports.useTableCellLayout_unstable = useTableCellLayout_unstable;
exports.useTableCellStyles_unstable = useTableCellStyles_unstable;
exports.useTableCell_unstable = useTableCell_unstable;
exports.useTableColumnSizing_unstable = useTableColumnSizing_unstable;
exports.useTableCompositeNavigation = useTableCompositeNavigation;
exports.useTableContext = useTableContext;
exports.useTableFeatures = useTableFeatures;
exports.useTableHeaderCellStyles_unstable = useTableHeaderCellStyles_unstable;
exports.useTableHeaderCell_unstable = useTableHeaderCell_unstable;
exports.useTableHeaderStyles_unstable = useTableHeaderStyles_unstable;
exports.useTableHeader_unstable = useTableHeader_unstable;
exports.useTableResizeHandleStyles_unstable = useTableResizeHandleStyles_unstable;
exports.useTableResizeHandle_unstable = useTableResizeHandle_unstable;
exports.useTableRowIdContext = useTableRowIdContext;
exports.useTableRowStyles_unstable = useTableRowStyles_unstable;
exports.useTableRow_unstable = useTableRow_unstable;
exports.useTableSelection = useTableSelection;
exports.useTableSelectionCellStyles_unstable = useTableSelectionCellStyles_unstable;
exports.useTableSelectionCell_unstable = useTableSelectionCell_unstable;
exports.useTableSort = useTableSort;
exports.useTableStyles_unstable = useTableStyles_unstable;
exports.useTable_unstable = useTable_unstable;
exports.useTagAvatarContextValues_unstable = useTagAvatarContextValues_unstable;
exports.useTagGroupContextValues_unstable = useTagGroupContextValues_unstable;
exports.useTagGroupStyles_unstable = useTagGroupStyles_unstable;
exports.useTagGroup_unstable = useTagGroup_unstable;
exports.useTagPickerButtonStyles_unstable = useTagPickerButtonStyles_unstable;
exports.useTagPickerButton_unstable = useTagPickerButton_unstable;
exports.useTagPickerContext_unstable = useTagPickerContext_unstable;
exports.useTagPickerControlStyles_unstable = useTagPickerControlStyles_unstable;
exports.useTagPickerControl_unstable = useTagPickerControl_unstable;
exports.useTagPickerFilter = useTagPickerFilter;
exports.useTagPickerGroupStyles_unstable = useTagPickerGroupStyles_unstable;
exports.useTagPickerGroup_unstable = useTagPickerGroup_unstable;
exports.useTagPickerInputStyles_unstable = useTagPickerInputStyles_unstable;
exports.useTagPickerInput_unstable = useTagPickerInput_unstable;
exports.useTagPickerListStyles_unstable = useTagPickerListStyles_unstable;
exports.useTagPickerList_unstable = useTagPickerList_unstable;
exports.useTagPickerOptionGroup = useTagPickerOptionGroup;
exports.useTagPickerOptionGroupStyles = useTagPickerOptionGroupStyles;
exports.useTagPickerOptionStyles_unstable = useTagPickerOptionStyles_unstable;
exports.useTagPickerOption_unstable = useTagPickerOption_unstable;
exports.useTagPicker_unstable = useTagPicker_unstable;
exports.useTagStyles_unstable = useTagStyles_unstable;
exports.useTag_unstable = useTag_unstable;
exports.useTeachingPopoverBodyStyles_unstable = useTeachingPopoverBodyStyles_unstable;
exports.useTeachingPopoverBody_unstable = useTeachingPopoverBody_unstable;
exports.useTeachingPopoverCarouselCardStyles_unstable = useTeachingPopoverCarouselCardStyles_unstable;
exports.useTeachingPopoverCarouselCard_unstable = useTeachingPopoverCarouselCard_unstable;
exports.useTeachingPopoverCarouselContextValues_unstable = useTeachingPopoverCarouselContextValues_unstable;
exports.useTeachingPopoverCarouselFooterStyles_unstable = useTeachingPopoverCarouselFooterStyles_unstable;
exports.useTeachingPopoverCarouselFooter_unstable = useTeachingPopoverCarouselFooter_unstable;
exports.useTeachingPopoverCarouselNavButtonStyles_unstable = useTeachingPopoverCarouselNavButtonStyles_unstable;
exports.useTeachingPopoverCarouselNavButton_unstable = useTeachingPopoverCarouselNavButton_unstable;
exports.useTeachingPopoverCarouselNavStyles_unstable = useTeachingPopoverCarouselNavStyles_unstable;
exports.useTeachingPopoverCarouselNav_unstable = useTeachingPopoverCarouselNav_unstable;
exports.useTeachingPopoverCarouselPageCountStyles_unstable = useTeachingPopoverCarouselPageCountStyles_unstable;
exports.useTeachingPopoverCarouselPageCount_unstable = useTeachingPopoverCarouselPageCount_unstable;
exports.useTeachingPopoverCarouselStyles_unstable = useTeachingPopoverCarouselStyles_unstable;
exports.useTeachingPopoverCarousel_unstable = useTeachingPopoverCarousel_unstable;
exports.useTeachingPopoverFooter_unstable = useTeachingPopoverFooter_unstable;
exports.useTeachingPopoverHeaderStyles_unstable = useTeachingPopoverHeaderStyles_unstable;
exports.useTeachingPopoverHeader_unstable = useTeachingPopoverHeader_unstable;
exports.useTeachingPopoverSurfaceStyles_unstable = useTeachingPopoverSurfaceStyles_unstable;
exports.useTeachingPopoverSurface_unstable = useTeachingPopoverSurface_unstable;
exports.useTeachingPopoverTitleStyles_unstable = useTeachingPopoverTitleStyles_unstable;
exports.useTeachingPopoverTitle_unstable = useTeachingPopoverTitle_unstable;
exports.useTeachingPopoverTrigger_unstable = useTeachingPopoverTrigger_unstable;
exports.useTeachingPopover_unstable = useTeachingPopover_unstable;
exports.useTextStyles_unstable = useTextStyles_unstable;
exports.useText_unstable = useText_unstable;
exports.useTextareaStyles_unstable = useTextareaStyles_unstable;
exports.useTextarea_unstable = useTextarea_unstable;
exports.useThemeClassName = useThemeClassName;
exports.useTimeout = useTimeout;
exports.useToastBodyStyles_unstable = useToastBodyStyles_unstable;
exports.useToastBody_unstable = useToastBody_unstable;
exports.useToastController = useToastController;
exports.useToastFooterStyles_unstable = useToastFooterStyles_unstable;
exports.useToastFooter_unstable = useToastFooter_unstable;
exports.useToastStyles_unstable = useToastStyles_unstable;
exports.useToastTitleStyles_unstable = useToastTitleStyles_unstable;
exports.useToastTitle_unstable = useToastTitle_unstable;
exports.useToastTrigger_unstable = useToastTrigger_unstable;
exports.useToast_unstable = useToast_unstable;
exports.useToasterStyles_unstable = useToasterStyles_unstable;
exports.useToaster_unstable = useToaster_unstable;
exports.useToggleButtonStyles_unstable = useToggleButtonStyles_unstable;
exports.useToggleButton_unstable = useToggleButton_unstable;
exports.useToggleState = useToggleState;
exports.useToolbarButtonStyles_unstable = useToolbarButtonStyles_unstable;
exports.useToolbarButton_unstable = useToolbarButton_unstable;
exports.useToolbarDividerStyles_unstable = useToolbarDividerStyles_unstable;
exports.useToolbarDivider_unstable = useToolbarDivider_unstable;
exports.useToolbarGroupStyles_unstable = useToolbarGroupStyles_unstable;
exports.useToolbarGroup_unstable = useToolbarGroup_unstable;
exports.useToolbarRadioButtonStyles_unstable = useToolbarRadioButtonStyles_unstable;
exports.useToolbarRadioButton_unstable = useToolbarRadioButton_unstable;
exports.useToolbarStyles_unstable = useToolbarStyles_unstable;
exports.useToolbarToggleButtonStyles_unstable = useToolbarToggleButtonStyles_unstable;
exports.useToolbarToggleButton_unstable = useToolbarToggleButton_unstable;
exports.useToolbar_unstable = useToolbar_unstable;
exports.useTooltipStyles_unstable = useTooltipStyles_unstable;
exports.useTooltipVisibility = useTooltipVisibility;
exports.useTooltip_unstable = useTooltip_unstable;
exports.useTreeContextValues_unstable = useTreeContextValues_unstable;
exports.useTreeContext_unstable = useTreeContext_unstable;
exports.useTreeItemContextValues_unstable = useTreeItemContextValues_unstable;
exports.useTreeItemContext_unstable = useTreeItemContext_unstable;
exports.useTreeItemLayoutStyles_unstable = useTreeItemLayoutStyles_unstable;
exports.useTreeItemLayout_unstable = useTreeItemLayout_unstable;
exports.useTreeItemPersonaLayoutStyles_unstable = useTreeItemPersonaLayoutStyles_unstable;
exports.useTreeItemPersonaLayout_unstable = useTreeItemPersonaLayout_unstable;
exports.useTreeItemStyles_unstable = useTreeItemStyles_unstable;
exports.useTreeItem_unstable = useTreeItem_unstable;
exports.useTreeNavigation = useTreeNavigation;
exports.useTreeStyles_unstable = useTreeStyles_unstable;
exports.useTree_unstable = useTree_unstable;
exports.useTypingAnnounce = useTypingAnnounce;
exports.useUncontrolledFocus = useUncontrolledFocus;
exports.webDarkTheme = webDarkTheme;
exports.webLightTheme = webLightTheme;
});